BEST,LEAST
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.ArrayDeque;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', 'import java.util.Queue;', '', 'public class C3 {', ' InputStream is;', ' PrintWriter out;', ' String INPUT = """";', ' ', ' void solve()', ' {', '  int n = ni();', '  char[][] ss = new char[n][];', '  for(int i = 0;i < n;i++){', '   ss[i] = ns().toCharArray();', '  }', '  int[] h = na(n);', '  ', '  int Q = ni();', '  char[][] qs = new char[Q][];', '  long[] es = new long[2*Q];', '  for(int i = 0;i < Q;i++){', '   int s = ni(), t = ni();', '   qs[i] = ns().toCharArray();', '   es[i] = (long)s<<32|(long)i<<1|0;', '   es[i+Q] = (long)t+1<<32|(long)i<<1|1;', '  }', '  Arrays.sort(es);', '  long[] rets = new long[Q];', '  TrieByLink[] tries = new TrieByLink[18];', '  int p = 0;', '  for(long e : es){', '   long x = e>>>32;', '   int ind = ((int)e)>>>1;', '   int pm = (e&1) == 0 ? -1 : 1;', '   while(p < n && p <= x-1){', '    int d = Integer.numberOfTrailingZeros(p+1);', '    tries[d] = new TrieByLink();', '    for(int k = p-(1<<d)+1;k <= p;k++){', '     tries[d].add(ss[k], h[k]);', '    }', '    tries[d].buildFailure();', '    p++;', '   }', '   long lhit = 0;', '   for(int d = 0;d < 18;d++){', '    if(p<<~d<0){', '     lhit += tries[d].countHit(qs[ind]);', '    }', '   }', '   rets[ind] += lhit*pm;', '  }', '  long min = Long.MAX_VALUE;', '  long max = Long.MIN_VALUE;', '  for(long r : rets)min = Math.min(min, r);', '  for(long r : rets)max = Math.max(max, r);', '  ', '  out.println(min + "" "" + max);', ' }', ' ', ' public static class TrieByLink {', '  public Node root = new Node((char)0, 0);', '  public int gen = 1;', '  public static final char[] atoz = ""abcdefghijklmnopqrstuvwxyz"".toCharArray();', '  ', '  public static class Node', '  {', '   public int id;', '   public char c;', '   public Node next, firstChild;', '   public long hit = 0;', '   ', '   public Node fail;', '   ', '   public Node(char c, int id)', '   {', '    this.id = id;', '    this.c = c;', '   }', '   ', '   public String toString(String indent)', '   {', '    StringBuilder sb = new StringBuilder();', '    sb.append(indent + id + "":"" + c);', '    if(hit != 0)sb.append("" H:"" + hit);', '    if(fail != null)sb.append("" F:"" + fail.id);', '    sb.append(""\\n"");', '    for(Node c = firstChild;c != null; c = c.next){', '     sb.append(c.toString(indent + ""  ""));', '    }', '    return sb.toString();', '   }', '  }', '  ', '  public void add(char[] s, long hit)', '  {', '   Node cur = root;', '   Node pre = null;', '   for(char c : s){', '    pre = cur; cur = cur.firstChild;', '    if(cur == null){', '     cur = pre.firstChild = new Node(c, gen++);', '    }else{', '     for(;cur != null && cur.c != c;pre = cur, cur = cur.next);', '     if(cur == null)cur = pre.next = new Node(c, gen++);', '    }', '   }', '   cur.hit += hit;', '  }', '  ', '  public void buildFailure()', '  {', '   root.fail = null;', '   Queue<Node> q = new ArrayDeque<Node>();', '   q.add(root);', '   while(!q.isEmpty()){', '    Node cur = q.poll();', '    inner:', '    for(Node ch = cur.firstChild;ch != null; ch = ch.next){', '     q.add(ch);', '     for(Node to = cur.fail; to != null; to = to.fail){', '      for(Node lch = to.firstChild;lch != null; lch = lch.next){', '       if(lch.c == ch.c){', '        ch.fail = lch;', '        ch.hit += lch.hit; // propagation of hit', '        continue inner;', '       }', '      }', '     }', '     ch.fail = root;', '    }', '   }', '  }', '  ', '  public Node next(Node cur, char c)', '  {', '   for(;cur != null;cur = cur.fail){', '    for(Node ch = cur.firstChild;ch != null; ch = ch.next){', '     if(ch.c == c)return ch;', '    }', '   }', '   return root;', '  }', '  ', '  public int[][] ngMatrix(char[] cs)', '  {', '   int[] map = new int[128];', '   Arrays.fill(map, -1);', '   for(int i = 0;i < cs.length;i++)map[cs[i]] = i;', '   ', '   int[][] a = new int[gen+1][gen+1];', '   Node[] nodes = toArray();', '   for(int i = 0;i < gen;i++){', '    if(nodes[i].hit > 0)continue;', '    int nohit = cs.length;', '    boolean[] ved = new boolean[cs.length];', '    for(Node cur = nodes[i];cur != null;cur = cur.fail){', '     for(Node ch = cur.firstChild;ch != null; ch = ch.next){', '      if(map[ch.c] >= 0 && !ved[map[ch.c]]){', '       ved[map[ch.c]] = true;', '       if(ch.hit == 0)a[ch.id][i]++;', '       nohit--;', '      }', '     }', '    }', '    a[0][i] += nohit;', '   }', '   Arrays.fill(a[gen], 1);', '   return a;', '  }', '  ', '  public int[][] okMatrix(char[] cs)', '  {', '   int[] map = new int[128];', '   Arrays.fill(map, -1);', '   for(int i = 0;i < cs.length;i++)map[cs[i]] = i;', '   ', '   int[][] a = new int[gen+1][gen+1];', '   Node[] nodes = toArray();', '   for(int i = 0;i < gen;i++){', '    if(nodes[i].hit > 0)continue;', '    int nohit = cs.length;', '    boolean[] ved = new boolean[cs.length];', '    for(Node cur = nodes[i];cur != null;cur = cur.fail){', '     for(Node ch = cur.firstChild;ch != null; ch = ch.next){', '      if(map[ch.c] >= 0 && !ved[map[ch.c]]){', '       ved[map[ch.c]] = true;', '       if(ch.hit > 0){', '        a[gen][i]++;', '       }else{', '        a[ch.id][i]++;', '       }', '       nohit--;', '      }', '     }', '    }', '    a[0][i] += nohit;', '   }', '   a[gen][gen]++;', '   return a;', '  }', '  ', '  public void search(char[] q)', '  {', '   Node cur = root;', '   outer:', '   for(char c : q){', '    for(;cur != null;cur = cur.fail){', '     for(Node ch = cur.firstChild;ch != null; ch = ch.next){', '      if(ch.c == c){', '       // ch.hit', '       cur = ch;', '       continue outer;', '      }', '     }', '    }', '    cur = root;', '   }', '  }', '  ', '  public long countHit(char[] q)', '  {', '   Node cur = root;', '   long hit = 0;', '   outer:', '   for(char c : q){', '    for(;cur != null;cur = cur.fail){', '     for(Node ch = cur.firstChild;ch != null; ch = ch.next){', '      if(ch.c == c){', '       hit += ch.hit; // add hit', '       cur = ch;', '       continue outer;', '      }', '     }', '    }', '    cur = root;', '   }', '   return hit;', '  }', '  ', '  public Node[] toArray()', '  {', '   Node[] ret = new Node[gen];', '   ret[0] = root;', '   for(int i = 0;i < gen;i++){', '    Node cur = ret[i];', '    if(cur.next != null)ret[cur.next.id] = cur.next;', '    if(cur.firstChild != null)ret[cur.firstChild.id] = cur.firstChild;', '   }', '   return ret;', '  }', '  ', '  public String toString()', '  {', '   return root.toString("""");', '  }', ' }', ' ', ' void run() throws Exception', ' {', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  long s = System.currentTimeMillis();', '  solve();', '  out.flush();', '  if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', ' }', ' ', ' public static void main(String[] args) throws Exception { new C3().run(); }', ' ', ' private byte[] inbuf = new byte[1024];', ' public int lenbuf = 0, ptrbuf = 0;', ' ', ' private int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private double nd() { return Double.parseDouble(ns()); }', ' private char nc() { return (char)skip(); }', ' ', ' private String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.ArrayDeque;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', 'import java.util.Queue;', '', 'public class C3 {', '    InputStream is;', '    PrintWriter out;', '    String INPUT = """";', '    ', '    void solve()', '    {', '        int n = ni();', '        char[][] ss = new char[n][];', '        for(int i = 0;i < n;i++){', '            ss[i] = ns().toCharArray();', '        }', '        int[] h = na(n);', '        ', '        int Q = ni();', '        char[][] qs = new char[Q][];', '        long[] es = new long[2*Q];', '        for(int i = 0;i < Q;i++){', '            int s = ni(), t = ni();', '            qs[i] = ns().toCharArray();', '            es[i] = (long)s<<32|(long)i<<1|0;', '            es[i+Q] = (long)t+1<<32|(long)i<<1|1;', '        }', '        Arrays.sort(es);', '        long[] rets = new long[Q];', '        TrieByLink[] tries = new TrieByLink[18];', '        int p = 0;', '        for(long e : es){', '            long x = e>>>32;', '            int ind = ((int)e)>>>1;', '            int pm = (e&1) == 0 ? -1 : 1;', '            while(p < n && p <= x-1){', '                int d = Integer.numberOfTrailingZeros(p+1);', '                tries[d] = new TrieByLink();', '                for(int k = p-(1<<d)+1;k <= p;k++){', '                    tries[d].add(ss[k], h[k]);', '                }', '                tries[d].buildFailure();', '                p++;', '            }', '            long lhit = 0;', '            for(int d = 0;d < 18;d++){', '                if(p<<~d<0){', '                    lhit += tries[d].countHit(qs[ind]);', '                }', '            }', '            rets[ind] += lhit*pm;', '        }', '        long min = Long.MAX_VALUE;', '        long max = Long.MIN_VALUE;', '        for(long r : rets)min = Math.min(min, r);', '        for(long r : rets)max = Math.max(max, r);', '        ', '        out.println(min + "" "" + max);', '    }', '    ', '    public static class TrieByLink {', '        public Node root = new Node((char)0, 0);', '        public int gen = 1;', '        public static final char[] atoz = ""abcdefghijklmnopqrstuvwxyz"".toCharArray();', '        ', '        public static class Node', '        {', '            public int id;', '            public char c;', '            public Node next, firstChild;', '            public long hit = 0;', '            ', '            public Node fail;', '            ', '            public Node(char c, int id)', '            {', '                this.id = id;', '                this.c = c;', '            }', '            ', '            public String toString(String indent)', '            {', '                StringBuilder sb = new StringBuilder();', '                sb.append(indent + id + "":"" + c);', '                if(hit != 0)sb.append("" H:"" + hit);', '                if(fail != null)sb.append("" F:"" + fail.id);', '                sb.append(""\\n"");', '                for(Node c = firstChild;c != null; c = c.next){', '                    sb.append(c.toString(indent + ""  ""));', '                }', '                return sb.toString();', '            }', '        }', '        ', '        public void add(char[] s, long hit)', '        {', '            Node cur = root;', '            Node pre = null;', '            for(char c : s){', '                pre = cur; cur = cur.firstChild;', '                if(cur == null){', '                    cur = pre.firstChild = new Node(c, gen++);', '                }else{', '                    for(;cur != null && cur.c != c;pre = cur, cur = cur.next);', '                    if(cur == null)cur = pre.next = new Node(c, gen++);', '                }', '            }', '            cur.hit += hit;', '        }', '        ', '        public void buildFailure()', '        {', '            root.fail = null;', '            Queue<Node> q = new ArrayDeque<Node>();', '            q.add(root);', '            while(!q.isEmpty()){', '                Node cur = q.poll();', '                inner:', '                for(Node ch = cur.firstChild;ch != null; ch = ch.next){', '                    q.add(ch);', '                    for(Node to = cur.fail; to != null; to = to.fail){', '                        for(Node lch = to.firstChild;lch != null; lch = lch.next){', '                            if(lch.c == ch.c){', '                                ch.fail = lch;', '                                ch.hit += lch.hit; // propagation of hit', '                                continue inner;', '                            }', '                        }', '                    }', '                    ch.fail = root;', '                }', '            }', '        }', '        ', '        public Node next(Node cur, char c)', '        {', '            for(;cur != null;cur = cur.fail){', '                for(Node ch = cur.firstChild;ch != null; ch = ch.next){', '                    if(ch.c == c)return ch;', '                }', '            }', '            return root;', '        }', '        ', '        public int[][] ngMatrix(char[] cs)', '        {', '            int[] map = new int[128];', '            Arrays.fill(map, -1);', '            for(int i = 0;i < cs.length;i++)map[cs[i]] = i;', '            ', '            int[][] a = new int[gen+1][gen+1];', '            Node[] nodes = toArray();', '            for(int i = 0;i < gen;i++){', '                if(nodes[i].hit > 0)continue;', '                int nohit = cs.length;', '                boolean[] ved = new boolean[cs.length];', '                for(Node cur = nodes[i];cur != null;cur = cur.fail){', '                    for(Node ch = cur.firstChild;ch != null; ch = ch.next){', '                        if(map[ch.c] >= 0 && !ved[map[ch.c]]){', '                            ved[map[ch.c]] = true;', '                            if(ch.hit == 0)a[ch.id][i]++;', '                            nohit--;', '                        }', '                    }', '                }', '                a[0][i] += nohit;', '            }', '            Arrays.fill(a[gen], 1);', '            return a;', '        }', '        ', '        public int[][] okMatrix(char[] cs)', '        {', '            int[] map = new int[128];', '            Arrays.fill(map, -1);', '            for(int i = 0;i < cs.length;i++)map[cs[i]] = i;', '            ', '            int[][] a = new int[gen+1][gen+1];', '            Node[] nodes = toArray();', '            for(int i = 0;i < gen;i++){', '                if(nodes[i].hit > 0)continue;', '                int nohit = cs.length;', '                boolean[] ved = new boolean[cs.length];', '                for(Node cur = nodes[i];cur != null;cur = cur.fail){', '                    for(Node ch = cur.firstChild;ch != null; ch = ch.next){', '                        if(map[ch.c] >= 0 && !ved[map[ch.c]]){', '                            ved[map[ch.c]] = true;', '                            if(ch.hit > 0){', '                                a[gen][i]++;', '                            }else{', '                                a[ch.id][i]++;', '                            }', '                            nohit--;', '                        }', '                    }', '                }', '                a[0][i] += nohit;', '            }', '            a[gen][gen]++;', '            return a;', '        }', '        ', '        public void search(char[] q)', '        {', '            Node cur = root;', '            outer:', '            for(char c : q){', '                for(;cur != null;cur = cur.fail){', '                    for(Node ch = cur.firstChild;ch != null; ch = ch.next){', '                        if(ch.c == c){', '                            // ch.hit', '                            cur = ch;', '                            continue outer;', '                        }', '                    }', '                }', '                cur = root;', '            }', '        }', '        ', '        public long countHit(char[] q)', '        {', '            Node cur = root;', '            long hit = 0;', '            outer:', '            for(char c : q){', '                for(;cur != null;cur = cur.fail){', '                    for(Node ch = cur.firstChild;ch != null; ch = ch.next){', '                        if(ch.c == c){', '                            hit += ch.hit; // add hit', '                            cur = ch;', '                            continue outer;', '                        }', '                    }', '                }', '                cur = root;', '            }', '            return hit;', '        }', '        ', '        public Node[] toArray()', '        {', '            Node[] ret = new Node[gen];', '            ret[0] = root;', '            for(int i = 0;i < gen;i++){', '                Node cur = ret[i];', '                if(cur.next != null)ret[cur.next.id] = cur.next;', '                if(cur.firstChild != null)ret[cur.firstChild.id] = cur.firstChild;', '            }', '            return ret;', '        }', '        ', '        public String toString()', '        {', '            return root.toString("""");', '        }', '    }', '    ', '    void run() throws Exception', '    {', '        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        long s = System.currentTimeMillis();', '        solve();', '        out.flush();', '        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', '    }', '    ', '    public static void main(String[] args) throws Exception { new C3().run(); }', '    ', '    private byte[] inbuf = new byte[1024];', '    public int lenbuf = 0, ptrbuf = 0;', '    ', '    private int readByte()', '    {', '        if(lenbuf == -1)throw new InputMismatchException();', '        if(ptrbuf >= lenbuf){', '            ptrbuf = 0;', '            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '            if(lenbuf <= 0)return -1;', '        }', '        return inbuf[ptrbuf++];', '    }', '    ', '    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', '    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', '    ', '    private double nd() { return Double.parseDouble(ns()); }', '    private char nc() { return (char)skip(); }', '    ', '    private String ns()', '    {', '        int b = skip();', '        StringBuilder sb = new StringBuilder();', ""        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '            sb.appendCodePoint(b);', '            b = readByte();', '        }', '        return sb.toString();', '    }', '    ', '    private char[] ns(int n)', '    {', '        char[] buf = new char[n];', '        int b = skip(), p = 0;', '        while(p < n && !(isSpaceChar(b))){', '            buf[p++] = (char)b;', '            b = readByte();', '        }', '        return n == p ? buf : Arrays.copyOf(buf, p);', '    }', '    ', '    private char[][] nm(int n, int m)', '    {', '        char[][] map = new char[n][];', '        for(int i = 0;i < n;i++)map[i] = ns(m);', '        return map;', '    }', '    ', '    private int[] na(int n)', '    {', '        int[] a = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        return a;', '    }', '    ', '    private int ni()', '    {', '        int num = 0, b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private long nl()', '    {', '        long num = 0;', '        int b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']"
"['import java.io.InputStreamReader;', 'import java.io.IOException;', 'import java.io.BufferedReader;', 'import java.io.OutputStream;', 'import java.io.PrintWriter;', 'import java.io.Writer;', 'import java.util.StringTokenizer;', 'import java.io.InputStream;', '', '/**', ' * Built using CHelper plug-in', ' * Actual solution is at the top', ' * @author lwc626', ' */', 'public class Solution {', ' public static void main(String[] args) {', '  InputStream inputStream = System.in;', '  OutputStream outputStream = System.out;', '  MyInputReader in = new MyInputReader(inputStream);', '  MyOutputWriter out = new MyOutputWriter(outputStream);', '  Insertion_Sort solver = new Insertion_Sort();', '  int testCount = Integer.parseInt(in.next());', '  for (int i = 1; i <= testCount; i++)', '   solver.solve(i, in, out);', '  out.close();', ' }', '}', '', 'class Insertion_Sort {', ' public void solve(int testNumber, MyInputReader in, MyOutputWriter out) {', '        int n = in.nextInt() ;', '        int[] A = new int[ n ] ;', '        IOUtils.readIntArrays(in, A);', '        out.printLine( reverse_pair(out,A, 0 , n-1) );', ' }', '', '    private long reverse_pair(MyOutputWriter out,int[] a , int l , int r) {', '        if( l == r ) return 0 ;', '        int m = ( l + r ) / 2 ;', '        long ret = reverse_pair( out,a , l , m ) ;', '        ret += reverse_pair( out,a , m+1 , r ) ;', '', '        //out.printLine( l , r );', '        //IOUtils.printIntArrays(out , a );', '        int [] tmp = new int[ r - l + 1];', '        int nl = l , nr = m+1 , n = 0;', '        while ( nl <= m && nr <= r ){', '            if( a[nl] <= a[nr] ){', '                tmp[n++] = a[nl++] ;', '                ret += nr - m -1 ;', '            }else{', '                tmp[n++] = a[nr++] ;', '            }', '        }', '        while ( nl <= m ) { tmp[ n ++ ] = a[ nl ++ ]; ret += nr-m-1;}', '        while ( nr <= r ) tmp[ n ++ ] = a[ nr ++ ];', '        System.arraycopy( tmp , 0 , a , l, n );', '        return ret;', '    }', '}', '', 'class MyInputReader {', '    private BufferedReader reader;', '    private StringTokenizer tokenizer;', '', '    public MyInputReader(InputStream stream) {', '        reader = new BufferedReader(new InputStreamReader(stream));', '        tokenizer = null;', '    }', '', '    public String next() {', '        while (tokenizer == null || !tokenizer.hasMoreTokens()) {', '            try {', '                tokenizer = new StringTokenizer(reader.readLine());', '            } catch (IOException e) {', '                throw new RuntimeException(e);', '            }', '        }', '        return tokenizer.nextToken();', '    }', '', '    public int nextInt() {', '        return Integer.parseInt(next());', '    }', '    ', '    }', '', 'class MyOutputWriter {', '    private final PrintWriter writer;', '', '    public MyOutputWriter(OutputStream outputStream) {', '        writer = new PrintWriter(outputStream);', '    }', '', '    public MyOutputWriter(Writer writer) {', '        this.writer = new PrintWriter(writer);', '    }', '', '    public void print(Object...objects) {', '        for (int i = 0; i < objects.length; i++) {', '            if (i != 0)', ""                writer.print(' ');"", '            writer.print(objects[i]);', '        }', '    }', '', '    public void printLine(Object...objects) {', '        print(objects);', '        writer.println();', '    }', '', '    public void close() {', '        writer.close();', '    }', '', '}', '', 'class IOUtils {', '    public static void readIntArrays( MyInputReader in,int[]... arrays ){', '        for(int i = 0 ; i < arrays[0].length; i++ )', '            for( int j = 0 ; j < arrays.length ; j ++ )', '                arrays[j][i] = in.nextInt();', '    }', '    }']","['import java.util.Scanner;', '', 'public class InsertionSort {', '', '    static long mergeSort(int[] arr, int[] temp, int left, int right) {', '        long shifts = 0;', '        if (left < right) {', '            int mid = (left + right) / 2;', '', '            shifts += mergeSort(arr, temp, left, mid);', '            shifts += mergeSort(arr, temp, mid + 1, right);', '            shifts += merge(arr, temp, left, mid, right);', '        }', '        return shifts;', '    }', '', '    static long merge(int[] arr, int[] temp, int left, int mid, int right) {', '        long shifts = 0;', '', '        int i = left;', '        int j = mid + 1;', '        int k = left;', '', '        while (i <= mid && j <= right) {', '            if (arr[i] <= arr[j]) {', '                temp[k++] = arr[i++];', '            } else {', '                temp[k++] = arr[j++];', '                shifts += mid - i + 1; // Count shifts during merge', '            }', '        }', '', '        while (i <= mid) {', '            temp[k++] = arr[i++];', '        }', '', '        while (j <= right) {', '            temp[k++] = arr[j++];', '        }', '', '        // Copy the merged elements back to the original array', '        for (i = left; i <= right; i++) {', '            arr[i] = temp[i];', '        }', '', '        return shifts;', '    }', '', '    public static void main(String[] args) {', '        Scanner scanner = new Scanner(System.in);', '', '        // Read the number of queries', '        int q = scanner.nextInt();', '', '        for (int query = 0; query < q; query++) {', '            // Read the length of the array', '            int n = scanner.nextInt();', '', '            // Read the array elements', '            int[] arr = new int[n];', '            for (int i = 0; i < n; i++) {', '                arr[i] = scanner.nextInt();', '            }', '', '            // Temporary array for merge sort', '            int[] temp = new int[n];', '', '            // Call the mergeSort function and print the result', '            long result = mergeSort(arr, temp, 0, n - 1);', '            System.out.println(result);', '        }', '', '        scanner.close();', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  for(int T = ni();T >= 1;T--){', '   char[] s = ns().toCharArray();', '   char[] t = ns().toCharArray();', '   int p = 0, q = 0, r = 0;', '   char[] ret = new char[s.length+t.length];', '   outer:', '   while(r < ret.length){', '    if(q == t.length){', '     ret[r++] = s[p++];', '    }else if(p == s.length){', '     ret[r++] = t[q++];', '    }else if(s[p] < t[q]){', '     ret[r++] = s[p++];', '    }else if(s[p] > t[q]){', '     ret[r++] = t[q++];', '    }else{', '     int i = p, j = q;', '     for(;i < s.length && j < t.length;i++,j++){', '      if(s[i] < t[j]){', '       for(int k = p, o = k;k < i && s[k] == s[o];k++){', '        ret[r++] = s[p++];', '       }', '       continue outer;', '      }', '      if(s[i] > t[j]){', '       for(int k = q, o = k;k < j && t[k] == t[o];k++){', '        ret[r++] = t[q++];', '       }', '       continue outer;', '      }', '     }', '     if(i == s.length){', '      for(int k = q, o = k;k < j && t[k] == t[o];k++){', '       ret[r++] = t[q++];', '      }', '      continue outer;', '     }', '     if(j == t.length){', '      for(int k = p, o = k;k < i && s[k] == s[o];k++){', '       ret[r++] = s[p++];', '      }', '      continue outer;', '     }', '     throw new RuntimeException();', '    }', '   }', '   out.println(new String(ret));', '  }', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    private static final int MAXSIZE = 200100;', '    private static final int ALPHABET = 128;', '    ', '    public static void main(String[] args) {', '      ', '        Scanner in = new Scanner(System.in);', '        int testcase = Integer.parseInt(in.nextLine());', '        for (int i = 0; i < testcase; i++) {', '            String str1 = in.nextLine();', '            String str2 = in.nextLine();', '            System.out.println(solution(str1 + ""a"", str2 + ""b""));', '        }', '    }', '    private static List<Integer> buildSuffixArray(String str) {', '        int[] p = new int[MAXSIZE];', '        int[] c = new int[MAXSIZE];', '        int[] cnt = new int[MAXSIZE];', '        int[] pn = new int[MAXSIZE];', '        int[] cn = new int[MAXSIZE];', '        Arrays.fill(cnt, 0);', '        int n = str.length();', '        for (int i = 0; i < n; i++) {', '            ++cnt[str.charAt(i)];', '        }', '        for (int i = 1; i < ALPHABET; i++) {', '            cnt[i] += cnt[i - 1];', '        }', '        for (int i = 0; i < n; i++) {', '            p[--cnt[str.charAt(i)]] = i;', '        }', '        int count = 1;', '        c[p[0]] = count - 1;', '        for (int i = 1; i < n; i++) {', '            if (str.charAt(p[i]) != str.charAt(p[i - 1])) {', '                ++count;', '            }', '            c[p[i]] = count - 1;', '        }', '        for (int h = 0; (1 << h) < n; ++h) {', '            for (int i =0; i < n; i++) {', '                pn[i] = p[i] - (1 << h);', '                if (pn[i] < 0) {', '                    pn[i] += n;', '                }', '            }', '            Arrays.fill(cnt, 0);', '            for (int i = 0; i < n; i++) {', '                ++cnt[c[i]];', '            }', '            for (int i = 1; i < count; i++) {', '                cnt[i] += cnt[i - 1];', '            }', '            for (int i = n - 1; i >= 0; i--) {', '                p[--cnt[c[pn[i]]]] = pn[i];', '            }', '            count = 1;', '            cn[p[0]] = count - 1;', '            for (int i = 1; i < n; i++) {', '                int pos1 = (p[i] + (1 << h)) % n;', '                int pos2 = (p[i - 1] +  (1 << h)) % n;', '                if (c[p[i]] != c[p[i - 1]] || c[pos1] != c[pos2]) {', '                    ++count;', '                }', '                cn[p[i]] = count - 1;', '            }', '            for (int i = 0; i < n; i++) {', '                c[i] = cn[i];', '            }', '        }', '        List<Integer> res = new ArrayList<Integer>(n);', '        for (int i = 0; i < n; i++) {', '            res.add(c[i]);', '        }', '        return res;', '    }', '    ', '    private static String solution(String str1, String str2) {', '        StringBuilder sb = new StringBuilder(str1).append(str2);', '        List<Integer> suffix = buildSuffixArray(sb.toString());', '        StringBuilder rst = new StringBuilder();', '        int start1 = 0;', '        int start2 = 0;', '        while (start1 < str1.length() - 1 || start2 < str2.length() - 1) {', '            if (start1 >= str1.length() - 1) {', '                rst.append(str2.charAt(start2++));', '                continue;', '            }', '            if (start2 >= str2.length() - 1) {', '                rst.append(str1.charAt(start1++));', '                continue;', '            }', '            if (suffix.get(start1) < suffix.get(str1.length() + start2)) {', '                rst.append(str1.charAt(start1++));', '            } else {', '                rst.append(str2.charAt(start2++));', '            }', '        }', '        return rst.toString();', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.ArrayDeque;', 'import java.util.ArrayList;', 'import java.util.Arrays;', 'import java.util.BitSet;', 'import java.util.HashMap;', 'import java.util.InputMismatchException;', 'import java.util.List;', 'import java.util.Map;', 'import java.util.Queue;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' static char[] reg;', ' static int len, pos;', ' static List<Node> nodes;', ' ', ' static void solve()', ' {', '  int mod = 1000000007;', '  for(int T = ni();T >= 1;T--){', '   reg = ns(123);', '   len = reg.length;', '   pos = 0;', '   idbase = 0;', '   nodes = new ArrayList<Node>();', '   Node[] root = expr();', '   if(pos != len){', '    throw new AssertionError();', '   }', '   ', '//   root[0].makeNexts();', '   for(Node n : nodes){', '    n.makeNexts();', '   }', '   root[1].isSink = 1;', '   root[0].makeSink();', '//   for(Node n : nodes){', '//    tr(n.id, n.as, n.bs, n.next, n.isSink);', '//   }', '   ', '   Map<BitSet, Integer> states = new HashMap<BitSet, Integer>();', '   BitSet ini = new BitSet();', '   ini.set(root[0].id);', '   states.put(ini, 0);', '   ', '   Queue<BitSet> q = new ArrayDeque<BitSet>();', '   q.add(ini);', '   int step = 1;', '   List<int[]> es = new ArrayList<int[]>();', '   while(!q.isEmpty()){', '    BitSet cur = q.poll();', '    {', '     BitSet nex = new BitSet();', '     for(int i = cur.nextSetBit(0);i != -1;i = cur.nextSetBit(i + 1)){', '      nex.or(nodes.get(i).as);', '     }', ""//     tr(cur, 'a', nex);"", '     if(!nex.isEmpty()){', '      if(!states.containsKey(nex)){', '       states.put(nex, step++);', '       q.add(nex);', '      }', '      es.add(new int[]{states.get(cur), states.get(nex)});', '     }', '    }', '    {', '     BitSet nex = new BitSet();', '     for(int i = cur.nextSetBit(0);i != -1;i = cur.nextSetBit(i + 1)){', '      nex.or(nodes.get(i).bs);', '     }', ""//     tr(cur, 'b', nex);"", '     if(!nex.isEmpty()){', '      if(!states.containsKey(nex)){', '       states.put(nex, step++);', '       q.add(nex);', '      }', '      es.add(new int[]{states.get(cur), states.get(nex)});', '     }', '    }', '   }', '   ', '   int[][] M = new int[step+1][step+1];', '   for(int[] e : es){', '    M[e[1]][e[0]]++;', '   }', '   for(Map.Entry<BitSet, Integer> e : states.entrySet()){', '    for(int i = e.getKey().nextSetBit(0);i != -1;i = e.getKey().nextSetBit(i + 1)){', '     if(nodes.get(i).isSink == 1){', '      M[step][e.getValue()]++;', '      break;', '     }', '    }', '   }', '   ', '   int L = ni();', '   int[] v = new int[step+1];', '   v[0] = 1;', '   out.println(pow(M, v, L+1, mod)[step]);', '  }', ' }', ' ', ' // A^e*v', ' public static int[] pow(int[][] A, int[] v, long e, int mod)', ' {', '  int[][] MUL = A;', '  for(int i = 0;i < v.length;i++)v[i] %= mod;', '  for(;e > 0;e>>>=1) {', '   if((e&1)==1)v = mul(MUL, v, mod);', '   MUL = p2(MUL, mod);', '  }', '  return v;', ' }', ' ', ' public static int[] mul(int[][] A, int[] v, int mod)', ' {', '  int m = A.length;', '  int n = v.length;', '  int[] w = new int[m];', '  for(int i = 0;i < m;i++){', '   long sum = 0;', '   for(int k = 0;k < n;k++){', '    sum += (long)A[i][k] * v[k];', '    sum %= mod;', '   }', '   w[i] = (int)sum;', '  }', '  return w;', ' }', ' ', ' public static int[][] p2(int[][] A, int mod)', ' {', '  int n = A.length;', '  int[][] C = new int[n][n];', '  for(int i = 0;i < n;i++){', '   for(int j = 0;j < n;j++){', '    long sum = 0;', '    for(int k = 0;k < n;k++){', '     sum += (long)A[i][k] * A[k][j];', '     sum %= mod;', '    }', '    C[i][j] = (int)sum;', '   }', '  }', '  return C;', ' }', ' ', ' static Node[] expr()', ' {', ""  if(reg[pos] == '('){"", '   pos++;', '   Node[] r1 = expr();', ""   if(reg[pos] == '*'){"", '    pos++;', ""    if(reg[pos] != ')')throw new AssertionError();"", '    pos++;', '    Node source = new Node();', '    Node sink = new Node();', ""    source.link(r1[0], 'e');"", ""    r1[1].link(sink, 'e');"", ""    r1[1].link(r1[0], 'e');"", ""    source.link(sink, 'e');"", '    return new Node[]{source, sink};', ""   }else if(reg[pos] == '|'){"", '    pos++;', '    Node[] r2 = expr();', ""    if(reg[pos] != ')')throw new AssertionError();"", '    pos++;', '    Node source = new Node();', '    Node sink = new Node();', ""    source.link(r1[0], 'e');"", ""    source.link(r2[0], 'e');"", ""    r1[1].link(sink, 'e');"", ""    r2[1].link(sink, 'e');"", '    return new Node[]{source, sink};', '   }else{', '    Node[] r2 = expr();', ""    if(reg[pos] != ')')throw new AssertionError();"", '    pos++;', ""    r1[1].link(r2[0], 'e');"", '    return new Node[]{r1[0], r2[1]};', '   }', '  }else{', '   Node source = new Node();', '   Node sink = new Node();', '   source.link(sink, reg[pos++]);', '   return new Node[]{source, sink};', '  }', ' }', ' ', ' static class Edge', ' {', '  public char c;', '  public Node to;', ' ', '  public Edge(char c, Node to) {', '   this.c = c;', '   this.to = to;', '  }', '  ', '  public String toString()', '  {', '   return c + "":"" + to.id;', '  }', ' }', ' ', ' static int idbase = 0;', ' ', ' static class Node', ' {', '  public List<Edge> next;', '  public BitSet as;', '  public BitSet bs;', '  public int id;', '  public int isSink;', '  public boolean und;', '  ', '  public Node()', '  {', '   next = new ArrayList<Edge>();', '   nodes.add(this);', '   id = idbase++;', '  }', '  ', '  public void link(Node to, char c)', '  {', '   next.add(new Edge(c, to));', '  }', '  ', '  public void makeSink()', '  {', '   if(isSink != 0)return;', '   this.isSink = -1;', '   for(Edge e : next){', '    e.to.makeSink();', ""    if(e.c == 'e' && e.to.isSink == 1){"", '     this.isSink = 1;', '    }', '   }', '  }', '  ', '  public void makeNexts()', '  {', '   Queue<Node> q = new ArrayDeque<Node>();', '   as = new BitSet();', '   bs = new BitSet();', '   q.add(this);', '   BitSet ved = new BitSet();', '   ved.set(this.id);', '   while(!q.isEmpty()){', '    Node n = q.poll();', '    for(Edge e : n.next){', ""     if(e.c == 'e'){"", '      if(!ved.get(e.to.id)){', '       ved.set(e.to.id);', '       q.add(e.to);', '      }', ""     }else if(e.c == 'a'){"", '      as.set(e.to.id);', ""     }else if(e.c == 'b'){"", '      bs.set(e.to.id);', '     }', '    }', '   }', '  }', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'class Regex {', ""        static char e = '\\0';"", '', '        final Node root;', '        final Node[] nodes;', '', '        Regex(String regex) {', '            Parser parser = new Parser(regex);', '            parser.parse();', '            SubsetConstruction subset = new SubsetConstruction(parser.expr.start, parser.expr.end);', '            this.nodes = subset.dfa();', '            this.root = nodes[0];', '        }', '', '        class SubsetConstruction {', '            private final Node nfaEnd;', '            private final Queue<State> queue;', '            private final Map<Set<Node>, Node> dfaMap;', '            private final Node dfaRoot;', '', '            SubsetConstruction(Node nfaRoot, Node nfaEnd) {', '                this.nfaEnd = nfaEnd;', '                this.queue = new ArrayDeque<>();', '                this.dfaMap = new HashMap<>();', '                this.dfaRoot = addState(eClosure(nfaRoot)).dfa;', '            }', '', '            Node[] dfa() {', '                while (!queue.isEmpty()) {', '                    State state = queue.poll();', ""                    for (char c : new char[]{'a', 'b'}) {"", '                        Set<Node> nfaNext = eClosure(next(state.nfa, c));', '                        if (nfaNext.isEmpty())', '                            continue;', '                        Node dfaNext = dfaMap.get(nfaNext);', '                        if (dfaNext == null)', '                            dfaNext = addState(nfaNext).dfa;', '                        state.dfa.edges.add(new Edge(c, dfaNext));', '                    }', '                }', '                return getNodes();', '            }', '', '            private Node[] getNodes() {', '                ArrayList<Node> nodes = new ArrayList<>();', '                nodes.add(dfaRoot);', '                for (Node node : dfaMap.values())', '                    if (node != dfaRoot) nodes.add(node);', '                return nodes.toArray(new Node[nodes.size()]);', '            }', '', '            private State addState(Set<Node> nfa) {', '                State state = new State(nfa);', '                state.dfa.isFinal = nfa.contains(nfaEnd);', '                dfaMap.put(state.nfa, state.dfa);', '                queue.add(state);', '                return state;', '            }', '', '            class State {', '                final Set<Node> nfa;', '                final Node dfa = new Node();', '                State(Set<Node> nfa) { this.nfa = nfa; }', '            }', '', '            private Set<Node> eClosure(Node node) {', '                return eClosure(Collections.singletonList(node));', '            }', '', '            private Set<Node> eClosure(Collection<Node> nodes) {', '                Set<Node> closure = new HashSet<>();', '                Stack<Node> stack = new Stack<>();', '                stack.addAll(nodes);', '                while (!stack.isEmpty()) {', '                    Node node = stack.pop();', '                    if (closure.add(node))', '                        stack.addAll(next(node, e));', '                }', '                return closure;', '            }', '', '            private Collection<Node> next(Collection<Node> nodes, char c) {', '                Collection<Node> list = new ArrayList<>();', '                for (Node node : nodes)', '                    list.addAll(next(node, c));', '                return list;', '            }', '', '            private Collection<Node> next(Node node, char c) {', '                Collection<Node> list = new ArrayList<>();', '                for (Edge edge : node.edges)', '                    if (edge.value == c) list.add(edge.node);', '                return list;', '            }', '        }', '', '        class Parser {', '            private final String regex;', '            private int pos;', '            Expression expr;', '', '            Parser(String regex) {', '                this.regex = regex;', '                this.pos = 0;', '            }', '', '            Node parse() {', '                return (expr = sequence()).start;', '            }', '', '            class Expression {', '                Node start = new Node();', '                Node end = start;', '            }', '', '            private Expression sequence() {', '                Expression expr = new Expression();', '                for (; ; ) {', '                    char c = take();', '                    switch (c) {', ""                        case 'a':"", ""                        case 'b': literal(expr, c); break;"", ""                        case '(': expr = parenthesis(expr); break;"", ""                        case '|': expr = pipe(expr); break;"", ""                        case '*': expr = star(expr); break;"", '                        default: putback(); return expr;', '                    }', '                }', '            }', '', '            private void literal(Expression expr, char c) {', '                expr.end.edges.add(new Edge(c, expr.end = new Node()));', '            }', '', '            private Expression parenthesis(Expression expr) {', '                Expression nested = sequence();', ""                if (take() != ')')"", '                    throw new IllegalStateException(""syntax error: "" + "") expected"");', '                if (expr.start == expr.end) return nested;', '                expr.end.edges.add(new Edge(e, nested.start));', '                expr.end = nested.end;', '                return expr;', '            }', '', '            private Expression pipe(Expression first) {', '                Expression second = sequence();', '                Expression expr = new Expression();', '                expr.start.edges.add(new Edge(e, first.start));', '                expr.start.edges.add(new Edge(e, second.start));', '                first.end.edges.add(new Edge(e, expr.end = new Node()));', '                second.end.edges.add(new Edge(e, expr.end));', '                return expr;', '            }', '', '            private Expression star(Expression inner) {', '                Expression expr = new Expression();', '                expr.start.edges.add(new Edge(e, inner.start));', '                inner.end.edges.add(new Edge(e, inner.start));', '                inner.end.edges.add(new Edge(e, expr.end = new Node()));', '                expr.start.edges.add(new Edge(e, expr.end));', '                return expr;', '            }', '', '            private char take() {', '                return skipWs() ? regex.charAt(pos++) : e;', '            }', '', '            private void putback() {', '                if (pos >= 0) --pos;', '            }', '', '            private boolean skipWs() {', '                while (pos < regex.length() && Character.isWhitespace(regex.charAt(pos))) ++pos;', '                return pos < regex.length();', '            }', '        }', '', '        class Node {', '            final ArrayList<Edge> edges = new ArrayList<>();', '            boolean isFinal;', '        }', '', '        class Edge {', '            final char value;', '            final Node node;', '', '            Edge(char value, Node node) {', '                this.value = value;', '                this.node = node;', '            }', '        }', '    }', '', '    class RegexCounter {', '        private final long[][] adjacencyMatrix;', '        private final ArrayList<Integer> finalStates;', '', '        RegexCounter(Regex regex) {', '            Map<Regex.Node, Integer> indexes = new HashMap<>();', '            this.adjacencyMatrix = new long[regex.nodes.length][regex.nodes.length];', '            this.finalStates = new ArrayList<>();', '            for (Regex.Node node : regex.nodes) {', '                int index = getIndex(indexes, node);', '                for (Regex.Edge edge : node.edges) {', '                    int next = getIndex(indexes, edge.node);', '                    adjacencyMatrix[index][next] = 1;', '                }', '            }', '        }', '', '        private int getIndex(Map<Regex.Node, Integer> indexes, Regex.Node node) {', '            Integer index = indexes.get(node);', '            if (index == null) {', '                indexes.put(node, index = indexes.size());', '                if (node.isFinal)', '                    finalStates.add(index);', '            }', '            return index;', '        }', '', '        long count(int len) {', '            long[][] m = new MatrixPower(adjacencyMatrix).power(len);', '            long count = 0;', '            for (int finalState : finalStates)', '                count = (count + m[0][finalState]) % 1000000007L;', '            return count;', '        }', '    }', '', '    class MatrixPower {', '        private final long[][] matrix;', '        private final Map<Integer, long[][]> powers;', '', '        MatrixPower(long[][] matrix) {', '            this.matrix = matrix;', '            this.powers = new HashMap<>();', '        }', '', '        long[][] power(int p) {', '            if (p == 1) return matrix;', '            long[][] result = powers.get(p);', '            if (result != null)', '                return result;', '            result = power(p / 2);', '            powers.put(p / 2 * 2, result = multiply(result, result));', '            if (p % 2 > 0)', '                powers.put(p, result = multiply(result, power(p % 2)));', '            return result;', '        }', '', '        private long[][] multiply(long[][] a, long[][] b) {', '            long[][] m = new long[a.length][a.length];', '            for (int i = 0; i < a.length; ++i) {', '                for (int j = 0; j < a.length; ++j) {', '                    long sum = 0;', '                    for (int k = 0; k < a.length; ++k)', '                        sum = (sum + a[i][k] * b[k][j]) % 1000000007L;', '                    m[i][j] = sum;', '                }', '            }', '            return m;', '        }', '    }', 'public class Solution {', '    ', '    /*', '     * Complete the countStrings function below.', '     */', '    static long countStrings(String r, int l) {', '        return l == 0 ? 0 : new RegexCounter(new Regex(r)).count(l);', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int t = Integer.parseInt(scanner.nextLine().trim());', '', '        for (int tItr = 0; tItr < t; tItr++) {', '            String[] rl = scanner.nextLine().split("" "");', '', '            String r = rl[0];', '', '            int l = Integer.parseInt(rl[1].trim());', '', '            long result = countStrings(r, l);', '', '            bufferedWriter.write(String.valueOf(result));', '            bufferedWriter.newLine();', '        }', '', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.ArrayList;', 'import java.util.List;', '', 'public class Solution {', '', '    static class SuffixAutomata {', '', '        static class Vertex {', '            Vertex suffixLink = null;', '            Vertex[] edges;', '            int log = 0;', '', '            int terminals;', '            boolean visited;', '', '            public Vertex(Vertex o, int log) {', '                edges = o.edges.clone();', '                this.log = log;', '            }', '', '            public Vertex(int log) {', '                edges = new Vertex[26];', '                this.log = log;', '            }', '', '            long dp() {', '                if (visited) {', '                    return 0;', '                }', '                visited = true;', '                long r = 0;', '                for (Vertex v : edges) {', '                    if (v != null) {', '                        r = Math.max(r, v.dp());', '                        terminals += v.terminals;', '                    }', '                }', '                return Math.max(r, 1L * log * terminals);', '            }', '        }', '', '        Vertex root, last;', '', '        public SuffixAutomata(String str) {', '            last = root = new Vertex(0);', '            for (int i = 0; i < str.length(); i++) {', '                addChar(str.charAt(i));', '            }', '            addTerm();', '        }', '', '        private void addChar(char c) {', '            Vertex cur = last;', '            last = new Vertex(cur.log + 1);', ""            while (cur != null && cur.edges[c - 'a'] == null) {"", ""                cur.edges[c - 'a'] = last;"", '                cur = cur.suffixLink;', '            }', '            if (cur != null) {', ""                Vertex q = cur.edges[c - 'a'];"", '                if (q.log == cur.log + 1) {', '                    last.suffixLink = q;', '                } else {', '                    Vertex r = new Vertex(q, cur.log + 1);', '                    r.suffixLink = q.suffixLink;', '                    q.suffixLink = r;', '                    last.suffixLink = r;', '                    while (cur != null) {', ""                        if (cur.edges[c - 'a'] == q) {"", ""                            cur.edges[c - 'a'] = r;"", '                        } else {', '                            break;', '                        }', '                        cur = cur.suffixLink;', '                    }', '                }', '            } else {', '                last.suffixLink = root;', '            }', '        }', '', '        private void addTerm() {', '            Vertex cur = last;', '            while (cur != null) {', '                cur.terminals++;', '                cur = cur.suffixLink;', '            }', '        }', '    }', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        String s = in.next();', '        SuffixAutomata a = new SuffixAutomata(s);', '        out.println(a.root.dp());', '    }', '', '    public static void main(String[] args) throws IOException {', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']","['import java.io.*;', 'import java.util.ArrayList;', 'import java.util.List;', '', 'public class Solution {', '', '    static class SuffixAutomata {', '', '        static class Vertex {', '            Vertex suffixLink = null;', '            Vertex[] edges;', '            int log = 0;', '', '            int terminals;', '            boolean visited;', '', '            public Vertex(Vertex o, int log) {', '                edges = o.edges.clone();', '                this.log = log;', '            }', '', '            public Vertex(int log) {', '                edges = new Vertex[26];', '                this.log = log;', '            }', '', '            long dp() {', '                if (visited) {', '                    return 0;', '                }', '                visited = true;', '                long r = 0;', '                for (Vertex v : edges) {', '                    if (v != null) {', '                        r = Math.max(r, v.dp());', '                        terminals += v.terminals;', '                    }', '                }', '                return Math.max(r, 1L * log * terminals);', '            }', '        }', '', '        Vertex root, last;', '', '        public SuffixAutomata(String str) {', '            last = root = new Vertex(0);', '            for (int i = 0; i < str.length(); i++) {', '                addChar(str.charAt(i));', '            }', '            addTerm();', '        }', '', '        private void addChar(char c) {', '            Vertex cur = last;', '            last = new Vertex(cur.log + 1);', ""            while (cur != null && cur.edges[c - 'a'] == null) {"", ""                cur.edges[c - 'a'] = last;"", '                cur = cur.suffixLink;', '            }', '            if (cur != null) {', ""                Vertex q = cur.edges[c - 'a'];"", '                if (q.log == cur.log + 1) {', '                    last.suffixLink = q;', '                } else {', '                    Vertex r = new Vertex(q, cur.log + 1);', '                    r.suffixLink = q.suffixLink;', '                    q.suffixLink = r;', '                    last.suffixLink = r;', '                    while (cur != null) {', ""                        if (cur.edges[c - 'a'] == q) {"", ""                            cur.edges[c - 'a'] = r;"", '                        } else {', '                            break;', '                        }', '                        cur = cur.suffixLink;', '                    }', '                }', '            } else {', '                last.suffixLink = root;', '            }', '        }', '', '        private void addTerm() {', '            Vertex cur = last;', '            while (cur != null) {', '                cur.terminals++;', '                cur = cur.suffixLink;', '            }', '        }', '    }', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        String s = in.next();', '        SuffixAutomata a = new SuffixAutomata(s);', '        out.println(a.root.dp());', '    }', '', '    public static void main(String[] args) throws IOException {', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']"
"['import java.util.*;', '', 'public class PalindromeBuilder {', '    public static class State {', '        int length;', '        int link;', '        int[] next = new int[128];', '        int endpos;', '        final List<Integer> ilink;', '', '        public State()', '        {', '            Arrays.fill(next, -1);', '            ilink = new ArrayList<>();', '        }', '    }', '', '    public static State[] buildSuffixAutomaton(String s) {', '        int n = s.length();', '        State[] st = new State[Math.max(2, 2 * n - 1)];', '        st[0] = new State();', '        st[0].link = -1;', '        st[0].endpos = -1;', '        int last = 0;', '        int size = 1;', '        for (char c : s.toCharArray()) {', '            int cur = size++;', '            st[cur] = new State();', '            st[cur].length = st[last].length + 1;', '            st[cur].endpos = st[last].length;', '', '            int p = go(st, last, -1, c, cur);', '            if (p == -1) {', '                st[cur].link = 0;', '            } else {', '                int q = st[p].next[c];', '                if (st[p].length + 1 == st[q].length)', '                    st[cur].link = q;', '                else {', '                    int clone = size++;', '                    st[clone] = new State();', '                    st[clone].length = st[p].length + 1;', '                    st[clone].next = st[q].next.clone();', '                    st[clone].link = st[q].link;', '                    go(st, p, q, c, clone);', '                    st[q].link = clone;', '                    st[cur].link = clone;', '                    st[clone].endpos = -1;', '                }', '            }', '            last = cur;', '        }', '        for (int i = 1; i < size; i++) {', '            st[st[i].link].ilink.add(i);', '        }', '        return Arrays.copyOf(st, size);', '    }', '', '    private static int go(State[] st, int p, int q, char c, int ns) {', '        while (p != -1 && st[p].next[c] == q) {', '            st[p].next[c] = ns;', '            p = st[p].link;', '        }', '        return p;', '    }', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(System.in);', '        int n = sc.nextInt();', '        for (int i = 0; i < n; ++i) {', '            String a = sc.next();', '            String b = sc.next();', '            System.out.println(solve(a, b));', '        }', '    }', '', '    static String candidate(String a, String b) {', '        State[] as = buildSuffixAutomaton(a);', '        int[] l = buildPalindromeLookup(b);', '', '        int len = 0;', '', '        int bestHalf = 0;', '        int bestMid = 0;', '        int bestTotal = 0;', '        int start = -1;', '        for (int i = 0, aPos = 0; i < b.length(); ++i) {', '            char c = b.charAt(i);', '            if (as[aPos].next[c] == -1) {', '                while (aPos != -1 && as[aPos].next[c] == -1) {', '                    aPos = as[aPos].link;', '                }', '                if (aPos == -1) {', '                    aPos = 0;', '                    len = 0;', '                    continue;', '                }', '                len = as[aPos].length;', '            }', '            ++len;', '            aPos = as[aPos].next[c];', '', '            int nStart = i - len + 1;', '            int nMid = 0;', '            if (i + 1 < b.length()) {', '                nMid = l[i + 1];', '            }', '            int nTotal = 2*len + nMid;', '', '            if (bestTotal < nTotal || (bestTotal == nTotal && gt(b, start, nStart, len + nMid))) {', '                bestHalf = len;', '                bestMid = nMid;', '                bestTotal = nTotal;', '                start = nStart;', '            }', '        }', '        StringBuilder sb = new StringBuilder();', '        for (int i = 0; i < bestHalf + bestMid; ++i) {', '            sb.append(b.charAt(start + i));', '        }', '        for (int i = bestHalf - 1; i >= 0; --i) {', '            sb.append(sb.charAt(i));', '        }', '        return sb.toString();', '    }', '', '    static String solve(String a, String b) {', '        String rb = rev(b);', '        String res = candidate(a, rb);', '        String c1 = candidate(rb, a);', '        if (c1.length() > res.length() || (c1.length() == res.length() && c1.compareTo(res) < 0)) {', '            res = c1;', '        }', '        if (res.length() == 0) {', '            res = ""-1"";', '        }', '        return res;', '    }', '', '    static String rev(String s) {', '        StringBuilder sb = new StringBuilder();', '        for (int i = s.length() - 1; i >= 0; --i) {', '            sb.append(s.charAt(i));', '        }', '        return sb.toString();', '    }', '', '    static boolean gt(String s, int start, int nStart, int size) {', '        int cmp = 0;', '        for (int i = 0; i < size; ++i) {', '            cmp = Character.compare(s.charAt(start + i), s.charAt(nStart + i));', '            if (cmp != 0) {', '                break;', '            }', '        }', '        return cmp > 0;', '    }', '', '    static int[] buildPalindromeLookup(String s) {', '        char[] s2 = addBoundaries(s.toCharArray());', '        int[] p = new int[s2.length];', '        int c = 0, r = 0;', '        int m = 0, n = 0;', '        for (int i = 1; i < s2.length; i++) {', '            if (i > r) {', '                p[i] = 0;', '                m = i - 1;', '                n = i + 1;', '            } else {', '                int i2 = c * 2 - i;', '                if (p[i2] < (r-i)) {', '                    p[i] = p[i2];', '                    m = -1;', '                } else {', '                    p[i] = r - i;', '                    n = r + 1;', '                    m = i * 2 - n;', '                }', '            }', '            while (m >= 0 && n < s2.length && s2[m] == s2[n]) {', '                p[i]++;', '                m--;', '                n++;', '            }', '            if ((i + p[i]) > r) {', '                c = i;', '                r = i + p[i];', '            }', '        }', '        int[] res = new int[s.length()];', '        for (int i = 1; i < s2.length - 1; i++) {', '            int idx = (i - p[i])/2;', '            res[idx] = Math.max(res[idx], p[i]);', '        }', '        return res;', '    }', '', '    private static char[] addBoundaries(char[] cs) {', '        if (cs == null || cs.length == 0)', '            return ""||"".toCharArray();', '', '        char[] cs2 = new char[cs.length * 2 + 1];', '        for (int i = 0; i < cs2.length - 1; i += 2) {', ""            cs2[i] = '|';"", '            cs2[i + 1] = cs[i / 2];', '        }', ""        cs2[cs2.length - 1] = '|';"", '        return cs2;', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '  static int N = 100000;', '  static int M = 4 * N + 3;', '  static char[] a = new char[M];', '  static int[] sa = new int[M];', '  static int[] isa = new int[M];', '', '  static void iota(int v[], int end, int val) {', '    for (int i = 0; i < end; i++) {', '      v[i] = val++;', '    }', '  }', '', '  static void suffixArray(int n, int m, int h[], int x[]) {', '    Arrays.fill(h, 0, m, 0);', '    for (int i = 0; i < n; i++) {', '      isa[i] = a[i];', '    }', '    for (int i = 0; i < n; i++) {', '      h[isa[i]]++;', '    }', '    for (int i = 1; i < m; i++) {', '      h[i] += h[i - 1];', '    }', '    for (int i = n; --i >= 0;) {', '      sa[--h[isa[i]]] = i;', '    }', '    int k = 1;', '    for (;; k <<= 1) {', '      iota(x, k, n - k);', '      int j = k;', '      for (int i = 0; i < n; i++) {', '        if (sa[i] >= k) {', '          x[j++] = sa[i] - k;', '        }', '      }', '      Arrays.fill(h, 0, m, 0);', '      for (int i = 0; i < n; i++) {', '        h[isa[x[i]]]++;', '      }', '      for (int i = 1; i < m; i++) {', '        h[i] += h[i - 1];', '      }', '      for (int i = n; --i >= 0;) {', '        sa[--h[isa[x[i]]]] = x[i];', '      }', '      Arrays.fill(h, 0, m, 0);', '      m = 1;', '      h[sa[0]] = 0;', '      for (int i = 1; i < n; i++) {', '        if (isa[sa[i]] != isa[sa[i - 1]] || Math.max(sa[i], sa[i - 1]) >= n - k', '            || isa[sa[i] + k] != isa[sa[i - 1] + k]) {', '          m++;', '        }', '        h[sa[i]] = m - 1;', '      }', '      System.arraycopy(h, 0, isa, 0, n);', '      if (m == n) {', '        break;', '      }', '    }', '    k = 0;', '    h[0] = 0;', '    for (int i = 0; i < n; i++) {', '      if (isa[i] > 0) {', '        for (int j = sa[isa[i] - 1]; i + k < n && j + k < n && a[i + k] == a[j + k]; k++)', '          ;', '        h[isa[i]] = k;', '        if (k > 0) {', '          k--;', '        }', '      }', '    }', '  }', '', '  static int[][] tab = new int[19][M];', '', '  static int lcp(int x, int y) {', '    if (x < 0 || y < 0) {', '      return 0;', '    }', '    x = isa[x];', '    y = isa[y];', '    if (x > y) {', '      int t = x;', '      x = y;', '      y = t;', '    }', '    x++;', '    int k = 0;', '    while (1 << k + 1 < y - x + 1) {', '      k++;', '    }', '    return Math.min(tab[k][x], tab[k][y - (1 << k) + 1]);', '  }', '', '  static long[] z = new long[2 * N + 1];', '  static int[] len = new int[N];', '  ', '  static void manacher(int from, int n) {', '    int m = 2 * n + 1;', '    z[0] = 1;', '    for (int f = 0, g = 0, i = 1; i < m; i++) {', '      if (i < g && z[2 * f - i] != g - i) {', '        z[i] = Math.min(z[2 * f - i], g - i);', '      } else {', '        g = Math.max(g, f = i);', '        for (; g < m && 2 * f - g >= 0 && (g % 2 == 0 || a[from + (2 * f - g) / 2] == a[from + g / 2]); g++) {', '          len[(g - 1) / 2] = g - f;', '        }', '        z[f] = g - f;', '      }', '    }', '  }', '', '  static int[] L = new int[M];', '  static int[] R = new int[M];', '', '  static char[] buildPalindrome(char[] a1, char[] b) {', '    int na = a1.length;', '    System.arraycopy(a1, 0, a, 0, na);', '    a[na] = 0;', '    int ra = na + 1;', '    for (int i = 0; i < na; i++) {', '      a[ra + i] = a[na - 1 - i];', '    }', '    a[ra + na] = 1;', '    int nb = b.length;', '    int b0 = ra + na + 1;', '    System.arraycopy(b, 0, a, b0, nb);', '    a[b0 + nb] = 2;', '    int rb = b0 + nb + 1;', '    for (int i = 0; i < nb; i++) {', '      a[rb + i] = b[nb - 1 - i];', '    }', '    int n = 2 * na + 2 * nb + 3;', ""    suffixArray(n, 'z' + 1, tab[0], L);"", '    for (int i = 1; 1 << i < n; i++) {', '      for (int j = n - (1 << i); j > 0; j--) {', '        tab[i][j] = Math.min(tab[i - 1][j], tab[i - 1][j + (1 << i - 1)]);', '      }', '    }', '    int bma = na + 1 + na + 1;', '    for (int i = 0; i < n; i++) {', '      if (bma <= sa[i] && sa[i] < bma + nb) {', '        L[i] = sa[i];', '      } else {', '        L[i] = i > 0 ? L[i - 1] : -1;', '      }', '    }', '    for (int i = n; --i >= 0;) {', '      if (bma <= sa[i] && sa[i] < bma + nb) {', '        R[i] = sa[i];', '      } else {', '        R[i] = i + 1 < n ? R[i + 1] : -1;', '      }', '    }', '    manacher(na + 1, na);', '    int opt = 0;', '    int optp = 0;', '    int optx = 0;', '    int opty = 0;', '    ', '    for (int i = 0; i < na; i++) {', '      int pal = i > 0 ? len[i - 1] : 0;', '      int ii = na + 1 + i;', '      int j = L[isa[ii]];', '      if (lcp(ii, R[isa[ii]]) > lcp(ii, j))', '        j = R[isa[ii]];', '      int comm = lcp(ii, j);', '      if (comm > 0) {', '        int len = pal + 2 * comm;', '        int pos = na - (i + comm);', '        if (len > opt || len == opt && isa[pos] < isa[optp]) {', '          opt = len;', '          optp = pos;', '          optx = pal + comm;', '          opty = comm;', '        }', '      }', '    }', '    for (int i = 0; i < n; i++) {', '      if (na + 1 <= sa[i] && sa[i] < na + 1 + na) {', '        L[i] = sa[i];', '      } else {', '        L[i] = i > 0 ? L[i - 1] : -1;', '      }', '    }', '    for (int i = n; --i >= 0;) {', '      if (na + 1 <= sa[i] && sa[i] < na + 1 + na) {', '        R[i] = sa[i];', '      } else {', '        R[i] = i + 1 < n ? R[i + 1] : -1;', '      }', '    }', '    manacher(bma, nb);', '    for (int i = 0; i < nb; i++) {', '      int pal = i > 0 ? len[i - 1] : 0;', '      int ii = bma + i;', '      int j = L[isa[ii]];', '      if (lcp(ii, R[isa[ii]]) > lcp(ii, j)) {', '        j = R[isa[ii]];', '      }', '      int comm = lcp(ii, j);', '      if (comm > 0) {', '        int len = pal + 2 * comm, pos = n - (i + comm);', '        if (len > opt || len == opt && isa[pos] < isa[optp]) {', '          opt = len;', '          optp = pos;', '          optx = comm;', '          opty = pal + comm;', '        }', '      }', '    }', '', '    if (opt == 0) {', '      return ""-1"".toCharArray();', '    }', '    char[] result = new char[optx + opty];', '    for (int i = 0; i < optx; i++) {', '      result[i] = a[optp + i];', '    }', '    for (int i = 0; i < opty; i++) {', '      result[optx + i] = a[optp + opty - i - 1];', '    }', '    return result;', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int t = Integer.parseInt(st.nextToken());', '', '    for (int tItr = 0; tItr < t; tItr++) {', '      char[] a = br.readLine().toCharArray();', '      char[] b = br.readLine().toCharArray();', '', '      bw.write(buildPalindrome(a, b));', '      bw.newLine();', '    }', '', '    bw.close();', '    br.close();', '  }', '}']"
"['import java.awt.*;', 'import java.awt.event.*;', 'import java.awt.geom.*;', 'import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*; ', 'import java.util.*;', 'import java.util.regex.*;', '/*', '   br = new BufferedReader(new FileReader(""input.txt""));', '   pw = new PrintWriter(new BufferedWriter(new FileWriter(""output.txt"")));', '   br = new BufferedReader(new InputStreamReader(System.in));', '   pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));', ' */', '', '', 'public class Solution {', ' private static BufferedReader br;', ' private static StringTokenizer st;', ' private static PrintWriter pw;', '', ' public static void main(String[] args) throws Exception {', '  br = new BufferedReader(new InputStreamReader(System.in));', '  pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));', '  //int qq = 1;', '  //int qq = Integer.MAX_VALUE;', '  int qq = readInt();', '  for(int casenum = 1; casenum <= qq; casenum++) {', '   int n = readInt();', '   int a = readInt();', '   int b = readInt();', '   String s = nextToken();', '   int[] list = new int[n];', '   for(int i = 0; i < n; i++) {', ""    list[i] = s.charAt(i) - 'a';"", '   }', '', '   int[] dp = new int[n+1];', '   Arrays.fill(dp, 1 << 30);', '   dp[0] = 0;', '', '   ArrayList<int[]> edges = new ArrayList<int[]>();', '   ArrayList<Integer> link = new ArrayList<Integer>();', '   ArrayList<Integer> length = new ArrayList<Integer>();', '   edges.add(empty(26));', '   link.add(-1);', '   length.add(0);', '   int last = 0;', '   for(int i = 0; i < n; i++) {', '    ', '    dp[i+1] = Math.min(dp[i+1], dp[i] + a);', '    int len = 0;', '    int currSuffixLoc = 0;', '    while(currSuffixLoc < edges.size() && i + len < list.length) {', '     if(edges.get(currSuffixLoc)[list[i+len]] == -1) {', '      break;', '     }', '     currSuffixLoc = edges.get(currSuffixLoc)[list[i+len]];', '     len++;', '    }', '    ', '    dp[i+len] = Math.min(dp[i+len], dp[i] + b);', '    ', '    // construct r', '    edges.add(empty(26));', '    length.add(i+1);', '    link.add(0);', '    int r = edges.size() - 1;', '    int p = last;', '    while(p >= 0 && edges.get(p)[list[i]] == -1) {', '     edges.get(p)[list[i]] = r;', '     p = link.get(p);', '    }', '    if(p != -1) {', '     int q = edges.get(p)[list[i]];', '     if(length.get(p) + 1 == length.get(q)) {', '      link.set(r, q);', '     } ', '     else {', ""      // we have to split, add q'"", '      edges.add(deepCopy(edges.get(q))); // copy edges of q', '      length.add(length.get(p) + 1);', '      link.add(link.get(q).intValue()); // copy parent of q', '      int qqq = edges.size()-1;', '      // add qq as the new parent of q and r', '      link.set(q, qqq);', '      link.set(r, qqq);', ""      // move short classes pointing to q to point to q'"", '      while(p >= 0 && edges.get(p)[list[i]] == q) {', '       edges.get(p)[list[i]] = qqq;', '       p = link.get(p);', '      }', '     }', '    }', '    last = r;', '   }', '   pw.println(dp[n]);', '  }', '  exitImmediately();', ' }', '', ' public static int[] deepCopy(int[] list) {', '  int[] ret = new int[list.length];', '  for(int i = 0; i < ret.length; i++) {', '   ret[i] = list[i];', '  }', '  return ret;', ' }', ' ', ' public static int[] empty(int len) {', '  int[] ret = new int[len];', '  Arrays.fill(ret, -1);', '  return ret;', ' }', '', ' private static void exitImmediately() {', '  pw.close();', '  System.exit(0);', ' }', '', ' private static long readLong() throws IOException {', '  return Long.parseLong(nextToken());', ' }', '', ' private static double readDouble() throws IOException {', '  return Double.parseDouble(nextToken());', ' }', '', ' private static int readInt() throws IOException {', '  return Integer.parseInt(nextToken());', ' }', '', ' private static String nextLine() throws IOException  {', '  if(!br.ready()) {', '   exitImmediately();', '  }', '  st = null;', '  return br.readLine();', ' }', '', ' private static String nextToken() throws IOException  {', '  while(st == null || !st.hasMoreTokens())  {', '   if(!br.ready()) {', '    exitImmediately();', '   }', '   st = new StringTokenizer(br.readLine().trim());', '  }', '  return st.nextToken();', ' }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '    ', '        Scanner sc = new Scanner(System.in);', '        int T = sc.nextInt();', '        for(int t=0;t<T;t++){', '            int N = sc.nextInt();', '            int A = sc.nextInt();', '            int B = sc.nextInt();', '            String S = sc.next();', '            System.out.println( buildStringCost(N,A,B,S) );', '        }', '    }', '    ', '    public static int buildStringCost(int N, int A, int B, String S){', '        int[] dp = new int[N];', '        dp[0] = A;', '        int lastL = 0;', '        for(int k=1;k<N;++k){', '            dp[k] = dp[k-1]+A;', '            int L = lastL+1;', '            while(L>0){', '                String cur = S.substring(k-L+1, k+1);', '                int idx = S.substring(0, k-L+1).indexOf(cur);', '                if( -1==idx )', '                    L--;', '                else{', '                    dp[k] = Math.min(dp[k], dp[k-L]+B);', '                    break;', '                }', '            }', '            lastL = L;', '        }', '        return dp[N-1];', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.math.BigInteger;', 'import java.util.Arrays;', 'import java.util.HashSet;', 'import java.util.InputMismatchException;', 'import java.util.Random;', 'import java.util.Set;', '', 'public class E4 {', '    InputStream is;', '    PrintWriter out;', '//    String INPUT = ""1 6 abcdef ijklmn"";', '    String INPUT = """";', '//    String INPUT = ""1 3 abc def"";', '//    String INPUT = """";', '    ', '//    String INPUT = """";', '    void solve()', '    {', '        long B1 = BigInteger.probablePrime(29, new Random()).longValue();', '        long B2 = BigInteger.probablePrime(29, new Random()).longValue();', '        long M1 = BigInteger.probablePrime(30, new Random()).longValue();', '        long M2 = BigInteger.probablePrime(30, new Random()).longValue();', '        long[] ps1 = new long[2000];', '        long[] ps2 = new long[2000];', '        ps1[0] = 1;', '        ps2[0] = 1;', '        for(int i = 1;i < 2000;i++){', '            ps1[i] = ps1[i-1] * B1 % M1;', '            ps2[i] = ps2[i-1] * B2 % M2;', '        }', '        ', '        for(int T = ni();T > 0;T--){', '            int m = ni();', '            char[][] map = nm(2, m);', '            Set<Long> set = new HashSet<>();', '            long[][] hs = new long[2][m];', '            long[][] rhs = new long[2][m];', '            long[][] hs2 = new long[2][m];', '            long[][] rhs2 = new long[2][m];', '            for(int sr = 0;sr < 2;sr++){', '                for(int l = 1;l < m;l++){', '                    int p = 0;', '                    int r = sr;', '                    long t1 = 0, rt1 = 0;', '                    long t2 = 0, rt2 = 0;', '                    for(int u = l-1;u >= 0;u--){', '                        t1 = (t1 * B1 + map[r][u]) % M1; rt1 = (rt1 + map[r][u] * ps1[p]) % M1;', '                        t2 = (t2 * B2 + map[r][u]) % M2; rt2 = (rt2 + map[r][u] * ps2[p]) % M2;', '                        p++;', '                    }', '                    r ^= 1;', '                    for(int u = 0;u < l;u++){', '                        t1 = (t1 * B1 + map[r][u]) % M1; rt1 = (rt1 + map[r][u] * ps1[p]) % M1;', '                        t2 = (t2 * B2 + map[r][u]) % M2; rt2 = (rt2 + map[r][u] * ps2[p]) % M2;', '                        p++;', '                    }', '                    hs[sr][l] = t1<<32|t2;', '                    rhs[sr][l] = rt1<<32|rt2;', '                }', '            }', '            for(int sr = 0;sr < 2;sr++){', '                for(int h = m-2;h >= 0;h--){', '                    int p = 0;', '                    int r = sr;', '                    long t1 = 0, rt1 = 0;', '                    long t2 = 0, rt2 = 0;', '                    for(int u = h+1;u < m;u++){', '                        t1 = (t1 * B1 + map[r][u]) % M1; rt1 = (rt1 + map[r][u] * ps1[p]) % M1;', '                        t2 = (t2 * B2 + map[r][u]) % M2; rt2 = (rt2 + map[r][u] * ps2[p]) % M2;', '                        p++;', '                    }', '                    r ^= 1;', '                    for(int u = m-1;u > h;u--){', '                        t1 = (t1 * B1 + map[r][u]) % M1; rt1 = (rt1 + map[r][u] * ps1[p]) % M1;', '                        t2 = (t2 * B2 + map[r][u]) % M2; rt2 = (rt2 + map[r][u] * ps2[p]) % M2;', '                        p++;', '                    }', '                    hs2[sr][h] = t1<<32|t2;', '                    rhs2[sr][h] = rt1<<32|rt2;', '                }', '            }', '            for(int sr = 0;sr < 2;sr++){', '                int p = 0;', '                int r = sr;', '                long t1 = 0, rt1 = 0;', '                long t2 = 0, rt2 = 0;', '                for(int u = m-1;u >= 0;u--){', '                    t1 = (t1 * B1 + map[r][u]) % M1; rt1 = (rt1 + map[r][u] * ps1[p]) % M1;', '                    t2 = (t2 * B2 + map[r][u]) % M2; rt2 = (rt2 + map[r][u] * ps2[p]) % M2;', '                    p++;', '                }', '                r^=1;', '                for(int u = 0;u <= m-1;u++){', '                    t1 = (t1 * B1 + map[r][u]) % M1; rt1 = (rt1 + map[r][u] * ps1[p]) % M1;', '                    t2 = (t2 * B2 + map[r][u]) % M2; rt2 = (rt2 + map[r][u] * ps2[p]) % M2;', '                    p++;', '                }', '                assert p == 2*m;', '                set.add(t1<<32|t2);', '                set.add(rt1<<32|rt2);', '            }', '            for(int sr = 0;sr < 2;sr++){', '                int p = 0;', '                int r = sr;', '                long t1 = 0, rt1 = 0;', '                long t2 = 0, rt2 = 0;', '                for(int u = 0;u < m;u++){', '                    t1 = (t1 * B1 + map[r][u]) % M1; rt1 = (rt1 + map[r][u] * ps1[p]) % M1;', '                    t2 = (t2 * B2 + map[r][u]) % M2; rt2 = (rt2 + map[r][u] * ps2[p]) % M2;', '                    p++;', '                }', '                r^=1;', '                for(int u = m-1;u >= 0;u--){', '                    t1 = (t1 * B1 + map[r][u]) % M1; rt1 = (rt1 + map[r][u] * ps1[p]) % M1;', '                    t2 = (t2 * B2 + map[r][u]) % M2; rt2 = (rt2 + map[r][u] * ps2[p]) % M2;', '                    p++;', '                }', '                assert p == 2*m;', '                set.add(t1<<32|t2);', '                set.add(rt1<<32|rt2);', '            }', '            ', '//            for(int b = 0;b < m;b++){', '//                for(int sr = 0;sr < 2;sr++){', '//                    int p = 0;', '//                    int r = sr;', '//                    long t1 = 0, rt1 = 0;', '//                    long t2 = 0, rt2 = 0;', '//                    for(int u = b;u < m;u++){', '//                        t1 = (t1 * B1 + map[r][u]) % M1; rt1 = (rt1 + map[r][u] * ps1[p]) % M1;', '//                        t2 = (t2 * B2 + map[r][u]) % M2; rt2 = (rt2 + map[r][u] * ps2[p]) % M2;', '//                        p++;', '//                    }', '//                    r^=1;', '//                    for(int u = m-1;u >= 0;u--){', '//                        t1 = (t1 * B1 + map[r][u]) % M1; rt1 = (rt1 + map[r][u] * ps1[p]) % M1;', '//                        t2 = (t2 * B2 + map[r][u]) % M2; rt2 = (rt2 + map[r][u] * ps2[p]) % M2;', '//                        p++;', '//                    }', '//                    r ^= 1;', '//                    for(int u = 0;u < b;u++){', '//                        t1 = (t1 * B1 + map[r][u]) % M1; rt1 = (rt1 + map[r][u] * ps1[p]) % M1;', '//                        t2 = (t2 * B2 + map[r][u]) % M2; rt2 = (rt2 + map[r][u] * ps2[p]) % M2;', '//                        p++;', '//                    }', '//                    assert p == 2*m;', '//                    set.add(t1<<32|t2);', '//                    set.add(rt1<<32|rt2);', '//                }', '//            }', '            for(int sr = 0;sr < 2;sr++){', '                for(int l = 0;l < m;l++){', '                    long t1 = hs[sr][l]>>>32, rt1 = rhs[sr][l]>>>32;', '                    long t2 = (int)hs[sr][l], rt2 = (int)rhs[sr][l];', '                    int r = sr^1;', '                    if(l-1 >= 0){', '                        long xt1 = (t1 * ps1[2*m-(2*l)] + (rhs2[r^1][l-1]>>>32)) % M1;', '                        long xt2 = (t2 * ps2[2*m-(2*l)] + ((int)rhs2[r^1][l-1])) % M2;', '                        long xrt1 = (rt1 + (hs2[r^1][l-1]>>>32) * ps1[2*l]) % M1;', '                        long xrt2 = (rt2 + ((int)(hs2[r^1][l-1])) * ps2[2*l]) % M2;', '                        set.add(xt1<<32|xt2);', '                        set.add(xrt1<<32|xrt2);', '                    }', '                    for(int h = l;h < m;h++){', '                        t1 = (t1 * B1 + map[r][h]) % M1; rt1 = (rt1 + map[r][h] * ps1[2*h]) % M1;', '                        t2 = (t2 * B2 + map[r][h]) % M2; rt2 = (rt2 + map[r][h] * ps2[2*h]) % M2;', '                        r ^= 1;', '                        t1 = (t1 * B1 + map[r][h]) % M1; rt1 = (rt1 + map[r][h] * ps1[2*h+1]) % M1;', '                        t2 = (t2 * B2 + map[r][h]) % M2; rt2 = (rt2 + map[r][h] * ps2[2*h+1]) % M2;', '                        ', '                        long xt1 = (t1 * ps1[2*m-(2*h+2)] + (rhs2[r^1][h]>>>32)) % M1;', '                        long xt2 = (t2 * ps2[2*m-(2*h+2)] + ((int)rhs2[r^1][h])) % M2;', '                        long xrt1 = (rt1 + (hs2[r^1][h]>>>32) * ps1[2*h+2]) % M1;', '                        long xrt2 = (rt2 + ((int)(hs2[r^1][h])) * ps2[2*h+2]) % M2;', '//                        tr(sr, l, h, xt, xrt);', '                        set.add(xt1<<32|xt2);', '                        set.add(xrt1<<32|xrt2);', '                    }', '                }', '            }', '//            for(String line : new TreeSet<>(set)){', '//                tr(line);', '//            }', '            out.println(set.size());', '        }', '    }', '    ', '    void run() throws Exception', '    {', '//        int n = 600, m = 99999;', '//        Random gen = new Random();', '//        StringBuilder sb = new StringBuilder();', '//        sb.append(1 + "" "");', '//        sb.append(n + "" "");', '//        for (int i = 0; i < n; i++) {', ""//            sb.append((char)('a'+gen.nextInt(26)));"", '//        }', '//        sb.append(""\\n"");', '//        for (int i = 0; i < n; i++) {', ""//            sb.append((char)('a'+gen.nextInt(26)));"", '//        }', '//        INPUT = sb.toString();', '', '        ', '        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        long s = System.currentTimeMillis();', '        solve();', '        out.flush();', '        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', '    }', '    ', '    public static void main(String[] args) throws Exception { new E4().run(); }', '    ', '    private byte[] inbuf = new byte[1024];', '    private int lenbuf = 0, ptrbuf = 0;', '    ', '    private int readByte()', '    {', '        if(lenbuf == -1)throw new InputMismatchException();', '        if(ptrbuf >= lenbuf){', '            ptrbuf = 0;', '            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '            if(lenbuf <= 0)return -1;', '        }', '        return inbuf[ptrbuf++];', '    }', '    ', '    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', '    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', '    ', '    private double nd() { return Double.parseDouble(ns()); }', '    private char nc() { return (char)skip(); }', '    ', '    private String ns()', '    {', '        int b = skip();', '        StringBuilder sb = new StringBuilder();', ""        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '            sb.appendCodePoint(b);', '            b = readByte();', '        }', '        return sb.toString();', '    }', '    ', '    private char[] ns(int n)', '    {', '        char[] buf = new char[n];', '        int b = skip(), p = 0;', '        while(p < n && !(isSpaceChar(b))){', '            buf[p++] = (char)b;', '            b = readByte();', '        }', '        return n == p ? buf : Arrays.copyOf(buf, p);', '    }', '    ', '    private char[][] nm(int n, int m)', '    {', '        char[][] map = new char[n][];', '        for(int i = 0;i < n;i++)map[i] = ns(m);', '        return map;', '    }', '    ', '    private int[] na(int n)', '    {', '        int[] a = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        return a;', '    }', '    ', '    private int ni()', '    {', '        int num = 0, b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private long nl()', '    {', '        long num = 0;', '        int b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']","['import java.util.HashSet;', 'import java.util.Scanner;', 'import java.util.Set;', '', 'public class Solution2 {', 'private final static Scanner scanner = ', 'new Scanner(System.in);', 'private final static long mod1 = 2147483607,', ' f1 = 107, f2 = 101;', 'private final static long[] arr1 = new long[10000], ', 'arr2 = new long[10000]; ', 'private final static Set<Long> result = new HashSet<>();', 'public static void main(String[] args) {', 'for (int i = 0; i < arr1.length; ++i) {', 'arr1[i] = i > 0 ? arr1[i - 1] * f1 % mod1 : 1;', 'arr2[i] = i > 0 ? arr2[i - 1] * f2 % mod1 : 1;', '}', '', 'for (int t = scanner.nextInt(); t > 0; --t) {', 'result.clear();', 'scanner.nextInt();', 'char[] c1 = scanner.next().toCharArray();', 'char[] c2 = scanner.next().toCharArray();', '', 'for (int i = 0; i < c1.length; ++i) {', 'process(c1, c2, i, false);', 'process(c2, c1, i, false); ', 'process(c1, c2, i, true);', 'process(c2, c1, i, true);', '}', 'reverse(c1);', 'reverse(c2);', 'for (int i = 0; i < c1.length; ++i) {', 'process(c1, c2, i, false);', 'process(c2, c1, i, false); ', 'process(c1, c2, i, true);', 'process(c2, c1, i, true);', '}', 'System.out.println(result.size());', '}', '}', '', 'static void process(char[] s1, char[] s2, int k, boolean b) {', 'long p1 = 0, p2 = 0, p3 = 0, p4 = 0;', 'for (int i = 0; i < k; ++i) {', 'p1 = (p1 + s1[i] * arr1[k - 1 - i]) % mod1;', 'p1 = (p1 + s2[i] * arr1[k + i]) % mod1;', 'p3 = (p3 + s1[i] * arr2[k - 1 - i]) % mod1;', 'p3 = (p3 + s2[i] * arr2[k + i]) % mod1;', '}', 'if (b) {', 'p1 = (p1 + s2[k] * arr1[k * 2]) % mod1;', 'p1 = (p1 + s1[k] * arr1[k * 2 + 1]) % mod1;', 'p3 = (p3 + s2[k] * arr2[k * 2]) % mod1;', 'p3 = (p3 + s1[k] * arr2[k * 2 + 1]) % mod1;', 'char[] s = s1; s1 = s2; s2 = s;', '++k;', '}', 'for (int i = k; i < s1.length; ++i) {', 'p2 = (p2 + s1[i] * arr1[s1.length * 2 + k - 1 - i]) % mod1;', 'p2 = (p2 + s2[i] * arr1[i + k]) % mod1;', 'p4 = (p4 + s1[i] * arr2[s1.length * 2 + k - 1 - i]) % mod1;', 'p4 = (p4 + s2[i] * arr2[i + k]) % mod1;', '}', 'result.add(((p1 + p2) % mod1) * mod1 + (p3 + p4) % mod1);', '', 'for (int i = k; i < s1.length - 1; i += 2) {', 'p1 = (p1 + s2[i] * arr1[i * 2]) % mod1;', 'p1 = (p1 + s1[i] * arr1[i * 2 + 1]) % mod1;', 'p1 = (p1 + s1[i + 1] * arr1[i * 2 + 2]) % mod1;', 'p1 = (p1 + s2[i + 1] * arr1[i * 2 + 3]) % mod1;', 'p2 = (p2 + s2[i] * (mod1 - arr1[i * 2])) % mod1;', 'p2 = (p2 + s2[i+1] * (mod1 - arr1[i * 2 + 1])) % mod1;', 'p2 = (p2 + s1[i] * (mod1 - arr1[s1.length * 2 - 1])) % mod1;', 'p2 = (p2 + s1[i+1] * (mod1 - arr1[s1.length * 2 - 2])) % mod1;', 'p2 = (p2 * f1 * f1) % mod1;', '', 'p3 = (p3 + s2[i] * arr2[i * 2]) % mod1;', 'p3 = (p3 + s1[i] * arr2[i * 2 + 1]) % mod1;', 'p3 = (p3 + s1[i + 1] * arr2[i * 2 + 2]) % mod1;', 'p3 = (p3 + s2[i + 1] * arr2[i * 2 + 3]) % mod1;', 'p4 = (p4 + s2[i] * (mod1 - arr2[i * 2])) % mod1;', 'p4 = (p4 + s2[i+1] * (mod1 - arr2[i * 2 + 1])) % mod1;', 'p4 = (p4 + s1[i] * (mod1 - arr2[s1.length * 2 - 1])) % mod1;', 'p4 = (p4 + s1[i+1] * (mod1 - arr2[s1.length * 2 - 2])) % mod1;', 'p4 = (p4 * f2 * f2) % mod1;', '', 'result.add(((p1 + p2) % mod1) * mod1 + (p3 + p4) % mod1);', '}', '}', '', 'private static void reverse(char[] str) {', 'for (int i = str.length / 2 - 1; i >= 0; --i) {', 'char t = str[i];', 'str[i] = str[str.length - 1 - i];', 'str[str.length - 1 - i] = t;', '}', '}', '', '}']"
"['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    private static final int modulus = 1000000007;', '    private static int[] knowns;              // known numbers, (input order)', '    private static int[] gkArr;               // gkArr[k] number of knowns after k in x s.t k>i_i', '    private static int[] guArr;               // guArr[k] number of unknowns s.t. k>u', '    private static int[] remainingUnknownsArr;// number of unknowns in x[n-1-i:x.length]', '    private static long[] factorials;         // factorials[i] = i! % modulus', '    private static long[] runningDiffs;        // sum over remaining k of (U.len-guArr)', '    private static long[] EO;                 // Expected ordinals', '    //O(n+klgk) sum = |U|!(1+sum over n of n!*EO_n) % modulus', '    static long solve(int[] x) { //O(n + klgk)', '        int n = x.length;', '        long sum = 1L;', '        factorialsInit(n); //O(n)', '        int[] U = getUnknownInts(n, x); //O(n) - relies on x', '        knownsInit(x); //O(n) - relies on x', '        gkInit(n); //O(klgk) - relies on knowns, x', '        guInit(n, U); //O(n) - relies on unknowns, x', '        unknownsRemainingInit(x); //O(n) -relies on x', '        runningDiffsInit(x, U); //O(n) -relies on gu, x', '        EOInit(x, n, U); //O(n) - relies on knowns, unknowns, gk, gu, running sums, x', '        for(int i = 1; i < n; i++) //O(n)                   ', '            sum = addMod(sum, mulMod(EO[i], factorials[i]));', '        sum = mulMod(sum, factorials[U.length]);', '        return sum;', '    }', '    //O(klgk) setup GOOD', '    private static void gkInit(int n) {', '        gkArr = new int[n+1];', '        int[][] arrs = new int[2][knowns.length];', '        arrs[0] = Arrays.copyOfRange(knowns, 0, knowns.length); ', '        int subLen = 1;', '        int b = 0;', '        do {', '            int i = 0;', '            subLen *= 2;', '            int j = (subLen >>> 1);', '            int endSub = subLen;', '            int counter = 0;', '            int imin = Math.min(knowns.length, endSub - (subLen>>>1));', '            int jmin = Math.min(knowns.length, endSub);', '            while(counter < knowns.length) {', '                if(j < jmin && i < imin && arrs[b][i] < arrs[b][j]) {', '                    arrs[(b+1)%2][counter] = arrs[b][i];', '                    gkArr[arrs[b][i]] += Math.max(0, (counter++)-i++);', '                } else if(j < jmin) {', '                    arrs[(b+1)%2][counter] = arrs[b][j];', '                    gkArr[arrs[b][j]] += Math.max(0, (counter++)-j++);', '                } else if(i < imin) {', '                    arrs[(b+1)%2][counter] = arrs[b][i];', '                    gkArr[arrs[b][i]] += Math.max(0, (counter++)-i++);', '                } else {', '                    endSub += subLen;', '                    i = j;', '                    j += (subLen>>>1);', '                    imin = Math.min(knowns.length, endSub - (subLen>>>1));', '                    jmin = Math.min(knowns.length, endSub);', '                }', '            }', '            b = (b+1)%2;', '        } while (subLen < knowns.length);', '    }', '    //O(n) setup', '    private static void runningDiffsInit(int[] x, int[] U) { //Sum over k of U_g', '        runningDiffs = new long[x.length];', '        runningDiffs[0] = (x[x.length-1] == 0) ? 0 : U.length - guArr[x[x.length-1]]; ', '        for(int i = 1; i < x.length; i++) {', '            if(x[x.length-1-i] != 0)', '                runningDiffs[i] = U.length - guArr[x[x.length-1-i]];', '            runningDiffs[i] = addMod(runningDiffs[i], runningDiffs[i-1]);', '        }', '    }', '    //O(n) setup GOOD', '    private static void unknownsRemainingInit(int[] x) {', '        remainingUnknownsArr = new int[x.length];', '        int u = 0;', '        for(int i = x.length-1; i >= 0; i--)', '            remainingUnknownsArr[i] = (x[i] == 0) ? u++ : u; //INCLUSIVE', '    }', '    //O(n) setup GOOD', '    private static void guInit(int n, int[] U) {', '        guArr = new int[n+1];', '        int k = 0;', '        int u = 0;', '        for(int i = 0; i < U.length; i++) {', '            while( k <= U[i])', '                guArr[k++] = u;', '            u++;', '        }', '         while( k < guArr.length)', '                guArr[k++] = u;', '    }', '    //O(n) setup', '    private static void EOInit(int[] x, int n , int[] U) {', '        EO = new long[x.length];', '        long d = 0L;', '        long invertedUlen = binaryExpMod(U.length, Solution.modulus-2L);', '        for(int i = 1; i < n; i++) {', '            if(x[n-1-i] == 0) {', '                //from unknown perms ', '                EO[i] = mulMod(remainingUnknownsArr[n-1-i], 500000004L); // div by 2', '                //from knowns DP ', '                d = mulMod(runningDiffs[i], invertedUlen);', '                EO[i] = addMod(EO[i], d);', '            } else {', '                //fraction of unknowns larger', '                d = mulMod(guArr[x[n-1-i]], invertedUlen);', '                EO[i] = addMod(EO[i], mulMod(remainingUnknownsArr[n-1-i], d));', '                //number of knowns larger', '                EO[i] = addMod(EO[i], gkArr[x[n-1-i]]);', '            }', '        }', '    }', '    //O(lgn) GOOD', '    private static long binaryExpMod(long l, long pow) { //l^(modulus-2) mod modulus', '        if (l == 0L && pow != 0L)', '            return 0L;', '        long[] squares = new long[30];         //30 = ciel(lg(modulus-2)) > ciel(lg(n))', '        squares[0] = l % Solution.modulus;', '        for(int i = 1; i < 30; i++) ', '            squares[i] = mulMod(squares[i-1], squares[i-1]);', '        long result = 1L;', '        int i = 0;', '        while(pow != 0L) {', '            if((pow & 1L) == 1L)', '                result = mulMod(result, squares[i]);', '            i++;', '            pow >>>= 1;', '        }', '        return result;', '    }', '    //O(n) setup ', '    private static void factorialsInit(int n) {', '        factorials = new long[n+1];', '        factorials[0] = 1L;', '        factorials[1] = 1L;', '        for(int i = 2; i <= n; i++)', '            factorials[i] = Solution.mulMod(factorials[i-1], i);', '    }', '    //O(1) GOOD', '    private static long mulMod(long result, long l) {', '        return ( (result%Solution.modulus) * (l%Solution.modulus) )%Solution.modulus;', '    }', '    //O(1) GOOD', '    private static long addMod(long result, long l) {', '        return ( (result%Solution.modulus) + (l%Solution.modulus) )%Solution.modulus;', '    }', '    //O(n) setup GOOD', '    private static int[] getUnknownInts(int n, int[] x) { //O(n) but setup so insignif', '        int[] ints = new int[n];    ', '        for(int i = 1; i <= n; i++)', '            ints[i-1] = i;', '        for(int i: x)', '            if(i != 0) {', '                ints[i-1] = 0;', '                n--;', '            }', '        int[] intsOut = new int[n];', '        n = 0; //becomes index', '        for(int i: ints) ', '            if(i != 0)', '                intsOut[n++] = i;', '        return intsOut;', '    }', '    //O(n) setup GOOD', '    private static void knownsInit(int[] x) {', '        int counter = 0;', '        for(int a: x) ', '            if(a > 0)', '                counter++;', '        knowns = new int[counter];', '        counter = 0;', '        for(int a: x)', '            if(a > 0)', '                knowns[counter++] = a;', '    } ', '    ', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int n = scanner.nextInt();', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])?"");', '', '        int[] a = new int[n];', '', '        String[] aItems = scanner.nextLine().split("" "");', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])?"");', '', '        for (int i = 0; i < n; i++) {', '            int aItem = Integer.parseInt(aItems[i]);', '            a[i] = aItem;', '        }', '', '        long result = solve(a);', '', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '', '        bufferedWriter.close();', '', '        scanner.close();', '    }', '}']","['import java.io.BufferedReader;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.util.*;', 'public class CardsPermutationFinal {', '    private final static long MOD = 1000000007;', '    private final static long INV_TWO = inverseElmnt(2);', '    private static final long Y_DISP = 10000000000l;', '    private static final Set<Long> USED_Y = new HashSet<>();', '    private static long pow(long n, long p) {', '        if (p == 0) {', '            return 1;', '        }', '        if (p % 2 == 0) {', '            return pow((n * n) % MOD, p / 2) % MOD;', '        } else {', '            return (n * pow(n, p - 1)) % MOD;', '        }', '    }', '    private static long inverseElmnt(long n) {', '        return pow(n, MOD - 2);', '    }', '    private static long fact(int n) {', '        long res = 1;', '        for(int i = 1; i <= n; i++) {', '            res = (res * i) % MOD;', '        }', '        return res;', '    }', '    private static long generateY() {', '        long y;', '        do {', '            y = (long)(Y_DISP * Math.random());', '        } while (USED_Y.contains(y));', '        USED_Y.add(y);', '        return y;', '    }', '    private long run(int n, int[] perm) {', '        int[] undefinedAmnt = new int[n];', '        undefinedAmnt[n - 1] = 0;', '        for (int i = n - 2; i >= 0; i--) {', '            undefinedAmnt[i] = undefinedAmnt[i + 1] + (perm[i + 1] == 0 ? 1 : 0);', '        }', '        int totalUndef = undefinedAmnt[0] + (perm[0] == 0 ? 1 : 0);', '        long[] bin = new long[n];', '        bin[n - 1] = 1;', '        long chisl = totalUndef;', '        long znam = 1;', '        long[] incr = new long[n];', '        incr[n - 1] = 0;', '        long currentIncr = perm[n - 1] == 0 ? 1 : 0;', '        int chislForIncr = totalUndef - 1;', '        int znamForIncr = 1;', '        for (int i = n - 2; i >= 0; i--) {', '            if (undefinedAmnt[i] == undefinedAmnt[i + 1]) {', '                bin[i] = bin[i + 1];', '            } else {', '                bin[i] = (((bin[i + 1] * chisl) % MOD) * inverseElmnt(znam))% MOD;', '                chisl--;', '                znam++;', '            }', '            if (perm[i] != 0) {', '                incr[i] = perm[i + 1] != 0 ? incr[i + 1] : currentIncr;', '            } else {', '                if (0 == currentIncr) {', '                    currentIncr = 1;', '                } else {', '                    currentIncr = (((currentIncr * chislForIncr) % MOD) * inverseElmnt(znamForIncr)) % MOD;', '                    chislForIncr--;', '                    znamForIncr++;', '                }', '            }', '        }', '        long[] colSum = new long[n];', '        long[] rowSum = new long[n];', '        int cell = n - 1;', '        while (cell >= 0 && perm[cell] != 0) {', '            cell--;', '        }', '        if (cell >= 0) {', '            colSum[cell] = 1;', '            rowSum[cell] = totalUndef;', '        }', '        int chislColSum = totalUndef - 1;', '        int znamColSum = 1;', '        int chislRowSum = totalUndef - 1;', '        int znamRowSum = 2;', '        for (int i = cell - 1; i >= 0; i--) {', '            if (perm[i] == 0) {', '                colSum[i] = (((colSum[i + 1] * chislColSum) % MOD) * inverseElmnt(znamColSum)) % MOD;', '                chislColSum--;', '                znamColSum++;', '                rowSum[i] = (((rowSum[i + 1] * chislRowSum) % MOD) * inverseElmnt(znamRowSum)) % MOD;', '                chislRowSum--;', '                znamRowSum++;', '            } else {', '                colSum[i] = colSum[i + 1];', '                rowSum[i] = rowSum[i + 1];', '            }', '        }', '        int[] lessAmntLeft = new int[n + 1];', '        cell = n - 1;', '        while (cell >= 0 && perm[cell] == 0) {', '            cell--;', '        }', '        Treap t = null;', '        if (cell >= 0) {', '            t = new Treap(perm[cell], generateY(), null, null);', '        }', '        for (int i = cell - 1; i >= 0; i--) {', '            if (perm[i] != 0) {', '                Treap res = new Treap(perm[i], generateY(), null, null);', '                Treap[] splitRes = t.split(perm[i]);', '                lessAmntLeft[perm[i]] = splitRes[0] == null ? 0 : splitRes[0].size;', '                if (null != splitRes[0]) {', '                    res = merge(splitRes[0], res);', '                }', '                if (null != splitRes[1]) {', '                    res = merge(res, splitRes[1]);', '                }', '                t = res;', '            }', '        }', '        int[] defVals = new int[n - totalUndef];', '        int defValsSize = 0;', '        for (int i = 0; i < n; i++) {', '            if (perm[i] != 0) {', '                defVals[defValsSize] = perm[i];', '                defValsSize++;', '            }', '        }', '        Arrays.sort(defVals);', '        long[] greaterUndef = new long[n + 1];', '        long[] smallerDefined = new long[n + 1];', '        long totalSum = 0;', '        for (int i = 0; i < defValsSize; i++) {', '            int definedValue = defVals[i];', '            int greaterCnt = n - definedValue - (defValsSize - i - 1);', '            greaterUndef[definedValue] = greaterCnt;', '            totalSum = (totalSum + greaterCnt) % MOD;', '            smallerDefined[definedValue] = i;', '        }', '        long[] resultInpt = new long[n];', '        for (int i = n - 1; i >= 0; i--) {', '            if (perm[i] != 0) {', '                resultInpt[i] = (((incr[i] * (perm[i] - 1 - smallerDefined[perm[i]])) % MOD) +', '                        (lessAmntLeft[perm[i]] * bin[i]) % MOD) % MOD;', '            }', '        }', '        int undef = totalUndef;', '        for (int i = 0; i < n; i++) {', '            if (perm[i] == 0) {', '                resultInpt[i] = (((((rowSum[i] * undef) % MOD) * (undef - 1)) % MOD) * INV_TWO) % MOD;', '                resultInpt[i] = (resultInpt[i] + (colSum[i] * totalSum) % MOD) % MOD;', '                undef--;', '            } else {', '                totalSum = (totalSum - greaterUndef[perm[i]] + MOD) % MOD;', '            }', '        }', '        int undefRight = undefinedAmnt[0];', '        int undefLeft = 0;', '        long rightFact = fact(undefRight);', '        long leftFact = 1;', '        resultInpt[0] = (resultInpt[0] * rightFact) % MOD;', '        for (int i = 1; i < n; i++) {', '            if (perm[i] == 0) {', '                rightFact = (rightFact * inverseElmnt(undefRight)) % MOD;', '                undefRight--;', '            }', '            if (perm[i - 1] == 0) {', '                undefLeft++;', '                leftFact = (leftFact * undefLeft) % MOD;', '            }', '            resultInpt[i] = (resultInpt[i] * ((rightFact * leftFact) % MOD)) % MOD;', '        }', '        long fact = 1;', '        int cnt = 1;', '        for (int i = n - 2; i >= 0; i--) {', '            resultInpt[i] = (resultInpt[i] * fact) % MOD;', '            cnt++;', '            fact = (fact * cnt) % MOD;', '        }', '        long result = fact(totalUndef);', '        for (int i = 0; i < n; i++) {', '            result = (result + resultInpt[i]) % MOD;', '        }', '        return result;', '    }', '    public static void main(String[] args) throws IOException {', '        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '        //BufferedReader br = new BufferedReader(new FileReader(""D:\\\\cards44.txt""));', '        //BufferedReader br = new BufferedReader(new FileReader(""D:\\\\cards41.txt""));', '        int n = Integer.parseInt(br.readLine());', '        int[] perm = new int[n];', '        StringTokenizer permTkn = new StringTokenizer(br.readLine());', '        for (int i = 0; i < n; i++) {', '            perm[i] = Integer.parseInt(permTkn.nextToken());', '        }', '        //Date start = new Date();', '        long res = new CardsPermutationFinal().run(n, perm);', '        //Date end = new Date();', '        //System.out.println(end.getTime() - start.getTime() + ""ms"");', '        System.out.println(res);', '    }', '    private static void recalculateSize(Treap t) {', '        if (null != t) {', '            t.recalculateSize();', '        }', '    }', '    public Treap merge(Treap l, Treap r) {', '        if (null == l) {', '            return r;', '        }', '        if (null == r) {', '            return l;', '        }', '        Treap res;', '        if (l.y > r.y) {', '            Treap newTreap = merge(l.right, r);', '            recalculateSize(newTreap);', '            res = new Treap(l.x, l.y, l.left, newTreap);', '        } else {', '            Treap newTreap = merge(l, r.left);', '            recalculateSize(newTreap);', '            res = new Treap(r.x, r.y, newTreap, r.right);', '        }', '        recalculateSize(res);', '        return res;', '    }', '    private class Treap {', '        private int x;', '        private long y;', '        private Treap left;', '        private Treap right;', '        private int size;', '        public Treap(final int x, final long y, final Treap left, final Treap right) {', '            this.x = x;', '            this.y = y;', '            this.right = right;', '            this.left = left;', '        }', '        private void recalculateSize() {', '            size = (null == left ? 0 : left.size) + (null == right ? 0 : right.size) + 1;', '        }', '        public Treap[] split(int x) {', '            Treap newLeft = null;', '            Treap newRight = null;', '            if (x < this.x) {', '                if (this.left == null) {', '                    newRight = new Treap(this.x, this.y, this.left, this.right);', '                } else {', '                    Treap[] splitResult = this.left.split(x);', '                    newLeft = splitResult[0];', '                    newRight = new Treap(this.x, this.y, splitResult[1], this.right);', '                }', '            } else {', '                if (this.right == null) {', '                    newLeft = new Treap(this.x, this.y, this.left, this.right);', '                } else {', '                    Treap[] splitResult = this.right.split(x);', '                    newLeft = new Treap(this.x, this.y, this.left, splitResult[0]);', '                    newRight = splitResult[1];', '                }', '            }', '            CardsPermutationFinal.recalculateSize(newLeft);', '            CardsPermutationFinal.recalculateSize(newRight);', '            return new Treap[]{newLeft, newRight};', '        }', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  for(int T = ni();T >= 1;T--){', '   char[] s = ns().toCharArray();', '   long K = nl();', '   int[] sa = sa(s);', '   int[] lcp = buildLCP0(s, sa);', '   int n = s.length;', '   out:', '   for(int i = 0;i < lcp.length;i++){', '//    long num = (n-sa[i]-lcp[i]);', '    long len = (long)(n-sa[i])*(n-sa[i]+1)/2 - (long)lcp[i]*(lcp[i]+1)/2;', '    if(K <= len){', '     for(int j = lcp[i]+1;j <= n-sa[i];j++){', '      long llen = j;', '      if(K <= llen){', '       out.println(s[(int)(sa[i]+K-1)]);', '       break out;', '      }else{', '       K -= llen;', '      }', '     }', '     break;', '    }else{', '     K -= len;', '    }', '   }', '  }', ' }', ' ', '  private static interface BaseArray {', '   public int get(int i);', '', '   public void set(int i, int val);', '', '   public int update(int i, int val);', '  }', '', '  private static class CharArray implements BaseArray {', '   private char[] m_A = null;', '   private int m_pos = 0;', '', '   CharArray(char[] A, int pos) {', '    m_A = A;', '    m_pos = pos;', '   }', '', '   public int get(int i) {', '    return m_A[m_pos + i] & 0xffff;', '   }', '', '   public void set(int i, int val) {', '    m_A[m_pos + i] = (char) (val & 0xffff);', '   }', '', '   public int update(int i, int val) {', '    return m_A[m_pos + i] += val & 0xffff;', '   }', '  }', '', '  private static class IntArray implements BaseArray {', '   private int[] m_A = null;', '   private int m_pos = 0;', '', '   IntArray(int[] A, int pos) {', '    m_A = A;', '    m_pos = pos;', '   }', '', '   public int get(int i) {', '    return m_A[m_pos + i];', '   }', '', '   public void set(int i, int val) {', '    m_A[m_pos + i] = val;', '   }', '', '   public int update(int i, int val) {', '    return m_A[m_pos + i] += val;', '   }', '  }', '', '  /* find the start or end of each bucket */', '  private static void getCounts(BaseArray T, BaseArray C, int n, int k) {', '   int i;', '   for(i = 0;i < k;++i){', '    C.set(i, 0);', '   }', '   for(i = 0;i < n;++i){', '    C.update(T.get(i), 1);', '   }', '  }', '', '  private static void getBuckets(BaseArray C, BaseArray B, int k, boolean end) {', '   int i, sum = 0;', '   if(end != false){', '    for(i = 0;i < k;++i){', '     sum += C.get(i);', '     B.set(i, sum);', '    }', '   }else{', '    for(i = 0;i < k;++i){', '     sum += C.get(i);', '     B.set(i, sum - C.get(i));', '    }', '   }', '  }', '', '  /* sort all type LMS suffixes */', '  private static void LMSsort(BaseArray T, int[] SA, BaseArray C,', '    BaseArray B, int n, int k) {', '   int b, i, j;', '   int c0, c1;', '   /* compute SAl */', '   if(C == B){', '    getCounts(T, C, n, k);', '   }', '   getBuckets(C, B, k, false); /* find starts of buckets */', '   j = n - 1;', '   b = B.get(c1 = T.get(j));', '   --j;', '   SA[b++] = (T.get(j) < c1) ? ~j : j;', '   for(i = 0;i < n;++i){', '    if(0 < (j = SA[i])){', '     if((c0 = T.get(j)) != c1){', '      B.set(c1, b);', '      b = B.get(c1 = c0);', '     }', '     --j;', '     SA[b++] = (T.get(j) < c1) ? ~j : j;', '     SA[i] = 0;', '    }else if(j < 0){', '     SA[i] = ~j;', '    }', '   }', '   /* compute SAs */', '   if(C == B){', '    getCounts(T, C, n, k);', '   }', '   getBuckets(C, B, k, true); /* find ends of buckets */', '   for(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){', '    if(0 < (j = SA[i])){', '     if((c0 = T.get(j)) != c1){', '      B.set(c1, b);', '      b = B.get(c1 = c0);', '     }', '     --j;', '     SA[--b] = (T.get(j) > c1) ? ~(j + 1) : j;', '     SA[i] = 0;', '    }', '   }', '  }', '', '  private static int LMSpostproc(BaseArray T, int[] SA, int n, int m) {', '   int i, j, p, q, plen, qlen, name;', '   int c0, c1;', '   boolean diff;', '', '   /*', '    * compact all the sorted substrings into the first m items of SA 2*m', '    * must be not larger than n (proveable)', '    */', '   for(i = 0;(p = SA[i]) < 0;++i){', '    SA[i] = ~p;', '   }', '   if(i < m){', '    for(j = i, ++i;;++i){', '     if((p = SA[i]) < 0){', '      SA[j++] = ~p;', '      SA[i] = 0;', '      if(j == m){', '       break;', '      }', '     }', '    }', '   }', '', '   /* store the length of all substrings */', '   i = n - 1;', '   j = n - 1;', '   c0 = T.get(n - 1);', '   do{', '    c1 = c0;', '   }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '   for(;0 <= i;){', '    do{', '     c1 = c0;', '    }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));', '    if(0 <= i){', '     SA[m + ((i + 1) >> 1)] = j - i;', '     j = i + 1;', '     do{', '      c1 = c0;', '     }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '    }', '   }', '', '   /* find the lexicographic names of all substrings */', '   for(i = 0, name = 0, q = n, qlen = 0;i < m;++i){', '    p = SA[i];', '    plen = SA[m + (p >> 1)];', '    diff = true;', '    if((plen == qlen) && ((q + plen) < n)){', '     for(j = 0;(j < plen) && (T.get(p + j) == T.get(q + j));++j){', '     }', '     if(j == plen){', '      diff = false;', '     }', '    }', '    if(diff != false){', '     ++name;', '     q = p;', '     qlen = plen;', '    }', '    SA[m + (p >> 1)] = name;', '   }', '', '   return name;', '  }', '', '  /* compute SA and BWT */', '  private static void induceSA(BaseArray T, int[] SA, BaseArray C,', '    BaseArray B, int n, int k) {', '   int b, i, j;', '   int c0, c1;', '   /* compute SAl */', '   if(C == B){', '    getCounts(T, C, n, k);', '   }', '   getBuckets(C, B, k, false); /* find starts of buckets */', '   j = n - 1;', '   b = B.get(c1 = T.get(j));', '   SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;', '   for(i = 0;i < n;++i){', '    j = SA[i];', '    SA[i] = ~j;', '    if(0 < j){', '     if((c0 = T.get(--j)) != c1){', '      B.set(c1, b);', '      b = B.get(c1 = c0);', '     }', '     SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;', '    }', '   }', '   /* compute SAs */', '   if(C == B){', '    getCounts(T, C, n, k);', '   }', '   getBuckets(C, B, k, true); /* find ends of buckets */', '   for(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){', '    if(0 < (j = SA[i])){', '     if((c0 = T.get(--j)) != c1){', '      B.set(c1, b);', '      b = B.get(c1 = c0);', '     }', '     SA[--b] = ((j == 0) || (T.get(j - 1) > c1)) ? ~j : j;', '    }else{', '     SA[i] = ~j;', '    }', '   }', '  }', '', '  /*', '   * find the suffix array SA of T[0..n-1] in {0..k-1}^n use a working space', '   * (excluding T and SA) of at most 2n+O(1) for a constant alphabet', '   */', '  private static void SA_IS(BaseArray T, int[] SA, int fs, int n, int k) {', '   BaseArray C, B, RA;', '   int i, j, b, m, p, q, name, newfs;', '   int c0, c1;', '   int flags = 0;', '', '   if(k <= 256){', '    C = new IntArray(new int[k], 0);', '    if(k <= fs){', '     B = new IntArray(SA, n + fs - k);', '     flags = 1;', '    }else{', '     B = new IntArray(new int[k], 0);', '     flags = 3;', '    }', '   }else if(k <= fs){', '    C = new IntArray(SA, n + fs - k);', '    if(k <= (fs - k)){', '     B = new IntArray(SA, n + fs - k * 2);', '     flags = 0;', '    }else if(k <= 1024){', '     B = new IntArray(new int[k], 0);', '     flags = 2;', '    }else{', '     B = C;', '     flags = 8;', '    }', '   }else{', '    C = B = new IntArray(new int[k], 0);', '    flags = 4 | 8;', '   }', '', '   /*', '    * stage 1: reduce the problem by at least 1/2 sort all the', '    * LMS-substrings', '    */', '   getCounts(T, C, n, k);', '   getBuckets(C, B, k, true); /* find ends of buckets */', '   for(i = 0;i < n;++i){', '    SA[i] = 0;', '   }', '   b = -1;', '   i = n - 1;', '   j = n;', '   m = 0;', '   c0 = T.get(n - 1);', '   do{', '    c1 = c0;', '   }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '   for(;0 <= i;){', '    do{', '     c1 = c0;', '    }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));', '    if(0 <= i){', '     if(0 <= b){', '      SA[b] = j;', '     }', '     b = B.update(c1, -1);', '     j = i;', '     ++m;', '     do{', '      c1 = c0;', '     }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '    }', '   }', '   if(1 < m){', '    LMSsort(T, SA, C, B, n, k);', '    name = LMSpostproc(T, SA, n, m);', '   }else if(m == 1){', '    SA[b] = j + 1;', '    name = 1;', '   }else{', '    name = 0;', '   }', '', '   /*', '    * stage 2: solve the reduced problem recurse if names are not yet', '    * unique', '    */', '   if(name < m){', '    if((flags & 4) != 0){', '     C = null;', '     B = null;', '    }', '    if((flags & 2) != 0){', '     B = null;', '    }', '    newfs = (n + fs) - (m * 2);', '    if((flags & (1 | 4 | 8)) == 0){', '     if((k + name) <= newfs){', '      newfs -= k;', '     }else{', '      flags |= 8;', '     }', '    }', '    for(i = m + (n >> 1) - 1, j = m * 2 + newfs - 1;m <= i;--i){', '     if(SA[i] != 0){', '      SA[j--] = SA[i] - 1;', '     }', '    }', '    RA = new IntArray(SA, m + newfs);', '    SA_IS(RA, SA, newfs, m, name);', '    RA = null;', '', '    i = n - 1;', '    j = m * 2 - 1;', '    c0 = T.get(n - 1);', '    do{', '     c1 = c0;', '    }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '    for(;0 <= i;){', '     do{', '      c1 = c0;', '     }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));', '     if(0 <= i){', '      SA[j--] = i + 1;', '      do{', '       c1 = c0;', '      }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '     }', '    }', '', '    for(i = 0;i < m;++i){', '     SA[i] = SA[m + SA[i]];', '    }', '    if((flags & 4) != 0){', '     C = B = new IntArray(new int[k], 0);', '    }', '    if((flags & 2) != 0){', '     B = new IntArray(new int[k], 0);', '    }', '   }', '', '   /* stage 3: induce the result for the original problem */', '   if((flags & 8) != 0){', '    getCounts(T, C, n, k);', '   }', '   /* put all left-most S characters into their buckets */', '   if(1 < m){', '    getBuckets(C, B, k, true); /* find ends of buckets */', '    i = m - 1;', '    j = n;', '    p = SA[m - 1];', '    c1 = T.get(p);', '    do{', '     q = B.get(c0 = c1);', '     while (q < j){', '      SA[--j] = 0;', '     }', '     do{', '      SA[--j] = p;', '      if(--i < 0){', '       break;', '      }', '      p = SA[i];', '     }while ((c1 = T.get(p)) == c0);', '    }while (0 <= i);', '    while (0 < j){', '     SA[--j] = 0;', '    }', '   }', '   induceSA(T, SA, C, B, n, k);', '   C = null;', '   B = null;', '  }', '', '  /* char */', '  public static void suffixsort(char[] T, int[] SA, int n) {', '   if((T == null) || (SA == null) || (T.length < n) || (SA.length < n)){', '    return;', '   }', '   if(n <= 1){', '    if(n == 1){', '     SA[0] = 0;', '    }', '    return;', '   }', '   SA_IS(new CharArray(T, 0), SA, 0, n, 128);', '  }', '  ', '  public static int[] sa(char[] T)', '  {', '   int n = T.length;', '   int[] sa = new int[n];', '   suffixsort(T, sa, n);', '   return sa;', '  }', '  ', '  public static int[] buildLCP0(char[] str, int[] sa)', '  {', '   int n = str.length;', '   int h = 0;', '   int[] lcp = new int[n];', '   int[] b = new int[n];', '   for(int i = 0;i < n;i++)b[sa[i]] = i;', '   for(int i = 0;i < n;i++){', '    if(b[i] > 0){', '     for(int j = sa[b[i]-1]; j+h<n && i+h<n && str[j+h] == str[i+h]; h++);', '     lcp[b[i]] = h;', '    }else{', '     lcp[b[i]] = 0;', '    }', '    if(h > 0)h--;', '   }', '   return lcp;', '  } ', ' ', ' public static void main(String[] args) throws Exception', ' {', '//  int n = 100000, m = 99999;', '//  Random gen = new Random();', '//  StringBuilder sb = new StringBuilder();', '//  sb.append(1 + "" "");', '//  for(int i = 0;i < n;i++){', ""//   sb.append((char)(gen.nextInt(26)+'a'));"", '//  }', '//  sb.append("" "" + gen.nextInt(10000000)+1 + "" "");', '//  INPUT = sb.toString();', '  ', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', 'public class Solution {', '    ', '    static char ashtonString(String a, int k) {', '        TreeSet<String> subStringSet = new TreeSet<>();', '        //TreeSet<String> nextSubStringSet = new TreeSet<>();', '        TreeSet<String> resultSet = new TreeSet<>();', '        int index = -1;', '        long len   = a.length();', '        int tempIndex = 1;', '        String str = a;', '        int charIndex = -1;', '        int finalLen = 0;', '        for(int i=97; i<123; i++){', '            //System.out.println(i+""-----""+i);', '            str = a;', '            int fromIndex = 0;', '            while ((charIndex=str.indexOf(i,fromIndex)) != -1){', '                str = str.substring(charIndex);', '                subStringSet.add(str);', '                fromIndex=1;', '                //str = str.replaceFirst(""[""+((char)i)+""]"", """");', '            }', '            while((str=subStringSet.pollFirst())!=null) {', '                if (str.length() > 1) {', '                    //char ch = str.charAt(0);', '                    if (str.charAt(1) == i) {', '                        //subStringSet.add(str.replaceFirst(""[""+ch+""]"", """"));', '                    }else if (str.charAt(0) != i) {', '                        //nextSubStringSet.add(str.substring(1));', '                        subStringSet.clear();', '                        resultSet.clear();', '                        break;', '                    }', '                }', '                len = str.length();', '                tempIndex = 0;', '                long totLen = (len*(len+1))/2;', '                if(totLen >= k){', '                //if((len*(len+1))/2 >= k){', '                    int lenFnd = 0;', '                    for(String strFnd : resultSet){', '                        if(str.startsWith(strFnd)){', '                            lenFnd += strFnd.length();', '                        }', '                    }', '                    k+=lenFnd;', '                    for (int n=1;n<=len;n++){', '                        if((n*(n+1))/2 > k){', '                            int diff = k-((n-1)*n)/2;', '                            return str.charAt(diff-1);', '                        } else if((n*(n+1))/2 == k){', '                            return str.charAt(n-1);', '                        }', '                    }', '                } else {', '                    while (tempIndex++ < (len > 100 ? 100 : len)) {', '                        String res = str.substring(0, tempIndex);', '                        if (resultSet.add(res)) {', '                            k -= res.length();', '                        }', '                    }', '                    for(int n=tempIndex;n<len+1;n++){', '                        k-=n;', '                    }', '                    resultSet.add(str);', '                }', '            }', '        }', ""        return '$';"", '    }', '    ', '    static char ashtonString7(String a, int k) {', '        TreeSet<String> subStringSet = new TreeSet<>();', '        //TreeSet<String> nextSubStringSet = new TreeSet<>();', '        TreeSet<String> resultSet = new TreeSet<>();', '        int index = -1;', '        int len   = a.length();', '        int tempIndex = 1;', '        String str = a;', '        int charIndex = -1;', '        int finalLen = 0;', '        for(int i=97; i<123; i++){', '            //System.out.println(i+""-----""+i);', '            str = a;', '            while ((charIndex=str.indexOf(i)) != -1){', '                str = str.substring(charIndex+1);', '                subStringSet.add((char)i+str);', '            }', '            while((str = subStringSet.pollFirst())!=null) {', '                if (str.length() > 1) {', '                     if (str.charAt(1) == i) {', '                        subStringSet.add(str.substring(1));', '                    }else if (str.charAt(0) != i) {', '                        //nextSubStringSet.add(str.substring(1));', '                        subStringSet.clear();', '                        resultSet.clear();', '                        break;', '                    }', '                }', '                len = str.length();', '                tempIndex = 0;', '                while (tempIndex++ < len) {', '                    String res = str.substring(0, tempIndex);', '                    if (resultSet.add(res)) {', '                        if (res.length() >= k) {', '                            char ch = res.charAt(k - 1);', '                            resultSet.clear();', '                            subStringSet.clear();', '                            //nextSubStringSet.clear();', '                            resultSet = null;', '                            subStringSet = null;', '                            //nextSubStringSet = null;', '                            return ch;', '                        } else {', '                            k -= res.length();', '                        }', '                    }', '                }', '            }', '        }', ""        return '$';"", '    }', '    ', '    static char ashtonString1(String a, int k) {', '        TreeSet<String> subStringSet = new TreeSet<>();', '        TreeSet<String> resultSet = new TreeSet<>();', '        int index = 0;', '        int len   = a.length();', '        int tempIndex = 1;', '        while (index < len){', '            subStringSet.add(a.substring(index++));', '        }', '        StringBuilder stringBuilder = new StringBuilder();', '        while (true){', '            String str = subStringSet.pollFirst();', '            if(str.length() > 1){', '                subStringSet.add(str.substring(1));', '            }', '            len   = str.length();', '            tempIndex = 0;', '            while (tempIndex++ < len){', '                String res = str.substring(0, tempIndex);', '                if(resultSet.add(res)){', '                    stringBuilder.append(res);', '                }', '            }', '            int strLen = stringBuilder.length();', '            if(strLen > k){', '                char ch = stringBuilder.charAt(k-1);', '                resultSet.clear();', '                subStringSet.clear();', '                resultSet = null;', '                subStringSet = null;', '                stringBuilder = null;', '                return ch;', '            }', '        }', '    }', '    ', '    private static final Scanner scanner = new Scanner(System.in);', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '        int t = Integer.parseInt(scanner.nextLine().trim());', '        for (int tItr = 0; tItr < t; tItr++) {', '            String s = scanner.nextLine();', '            int k = Integer.parseInt(scanner.nextLine().trim());', '            char res = ashtonString(s, k);', '            bufferedWriter.write(String.valueOf(res));', '            bufferedWriter.newLine();', '        }', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', ' private void solution() throws IOException {', '  int ts = in.nextInt();', '  while (ts-- > 0) {', '   String s = in.next();', '   int[] z = zFunc(s);', '   // System.err.println(Arrays.toString(z));', '   long res = 0;', '   for (int x : z) {', '    res += x;', '   }', '   out.println(res + s.length());', '  }', ' }', '', ' private int[] zFunc(String s) {', '  int[] res = new int[s.length()];', '  int left = 0;', '  int right = 0;', '  for (int i = 1; i < s.length(); ++i) {', '   if (i <= right) {', '    res[i] = Math.min(right - i + 1, res[i - left]);', '   }', '   while (i + res[i] < s.length() && s.charAt(res[i]) == s.charAt(i + res[i])) {', '    ++res[i];', '   }', '', '   if (i + res[i] - 1 > right) {', '    left = i;', '    right = i + res[i] - 1;', '   }', '  }', '  return res;', ' }', '', ' public void run() {', '  try {', '   solution();', '   in.reader.close();', '   out.close();', '  } catch (Exception e) {', '   e.printStackTrace();', '   System.exit(1);', '  }', ' }', '', ' private class Scanner {', '  StringTokenizer tokenizer;', '', '  BufferedReader reader;', '', '  public Scanner(Reader reader) {', '   this.reader = new BufferedReader(reader);', '   this.tokenizer = new StringTokenizer("""");', '  }', '', '  public boolean hasNext() throws IOException {', '   while (!tokenizer.hasMoreTokens()) {', '    String line = reader.readLine();', '    if (line == null) {', '     return false;', '    }', '    tokenizer = new StringTokenizer(line);', '   }', '   return true;', '  }', '', '  public String next() throws IOException {', '   hasNext();', '   return tokenizer.nextToken();', '  }', '', '  // public String nextLine() throws IOException {', '  // tokenizer = new StringTokenizer("""");', '  // return reader.readLine();', '  // }', '', '  public int nextInt() throws IOException {', '   return Integer.parseInt(next());', '  }', '', '  // public long nextLong() throws IOException {', '  // return Long.parseLong(next());', '  // }', ' }', '', ' public static void main(String[] args) throws IOException {', '  new Solution().run();', ' }', '', ' Scanner in = new Scanner(new InputStreamReader(System.in));', ' PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */', '        Scanner s = new Scanner(System.in);', '        int q = s.nextInt();', '        for(int i = 0; i < q; i++){', '            String st = s.next();', '            long total = zFunc(st);', '            System.out.println(total + st.length());', '        }', '    }', '    public static long zFunc(String st){', '        int n = st.length();', '        char[] s = st.toCharArray();', '        long total = 0;', '        long[] z = new long[n];', '        int L = 0, R = 0;', '        for (int i = 0; i < n; i++) {', '          if (i > R) {', '            L = R = i;', '            while (R < n && s[R-L] == s[R]) R++;', '            z[i] = R-L; R--;', '          } else {', '            int k = i-L;', '            if (z[k] < R-i+1) z[i] = z[k];', '            else {', '              L = i;', '              while (R < n && s[R-L] == s[R]) R++;', '              z[i] = R-L; R--;', '            }', '          }', '          total+=z[i];', '        }', '        return total;', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class D {', ' InputStream is;', ' PrintWriter out;', ' String INPUT = """";', ' ', ' void solve()', ' {', '  int mod = 1000000007;', '  long[][] psums = new long[27][100005];', '  long[] tp = new long[100005];', '  Arrays.fill(tp, 1);', '  for(int i = 0;i < 27;i++){', '   psums[i][0] = 1;', '   for(int j = 1;j < 100005;j++){', '    psums[i][j] = psums[i][j-1] + tp[j];', '    if(psums[i][j] >= mod)psums[i][j] -= mod;', '    tp[j] = tp[j] * j % mod;', '   }', '  }', '  ', '  for(int T = ni();T > 0;T--){', '   char[] s = ns().toCharArray();', '   int n = s.length;', '   ', '   int[][] nexts = new int[n+1][26];', '   Arrays.fill(nexts[n], n);', '   // +1', '   for(int j = n-1;j >= 0;j--){', '    for(int k = 0;k < 26;k++){', '     nexts[j][k] = nexts[j+1][k];', '    }', ""    nexts[j][s[j]-'a'] = j;"", '   }', '   ', '   int[] sa = sa(s);', '   int[] lcp = buildLCP(s, sa);', '   long ret = 0;', '   for(int i = 0;i < n;i++){', '    // lcp+1,...,n-sa[i]', '    Arrays.sort(nexts[sa[i]]);', '    for(int j = 1;j <= 26;j++){', '     int ne = j == 26 ? n-sa[i] : nexts[sa[i]][j]-sa[i];', '     int pr = nexts[sa[i]][j-1]-sa[i]+1;', '     pr = Math.max(pr, lcp[i]+1);', '     ', '     if(pr <= ne){', '      ret += psums[j][ne]-psums[j][pr-1];', '     }', '    }', '   }', '   ret %= mod;', '   if(ret < 0)ret += mod;', '   out.println(ret);', '  }', ' }', ' ', ' private static interface BaseArray {', '  public int get(int i);', '', '  public void set(int i, int val);', '', '  public int update(int i, int val);', ' }', '', ' private static class CharArray implements BaseArray {', '  private char[] m_A = null;', '  private int m_pos = 0;', '', '  CharArray(char[] A, int pos) {', '   m_A = A;', '   m_pos = pos;', '  }', '', '  public int get(int i) {', '   return m_A[m_pos + i] & 0xffff;', '  }', '', '  public void set(int i, int val) {', '   m_A[m_pos + i] = (char) (val & 0xffff);', '  }', '', '  public int update(int i, int val) {', '   return m_A[m_pos + i] += val & 0xffff;', '  }', ' }', '', ' private static class IntArray implements BaseArray {', '  private int[] m_A = null;', '  private int m_pos = 0;', '', '  IntArray(int[] A, int pos) {', '   m_A = A;', '   m_pos = pos;', '  }', '', '  public int get(int i) {', '   return m_A[m_pos + i];', '  }', '', '  public void set(int i, int val) {', '   m_A[m_pos + i] = val;', '  }', '', '  public int update(int i, int val) {', '   return m_A[m_pos + i] += val;', '  }', ' }', '', ' /* find the start or end of each bucket */', ' private static void getCounts(BaseArray T, BaseArray C, int n, int k) {', '  int i;', '  for(i = 0;i < k;++i){', '   C.set(i, 0);', '  }', '  for(i = 0;i < n;++i){', '   C.update(T.get(i), 1);', '  }', ' }', '', ' private static void getBuckets(BaseArray C, BaseArray B, int k, boolean end) {', '  int i, sum = 0;', '  if(end != false){', '   for(i = 0;i < k;++i){', '    sum += C.get(i);', '    B.set(i, sum);', '   }', '  }else{', '   for(i = 0;i < k;++i){', '    sum += C.get(i);', '    B.set(i, sum - C.get(i));', '   }', '  }', ' }', '', ' /* sort all type LMS suffixes */', ' private static void LMSsort(BaseArray T, int[] SA, BaseArray C,', '   BaseArray B, int n, int k) {', '  int b, i, j;', '  int c0, c1;', '  /* compute SAl */', '  if(C == B){', '   getCounts(T, C, n, k);', '  }', '  getBuckets(C, B, k, false); /* find starts of buckets */', '  j = n - 1;', '  b = B.get(c1 = T.get(j));', '  --j;', '  SA[b++] = (T.get(j) < c1) ? ~j : j;', '  for(i = 0;i < n;++i){', '   if(0 < (j = SA[i])){', '    if((c0 = T.get(j)) != c1){', '     B.set(c1, b);', '     b = B.get(c1 = c0);', '    }', '    --j;', '    SA[b++] = (T.get(j) < c1) ? ~j : j;', '    SA[i] = 0;', '   }else if(j < 0){', '    SA[i] = ~j;', '   }', '  }', '  /* compute SAs */', '  if(C == B){', '   getCounts(T, C, n, k);', '  }', '  getBuckets(C, B, k, true); /* find ends of buckets */', '  for(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){', '   if(0 < (j = SA[i])){', '    if((c0 = T.get(j)) != c1){', '     B.set(c1, b);', '     b = B.get(c1 = c0);', '    }', '    --j;', '    SA[--b] = (T.get(j) > c1) ? ~(j + 1) : j;', '    SA[i] = 0;', '   }', '  }', ' }', '', ' private static int LMSpostproc(BaseArray T, int[] SA, int n, int m) {', '  int i, j, p, q, plen, qlen, name;', '  int c0, c1;', '  boolean diff;', '', '  /*', '   * compact all the sorted substrings into the first m items of SA 2*m', '   * must be not larger than n (proveable)', '   */', '  for(i = 0;(p = SA[i]) < 0;++i){', '   SA[i] = ~p;', '  }', '  if(i < m){', '   for(j = i, ++i;;++i){', '    if((p = SA[i]) < 0){', '     SA[j++] = ~p;', '     SA[i] = 0;', '     if(j == m){', '      break;', '     }', '    }', '   }', '  }', '', '  /* store the length of all substrings */', '  i = n - 1;', '  j = n - 1;', '  c0 = T.get(n - 1);', '  do{', '   c1 = c0;', '  }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '  for(;0 <= i;){', '   do{', '    c1 = c0;', '   }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));', '   if(0 <= i){', '    SA[m + ((i + 1) >> 1)] = j - i;', '    j = i + 1;', '    do{', '     c1 = c0;', '    }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '   }', '  }', '', '  /* find the lexicographic names of all substrings */', '  for(i = 0, name = 0, q = n, qlen = 0;i < m;++i){', '   p = SA[i];', '   plen = SA[m + (p >> 1)];', '   diff = true;', '   if((plen == qlen) && ((q + plen) < n)){', '    for(j = 0;(j < plen) && (T.get(p + j) == T.get(q + j));++j){', '    }', '    if(j == plen){', '     diff = false;', '    }', '   }', '   if(diff != false){', '    ++name;', '    q = p;', '    qlen = plen;', '   }', '   SA[m + (p >> 1)] = name;', '  }', '', '  return name;', ' }', '', ' /* compute SA and BWT */', ' private static void induceSA(BaseArray T, int[] SA, BaseArray C,', '   BaseArray B, int n, int k) {', '  int b, i, j;', '  int c0, c1;', '  /* compute SAl */', '  if(C == B){', '   getCounts(T, C, n, k);', '  }', '  getBuckets(C, B, k, false); /* find starts of buckets */', '  j = n - 1;', '  b = B.get(c1 = T.get(j));', '  SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;', '  for(i = 0;i < n;++i){', '   j = SA[i];', '   SA[i] = ~j;', '   if(0 < j){', '    if((c0 = T.get(--j)) != c1){', '     B.set(c1, b);', '     b = B.get(c1 = c0);', '    }', '    SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;', '   }', '  }', '  /* compute SAs */', '  if(C == B){', '   getCounts(T, C, n, k);', '  }', '  getBuckets(C, B, k, true); /* find ends of buckets */', '  for(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){', '   if(0 < (j = SA[i])){', '    if((c0 = T.get(--j)) != c1){', '     B.set(c1, b);', '     b = B.get(c1 = c0);', '    }', '    SA[--b] = ((j == 0) || (T.get(j - 1) > c1)) ? ~j : j;', '   }else{', '    SA[i] = ~j;', '   }', '  }', ' }', '', ' /*', '  * find the suffix array SA of T[0..n-1] in {0..k-1}^n use a working space', '  * (excluding T and SA) of at most 2n+O(1) for a constant alphabet', '  */', ' private static void SA_IS(BaseArray T, int[] SA, int fs, int n, int k) {', '  BaseArray C, B, RA;', '  int i, j, b, m, p, q, name, newfs;', '  int c0, c1;', '  int flags = 0;', '', '  if(k <= 256){', '   C = new IntArray(new int[k], 0);', '   if(k <= fs){', '    B = new IntArray(SA, n + fs - k);', '    flags = 1;', '   }else{', '    B = new IntArray(new int[k], 0);', '    flags = 3;', '   }', '  }else if(k <= fs){', '   C = new IntArray(SA, n + fs - k);', '   if(k <= (fs - k)){', '    B = new IntArray(SA, n + fs - k * 2);', '    flags = 0;', '   }else if(k <= 1024){', '    B = new IntArray(new int[k], 0);', '    flags = 2;', '   }else{', '    B = C;', '    flags = 8;', '   }', '  }else{', '   C = B = new IntArray(new int[k], 0);', '   flags = 4 | 8;', '  }', '', '  /*', '   * stage 1: reduce the problem by at least 1/2 sort all the', '   * LMS-substrings', '   */', '  getCounts(T, C, n, k);', '  getBuckets(C, B, k, true); /* find ends of buckets */', '  for(i = 0;i < n;++i){', '   SA[i] = 0;', '  }', '  b = -1;', '  i = n - 1;', '  j = n;', '  m = 0;', '  c0 = T.get(n - 1);', '  do{', '   c1 = c0;', '  }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '  for(;0 <= i;){', '   do{', '    c1 = c0;', '   }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));', '   if(0 <= i){', '    if(0 <= b){', '     SA[b] = j;', '    }', '    b = B.update(c1, -1);', '    j = i;', '    ++m;', '    do{', '     c1 = c0;', '    }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '   }', '  }', '  if(1 < m){', '   LMSsort(T, SA, C, B, n, k);', '   name = LMSpostproc(T, SA, n, m);', '  }else if(m == 1){', '   SA[b] = j + 1;', '   name = 1;', '  }else{', '   name = 0;', '  }', '', '  /*', '   * stage 2: solve the reduced problem recurse if names are not yet', '   * unique', '   */', '  if(name < m){', '   if((flags & 4) != 0){', '    C = null;', '    B = null;', '   }', '   if((flags & 2) != 0){', '    B = null;', '   }', '   newfs = (n + fs) - (m * 2);', '   if((flags & (1 | 4 | 8)) == 0){', '    if((k + name) <= newfs){', '     newfs -= k;', '    }else{', '     flags |= 8;', '    }', '   }', '   for(i = m + (n >> 1) - 1, j = m * 2 + newfs - 1;m <= i;--i){', '    if(SA[i] != 0){', '     SA[j--] = SA[i] - 1;', '    }', '   }', '   RA = new IntArray(SA, m + newfs);', '   SA_IS(RA, SA, newfs, m, name);', '   RA = null;', '', '   i = n - 1;', '   j = m * 2 - 1;', '   c0 = T.get(n - 1);', '   do{', '    c1 = c0;', '   }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '   for(;0 <= i;){', '    do{', '     c1 = c0;', '    }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));', '    if(0 <= i){', '     SA[j--] = i + 1;', '     do{', '      c1 = c0;', '     }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '    }', '   }', '', '   for(i = 0;i < m;++i){', '    SA[i] = SA[m + SA[i]];', '   }', '   if((flags & 4) != 0){', '    C = B = new IntArray(new int[k], 0);', '   }', '   if((flags & 2) != 0){', '    B = new IntArray(new int[k], 0);', '   }', '  }', '', '  /* stage 3: induce the result for the original problem */', '  if((flags & 8) != 0){', '   getCounts(T, C, n, k);', '  }', '  /* put all left-most S characters into their buckets */', '  if(1 < m){', '   getBuckets(C, B, k, true); /* find ends of buckets */', '   i = m - 1;', '   j = n;', '   p = SA[m - 1];', '   c1 = T.get(p);', '   do{', '    q = B.get(c0 = c1);', '    while (q < j){', '     SA[--j] = 0;', '    }', '    do{', '     SA[--j] = p;', '     if(--i < 0){', '      break;', '     }', '     p = SA[i];', '    }while ((c1 = T.get(p)) == c0);', '   }while (0 <= i);', '   while (0 < j){', '    SA[--j] = 0;', '   }', '  }', '  induceSA(T, SA, C, B, n, k);', '  C = null;', '  B = null;', ' }', '', ' /* char */', ' public static void suffixsort(char[] T, int[] SA, int n) {', '  if((T == null) || (SA == null) || (T.length < n) || (SA.length < n)){', '   return;', '  }', '  if(n <= 1){', '   if(n == 1){', '    SA[0] = 0;', '   }', '   return;', '  }', '  SA_IS(new CharArray(T, 0), SA, 0, n, 128);', ' }', ' ', ' public static int[] sa(char[] T)', ' {', '  int n = T.length;', '  int[] sa = new int[n];', '  suffixsort(T, sa, n);', '  return sa;', ' }', ' ', ' public static int[] buildLCP(char[] str, int[] sa)', ' {', '  int n = str.length;', '  int h = 0;', '  int[] lcp = new int[n];', '  int[] isa = new int[n];', '  for(int i = 0;i < n;i++)isa[sa[i]] = i;', '  for(int i = 0;i < n;i++){', '   if(isa[i] > 0){', '    for(int j = sa[isa[i]-1]; j+h<n && i+h<n && str[j+h] == str[i+h]; h++);', '    lcp[isa[i]] = h;', '   }else{', '    lcp[isa[i]] = 0;', '   }', '   if(h > 0)h--;', '  }', '  return lcp;', ' }', '', ' ', ' void run() throws Exception', ' {', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  long s = System.currentTimeMillis();', '  solve();', '  out.flush();', '  if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', ' }', ' ', ' public static void main(String[] args) throws Exception { new D().run(); }', ' ', ' private byte[] inbuf = new byte[1024];', ' private int lenbuf = 0, ptrbuf = 0;', ' ', ' private int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private double nd() { return Double.parseDouble(ns()); }', ' private char nc() { return (char)skip(); }', ' ', ' private String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class D {', '    InputStream is;', '    PrintWriter out;', '    String INPUT = """";', '    ', '    void solve()', '    {', '        int mod = 1000000007;', '        long[][] psums = new long[27][100005];', '        long[] tp = new long[100005];', '        Arrays.fill(tp, 1);', '        for(int i = 0;i < 27;i++){', '            psums[i][0] = 1;', '            for(int j = 1;j < 100005;j++){', '                psums[i][j] = psums[i][j-1] + tp[j];', '                if(psums[i][j] >= mod)psums[i][j] -= mod;', '                tp[j] = tp[j] * j % mod;', '            }', '        }', '        ', '        for(int T = ni();T > 0;T--){', '            char[] s = ns().toCharArray();', '            int n = s.length;', '            ', '            int[][] nexts = new int[n+1][26];', '            Arrays.fill(nexts[n], n);', '            // +1', '            for(int j = n-1;j >= 0;j--){', '                for(int k = 0;k < 26;k++){', '                    nexts[j][k] = nexts[j+1][k];', '                }', ""                nexts[j][s[j]-'a'] = j;"", '            }', '            ', '            int[] sa = sa(s);', '            int[] lcp = buildLCP(s, sa);', '            long ret = 0;', '            for(int i = 0;i < n;i++){', '                // lcp+1,...,n-sa[i]', '                Arrays.sort(nexts[sa[i]]);', '                for(int j = 1;j <= 26;j++){', '                    int ne = j == 26 ? n-sa[i] : nexts[sa[i]][j]-sa[i];', '                    int pr = nexts[sa[i]][j-1]-sa[i]+1;', '                    // [pr,ne)', '//                    tr(j, pr, ne, lcp[i]+1);', '                    pr = Math.max(pr, lcp[i]+1);', '                    ', '                    if(pr <= ne){', '                        ret += psums[j][ne]-psums[j][pr-1];', '                    }', '                }', '            }', '            ret %= mod;', '            if(ret < 0)ret += mod;', '            out.println(ret);', '        }', '    }', '    ', '    private static interface BaseArray {', '        public int get(int i);', '', '        public void set(int i, int val);', '', '        public int update(int i, int val);', '    }', '', '    private static class CharArray implements BaseArray {', '        private char[] m_A = null;', '        private int m_pos = 0;', '', '        CharArray(char[] A, int pos) {', '            m_A = A;', '            m_pos = pos;', '        }', '', '        public int get(int i) {', '            return m_A[m_pos + i] & 0xffff;', '        }', '', '        public void set(int i, int val) {', '            m_A[m_pos + i] = (char) (val & 0xffff);', '        }', '', '        public int update(int i, int val) {', '            return m_A[m_pos + i] += val & 0xffff;', '        }', '    }', '', '    private static class IntArray implements BaseArray {', '        private int[] m_A = null;', '        private int m_pos = 0;', '', '        IntArray(int[] A, int pos) {', '            m_A = A;', '            m_pos = pos;', '        }', '', '        public int get(int i) {', '            return m_A[m_pos + i];', '        }', '', '        public void set(int i, int val) {', '            m_A[m_pos + i] = val;', '        }', '', '        public int update(int i, int val) {', '            return m_A[m_pos + i] += val;', '        }', '    }', '', '    /* find the start or end of each bucket */', '    private static void getCounts(BaseArray T, BaseArray C, int n, int k) {', '        int i;', '        for(i = 0;i < k;++i){', '            C.set(i, 0);', '        }', '        for(i = 0;i < n;++i){', '            C.update(T.get(i), 1);', '        }', '    }', '', '    private static void getBuckets(BaseArray C, BaseArray B, int k, boolean end) {', '        int i, sum = 0;', '        if(end != false){', '            for(i = 0;i < k;++i){', '                sum += C.get(i);', '                B.set(i, sum);', '            }', '        }else{', '            for(i = 0;i < k;++i){', '                sum += C.get(i);', '                B.set(i, sum - C.get(i));', '            }', '        }', '    }', '', '    /* sort all type LMS suffixes */', '    private static void LMSsort(BaseArray T, int[] SA, BaseArray C,', '            BaseArray B, int n, int k) {', '        int b, i, j;', '        int c0, c1;', '        /* compute SAl */', '        if(C == B){', '            getCounts(T, C, n, k);', '        }', '        getBuckets(C, B, k, false); /* find starts of buckets */', '        j = n - 1;', '        b = B.get(c1 = T.get(j));', '        --j;', '        SA[b++] = (T.get(j) < c1) ? ~j : j;', '        for(i = 0;i < n;++i){', '            if(0 < (j = SA[i])){', '                if((c0 = T.get(j)) != c1){', '                    B.set(c1, b);', '                    b = B.get(c1 = c0);', '                }', '                --j;', '                SA[b++] = (T.get(j) < c1) ? ~j : j;', '                SA[i] = 0;', '            }else if(j < 0){', '                SA[i] = ~j;', '            }', '        }', '        /* compute SAs */', '        if(C == B){', '            getCounts(T, C, n, k);', '        }', '        getBuckets(C, B, k, true); /* find ends of buckets */', '        for(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){', '            if(0 < (j = SA[i])){', '                if((c0 = T.get(j)) != c1){', '                    B.set(c1, b);', '                    b = B.get(c1 = c0);', '                }', '                --j;', '                SA[--b] = (T.get(j) > c1) ? ~(j + 1) : j;', '                SA[i] = 0;', '            }', '        }', '    }', '', '    private static int LMSpostproc(BaseArray T, int[] SA, int n, int m) {', '        int i, j, p, q, plen, qlen, name;', '        int c0, c1;', '        boolean diff;', '', '        /*', '         * compact all the sorted substrings into the first m items of SA 2*m', '         * must be not larger than n (proveable)', '         */', '        for(i = 0;(p = SA[i]) < 0;++i){', '            SA[i] = ~p;', '        }', '        if(i < m){', '            for(j = i, ++i;;++i){', '                if((p = SA[i]) < 0){', '                    SA[j++] = ~p;', '                    SA[i] = 0;', '                    if(j == m){', '                        break;', '                    }', '                }', '            }', '        }', '', '        /* store the length of all substrings */', '        i = n - 1;', '        j = n - 1;', '        c0 = T.get(n - 1);', '        do{', '            c1 = c0;', '        }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '        for(;0 <= i;){', '            do{', '                c1 = c0;', '            }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));', '            if(0 <= i){', '                SA[m + ((i + 1) >> 1)] = j - i;', '                j = i + 1;', '                do{', '                    c1 = c0;', '                }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '            }', '        }', '', '        /* find the lexicographic names of all substrings */', '        for(i = 0, name = 0, q = n, qlen = 0;i < m;++i){', '            p = SA[i];', '            plen = SA[m + (p >> 1)];', '            diff = true;', '            if((plen == qlen) && ((q + plen) < n)){', '                for(j = 0;(j < plen) && (T.get(p + j) == T.get(q + j));++j){', '                }', '                if(j == plen){', '                    diff = false;', '                }', '            }', '            if(diff != false){', '                ++name;', '                q = p;', '                qlen = plen;', '            }', '            SA[m + (p >> 1)] = name;', '        }', '', '        return name;', '    }', '', '    /* compute SA and BWT */', '    private static void induceSA(BaseArray T, int[] SA, BaseArray C,', '            BaseArray B, int n, int k) {', '        int b, i, j;', '        int c0, c1;', '        /* compute SAl */', '        if(C == B){', '            getCounts(T, C, n, k);', '        }', '        getBuckets(C, B, k, false); /* find starts of buckets */', '        j = n - 1;', '        b = B.get(c1 = T.get(j));', '        SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;', '        for(i = 0;i < n;++i){', '            j = SA[i];', '            SA[i] = ~j;', '            if(0 < j){', '                if((c0 = T.get(--j)) != c1){', '                    B.set(c1, b);', '                    b = B.get(c1 = c0);', '                }', '                SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;', '            }', '        }', '        /* compute SAs */', '        if(C == B){', '            getCounts(T, C, n, k);', '        }', '        getBuckets(C, B, k, true); /* find ends of buckets */', '        for(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){', '            if(0 < (j = SA[i])){', '                if((c0 = T.get(--j)) != c1){', '                    B.set(c1, b);', '                    b = B.get(c1 = c0);', '                }', '                SA[--b] = ((j == 0) || (T.get(j - 1) > c1)) ? ~j : j;', '            }else{', '                SA[i] = ~j;', '            }', '        }', '    }', '', '    /*', '     * find the suffix array SA of T[0..n-1] in {0..k-1}^n use a working space', '     * (excluding T and SA) of at most 2n+O(1) for a constant alphabet', '     */', '    private static void SA_IS(BaseArray T, int[] SA, int fs, int n, int k) {', '        BaseArray C, B, RA;', '        int i, j, b, m, p, q, name, newfs;', '        int c0, c1;', '        int flags = 0;', '', '        if(k <= 256){', '            C = new IntArray(new int[k], 0);', '            if(k <= fs){', '                B = new IntArray(SA, n + fs - k);', '                flags = 1;', '            }else{', '                B = new IntArray(new int[k], 0);', '                flags = 3;', '            }', '        }else if(k <= fs){', '            C = new IntArray(SA, n + fs - k);', '            if(k <= (fs - k)){', '                B = new IntArray(SA, n + fs - k * 2);', '                flags = 0;', '            }else if(k <= 1024){', '                B = new IntArray(new int[k], 0);', '                flags = 2;', '            }else{', '                B = C;', '                flags = 8;', '            }', '        }else{', '            C = B = new IntArray(new int[k], 0);', '            flags = 4 | 8;', '        }', '', '        /*', '         * stage 1: reduce the problem by at least 1/2 sort all the', '         * LMS-substrings', '         */', '        getCounts(T, C, n, k);', '        getBuckets(C, B, k, true); /* find ends of buckets */', '        for(i = 0;i < n;++i){', '            SA[i] = 0;', '        }', '        b = -1;', '        i = n - 1;', '        j = n;', '        m = 0;', '        c0 = T.get(n - 1);', '        do{', '            c1 = c0;', '        }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '        for(;0 <= i;){', '            do{', '                c1 = c0;', '            }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));', '            if(0 <= i){', '                if(0 <= b){', '                    SA[b] = j;', '                }', '                b = B.update(c1, -1);', '                j = i;', '                ++m;', '                do{', '                    c1 = c0;', '                }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '            }', '        }', '        if(1 < m){', '            LMSsort(T, SA, C, B, n, k);', '            name = LMSpostproc(T, SA, n, m);', '        }else if(m == 1){', '            SA[b] = j + 1;', '            name = 1;', '        }else{', '            name = 0;', '        }', '', '        /*', '         * stage 2: solve the reduced problem recurse if names are not yet', '         * unique', '         */', '        if(name < m){', '            if((flags & 4) != 0){', '                C = null;', '                B = null;', '            }', '            if((flags & 2) != 0){', '                B = null;', '            }', '            newfs = (n + fs) - (m * 2);', '            if((flags & (1 | 4 | 8)) == 0){', '                if((k + name) <= newfs){', '                    newfs -= k;', '                }else{', '                    flags |= 8;', '                }', '            }', '            for(i = m + (n >> 1) - 1, j = m * 2 + newfs - 1;m <= i;--i){', '                if(SA[i] != 0){', '                    SA[j--] = SA[i] - 1;', '                }', '            }', '            RA = new IntArray(SA, m + newfs);', '            SA_IS(RA, SA, newfs, m, name);', '            RA = null;', '', '            i = n - 1;', '            j = m * 2 - 1;', '            c0 = T.get(n - 1);', '            do{', '                c1 = c0;', '            }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '            for(;0 <= i;){', '                do{', '                    c1 = c0;', '                }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));', '                if(0 <= i){', '                    SA[j--] = i + 1;', '                    do{', '                        c1 = c0;', '                    }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '                }', '            }', '', '            for(i = 0;i < m;++i){', '                SA[i] = SA[m + SA[i]];', '            }', '            if((flags & 4) != 0){', '                C = B = new IntArray(new int[k], 0);', '            }', '            if((flags & 2) != 0){', '                B = new IntArray(new int[k], 0);', '            }', '        }', '', '        /* stage 3: induce the result for the original problem */', '        if((flags & 8) != 0){', '            getCounts(T, C, n, k);', '        }', '        /* put all left-most S characters into their buckets */', '        if(1 < m){', '            getBuckets(C, B, k, true); /* find ends of buckets */', '            i = m - 1;', '            j = n;', '            p = SA[m - 1];', '            c1 = T.get(p);', '            do{', '                q = B.get(c0 = c1);', '                while (q < j){', '                    SA[--j] = 0;', '                }', '                do{', '                    SA[--j] = p;', '                    if(--i < 0){', '                        break;', '                    }', '                    p = SA[i];', '                }while ((c1 = T.get(p)) == c0);', '            }while (0 <= i);', '            while (0 < j){', '                SA[--j] = 0;', '            }', '        }', '        induceSA(T, SA, C, B, n, k);', '        C = null;', '        B = null;', '    }', '', '    /* char */', '    public static void suffixsort(char[] T, int[] SA, int n) {', '        if((T == null) || (SA == null) || (T.length < n) || (SA.length < n)){', '            return;', '        }', '        if(n <= 1){', '            if(n == 1){', '                SA[0] = 0;', '            }', '            return;', '        }', '        SA_IS(new CharArray(T, 0), SA, 0, n, 128);', '    }', '    ', '    public static int[] sa(char[] T)', '    {', '        int n = T.length;', '        int[] sa = new int[n];', '        suffixsort(T, sa, n);', '        return sa;', '    }', '    ', '    public static int[] buildLCP(char[] str, int[] sa)', '    {', '        int n = str.length;', '        int h = 0;', '        int[] lcp = new int[n];', '        int[] isa = new int[n];', '        for(int i = 0;i < n;i++)isa[sa[i]] = i;', '        for(int i = 0;i < n;i++){', '            if(isa[i] > 0){', '  for(int j = sa[isa[i]-1]; j+h<n && i+h<n && str[j+h] == str[i+h]; h++);', '                lcp[isa[i]] = h;', '            }else{', '                lcp[isa[i]] = 0;', '            }', '            if(h > 0)h--;', '        }', '        return lcp;', '    }', '', '    ', '    void run() throws Exception', '    {', ' is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        long s = System.currentTimeMillis();', '        solve();', '        out.flush();', '        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', '    }', '    ', ' public static void main(String[] args) throws Exception { new D().run(); }', '    ', '    private byte[] inbuf = new byte[1024];', '    private int lenbuf = 0, ptrbuf = 0;', '    ', '    private int readByte()', '    {', '        if(lenbuf == -1)throw new InputMismatchException();', '        if(ptrbuf >= lenbuf){', '            ptrbuf = 0;', '            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '            if(lenbuf <= 0)return -1;', '        }', '        return inbuf[ptrbuf++];', '    }', '    ', '    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', '    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', '    ', '    private double nd() { return Double.parseDouble(ns()); }', '    private char nc() { return (char)skip(); }', '    ', '    private String ns()', '    {', '        int b = skip();', '        StringBuilder sb = new StringBuilder();', ""        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '            sb.appendCodePoint(b);', '            b = readByte();', '        }', '        return sb.toString();', '    }', '    ', '    private char[] ns(int n)', '    {', '        char[] buf = new char[n];', '        int b = skip(), p = 0;', '        while(p < n && !(isSpaceChar(b))){', '            buf[p++] = (char)b;', '            b = readByte();', '        }', '        return n == p ? buf : Arrays.copyOf(buf, p);', '    }', '    ', '    private char[][] nm(int n, int m)', '    {', '        char[][] map = new char[n][];', '        for(int i = 0;i < n;i++)map[i] = ns(m);', '        return map;', '    }', '    ', '    private int[] na(int n)', '    {', '        int[] a = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        return a;', '    }', '    ', '    private int ni()', '    {', '        int num = 0, b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private long nl()', '    {', '        long num = 0;', '        int b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static void tr(Object... o) ', '{ System.out.println(Arrays.deepToString(o)); }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    private static int[] maxPalinLen (String str)', '    {', '      int strLen = str.length();', '      StringBuilder buf = new StringBuilder();', '      buf.append(""^"");', '      for (int i = 0; i < strLen; i++)', '      {', '          buf.append(str.charAt(i)).append(""#"");', '      }', '      buf.append(""$"");', '  //    System.out.println(buf);', '      int bufLen = buf.length();', '      int[] palinLen = new int[bufLen];', '      int k = 0;', '      for (int i = 1; i < bufLen - 2; i++)', '      {', '          while (buf.charAt(i - k) == buf.charAt(i + k))', '              k++;', '          k--;', '          palinLen[i] = k;', '          int pos = 1;', '          for (; pos <= k; pos++)', '          {', '              if (palinLen[i - pos] < k - pos)', '              {', '                  palinLen[i + pos] = palinLen[i - pos];', '              }', '              else if (palinLen[i - pos] > k - pos)', '              {', '                  palinLen[i + pos] = k - pos;', '              }', '              else', '              {', '                  break;', '              }', '          }', '          i = i + pos - 1;', '          k = Math.max(0, k - pos);', '      }', '//        printArr(""before palinlen"", palinLen);', '      for (int i = 1; i < bufLen - 1; i++)', '      {', '        palinLen[i] = (i % 2 == 1) ? (1 + 2 * (palinLen[i] / 2)) ', '                : (2 * ((palinLen[i] + 1) / 2));', '      }', '//        printArr(""after palinlen"", palinLen);', '      return palinLen;', '    }', '      ', '    static class SegmentTree', '    {', '        int[] arr;', '        int from;', '        int to;', '        int maxVal;', '        SegmentTree left;', '        SegmentTree right;', '        public SegmentTree ()', '        {', '            ', '        }', '        public static SegmentTree build (int[] arr, int from, int to)', '        {', '            SegmentTree tree = new SegmentTree();', '            int mid = from + (to - from) / 2;', '            tree.from = from;', '            tree.to = to;', '            tree.left = from == to ? null : build(arr, from, mid);', '            tree.right = from == to ? null : build(arr, mid + 1, to);', '            tree.maxVal = from == to ? arr[from] : Math.max(tree.left.maxVal, tree.right.maxVal);', '            return tree;', '        }', '        public int getMax (int qfrom, int qto)', '        {', '            if (qfrom > qto || qto < from || qfrom > to)', '            {', '                return Integer.MIN_VALUE;', '            }', '            else if (qfrom <= from && qto >= to)', '            {', '//                System.out.println(from + "" , "" + to);', '                return this.maxVal;', '            }', '            else', '            {', '                return Math.max(this.left.getMax(qfrom, qto), this.right.getMax(qfrom, qto));', '            }', '        }', '    }', '    public static int[] maxRotatedPalinLen (String str)', '    {', '        int strLen = str.length();', '        int[] maxLen = new int[strLen];', '        String newStr = str + str.substring(0, strLen - 1);', '        int[] palinLen = maxPalinLen(newStr);', '        int[] modifiedPalinLen = new int[palinLen.length];', '        for (int i = 0; i < palinLen.length; i++)', '        {', '            modifiedPalinLen[i] = palinLen[i] - i;', '        }', '//        System.out.println(""modpalinlen = "" + modifiedPalinLen.length + "" array = "" + Arrays.toString(modifiedPalinLen));', '        SegmentTree tree = SegmentTree.build(palinLen, 0, palinLen.length - 1);', '        int ind = 1 + 2 * (strLen - 1) + (strLen - 1);', '//        System.out.println(""ind = "" + ind);', '        int rotateNum = strLen - 1;', '        int minVal = -2 * (strLen - 1);', '        while (rotateNum >= 0)', '        {', '            int to = 1 + 2 * rotateNum + (strLen - 1);', '            int from = to - strLen + 1;', '            while (ind > to)', '                ind--;', '            //ind > 0 && ', '            while (ind >= from && modifiedPalinLen[ind] < minVal)', '                ind--;', '            int palinInd = ind - from;', '            maxLen[rotateNum] = palinInd < 0 ? 0 : (palinInd + 1);', '            maxLen[rotateNum] = Math.max(maxLen[rotateNum], tree.getMax(ind + 1, to));', '            rotateNum--;', '            minVal += 2;', '        }', '//        System.out.println(""palin len = "" + Arrays.toString(palinLen));', '//        printArr(""palinLen"", palinLen);', '        //last part of palindrome', '        for (int i = 0; i < palinLen.length; i++)', '        {', '            modifiedPalinLen[i] = palinLen[i] - (palinLen.length - i - 1);', '        }', '//        System.out.println(""mod palin len = "" + Arrays.toString(modifiedPalinLen));', '        ind = 1;', '        rotateNum = 0;', '        minVal = 1 - (palinLen.length - (1 + 2 * (strLen - 1)) - 1);', '//        System.out.println(minVal);', '        while (rotateNum < strLen)', '        {', '            int to = 2 * rotateNum + 1 + 2 * (strLen - 1);', '            int from = to - strLen + 1;', '            while (ind < from)', '                ind++;', '            //ind < palinLen.length - 1', '            while (ind <= to && modifiedPalinLen[ind] < minVal)', '                ind++;', '            int palinInd = to - ind;', '            maxLen[rotateNum] = Math.max(maxLen[rotateNum], palinInd < 0 ? 0 : (palinInd + 1));', '            maxLen[rotateNum] = Math.max(maxLen[rotateNum], tree.getMax(from, ind - 1));', '//            System.out.println(""max between "" + from + "" and "" + (ind - 1) + "" == "" + tree.getMax(from, ind - 1) + "" \\n ------------------------- \\n"");', '            rotateNum++;', '            minVal += 2;', '        }', '        return maxLen;', '    }', '    ', '    public static void main (String[] args) throws Exception', '    {', '        //BufferedReader reader = new BufferedReader(new FileReader(""D:\\\\input04.txt""));', '        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));', '        int n = Integer.parseInt(reader.readLine().trim());', '        int[] maxPalinLen = maxRotatedPalinLen(reader.readLine().trim());', '        StringBuffer output = new StringBuffer();', '        for (int i = 0; i < n; i++)', '        {', '            output.append(maxPalinLen[i]).append(""\\n"");', '        }', '        System.out.print(output);', '//        System.out.println(""len = "" + longestPalin(""baababaababaabaaaabaabbbabaababaaaaaabaaabbaaababbaabaaaaaabbbabbabbbabababaababbbaaabaaabbabababbbbbbbaabbababbbababababbaabbbaababbbbaaaaabaa""));', '    } ', '}']","['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class E2 {', '    InputStream is;', '    PrintWriter out;', '    String INPUT = """";', '    ', '    void solve()', '    {', '        int n = ni();', '        char[] s = ns(n);', '        char[] s2 = new char[2*n];', '        for(int i = 0;i < n;i++){', '            s2[i] = s2[i+n] = s[i];', '        }', '        int[] pal = palindrome(s2);', '//        tr(pal, pal.length, n);', '        long[] es = new long[16*n];', '        int p = 0;', '        for(int i = 0;i < 4*n;i+=2){', '            pal[i] = Math.min(pal[i], n-((n&1)^1));', '            es[p++] = (long)(i/2)<<32|i;', '            es[p++] = (long)(i/2+pal[i]/2)<<32|i;', '            es[p++] = (long)(i/2+n-pal[i]/2-1)<<32|i;', '            es[p++] = (long)(i/2+n)<<32|i;', '        }', '        for(int i = 1;i < 4*n;i+=2){', '            pal[i] = Math.min(pal[i], n-((n&1)));', '            es[p++] = (long)(i/2)<<32|i;', '            es[p++] = (long)(i/2+pal[i]/2)<<32|i;', '            es[p++] = (long)(i/2+n-pal[i]/2)<<32|i;', '            es[p++] = (long)(i/2+n)<<32|i;', '        }', '        ', '        Arrays.sort(es, 0, p);', '        MaxHeap inc = new MaxHeap(4*n+1);', '        MaxHeap dec = new MaxHeap(4*n+1);', '        MaxHeap flat = new MaxHeap(4*n+1);', '        ', '        int[] st = new int[4*n];', '        int q = 0;', '        for(int i = 0;i < 2*n-1;i++){', '            while(q < p && es[q]>>>32 <= i){', '                int ind = (int)es[q];', '                if(st[ind] == 0){', '                    inc.add(ind, (pal[ind]&1)-2*i);', '                }else if(st[ind] == 1){', '                    inc.remove(ind);', '                    flat.add(ind, pal[ind]);', '                }else if(st[ind] == 2){', '                    flat.remove(ind);', '                    dec.add(ind, pal[ind]+2*i);', '                }else if(st[ind] == 3){', '                    dec.remove(ind);', '                }', '                st[ind]++;', '                q++;', '            }', '            if(i >= n-1){', '//                tr(""i"", i);', '                int max = 0;', '                if(inc.size() > 0)max = Math.max(inc.max()+2*i, max);', '//                tr(max);', '                if(dec.size() > 0)max = Math.max(dec.max()-2*i, max);', '//                tr(max);', '                max = Math.max(flat.max(), max);', '//                tr(max);', '                out.println(max);', '            }', '        }', '    }', '    public static class MaxHeap {', '        public int[] a;', '        public int[] map;', '        public int[] imap;', '        public int n;', '        public int pos;', '        public static int INF = Integer.MIN_VALUE;', '        ', '        public MaxHeap(int m)', '        {', '            n = m+2;', '            a = new int[n];', '            map = new int[n];', '            imap = new int[n];', '            Arrays.fill(a, INF);', '            Arrays.fill(map, -1);', '            Arrays.fill(imap, -1);', '            pos = 1;', '        }', '        ', '        public int add(int ind, int x)', '        {', '            int ret = imap[ind];', '            if(imap[ind] < 0){', '                a[pos] = x; map[pos] = ind; imap[ind] = pos;', '                pos++;', '                up(pos-1);', '            }', '            return ret != -1 ? a[ret] : x;', '        }', '        ', '        public int update(int ind, int x)', '        {', '            int ret = imap[ind];', '            if(imap[ind] < 0){', '                a[pos] = x; map[pos] = ind; imap[ind] = pos;', '                pos++;', '                up(pos-1);', '            }else{', '                int o = a[ret];', '                a[ret] = x;', '                up(ret);', '                down(ret);', '//                if(a[ret] < o){', '//                    up(ret);', '//                }else{', '//                    down(ret);', '//                }', '            }', '            return x;', '        }', '        ', '        public int remove(int ind)', '        {', '            if(pos == 1)return INF;', '            if(imap[ind] == -1)return INF;', '            ', '            pos--;', '            int rem = imap[ind];', '            int ret = a[rem];', '            map[rem] = map[pos];', '            imap[map[pos]] = rem;', '            imap[ind] = -1;', '            a[rem] = a[pos];', '            a[pos] = INF;', '            map[pos] = -1;', '            ', '            up(rem);', '            down(rem);', '            return ret;', '        }', '        ', '        public int max() { return a[1]; }', '        public int argmax() { return map[1]; }', '        public int size() {    return pos-1; }', '        ', '        private void up(int cur)', '        {', '            for(int c = cur, p = c>>>1;p >= 1 && a[p] < a[c];c>>>=1, p>>>=1){', '                int d = a[p]; a[p] = a[c]; a[c] = d;', '                int e = imap[map[p]]; imap[map[p]] = imap[map[c]]; imap[map[c]] = e;', '                e = map[p]; map[p] = map[c]; map[c] = e;', '            }', '        }', '        ', '        private void down(int cur)', '        {', '            for(int c = cur;2*c < pos;){', '                int b = a[2*c] > a[2*c+1] ? 2*c : 2*c+1;', '                if(a[b] > a[c]){', '                    int d = a[c]; a[c] = a[b]; a[b] = d;', '                    int e = imap[map[c]]; imap[map[c]] = imap[map[b]]; imap[map[b]] = e;', '                    e = map[c]; map[c] = map[b]; map[b] = e;', '                    c = b;', '                }else{', '                    break;', '                }', '            }', '        }', '    }', '    ', '    public static int[] palindrome(char[] str)', '    {', '        int n = str.length;', '        int[] r = new int[2*n];', '        int k = 0;', '        for(int i = 0, j = 0;i < 2*n;i += k, j = Math.max(j-k, 0)){', '            // normally', '            while(i-j >= 0 && i+j+1 < 2*n && str[(i-j)/2] == str[(i+j+1)/2])j++;', '            r[i] = j;', '            ', '            // skip based on the theorem', '            for(k = 1;i-k >= 0 && r[i]-k >= 0 && r[i-k] != r[i]-k;k++){', '                r[i+k] = Math.min(r[i-k], r[i]-k);', '            }', '        }', '        return r;', '    }', '', '    ', '    void run() throws Exception', '    {', '        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        long s = System.currentTimeMillis();', '        solve();', '        out.flush();', '        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', '    }', '    ', '    public static void main(String[] args) throws Exception { new E2().run(); }', '    ', '    private byte[] inbuf = new byte[1024];', '    private int lenbuf = 0, ptrbuf = 0;', '    ', '    private int readByte()', '    {', '        if(lenbuf == -1)throw new InputMismatchException();', '        if(ptrbuf >= lenbuf){', '            ptrbuf = 0;', '            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '            if(lenbuf <= 0)return -1;', '        }', '        return inbuf[ptrbuf++];', '    }', '    ', '    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', '    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', '    ', '    private double nd() { return Double.parseDouble(ns()); }', '    private char nc() { return (char)skip(); }', '    ', '    private String ns()', '    {', '        int b = skip();', '        StringBuilder sb = new StringBuilder();', ""        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '            sb.appendCodePoint(b);', '            b = readByte();', '        }', '        return sb.toString();', '    }', '    ', '    private char[] ns(int n)', '    {', '        char[] buf = new char[n];', '        int b = skip(), p = 0;', '        while(p < n && !(isSpaceChar(b))){', '            buf[p++] = (char)b;', '            b = readByte();', '        }', '        return n == p ? buf : Arrays.copyOf(buf, p);', '    }', '    ', '    private char[][] nm(int n, int m)', '    {', '        char[][] map = new char[n][];', '        for(int i = 0;i < n;i++)map[i] = ns(m);', '        return map;', '    }', '    ', '    private int[] na(int n)', '    {', '        int[] a = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        return a;', '    }', '    ', '    private int ni()', '    {', '        int num = 0, b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private long nl()', '    {', '        long num = 0;', '        int b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', 'import java.util.HashMap;', '', 'public class Solution {', '', '    static class InputReader {', '     ', '      private InputStream stream;', '      private byte[] buf = new byte[4096];', '      private int curChar;', '      private int numChars;', '      private SpaceCharFilter filter;', '     ', '      public InputReader(InputStream stream) {', '       this.stream = stream;', '      }', '     ', '      public int read() {', '       if (numChars == -1)', '        throw new InputMismatchException();', '       if (curChar >= numChars) {', '        curChar = 0;', '        try {', '         numChars = stream.read(buf);', '        } catch (IOException e) {', '         throw new InputMismatchException();', '        }', '        if (numChars <= 0)', '         return -1;', '       }', '       return buf[curChar++];', '      }', '     ', '      public int readInt() {', '       int c = read();', '       while (isSpaceChar(c))', '        c = read();', '       int sgn = 1;', ""       if (c == '-') {"", '        sgn = -1;', '        c = read();', '       }', '       int res = 0;', '       do {', ""        if (c < '0' || c > '9')"", '         throw new InputMismatchException();', '        res *= 10;', ""        res += c - '0';"", '        c = read();', '       } while (!isSpaceChar(c));', '       return res * sgn;', '      }', '     ', '      public String readString() {', '       int c = read();', '       while (isSpaceChar(c))', '        c = read();', '       StringBuilder res = new StringBuilder();', '       do {', '        res.appendCodePoint(c);', '        c = read();', '       } while (!isSpaceChar(c));', '       return res.toString();', '      }', '', '                void readCharArray(char[] ar, int len) {', '                    for(int i=0; i<len; i++)', '                        ar[i] = (char) read();', '                }', '                ', '      public boolean isSpaceChar(int c) {', '       if (filter != null)', '        return filter.isSpaceChar(c);', ""       return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;"", '      }', '     ', '      public String next() {', '       return readString();', '      }', '     ', '      public interface SpaceCharFilter {', '       public boolean isSpaceChar(int ch);', '      }', '     }', '     ', '    static class OutputWriter {', '      private final PrintWriter writer;', '     ', '      public OutputWriter(OutputStream outputStream) {', '       writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));', '      }', '     ', '      public OutputWriter(Writer writer) {', '       this.writer = new PrintWriter(writer);', '      }', '     ', '      public void print(Object...objects) {', '       for (int i = 0; i < objects.length; i++) {', '//        if (i != 0)', ""//         writer.print(' ');"", '        writer.print(objects[i]);', '       }', '      }', '     ', '      public void printLine(Object...objects) {', '       print(objects);', '       writer.println();', '      }', '     ', '      public void close() {', '       writer.close();', '      }', '     ', '      public void flush() {', '       writer.flush();', '      }', '     ', '      }', '     ', '    static class IOUtils {', '     ', '      public static int[] readIntArray(InputReader in, int size) {', '       int[] array = new int[size];', '       for (int i = 0; i < size; i++)', '        array[i] = in.readInt();', '       return array;', '      }', '     ', '     }', '         ', ""    static final int MAX_CHARS = 'k'; // we have limited alphabet"", '    static int LEN;', '    static char[] str;', '    static long[] mask; // number of times the first character repeats', '    static int[] lcp;', '    static HashMap<Long, ArrayList<Integer> > prefix_match;', '    public static void main(String[] args) {', '        OutputWriter writer = null;', '        try{', '            writer = new OutputWriter(System.out);', '            InputReader ri = new InputReader(System.in);', '//            InputReader ri = new InputReader(new FileInputStream(""c:\\\\source\\\\projects\\\\MyApps\\\\FastRead\\\\input2.txt""));', '            LEN = ri.readInt();', '            int q = ri.readInt();', '//            ri.read(); // read new line character', '            str = new char[LEN];', '            ri.readCharArray(str, LEN);', '            ', '            prefix_match = new HashMap<>();', '            ', '            countPrefixMask();', '            createIsomorphicLCP();', '', '            // for each query', '            int l;', '            int r;', '            int count;', '            for(int i=0; i<q; i++){', '                l = ri.readInt()-1;', '                r = ri.readInt();', '                count = countIsomorphic(l, r);', ""                writer.print(Integer.toString(count), '\\n');"", '            }', '//            writer.print(""countcalls=""+countcalls+""\\n"");', '        }catch(Exception ex){', '            ', '        } finally{', '            if(writer!=null){', '//                writer.flush();', '                writer.close();', '            }', '        }', '    }', '', '    static int countIsomorphic(int pb, int pe){', '        if(pe-pb>=MASK_LEN)', '            return countIsomorphicShort(pb, pe); // simplified search for long strings', '        else', '            return countIsomorphicLong(pb, pe); // do full search ', '    }', '    ', ""    // count number of isomorphic substrings 'pattern' in string 's'"", '    static int countIsomorphicShort(int pb, int pe){', '        ArrayList<Integer> node = prefix_match.get(mask[pb]);', '        int m = pe-pb;', '        int count = 1; // always matched to itself', '        int last = LEN-m;', '        int j;', '        for(Integer ind : node){', '            j = ind; // unbox once', '            ', '            if(j==pb){ // always equals to self', '                continue;', '            }', '            ', '            if(j>last)', '                break; // skip items that are beyond range', '', '            if(countIsomorphicLength(j, pb, pe)==m){', '                count++;', '            }', '        }', '        ', '        return count;        ', '    }', '    ', ""    // count number of isomorphic substrings 'pattern' in string 's'"", '    static int countIsomorphicLong(int pb, int pe){', '        int m = pe-pb;', '        int count = 1; // always matched to itself', '        boolean match = false;', '        int last = LEN-m;', '        for(int j=0; j<=last; j++){', '            if(j==pb){ // always equals to self', '                continue;', '            }', '                ', '            if(match){ // previous pattern matched', '                if(lcp[j-1]>=m){', '                    count++;', '                    continue;', '                }', '            }', '            ', '            if(!testMask(mask[pb], j, m)){', '                match = false;', '                continue;', '            }else if(m<=MASK_LEN){', '                count++;', '                continue;', '            }', '            ', '            if(countIsomorphicLength(j, pb, pe)==m){', '                count++;', '                match = true;', '            }else{', '                match = false;', '            }', '        }', '        return count;', '    }', '    ', '    // return Longest Common Prefix for each string starting at (i) and (i+1)', '    // much less than O(n2)!', '    static void createIsomorphicLCP(){', '        lcp = new int[LEN];', '        ', '        for(int i=0; i<LEN-1; i++){ // cycle for string pairs', '            lcp[i] = countIsomorphicLength(i, i+1, LEN);', '            while(lcp[i]>1){', '                lcp[i+1] = lcp[i++]-1;', '            }', '            //System.out.println(""lcp=""+lcp[i]);', '        }', '    }', '', '    // map characters to the ""first met position"" in the string', '    static final int MASK_LEN = 16; // 16 characters', '    static final int MASK_SHIFT = 2; // 4 bit per position number', '    static void countPrefixMask(){', '        mask = new long[LEN]; // mask for each substring', '        long[] charmap = new long[MAX_CHARS];', '        long current; // next character counter', '        char ch;', '        long cur_mask;', '        for(int i=0; i<LEN; i++){ // for each substring', '            Arrays.fill(charmap, 0L);', '            current = 0L;', '            cur_mask = 0L; // accumulate mask', '            for(int j=0; j<MASK_LEN && j+i<LEN; j++){ // first MASK_LEN characters', '                ch=str[i+j];', '                if(charmap[ch]==0L){', '                    charmap[ch] = ++current;', '                }', '                cur_mask |= charmap[ch]<<(j<<MASK_SHIFT);', '            }', '            mask[i] = cur_mask;', '            // add strings longer than MASK_LEN', '            if(LEN-i>=MASK_LEN){', '                // add current index to the list of matching prefix', '                ArrayList<Integer> node = prefix_match.get(cur_mask);', '                if(node==null){', '                    node = new ArrayList<>();', '                    prefix_match.put(cur_mask, node);', '                }', '                node.add(i);', '            }', '        }', '    }', '', '    static long filter;', '    static boolean testMask(long target, int index, int len){', '        if(MASK_LEN<=len){', '            return target == mask[index];', '        }', '        // if length of the request is less than mask', '        filter = -1L>>>( (MASK_LEN-len)<<MASK_SHIFT );', '        return (target & filter) == (mask[index] & filter );', '    }', '    ', '    // we check only if the beginning of text is isomorphic to pattern', '    // pb - begin index of pattern (inclusive)', '    // pe - end index of pattern (exclusive)', '    static long countcalls = 0; // 1095231 / 761059 / 524641', '    static boolean[] mapped = new boolean[MAX_CHARS];', '    static char[] map = new char[MAX_CHARS];', '    static int countIsomorphicLength(int start, int pb, int pe){', '        countcalls++;', '        ', '        char c;', '        char p;', '        int comp_len = pe-pb;', '        ', '        Arrays.fill(mapped, false);', ""        Arrays.fill(map, '\\0');"", '        for(int i=0; i<comp_len; i++){', '            c = str[start+i];', '            p = str[pb+i];', ""            if(map[c]=='\\0'){"", '                if(mapped[p])', '                    return i;', '                ', '                mapped[p] = true;', '                ', '                map[c] = p;', '            }else{', '                if(map[c]!=p)', '                    return i;', '            }', '        }', '        return comp_len;', '    }', ' ', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    static final int NUM_CHARS = 11;', '    static final int ENCODE_LENGTH = 85;', '   ', '    static long encode(final char[] chars, final int start, final int checkLength) {', '        final int length = Math.min(checkLength, chars.length-1);', '        long hash = 31;//5381;', '        int[] sim = new int[NUM_CHARS];', '        int count = 1;', '        int i=start;', '        for(; i <= start+length && i < chars.length; i++) {', ""            int sim_index = chars[i] - 'a';"", '            if(sim[sim_index] == 0) {', '                sim[sim_index] = count;', '                count++;', '            }', '            hash = hash * sim[sim_index] + 33;', '        }', '        return hash;', '    }', '    ', '    static Map<Long, List<Integer>> buildIndex(final char[] chars) {', '        Map<Long, List<Integer>> index = new HashMap<>();', '        ', '        for(int i = 0; i < chars.length - ENCODE_LENGTH; i++) {', '            final long encoded = encode(chars, i, ENCODE_LENGTH);', '            List<Integer> indexes = index.get(encoded);', '            if(indexes == null) {', '                indexes = new LinkedList<>();', '                index.put(encoded, indexes);', '            }', '            indexes.add(i);', '        }', '        ', '        return index;', '    }', '    ', '    static boolean isSimilar(final char[] chars, final int aStart, final int aEnd, final int bOffset) {', '        final int checkLength = aEnd - aStart + 1;', '        int[] simI = new int[NUM_CHARS+1];', '        int[] simJ = new int[NUM_CHARS+1];', '        for(int i=0; i < checkLength; i++) {', ""            int indexI = chars[i+aStart] - 'a' + 1;"", ""            int indexJ = chars[i+bOffset] - 'a' + 1;"", '            if(simI[indexI] == 0 && simJ[indexJ] == 0) {', '                simI[indexI] = indexJ;', '                simJ[indexJ] = indexI;', '            } else if(simI[indexI] != indexJ || simJ[indexJ] != indexI)', '                return false;', '        }', '        return true;', '    }', '    ', '    /*', '     * Complete the similarStrings function below.', '     */', '    static int similarStrings(final char[] chars, int start, int end, Map<Long, List<Integer>> charIndex) {', '        final int sLength = chars.length;', '        final int checkLength = end - start + 1;', '        int answer = 0;', '        if(checkLength == 1)', '            answer = sLength;', '        else if(checkLength == ENCODE_LENGTH) {', '            List<Integer> indexes = charIndex.get(encode(chars,start-1, ENCODE_LENGTH));', '            answer = indexes == null ? 1 : indexes.size();', '        } else if(checkLength < ENCODE_LENGTH) {', '            for(int index=0; index <= sLength - checkLength; index++)', '                if(index == start-1 ||', '                   isSimilar(chars, start-1, end-1, index))', '                    answer++;', '        } else {', '            List<Integer> indexes = charIndex.get(encode(chars,start-1,ENCODE_LENGTH));', '            if(indexes == null)', '                answer = 1;', '            else {', '                for(Integer index : indexes) {', '                    if(index + checkLength > chars.length) {', '                        break;', '                    } else if(index == start-1 ||', '                              isSimilar(chars, start-1, end-1, index))', '                        answer++;', '                }', '            }', '            if(answer == 0)', '                answer = 1;', '        }', '        return answer;', '    }', '', '    public static void main(String[] args) throws IOException {', '        final Scanner input = new Scanner(System.in);', '', '        String[] nq = input.nextLine().split("" "");', '        final int n = Integer.parseInt(nq[0].trim());', '        final int q = Integer.parseInt(nq[1].trim());', '', '        final String s = input.nextLine().trim();', '        final char[] sChars = s.toCharArray();', '        final Map<Long, List<Integer>> index = buildIndex(sChars);', '', '        StringBuilder answer = new StringBuilder(q*3);', '        for (int queriesRowItr = 0; queriesRowItr < q; queriesRowItr++) {', '            final int l = input.nextInt();', '            final int r = input.nextInt();', '            ', '            final int result = similarStrings(sChars, l, r, index);', '', '            answer.append(result);', ""            answer.append('\\n');"", '        }', '        System.out.print(answer.toString());', '        ', '        input.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.ArrayList;', 'import java.util.List;', 'import java.util.Random;', 'import java.util.StringTokenizer;', '', 'public class Solution {', '', '    // leave empty to read from stdin/stdout', '    private static final String TASK_NAME_FOR_IO = """";', '', '    // file names', '    private static final String FILE_IN = TASK_NAME_FOR_IO + "".in"";', '    private static final String FILE_OUT = TASK_NAME_FOR_IO + "".out"";', '', '    BufferedReader in;', '    PrintWriter out;', '    StringTokenizer tokenizer = new StringTokenizer("""");', '', '    public static void main(String[] args) {', '        new Solution().run();', '    }', '', '    char[] t, p;', '', '    private void solve() throws IOException {', '        // stress();', '        // timing();', '', '        int tc = nextInt();', '        for (int tcIdx = 0; tcIdx < tc; tcIdx++) {', '            t = nextToken().toCharArray();', '            p = nextToken().toCharArray();', '', '            List<Integer> answerFast = solveFast();', '            print(answerFast);', '        }', '    }', '', '    Random r = new Random(123456789L);', '', '    char[] gen(int len, int letters) {', '        char[] s = new char[len];', '        for (int i = 0; i < len; i++) {', ""            s[i] = (char) ('a' + r.nextInt(letters));"", '        }', '        return s;', '    }', '', '    private void stress() {', '        int numTc = 1000000;', '        for (int tc = 0; tc < numTc; tc++) {', '            System.out.print(""Stress "" + tc + "":"");', '', '            int tLen = 1 + r.nextInt(200);', '            t = gen(tLen, 2);', '', '            int pLen = Math.min(tLen, 1 + r.nextInt(4));', '            p = gen(pLen, 2);', '', '            List<Integer> answerFast = solveFast();', '            List<Integer> answerNaive = solveNaive();', '', '            if (!answerFast.equals(answerNaive)) {', '                throw new IllegalStateException(new String(t) + ""/"" + new String(p) + "": "" + answerFast + "" vs. "" + answerNaive);', '            }', '', '            System.out.println("" (OK - "" + answerFast.size() + "" elements)"");', '        }', '    }', '', '    private void timing() {', '        int numTc = 10;', '        for (int tc = 0; tc < numTc; tc++) {', '            System.out.print(""Timing "" + tc + "":"");', '', '            int tLen = 100000;', '            t = gen(tLen, 1);', '', '            int pLen = 1;', '            p = gen(pLen, 1);', '', '            List<Integer> answerFast = solveFast();', '            System.out.println("" (OK - "" + answerFast.size() + "" elements)"");', '        }', '    }', '', '    private void print(List<Integer> answerNaive) {', '        boolean first = true;', '        for (int v : answerNaive) {', '            if (!first) {', ""                out.print(' ');"", '            }', '            out.print(v);', '            first = false;', '        }', '        out.println();', '    }', '', '    private List<Integer> solveFast() {', '', '        char[] pt = concat(p, t);', '        int[] z = calcZ(pt);', '', '        char[] ptRev = concatRev(p, t);', '        int[] zRev = calcZ(ptRev);', '', '        List<Integer> result = new ArrayList<Integer>();', '        for (int i = 0; i <= t.length - p.length; i++) {', '            int commonPrefix = z[p.length + i + 1];', '', '            boolean match = false;', '            if (commonPrefix >= p.length) {', '                // entire match is found', '                match = true;', '            } else if (commonPrefix == p.length - 1) {', ""                // last character is different, but it's okay"", '                match = true;', '            } else {', '                // check remaining characters in a reversed string', '                int len = p.length - commonPrefix - 1;', '', '                // index in the original string', '                int nI = i + p.length - 1;', '', '                // index in the reversed string', '                nI = t.length - nI - 1;', '', '                // index in the concatenated reversed string', '                nI += p.length + 1;', '', '                // check the number of matching characters in a reverse string', '                if (zRev[nI] >= len) {', '                    match = true;', '                }', '            }', '', '            if (match) {', '                result.add(i);', '            }', '        }', '', '        return result;', '    }', '', '    private char[] concat(char[] p, char[] t) {', '        char[] result;', '        StringBuilder ptBuf = new StringBuilder();', '        ptBuf.append(p);', ""        ptBuf.append('#');"", '        ptBuf.append(t);', '        result = ptBuf.toString().toCharArray();', '        return result;', '    }', '', '    private char[] concatRev(char[] p, char[] t) {', '        char[] result;', '        StringBuilder ptBuf = new StringBuilder();', '        ptBuf.append(t);', ""        ptBuf.append('#');"", '        ptBuf.append(p);', '        result = ptBuf.reverse().toString().toCharArray();', '        return result;', '    }', '', '    private int[] calcZ(char[] s) {', '        int[] z = new int[s.length];', '        for (int i = 1, l = 0, r = 0; i < s.length; ++i) {', '            if (i <= r) {', '                z[i] = Math.min(r - i + 1, z[i - l]);', '            }', '            while (i + z[i] < s.length && s[z[i]] == s[i + z[i]]) {', '                z[i]++;', '            }', '            if (i + z[i] - 1 > r) {', '                l = i;', '                r = i + z[i] - 1;', '            }', '        }', '        return z;', '    }', '', '    private List<Integer> solveNaive() {', '', '        List<Integer> result = new ArrayList<Integer>();', '        for (int i = 0; i <= t.length - p.length; i++) {', '            int mismatches = 0;', '            for (int j = 0; j < p.length; j++)', '                if (t[i + j] != p[j]) {', '                    mismatches++;', '                    if (mismatches > 1) {', '                        break;', '                    }', '                }', '', '            if (mismatches <= 1) {', '                result.add(i);', '            }', '        }', '', '        return result;', '    }', '', '    public void run() {', '        long timeStart = System.currentTimeMillis();', '', '        boolean fileIO = TASK_NAME_FOR_IO.length() > 0;', '        try {', '', '            if (fileIO) {', '                in = new BufferedReader(new FileReader(FILE_IN));', '                out = new PrintWriter(new BufferedWriter(new FileWriter(FILE_OUT)));', '            } else {', '                in = new BufferedReader(new InputStreamReader(System.in));', '                out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));', '            }', '', '            solve();', '', '            in.close();', '            out.close();', '        } catch (IOException e) {', '            throw new IllegalStateException(e);', '        }', '        long timeEnd = System.currentTimeMillis();', '', '        if (fileIO) {', '            System.out.println(""Time spent: "" + (timeEnd - timeStart) + "" ms"");', '        }', '    }', '', '    private String nextToken() throws IOException {', '        while (!tokenizer.hasMoreTokens()) {', '            String line = in.readLine();', '            if (line == null) {', '                return null;', '            }', '            tokenizer = new StringTokenizer(line);', '        }', '        return tokenizer.nextToken();', '    }', '', '    private int nextInt() throws IOException {', '        return Integer.parseInt(nextToken());', '    }', '', '}']","['import java.util.*;', 'public class Solution {', '    private static final Scanner sc = new Scanner(System.in);', '', '    static RollingHash text, target;', '    private static boolean ok(final int s, final int l, final int r) {', '        if(r - l < 2) {', '            return true;', '        }', '        ', '        final int m = (l + r) / 2;', '        final long l1 = text.Hash(s + l, s + m);', '        final long l2 = target.Hash(l, m);', '        final long r1 = text.Hash(s + m, s + r);', '        final long r2 = target.Hash(m, r);', '        ', '        if(l1 == l2) {', '            return r1 == r2 ? true : ok(s, m, r);', '        } else if(r1 == r2) {', '            return ok(s, l, m);', '        }', '        return false;', '    }', '', '    public static void main(String[] args) {', '        int T = sc.nextInt();', '        while(T-- != 0) {', '            final String s = sc.next();', '            final String t = sc.next();', '            text = new RollingHash(s);', '            target = new RollingHash(t);', '            boolean first = true;', '            for(int i = 0; i + t.length() <= s.length(); i++) {', '                if(ok(i, 0, t.length())) {', '                    System.out.print((first ? """" : "" "") + i);', '                    first = false;', '                }', '            } if (first) {', '                    System.out.println(""No Match!"");', '            } else {', '                System.out.println();', '            }', '            ', '        }', '    }', '    static class RollingHash {', '        private static final long RADIX = 1000000009L;', '        private int n;', '        long[] table, pow;', '        public RollingHash(String str) {', '            n = str.length();', '            table = new long[n + 1];', '            pow = new long[n + 1];', '            pow[0] = 1;', '            table[0] = 0;', '            for (int i = 0; i < n; i++) {', '                table[i + 1] = table[i] * RADIX + str.charAt(i % n);', '                pow[i + 1] = pow[i] * RADIX;', '            }', '        }', '', '        public long Hash(int i, int j) {', '            assert(i <= j);', '            return table[j] - table[i] * pow[j - i];', '        }', '    }', '}']"
"['import java.io.* ;', 'import java.text.DecimalFormat;', 'import java.util.*;', 'import static java.lang.Math.* ;', 'import static java.util.Arrays.* ;', '', 'public class Solution {', ' ', ' public static void main(String[] args) {', '  ', '   new Solution().solveProblem();', '  ', '  out.close();', ' }', '', ' static Scanner in = new Scanner(new InputStreamReader(System.in));', ' static PrintStream out = new PrintStream(new BufferedOutputStream(System.out));', ' //static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));', ' ', ' ', ' int[] maxx ;', ' String s ="""";', ' public void solveProblem() {  ', '', '  int n = in.nextInt() ;', '  in.nextLine() ;', '', '  String[] sn = new String[n] ;', '  for( int i = 0 ; i < n ; i++ ){', '   sn[i] =  in.nextLine() + ""A"" ;', '   s += sn[i];', '  }', ' ', '  T = s.toCharArray() ;', '  maxx = new int[T.length] ;', '  int som = 0 ;', '  for( int i = 0 ; i < n ; i++ ){', '   int nu = sn[i].length() ;', '   ', '   for( int j = som ; j < som + nu ; j++)', '    maxx[j] = som + nu ;', '   ', '   som += nu ;', '   ', '  }', '  //System.out.println(Arrays.toString(maxx));', '  ', '  this.n = T.length ;', '  ', '  constructSA() ;', '  computeLCP() ;', '  ', '  int q = in.nextInt() ; in.nextLine() ;', '  for( int i = 0 ; i < q ; i++ )', '   losOp(in.nextLong()) ;', '   ', '  ', '  ', ' }', ' ', ' void losOp( long k ) {', '  ', '  int start = 0 ;', '  for( int i = 0 ; i < n ; i++ ){   ', '   ', '   int ind = SA[i] ;', '   start = LCP[i] ;', '   ', '   long aantal = max(0,maxx[ind] - 1 - ind - start) ;', '   //System.out.println(""Zoek "" + s.substring(ind) + "" "" + ind + "" "" + aantal + "" "" + start);', ""   if( T[ind] != 'A' && aantal >= k ){"", '    out.println(s.substring(ind, (int) (ind+start+k))) ;', '    return ;', ""   }else if( T[ind] != 'A')"", '    k -= aantal ;', '   //System.out.println(k);', '   ', '   ', '  }', '  ', '  out.println(""INVALID"") ;', '  ', ' }', ' ', ' int maxlen = 100010 ;', ' int n ;', ' ', ' char[] T ;', ' ', ' int[] RA = new int[maxlen] ;', ' int[] RATemp = new int[maxlen] ;', ' int[] SA = new int[maxlen] ; ', ' int[] SATemp = new int[maxlen] ;', ' ', ' int[] c = new int[maxlen] ;', ' ', ' void constructSA(){', '  ', '  for( int i = 0 ; i < n ; i++ ){', ""   RA[i] = T[i]-'.' ;"", '   SA[i] = i ;', '  }', '  ', '  for( int k = 1 ; k < n ; k <<= 1 ){', '   countingSort( k ) ;', '   countingSort( 0 ) ;', '   ', '   RATemp[SA[0]] = 1 ;   ', '   int r = 1 ;', '   for( int i = 1 ; i < n ; i++ ){', '    RATemp[SA[i]] = ( RA[SA[i]] == RA[SA[i-1]] &&  RA[SA[i]+k] == RA[SA[i-1]+k] ) ? r : ++r ;', '    ', '   }', ' ', '   RA = RATemp.clone() ;', '  }', ' } ', ' ', ' void countingSort( int k ){', '  ', '  int sum = 0 ;', '  int maxi = max( 300, n ) ;', '  ', '  fill( c, 0 ) ;', '  ', '  for( int i = 0 ; i < n ; i++ )', '   c[ ( i + k ) < n ? RA[i+k] : 0 ]++ ;', '  ', '  for( int i = 0 ; i <= maxi ; i++ ){', '   int t = c[i] ;', '   c[i] = sum ;', '   sum += t ;', '  }', '  ', '  for( int i = 0 ; i < n ; i++ ){', '   SATemp[c[(SA[i] + k) < n ? RA[SA[i]+k] : 0]++ ] = SA[i] ;', '  }', '  ', '  ', '  SA = SATemp.clone() ;', ' }', ' ', ' int[] Phi ;', ' int[] LCP ;', ' int max = 0 ;', ' ', ' void computeLCP(){', '  ', '  LCP = new int[n] ;', '  Phi = new int[n] ;', '  int[] PLCP = new int[n] ;', '  ', '   ', '  Phi[SA[0]] = -1 ;', '  for( int i = 1 ; i < n ; i++ )', '   Phi[SA[i]] = SA[i-1] ;', '  ', '  int L = 0; ', '  for( int i = 0 ; i < n ; i++){', '   if( Phi[i] == -1){', '    PLCP[i] = 0 ;', '    continue ;', '   }', '   ', '   while( i+L < n && Phi[i]+L < n && T[i+L] == T[Phi[i]+L])', '    L++ ;', '   ', '   max = max(max,L) ;', '   PLCP[i] = L ;', '   L = max(L-1,0) ;', '  }', '  ', '  for( int i =1 ; i < n ; i++ )', '   LCP[i] = PLCP[SA[i]] ;', '  ', '  ', ' }', '', '}']","['import java.io.BufferedReader;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.util.TreeSet;', 'public class Solution {', '    static TreeSet<String>t;', '    public static void main(String[] args) {', '        try{', '        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));', '        t=new TreeSet<String>();', '        int n=Integer.parseInt(br.readLine());', '        for(int i=0;i<n;i++){', '        String s=br.readLine();', '        for(int j=0;j<s.length();j++){', '        t.add(s.substring(j,s.length()));', '        }', '        }', '        Object [] suffix1=(t.toArray());', '        String suffix[]=new String[suffix1.length];', '        for(int l=0;l<suffix.length;l++){', '        suffix[l]=(String)suffix1[l];', '        //System.out.println(suffix[l]);', '        }', '        int len[]=new int[suffix.length];', '        int lcp[]=new int[suffix.length];', '        len[0]=suffix[0].toString().length();', '        lcp[0]=0;', '        for(int j=1;j<suffix.length;j++){', '        int count=0;', '        try{', '        while(true){', '        if(suffix[j-1].charAt(count)==suffix[j].charAt(count)){', '        count++;', '        }', '        else{', '        break;', '        }        ', '        }}catch(StringIndexOutOfBoundsException e){}', '        len[j]=suffix[j].length()-count;', '        lcp[j]=count;', '        }', '       int q=Integer.parseInt(br.readLine());', '       for(int i=0;i<q;i++){', '       int a=Integer.parseInt(br.readLine());', '       int a1=0;', '       int j=0;', '       int count=0;', '       try{', '       while(j<a){', '       a1=j;', '       j=j+len[count++];', '       }', '       count--;', '       System.out.println(suffix[count].substring(0, lcp[count]+a-a1));', '       }catch(ArrayIndexOutOfBoundsException e){', '       System.out.println(""INVALID"");', '       }', '       }         ', '        }catch(IOException e){', '        System.out.println(e);        ', '        }', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.ArrayList;', 'import java.util.Arrays;', 'import java.util.Comparator;', 'import java.util.InputMismatchException;', 'import java.util.List;', '', 'public class E {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  char[] s = ns().toCharArray();', '  int[] sa = sa(s);', '  int[] lcp = buildLCP(s, sa);', '  int n = s.length;', '  int[] isa = new int[n];', '  for(int i = 0;i < n;i++){', '   isa[sa[i]] = i;', '  }', '  ', '  long ret = 0;', '  int mod = 1000000007;', '  int[] palin = palindrome(s);', '  SuffixTree st = SuffixTree.build(s);', '  int[][] ps = new int[palin.length][];', '  int[][] qs = new int[palin.length][];', '  for(int i = 0;i < palin.length;i++){', '   qs[i] = ps[i] = new int[]{i, palin[i]};', '  }', '  Arrays.sort(qs, new Comparator<int[]>() {', '   public int compare(int[] a, int[] b) {', '    return (a[0]+a[1]-1)-(b[0]+b[1]-1);', '   }', '  });', '  SegmentTreeRMQ stm = new SegmentTreeRMQ(lcp);', '  ', '//  tr(palin);', '  LST lst = new LST(2*n+1);', '  int p = 0;', '  int q = 0;', '  for(int i = 0;i < n;i++){', '   while(p < 2*n && ps[p][0] <= 2*i){', '    if(ps[p][1] >= 1){', '     lst.set(ps[p][0]);', '//     addFenwick(ft, ps[p][0], 1);', '    }', '    p++;', '   }', '   for(int x = lst.next(0);x <= 2*i-st.remainders[i] && x != -1;x = lst.next(x+1)){', '//    tr(i, x);', '    int end = 2*i;', '    int cen = x;', '    int pstart = (2*cen-end)/2;', '    int plen = i-pstart+1;', '    int fl = stm.firstle(isa[pstart]+1, plen-1);', '    int ll = stm.lastle(isa[pstart], plen-1);', '    if(fl == -1)fl = n;', '//    tr(sa);', '//    tr(lcp, isa[pstart]);', '//    tr(fl, ll, fl-ll, plen-1);', '    ret += (long)(fl-ll)*(fl-ll-1)/2%mod;', '   }', '//   ret[i] += sumFenwick(ft, 2*i-st.remainders[i]);', '   while(q < 2*n && (qs[q][0]+qs[q][1]-1) <= 2*i){', '    if(qs[q][1] >= 1)lst.unset(qs[q][0]);', '    q++;', '   }', '  }', '  out.println(ret%mod);', ' }', ' ', ' public static class SegmentTreeRMQ {', '  public int M, H, N;', '  public int[] st;', '  ', '  public SegmentTreeRMQ(int n)', '  {', '   N = n;', '   M = Integer.highestOneBit(Math.max(N-1, 1))<<2;', '   H = M>>>1;', '   st = new int[M];', '   Arrays.fill(st, 0, M, Integer.MAX_VALUE);', '  }', '  ', '  public SegmentTreeRMQ(int[] a)', '  {', '   N = a.length;', '   M = Integer.highestOneBit(Math.max(N-1, 1))<<2;', '   H = M>>>1;', '   st = new int[M];', '   for(int i = 0;i < N;i++){', '    st[H+i] = a[i];', '   }', '   Arrays.fill(st, H+N, M, Integer.MAX_VALUE);', '   for(int i = H-1;i >= 1;i--)propagate(i);', '  }', '  ', '  public void update(int pos, int x)', '  {', '   st[H+pos] = x;', '   for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);', '  }', '  ', '  private void propagate(int i)', '  {', '   st[i] = Math.min(st[2*i], st[2*i+1]);', '  }', '  ', '  public int min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}', '  ', '  private int min(int l, int r, int cl, int cr, int cur)', '  {', '   if(l <= cl && cr <= r){', '    return st[cur];', '   }else{', '    int mid = cl+cr>>>1;', '    int ret = Integer.MAX_VALUE;', '    if(cl < r && l < mid){', '     ret = Math.min(ret, min(l, r, cl, mid, 2*cur));', '    }', '    if(mid < r && l < cr){', '     ret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));', '    }', '    return ret;', '   }', '  }', '  ', '  public int firstle(int l, int v) {', '   if(l >= N)return -1;', '   int cur = H+l;', '   while(true){', '    if(st[cur] <= v){', '     if(cur < H){', '      cur = 2*cur;', '     }else{', '      return cur-H;', '     }', '    }else{', '     cur++;', '     if((cur&cur-1) == 0)return -1;', '     if((cur&1)==0)cur>>>=1;', '    }', '   }', '  }', '  ', '  public int lastle(int l, int v) {', '   int cur = H+l;', '   while(true){', '    if(st[cur] <= v){', '     if(cur < H){', '      cur = 2*cur+1;', '     }else{', '      return cur-H;', '     }', '    }else{', '     if((cur&cur-1) == 0)return -1;', '     cur--;', '     if((cur&1)==1)cur>>>=1;', '    }', '   }', '  }', ' }', '', ' ', ' public static class LST {', '  public long[][] set;', '  public int n;', '//  public int size;', '  ', '  public LST(int n) {', '   this.n = n;', '   int d = 1;', '   for(int m = n;m > 1;m>>>=6, d++);', '   ', '   set = new long[d][];', '   for(int i = 0, m = n>>>6;i < d;i++, m>>>=6){', '    set[i] = new long[m+1];', '   }', '//   size = 0;', '  }', '  ', '  // [0,r)', '  public LST setRange(int r)', '  {', '   for(int i = 0;i < set.length;i++, r=r+63>>>6){', '    for(int j = 0;j < r>>>6;j++){', '     set[i][j] = -1L;', '    }', '    if((r&63) != 0)set[i][r>>>6] |= (1L<<r)-1;', '   }', '   return this;', '  }', '  ', '  // [0,r)', '  public LST unsetRange(int r)', '  {', '   if(r >= 0){', '    for(int i = 0;i < set.length;i++, r=r+63>>>6){', '     for(int j = 0;j < r+63>>>6;j++){', '      set[i][j] = 0;', '     }', '     if((r&63) != 0)set[i][r>>>6] &= ~((1L<<r)-1);', '    }', '   }', '   return this;', '  }', '  ', '  public LST set(int pos)', '  {', '   if(pos >= 0 && pos < n){', '//    if(!get(pos))size++;', '    for(int i = 0;i < set.length;i++, pos>>>=6){', '     set[i][pos>>>6] |= 1L<<pos;', '    }', '   }', '   return this;', '  }', '  ', '  public LST unset(int pos)', '  {', '   if(pos >= 0 && pos < n){', '//    if(get(pos))size--;', '    for(int i = 0;i < set.length && (i == 0 || set[i-1][pos] == 0L);i++, pos>>>=6){', '     set[i][pos>>>6] &= ~(1L<<pos);', '    }', '   }', '   return this;', '  }', '  ', '  public boolean get(int pos)', '  {', '   return pos >= 0 && pos < n && set[0][pos>>>6]<<~pos<0;', '  }', '  ', '  public int prev(int pos)', '  {', '   for(int i = 0;i < set.length && pos >= 0;i++, pos>>>=6, pos--){', '    int pre = prev(set[i][pos>>>6], pos&63);', '    if(pre != -1){', '     pos = pos>>>6<<6|pre;', '     while(i > 0)pos = pos<<6|63-Long.numberOfLeadingZeros(set[--i][pos]);', '     return pos;', '    }', '   }', '   return -1;', '  }', '  ', '  public int next(int pos)', '  {', '   for(int i = 0;i < set.length && pos>>>6 < set[i].length;i++, pos>>>=6, pos++){', '    int nex = next(set[i][pos>>>6], pos&63);', '    if(nex != -1){', '     pos = pos>>>6<<6|nex;', '     while(i > 0)pos = pos<<6|Long.numberOfTrailingZeros(set[--i][pos]);', '     return pos;', '    }', '   }', '   return -1;', '  }', '  ', '  private static int prev(long set, int n)', '  {', '   long h = Long.highestOneBit(set<<~n);', '   if(h == 0L)return -1;', '   return Long.numberOfTrailingZeros(h)-(63-n);', '  }', '  ', '  private static int next(long set, int n)', '  {', '   long h = Long.lowestOneBit(set>>>n);', '   if(h == 0L)return -1;', '   return Long.numberOfTrailingZeros(h)+n;', '  }', '  ', '  @Override', '  public String toString()', '  {', '   List<Integer> list = new ArrayList<Integer>();', '   for(int pos = next(0);pos != -1;pos = next(pos+1)){', '    list.add(pos);', '   }', '   return list.toString();', '  }', ' }', ' ', ' public static int[] restoreFenwick(int[] ft)', ' {', '  int n = ft.length-1;', '  int[] ret = new int[n];', '  for(int i = 0;i < n;i++)ret[i] = sumFenwick(ft, i);', '  for(int i = n-1;i >= 1;i--)ret[i] -= ret[i-1];', '  return ret;', ' }', ' ', ' public static int sumFenwick(int[] ft, int i)', ' {', '  int sum = 0;', '  for(i++;i > 0;i -= i&-i)sum += ft[i];', '  return sum;', ' }', ' ', ' public static void addFenwick(int[] ft, int i, int v)', ' {', '  if(v == 0)return;', '  int n = ft.length;', '  for(i++;i < n;i += i&-i)ft[i] += v;', ' }', ' ', ' public static class SuffixTree {', '  public Node root = new Node(-1, -1, 0);', '  public int gen = 1;', '  public char[] t;', '  public int[] remainders;', '  ', '  public static class Node', '  {', '   public int id;', '   public int l, r; // edge from parent', '   public int ptn = 0;', '   public int p = 0;', '   public Node[] child = null;', '   ', '   public Node fail = null;', '   ', '   public Node(int l, int r, int id)', '   {', '    this.id = id;', '    this.l = l;', '    this.r = r;', '   }', '   ', '   public void appendChild(Node n, int c)', '   {', '    if(p == 0){', '     child = new Node[2];', '    }else if(p+1 >= child.length){', '     child = Arrays.copyOf(child, child.length*2);', '    }', '    int nind = Integer.bitCount(ptn<<31-c);', '    ptn |= 1<<c;', '    System.arraycopy(child, nind, child, nind+1, p-nind);', '    child[nind] = n;', '    p++;', '   }', '   ', '   public String toString(String indent)', '   {', '    StringBuilder sb = new StringBuilder();', '    sb.append(indent + id + "":["" + l + "","" + r + ""] "");', '    if(fail != null)sb.append("" F:"" + fail.id);', '    sb.append(""\\n"");', '    if(p > 0){', '     for(int i = 0;i < p;i++){', '      sb.append(child[i].toString(indent + ""  ""));', '     }', '    }', '    return sb.toString();', '   }', '   ', '   public String toString(String indent, char[] t)', '   {', '    StringBuilder sb = new StringBuilder();', '//    sb.append(indent + id + "":["" + l + "","" + r + ""] "");', '    sb.append(indent + id + "":"" + (l != -1 ? new String(t, l, r-l) : """"));', '    if(fail != null)sb.append("" F:"" + fail.id);', '    sb.append(""\\n"");', '    if(p > 0){', '     for(int i = 0;i < p;i++){', '      sb.append(child[i].toString(indent + ""  "", t));', '     }', '    }', '    return sb.toString();', '   }', '  }', '  ', '  public String toString()', '  {', '   return this.root.toString("""", t);', '  }', '  ', '  public static SuffixTree build(char[] t)', '  {', '   int n = t.length;', '   SuffixTree st = new SuffixTree();', '   st.t = t;', '   st.remainders = new int[n];', '   Datum d = new Datum();', '   d.activePoint = st.root;', '   d.activeChild = null;', '   d.activeLength = 0;', '   d.remainder = 0;', '   d.t = t;', '   d.st = st;', '   for(int i = 0;i < n;i++){', '//    U.tr(""phase "" + i);', '    d.pos = i;', '    d.prevAppended = null;', '    d.remainder++;', '    insert(d);', '    ', '    st.remainders[i] = d.remainder;', '//    U.tr(d);', '//    U.tr(st);', '   }', '//   U.tr(st);', '   return st;', '  }', '  ', '  static void climb(Datum d)', '  {', '   while((d.activeChild = search(d, d.pos-d.activeLength)) != null && d.activeChild.r - d.activeChild.l <= d.activeLength){', '    d.activeLength -= d.activeChild.r - d.activeChild.l;', '    d.activePoint = d.activeChild;', '   }', '  }', '  ', '  static int step = 0;', '  ', '  static void insert(Datum d)', '  {', '   while(true){', '    if(d.activeLength != 0){', '     if(d.t[d.pos] == d.t[d.activeChild.l+d.activeLength]){', '      d.activeLength++;', '      if(d.activeChild.r == d.activeChild.l + d.activeLength){', '       d.activeLength = 0;', '       d.activePoint = d.activeChild;', '       d.activeChild = null;', '      }', '     }else{', '      // split', '      Node latter = d.activeChild;', '      Node former = new Node(latter.l, latter.l + d.activeLength, d.st.gen++);', '      latter.l += d.activeLength;', '      ', ""      int index = Integer.bitCount(d.activePoint.ptn<<31-(d.t[former.l]-'a'))-1;"", ""//      U.tr(Long.toBinaryString(d.activePoint.ptn), d.t[former.l]-'a', former.l, index, d.activePoint.p);"", '      d.activePoint.child[index] = former;', '      ', ""      former.appendChild(latter, d.t[latter.l]-'a');"", '      ', '      if(d.prevAppended != null)d.prevAppended.fail = former; // Rule 2', '      d.prevAppended = former;', '      ', '      Node anew = new Node(d.pos, d.t.length, d.st.gen++);', ""      former.appendChild(anew, d.t[anew.l]-'a');"", '      d.remainder--;', '      if(d.activePoint == d.st.root){ // Rule 1', '       d.activeChild = null;', '       d.activeLength--;', '      }else{ // Rule 3', '       d.activePoint = d.activePoint.fail;', '       if(d.activePoint == null){', '        d.activePoint = d.st.root;', '       }', '       if(d.activePoint == d.st.root){', '        d.activeLength = d.remainder-1;', '       }', '      }', '      climb(d);', '      continue;', '     }', '    }else if(d.activePoint.p > 0){', '     Node ch = search(d, d.pos-d.activeLength);', '     if(ch != null){', '      d.activeChild = ch;', '      d.activeLength++;', '      if(d.activeChild.r == d.activeChild.l + d.activeLength){', '       d.activeLength = 0;', '       d.activePoint = d.activeChild;', '       d.activeChild = null;', '      }', '     }else{', '      Node anew = new Node(d.pos, d.t.length, d.st.gen++);', ""      d.activePoint.appendChild(anew, d.t[anew.l]-'a');"", '      ', '      Node former = d.activePoint;', '      if(d.prevAppended != null)d.prevAppended.fail = former; // Rule 2', '      d.prevAppended = former;', '      d.remainder--;', '      ', '      if(d.activePoint != d.st.root){ // Rule 3', '       d.activePoint = d.activePoint.fail;', '       if(d.activePoint == null){', '        d.activePoint = d.st.root;', '       }', '       if(d.activePoint == d.st.root){', '        d.activeLength = d.remainder-1;', '       }', '       climb(d);', '       continue;', '      }', '     }', '    }else{', '     d.remainder--;', '     Node anew = new Node(d.pos, d.t.length, d.st.gen++);', ""     d.activePoint.appendChild(anew, d.t[anew.l]-'a');"", '    }', '    break;', '   }', '  }', '  ', '  static void check(SuffixTree st)', '  {', '   int n = st.t.length;', '   for(int i = 0;i < n;i++){', '    Node cur = st.root;', '    int j = i;', '    out:', '    while(true){', ""     int ind = st.t[j]-'a';"", '     if(cur.ptn<<31-ind<0){', '      Node ch = cur.child[Integer.bitCount(cur.ptn<<31-ind)-1];', '      for(int k = j, l = ch.l;k < n && l < ch.r;k++,l++){', '       if(st.t[k] != st.t[l])throw new AssertionError(i + "" "" + k + "" "" + l);', '      }', '      cur = ch;', '      if(j < ch.r){', '       break out;', '      }', '      j = ch.r;', '      continue out;', '     }else{', '      throw new AssertionError(i);', '     }', '    }', '   }', '  }', '  ', '  static Node search(Datum d, int pos)', '  {', ""   int ind = d.t[pos]-'a';"", '   if(d.activePoint.ptn<<31-ind<0){', '    return d.activePoint.child[Integer.bitCount(d.activePoint.ptn<<31-ind)-1];', '   }else{', '    return null;', '   }', '  }', '  ', '  public static class Datum', '  {', '   public Node activePoint, activeChild;', '   public int activeLength;', '   public int remainder;', '   public char[] t;', '   public int pos;', '   public SuffixTree st;', '   public Node prevAppended;', '   ', '   public String toString()', '   {', '    return ', '      ""activePoint: "" + activePoint.id + ""\\t"" +', '      ""activeChild: "" + (activeChild != null ? activeChild.id : -1) + ""\\t"" +', '      ""activeLength: "" + activeLength + ""\\t"" + ', '      ""remainder: "" + remainder + ""\\t"" + ', '      ""pos: "" + pos;', '   }', '  }', ' }', ' ', ' private static interface BaseArray {', '  public int get(int i);', '', '  public void set(int i, int val);', '', '  public int update(int i, int val);', ' }', '', ' private static class CharArray implements BaseArray {', '  private char[] m_A = null;', '  private int m_pos = 0;', '', '  CharArray(char[] A, int pos) {', '   m_A = A;', '   m_pos = pos;', '  }', '', '  public int get(int i) {', '   return m_A[m_pos + i] & 0xffff;', '  }', '', '  public void set(int i, int val) {', '   m_A[m_pos + i] = (char) (val & 0xffff);', '  }', '', '  public int update(int i, int val) {', '   return m_A[m_pos + i] += val & 0xffff;', '  }', ' }', ' ', ' public static int[] palindrome(char[] str)', ' {', '  int n = str.length;', '  int[] r = new int[2*n];', '  int k = 0;', '  for(int i = 0, j = 0;i < 2*n;i += k, j = Math.max(j-k, 0)){', '   while(i-j >= 0 && i+j+1 < 2*n && str[(i-j)/2] == str[(i+j+1)/2])j++;', '   r[i] = j;', '   ', '   for(k = 1;i-k >= 0 && r[i]-k >= 0 && r[i-k] != r[i]-k;k++){', '    r[i+k] = Math.min(r[i-k], r[i]-k);', '   }', '  }', '  return r;', ' }', '', ' private static class IntArray implements BaseArray {', '  private int[] m_A = null;', '  private int m_pos = 0;', '', '  IntArray(int[] A, int pos) {', '   m_A = A;', '   m_pos = pos;', '  }', '', '  public int get(int i) {', '   return m_A[m_pos + i];', '  }', '', '  public void set(int i, int val) {', '   m_A[m_pos + i] = val;', '  }', '', '  public int update(int i, int val) {', '   return m_A[m_pos + i] += val;', '  }', ' }', '', ' /* find the start or end of each bucket */', ' private static void getCounts(BaseArray T, BaseArray C, int n, int k) {', '  int i;', '  for(i = 0;i < k;++i){', '   C.set(i, 0);', '  }', '  for(i = 0;i < n;++i){', '   C.update(T.get(i), 1);', '  }', ' }', '', ' private static void getBuckets(BaseArray C, BaseArray B, int k, boolean end) {', '  int i, sum = 0;', '  if(end != false){', '   for(i = 0;i < k;++i){', '    sum += C.get(i);', '    B.set(i, sum);', '   }', '  }else{', '   for(i = 0;i < k;++i){', '    sum += C.get(i);', '    B.set(i, sum - C.get(i));', '   }', '  }', ' }', '', ' /* sort all type LMS suffixes */', ' private static void LMSsort(BaseArray T, int[] SA, BaseArray C,', '   BaseArray B, int n, int k) {', '  int b, i, j;', '  int c0, c1;', '  /* compute SAl */', '  if(C == B){', '   getCounts(T, C, n, k);', '  }', '  getBuckets(C, B, k, false); /* find starts of buckets */', '  j = n - 1;', '  b = B.get(c1 = T.get(j));', '  --j;', '  SA[b++] = (T.get(j) < c1) ? ~j : j;', '  for(i = 0;i < n;++i){', '   if(0 < (j = SA[i])){', '    if((c0 = T.get(j)) != c1){', '     B.set(c1, b);', '     b = B.get(c1 = c0);', '    }', '    --j;', '    SA[b++] = (T.get(j) < c1) ? ~j : j;', '    SA[i] = 0;', '   }else if(j < 0){', '    SA[i] = ~j;', '   }', '  }', '  /* compute SAs */', '  if(C == B){', '   getCounts(T, C, n, k);', '  }', '  getBuckets(C, B, k, true); /* find ends of buckets */', '  for(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){', '   if(0 < (j = SA[i])){', '    if((c0 = T.get(j)) != c1){', '     B.set(c1, b);', '     b = B.get(c1 = c0);', '    }', '    --j;', '    SA[--b] = (T.get(j) > c1) ? ~(j + 1) : j;', '    SA[i] = 0;', '   }', '  }', ' }', '', ' private static int LMSpostproc(BaseArray T, int[] SA, int n, int m) {', '  int i, j, p, q, plen, qlen, name;', '  int c0, c1;', '  boolean diff;', '', '  /*', '   * compact all the sorted substrings into the first m items of SA 2*m', '   * must be not larger than n (proveable)', '   */', '  for(i = 0;(p = SA[i]) < 0;++i){', '   SA[i] = ~p;', '  }', '  if(i < m){', '   for(j = i, ++i;;++i){', '    if((p = SA[i]) < 0){', '     SA[j++] = ~p;', '     SA[i] = 0;', '     if(j == m){', '      break;', '     }', '    }', '   }', '  }', '', '  /* store the length of all substrings */', '  i = n - 1;', '  j = n - 1;', '  c0 = T.get(n - 1);', '  do{', '   c1 = c0;', '  }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '  for(;0 <= i;){', '   do{', '    c1 = c0;', '   }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));', '   if(0 <= i){', '    SA[m + ((i + 1) >> 1)] = j - i;', '    j = i + 1;', '    do{', '     c1 = c0;', '    }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '   }', '  }', '', '  /* find the lexicographic names of all substrings */', '  for(i = 0, name = 0, q = n, qlen = 0;i < m;++i){', '   p = SA[i];', '   plen = SA[m + (p >> 1)];', '   diff = true;', '   if((plen == qlen) && ((q + plen) < n)){', '    for(j = 0;(j < plen) && (T.get(p + j) == T.get(q + j));++j){', '    }', '    if(j == plen){', '     diff = false;', '    }', '   }', '   if(diff != false){', '    ++name;', '    q = p;', '    qlen = plen;', '   }', '   SA[m + (p >> 1)] = name;', '  }', '', '  return name;', ' }', '', ' /* compute SA and BWT */', ' private static void induceSA(BaseArray T, int[] SA, BaseArray C,', '   BaseArray B, int n, int k) {', '  int b, i, j;', '  int c0, c1;', '  /* compute SAl */', '  if(C == B){', '   getCounts(T, C, n, k);', '  }', '  getBuckets(C, B, k, false); /* find starts of buckets */', '  j = n - 1;', '  b = B.get(c1 = T.get(j));', '  SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;', '  for(i = 0;i < n;++i){', '   j = SA[i];', '   SA[i] = ~j;', '   if(0 < j){', '    if((c0 = T.get(--j)) != c1){', '     B.set(c1, b);', '     b = B.get(c1 = c0);', '    }', '    SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;', '   }', '  }', '  /* compute SAs */', '  if(C == B){', '   getCounts(T, C, n, k);', '  }', '  getBuckets(C, B, k, true); /* find ends of buckets */', '  for(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){', '   if(0 < (j = SA[i])){', '    if((c0 = T.get(--j)) != c1){', '     B.set(c1, b);', '     b = B.get(c1 = c0);', '    }', '    SA[--b] = ((j == 0) || (T.get(j - 1) > c1)) ? ~j : j;', '   }else{', '    SA[i] = ~j;', '   }', '  }', ' }', '', ' /*', '  * find the suffix array SA of T[0..n-1] in {0..k-1}^n use a working space', '  * (excluding T and SA) of at most 2n+O(1) for a constant alphabet', '  */', ' private static void SA_IS(BaseArray T, int[] SA, int fs, int n, int k) {', '  BaseArray C, B, RA;', '  int i, j, b, m, p, q, name, newfs;', '  int c0, c1;', '  int flags = 0;', '', '  if(k <= 256){', '   C = new IntArray(new int[k], 0);', '   if(k <= fs){', '    B = new IntArray(SA, n + fs - k);', '    flags = 1;', '   }else{', '    B = new IntArray(new int[k], 0);', '    flags = 3;', '   }', '  }else if(k <= fs){', '   C = new IntArray(SA, n + fs - k);', '   if(k <= (fs - k)){', '    B = new IntArray(SA, n + fs - k * 2);', '    flags = 0;', '   }else if(k <= 1024){', '    B = new IntArray(new int[k], 0);', '    flags = 2;', '   }else{', '    B = C;', '    flags = 8;', '   }', '  }else{', '   C = B = new IntArray(new int[k], 0);', '   flags = 4 | 8;', '  }', '', '  /*', '   * stage 1: reduce the problem by at least 1/2 sort all the', '   * LMS-substrings', '   */', '  getCounts(T, C, n, k);', '  getBuckets(C, B, k, true); /* find ends of buckets */', '  for(i = 0;i < n;++i){', '   SA[i] = 0;', '  }', '  b = -1;', '  i = n - 1;', '  j = n;', '  m = 0;', '  c0 = T.get(n - 1);', '  do{', '   c1 = c0;', '  }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '  for(;0 <= i;){', '   do{', '    c1 = c0;', '   }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));', '   if(0 <= i){', '    if(0 <= b){', '     SA[b] = j;', '    }', '    b = B.update(c1, -1);', '    j = i;', '    ++m;', '    do{', '     c1 = c0;', '    }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '   }', '  }', '  if(1 < m){', '   LMSsort(T, SA, C, B, n, k);', '   name = LMSpostproc(T, SA, n, m);', '  }else if(m == 1){', '   SA[b] = j + 1;', '   name = 1;', '  }else{', '   name = 0;', '  }', '', '  /*', '   * stage 2: solve the reduced problem recurse if names are not yet', '   * unique', '   */', '  if(name < m){', '   if((flags & 4) != 0){', '    C = null;', '    B = null;', '   }', '   if((flags & 2) != 0){', '    B = null;', '   }', '   newfs = (n + fs) - (m * 2);', '   if((flags & (1 | 4 | 8)) == 0){', '    if((k + name) <= newfs){', '     newfs -= k;', '    }else{', '     flags |= 8;', '    }', '   }', '   for(i = m + (n >> 1) - 1, j = m * 2 + newfs - 1;m <= i;--i){', '    if(SA[i] != 0){', '     SA[j--] = SA[i] - 1;', '    }', '   }', '   RA = new IntArray(SA, m + newfs);', '   SA_IS(RA, SA, newfs, m, name);', '   RA = null;', '', '   i = n - 1;', '   j = m * 2 - 1;', '   c0 = T.get(n - 1);', '   do{', '    c1 = c0;', '   }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '   for(;0 <= i;){', '    do{', '     c1 = c0;', '    }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));', '    if(0 <= i){', '     SA[j--] = i + 1;', '     do{', '      c1 = c0;', '     }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '    }', '   }', '', '   for(i = 0;i < m;++i){', '    SA[i] = SA[m + SA[i]];', '   }', '   if((flags & 4) != 0){', '    C = B = new IntArray(new int[k], 0);', '   }', '   if((flags & 2) != 0){', '    B = new IntArray(new int[k], 0);', '   }', '  }', '', '  /* stage 3: induce the result for the original problem */', '  if((flags & 8) != 0){', '   getCounts(T, C, n, k);', '  }', '  /* put all left-most S characters into their buckets */', '  if(1 < m){', '   getBuckets(C, B, k, true); /* find ends of buckets */', '   i = m - 1;', '   j = n;', '   p = SA[m - 1];', '   c1 = T.get(p);', '   do{', '    q = B.get(c0 = c1);', '    while (q < j){', '     SA[--j] = 0;', '    }', '    do{', '     SA[--j] = p;', '     if(--i < 0){', '      break;', '     }', '     p = SA[i];', '    }while ((c1 = T.get(p)) == c0);', '   }while (0 <= i);', '   while (0 < j){', '    SA[--j] = 0;', '   }', '  }', '  induceSA(T, SA, C, B, n, k);', '  C = null;', '  B = null;', ' }', '', ' /* char */', ' public static void suffixsort(char[] T, int[] SA, int n) {', '  if((T == null) || (SA == null) || (T.length < n) || (SA.length < n)){', '   return;', '  }', '  if(n <= 1){', '   if(n == 1){', '    SA[0] = 0;', '   }', '   return;', '  }', '  SA_IS(new CharArray(T, 0), SA, 0, n, 128);', ' }', ' ', ' public static int[] sa(char[] T)', ' {', '  int n = T.length;', '  int[] sa = new int[n];', '  suffixsort(T, sa, n);', '  return sa;', ' }', ' ', ' public static int[] buildLCP(char[] str, int[] sa)', ' {', '  int n = str.length;', '  int h = 0;', '  int[] lcp = new int[n];', '  int[] isa = new int[n];', '  for(int i = 0;i < n;i++)isa[sa[i]] = i;', '  for(int i = 0;i < n;i++){', '   if(isa[i] > 0){', '    for(int j = sa[isa[i]-1]; j+h<n && i+h<n && str[j+h] == str[i+h]; h++);', '    lcp[isa[i]] = h;', '   }else{', '    lcp[isa[i]] = 0;', '   }', '   if(h > 0)h--;', '  }', '  return lcp;', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '//  int n = 100000, m = 99999;', '//  Random gen = new Random();', '//  StringBuilder sb = new StringBuilder();', '////  sb.append(n + "" "");', '//  for (int i = 0; i < n/8; i++) {', '//   sb.append(""abcdefgh"");', '//  }', '//  INPUT = sb.toString();', '  ', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.util.Arrays;', '', 'public class timus2040 {', '', '    static int[][] es;', '    static int[] slink, len, cnt;', '    static int free;', '', '    static int newNode(int l) {', '        len[free] = l;', '        return free++;', '    }', '', '    static int get(int i, char c) {', ""        return es[c - 'a'][i];"", '    }', '', '    static void set(int i, char c, int n) {', ""        es[c - 'a'][i] = n;"", '    }', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        char[] s = in.next().toCharArray();', '        int n = s.length;', '        es = new int[8][n + 2];', '        for (int[] ar : es) {', '            Arrays.fill(ar, -1);', '        }', '        len = new int[n + 2];', '        slink = new int[n + 2];', '        cnt = new int[n + 2];', '        int root0 = newNode(0);', '        int rootm1 = newNode(-1);', '        slink[root0] = slink[rootm1] = rootm1;', '        int cur = root0;', '        for (int i = 0; i < n; ++i) {', '            while (i - len[cur] == 0 || s[i] != s[i - len[cur] - 1]) {', '                cur = slink[cur];', '            }', '            if (get(cur, s[i]) == -1) {', '                set(cur, s[i], newNode(len[cur] + 2));', '                if (cur == rootm1) {', '                    slink[get(cur, s[i])] = root0;', '                } else {', '                    int cur1 = slink[cur];', '                    while (s[i] != s[i - len[cur1] - 1]) {', '                        cur1 = slink[cur1];', '                    }', '                    slink[get(cur, s[i])] = get(cur1, s[i]);', '                }', '            }', '            cur = get(cur, s[i]);', '            cnt[cur]++;', '        }', '        long ans = 0;', '        for (int i = free - 1; i >= 0; --i) {', '            cnt[slink[i]] += cnt[i];', '            if (len[i] > 0) {', '                ans = (ans + 1L * cnt[i] * (cnt[i] - 1) / 2) % 1000000007;', '            }', '        }', '        out.println(ans);', '    }', '', '    public static void main(String[] args) throws IOException {', '//        FileWriter out = new FileWriter(""output.txt"");', '//        solve(new FileReader(""input.txt""), out);', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']"
"['import java.io.*;', 'import java.math.BigInteger;', 'import java.util.ArrayList;', '', 'public class Solution {', '', '    static class Node {', '        Node[] edges = new Node[10];', '        Node slink;', '', '        int weight;', '    }', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        Node root = new Node();', '        for (int pow = 0; pow <= 800; ++pow) {', '            String s = BigInteger.ONE.shiftLeft(pow).toString();', '            Node cur = root;', '            for (char c : s.toCharArray()) {', ""                if (cur.edges[c - '0'] == null) {"", ""                    cur.edges[c - '0'] = new Node();"", '                }', ""                cur = cur.edges[c - '0'];"", '            }', '            cur.weight++;', '        }', '        ArrayList<Node> q = new ArrayList<Node>();', '        q.add(root);', '        for (int it = 0; it < q.size(); ++it) {', '            Node n = q.get(it);', '            for (int i = 0; i < 10; ++i) {', '                Node n1 = n.edges[i];', '                if (n1 == null) {', '                    continue;', '                }', '                q.add(n1);', '                n1.slink = n.slink;', '                while (n1.slink != null && n1.slink.edges[i] == null) {', '                    n1.slink = n1.slink.slink;', '                }', '                if (n1.slink == null) {', '                    n1.slink = root;', '                } else {', '                    n1.slink = n1.slink.edges[i];', '                }', '            }', '        }', '        for (Node n : q) {', '            if (n.slink != null) {', '                n.weight += n.slink.weight;', '            }', '        }', '        for (Node n : q) {', '            for (int i = 0; i < 10; ++i) {', '                if (n.edges[i] == null) {', '                    if (n.slink == null) {', '                        n.edges[i] = root;', '                    } else {', '                        n.edges[i] = n.slink.edges[i];', '                    }', '                }', '            }', '        }', '        int tests = in.nextInt();', '        for (int test = 0; test < tests; ++test) {', '            String s = in.next();', '            int ans = 0;', '            Node cur = root;', '            for (char c : s.toCharArray()) {', ""                cur = cur.edges[c - '0'];"", '                ans += cur.weight;', '            }', '            out.println(ans);', '        }', '    }', '', '    public static void main(String[] args) throws IOException {', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']","['import java.io.*;', 'import java.math.BigInteger;', 'import java.util.ArrayList;', '', 'public class Solution {', '', '    static class Node {', '        Node[] edges = new Node[10];', '        Node slink;', '', '        int weight;', '    }', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        Node root = new Node();', '        for (int pow = 0; pow <= 800; ++pow) {', '            String s = BigInteger.ONE.shiftLeft(pow).toString();', '            Node cur = root;', '            for (char c : s.toCharArray()) {', ""                if (cur.edges[c - '0'] == null) {"", ""                    cur.edges[c - '0'] = new Node();"", '                }', ""                cur = cur.edges[c - '0'];"", '            }', '            cur.weight++;', '        }', '        ArrayList<Node> q = new ArrayList<Node>();', '        q.add(root);', '        for (int it = 0; it < q.size(); ++it) {', '            Node n = q.get(it);', '            for (int i = 0; i < 10; ++i) {', '                Node n1 = n.edges[i];', '                if (n1 == null) {', '                    continue;', '                }', '                q.add(n1);', '                n1.slink = n.slink;', '                while (n1.slink != null && n1.slink.edges[i] == null) {', '                    n1.slink = n1.slink.slink;', '                }', '                if (n1.slink == null) {', '                    n1.slink = root;', '                } else {', '                    n1.slink = n1.slink.edges[i];', '                }', '            }', '        }', '        for (Node n : q) {', '            if (n.slink != null) {', '                n.weight += n.slink.weight;', '            }', '        }', '        for (Node n : q) {', '            for (int i = 0; i < 10; ++i) {', '                if (n.edges[i] == null) {', '                    if (n.slink == null) {', '                        n.edges[i] = root;', '                    } else {', '                        n.edges[i] = n.slink.edges[i];', '                    }', '                }', '            }', '        }', '        int tests = in.nextInt();', '        for (int test = 0; test < tests; ++test) {', '            String s = in.next();', '            int ans = 0;', '            Node cur = root;', '            for (char c : s.toCharArray()) {', ""                cur = cur.edges[c - '0'];"", '                ans += cur.weight;', '            }', '            out.println(ans);', '        }', '    }', '', '    public static void main(String[] args) throws IOException {', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.Comparator;', 'import java.util.InputMismatchException;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', '//  static String INPUT = ""2 2 5 ab cd"";', '// static String INPUT = ""5 2 4 aabaa cd"";', '// static String INPUT = ""4 2 4 aaab bb"";', ' ', ' static class Result', ' {', '  int[] sa;', '  int[] lcp;', '  int[][] branches;', '  long[] count;', '  int[] zero, one;', '  int[] deadline;', '  ', '  public Result(int[] sa, int[] lcp, int[][] branches, long[] count,', '    int[] zero, int[] one, int[] deadline) {', '   this.sa = sa;', '   this.lcp = lcp;', '   this.branches = branches;', '   this.count = count;', '   this.zero = zero;', '   this.one = one;', '   this.deadline = deadline;', '  }', ' }', ' ', ' static void solve()', ' {', '  int n = ni(), m = ni();', '  long K = nl();', '  char[] a = ns(n);', '  char[] b = ns(m);', '  ', '  Result ra = go(a);', '  Result rb = go(b);', '  long[] ca = ra.count;', '  long[] cb = rb.count;', '  if(cb.length < ca.length){', '   cb = Arrays.copyOf(cb, ca.length);', '  }', '  long totcb = 0;', '  for(long v : cb)totcb += v;', '  ', '  Arrays.sort(ra.branches, new Comparator<int[]>() {', '   public int compare(int[] a, int[] b) {', '    return a[0] - b[0];', '   }', '  });', '  ', '  K--;', '  ', '  // """"', '  {', '   long lcount = totcb - cb[ra.branches[0][3]];', '   if(K < lcount){', '    int[] resb = kth(rb, K, ra.branches[0][3]);', '    ', '    out.println("""");', '    out.println(new String(b, resb[0], resb[1]));', '    return;', '   }else{', '    K -= lcount;', '   }', '  }', '  ', '  int bp = 0;', '//  tr(ra.sa);', '  bp++;', '  for(int i = 0;i < n;i++){', '   // row', '   long lcount = 0;', '   lcount += ra.zero[i] * (totcb - cb[0]);', '   lcount += ra.one[i] * (totcb - cb[1]);', '   int obp = bp;', '   while(bp < ra.branches.length && ra.branches[bp][0] == i){', '    lcount += totcb - cb[ra.branches[bp][3]];', '    bp++;', '   }', '//   tr(""lcount?"", lcount);', '//   lcount += 999;', '   if(K < lcount){', '    // letter', '    int[] row = new int[n-ra.sa[i]];', '    Arrays.fill(row, -1);', '    for(int j = obp;j < bp;j++){', '     row[ra.branches[j][2]-1] = ra.branches[j][3];', '    }', '    for(int j = n-ra.sa[i]-1;j >= ra.deadline[i]+1;j--){', '     if(row[j] == -1){', '      if(j == n-ra.sa[i]-1){', '       row[j] = 0;', '      }else{', '       row[j] = row[j+1] > 0 ? 0 : 1;', '      }', '     }', '    }', '//    tr(""row"", row);', '    for(int j = ra.deadline[i]+1;j < n-ra.sa[i];j++){', '     long llcount = totcb - cb[row[j]];', '     if(K < llcount){', '      // rb', '      int[] resa = new int[]{ra.sa[i], j+1};', '      int[] resb = kth(rb, K, row[j]);', '      ', '      out.println(new String(a, resa[0], resa[1]));', '      out.println(new String(b, resb[0], resb[1]));', '      return;', '     }else{', '      K -= llcount;', '     }', '    }', '   }else{', '    K -= lcount;', '   }', '  }', '  ', '  out.println(""no solution"");', ' }', ' ', ' static int[] kth(Result rb, long K, int proh)', ' {', '  Arrays.sort(rb.branches, new Comparator<int[]>() {', '   public int compare(int[] a, int[] b) {', '    return a[0] - b[0];', '   }', '  });', '  ', '  // """"', '  if(rb.branches[0][3] != proh){', '   if(K == 0){', '    return new int[]{0, 0};', '   }else{', '    K--;', '   }', '  }', '  ', '  int n = rb.sa.length;', '  int bp = 1;', '  for(int i = 0;i < n;i++){', '   // row', '   long lcount = 0;', '   if(proh != 0)lcount += rb.zero[i];', '   if(proh != 1)lcount += rb.one[i];', '   int obp = bp;', '   while(bp < rb.branches.length && rb.branches[bp][0] == i){', '    if(proh != rb.branches[bp][3])lcount++;', '    bp++;', '   }', '   if(K < lcount){', '    // letter', '    int[] row = new int[n-rb.sa[i]];', '    Arrays.fill(row, -1);', '    for(int j = obp;j < bp;j++){', '     row[rb.branches[j][2]-1] = rb.branches[j][3];', '    }', '    for(int j = n-rb.sa[i]-1;j >= rb.deadline[i]+1;j--){', '     if(row[j] == -1){', '      if(j == n-rb.sa[i]-1){', '       row[j] = 0;', '      }else{', '       row[j] = row[j+1] > 0 ? 0 : 1;', '      }', '     }', '    }', '//    tr(row, rb.deadline[i]+1, n-rb.sa[i], K);', '    for(int j = rb.deadline[i]+1;j < n-rb.sa[i];j++){', '     if(row[j] != proh){', '      if(K == 0){', '       return new int[]{rb.sa[i], j+1};', '      }', '      K--;', '     }', '    }', '   }else{', '    K -= lcount;', '   }', '  }', '  return null;', ' }', ' ', ' static Result go(char[] a)', ' {', '  int[] sa = suffixsort(a);', '  int[] lcp = buildLCP(a, sa);', '//  tr(sa);', '//  tr(lcp);', '  int[][] branches = findBranches(lcp);', '//  tr(""branches"", branches);', '  ', '  LResult lres = countNimber(sa, lcp, branches);', '  ', '  return new Result(sa, lcp, branches, lres.count, lres.zero, lres.one, lres.deadline);', ' }', ' ', ' private static LResult countNimber(int[] sa, int[] lcp, int[][] branches)', ' {', '  int n = sa.length;', '  ', '  int[] zero = new int[n];', '  int[] one = new int[n];', '  int[] deadline = new int[n];', '  Arrays.fill(deadline, -1);', '  ', '  // nimber???suffix???????', '  int[] hs = new int[n];', '  int[] nim = new int[n];', '  Arrays.fill(nim, -1);', '  long[] count = new long[n+1];', '  for(int i = 0;i < n;i++){', '   hs[i] = n-sa[i]+1;', '  }', '  int[] alive = new int[n];', '  Arrays.fill(alive, 1);', '  int[] ftalive = buildFenwick(alive);', '  int bp = 0;', '  int[] bs2 = new int[n];', '  for(int[] branch : branches){', '   int sp = 0;', '   int L = branch[0];', '   int R = branch[1];', '   int h = branch[2];', '//   tr(L, R, h);', '   if(L == -1)L = 0;', '   int bs = 0;', '   // 2$', '   // .1$', '   // ..010', '   // .010$', '   // 010', '   for(int i = L;i <= R && i >= 0;i = after(ftalive, i)){', '//    tr(""i"", i);', '    if(nim[i] >= 0)count[nim[i]]++;', '    int bet = hs[i]-h-1;', '//    tr(""bet"", bet);', '    if(nim[i] == 0){', '     count[0] += bet / 2;', '     count[1] += (bet+1)/2;', '     zero[i] += bet/2;', '     one[i] += (bet+1)/2;', '     // 0|10|1', '     bs |= 1<<(bet&1);', '    }else{', '     count[0] += (bet+1) / 2;', '     count[1] += bet/2;', '     zero[i] += (bet+1)/2;', '     one[i] += bet/2;', '     if(bet == 0){', '      if(nim[i] >= 0){', '       if(nim[i] <= 31){', '        bs |= 1<<nim[i];', '       }else{', '        bs2[sp++] = nim[i];', '       }', '      }', '     }else{', '      bs |= 1<<((bet&1)^1);', '     }', '    }', '    hs[i] = h;', '//    tr(count, hs, h, i, nim);', '    if(i > L){', '     // kill', '     alive[i] = 0;', '     deadline[i] = h-1;', '     addFenwick(ftalive, i, -1);', '    }', '   }', '//   tr(""bs"",bs);', '   int clus = Integer.numberOfTrailingZeros(~bs);', '   if(clus >= 32){', '    Arrays.sort(bs2, 0, sp);', '    clus = 32;', '    for(int q = 0;q < sp;){', '     if(bs2[q] == clus){', '      while(q < sp && bs2[q] == clus)q++;', '      clus++;', '     }else{', '      break;', '     }', '    }', '   }', '   ', '   branches[bp++][3] = nim[L] = clus;', '   if(branch[0] == -1)count[nim[L]]++;', '  }', '//  out.println(Arrays.toString(count));', '//  tr(count);', '  ', '  return new LResult(count, zero, one, deadline);', ' }', ' ', ' static class LResult', ' {', '  long[] count;', '  int[] zero, one;', '  int[] deadline;', '  public LResult(long[] count, int[] zero, int[] one, int[] deadline) {', '   this.count = count;', '   this.zero = zero;', '   this.one = one;', '   this.deadline = deadline;', '  }', ' }', ' ', '// static int[][] findBranches(int[] a)', '// {', '//  int n = a.length;', '//  int[][] ap = new int[n][];', '//  for(int i = 0;i < n;i++)ap[i] = new int[]{a[i], i};', '//  Arrays.sort(ap, new Comparator<int[]>() {', '//   public int compare(int[] a, int[] b) {', '//    if(a[0] != b[0])return -(a[0] - b[0]);', '//    return a[1] - b[1];', '//   }', '//  });', '//  ', '//  int[][] branches = new int[n][];', '//  ', '//  // aabaa', '//  // a$', '//  // aa$', '//  // aabaa$', '//  // abaa$', '//  // baa', '//', '//  ', '//  int p = 0;', '//  int[] flag = new int[n];', '//  Arrays.fill(flag, 1);', '//  int[] ft = buildFenwick(flag);', '//  for(int i = 0;i < n;i++){', '//   int j;', '//   int last = ap[i][1];', '//   for(j = ap[i][1];j >= 0 && j < n && flag[j] == 1 && a[j] >= ap[i][0];j = after(ft, j)){ // on index', '////    tr(""un"", j);', '//    last = j;', '//    flag[j] = 0;', '//    addFenwick(ft, j, -1);', '//   }', '////   tr(restoreFenwick(ft));', '////   tr(flag);', '////   tr(j,i);', '//   if(j == ap[i][1])continue; // already processed', '//   branches[p++] = new int[]{before(ft, ap[i][1]), last, ap[i][0], -1};', '////   branches[p++] = new int[]{ap[i][1]-1, last, ap[i][0]};', '//  }', '//  return Arrays.copyOf(branches, p);', '// }', ' ', ' static int[][] findBranches(int[] a)', ' {', '  int n = a.length;', '  long[] ap = new long[n];', '  for(int i = 0;i < n;i++)ap[i] = (long)(1000000-a[i])<<32|i;', '  Arrays.sort(ap);', '  int[][] branches = new int[n][];', '  ', '  // aabaa', '  // a$', '  // aa$', '  // aabaa$', '  // abaa$', '  // baa', '', '  int p = 0;', '  int[] flag = new int[n];', '  Arrays.fill(flag, 1);', '  int[] ft = buildFenwick(flag);', '  for(int i = 0;i < n;i++){', '   int j;', '   int last = (int)ap[i];', '   int va = 1000000-(int)(ap[i]>>>32);', '   for(j = (int)ap[i];j >= 0 && j < n && flag[j] == 1 && a[j] >= va;j = after(ft, j)){ // on index', '    last = j;', '    flag[j] = 0;', '    addFenwick(ft, j, -1);', '   }', '//   tr(restoreFenwick(ft));', '//   tr(flag);', '//   tr(j,i);', '   if(j == (int)ap[i])continue;', '//   if(j == ap[i][1])continue; // already processed', '   branches[p++] = new int[]{before(ft, (int)ap[i]), last, va, -1};', '//   branches[p++] = new int[]{before(ft, ap[i][1]), last, ap[i][0], -1};', '  }', '  return Arrays.copyOf(branches, p);', ' }', ' ', ' public static int sumFenwick(int[] ft, int i)', ' {', '  int sum = 0;', '  for(i++;i > 0;i -= i&-i)sum += ft[i];', '  return sum;', ' }', ' ', ' public static void addFenwick(int[] ft, int i, int v)', ' {', '  if(v == 0)return;', '  int n = ft.length;', '  for(i++;i < n;i += i&-i)ft[i] += v;', ' }', ' ', ' public static int findGFenwick(int[] ft, int v)', ' {', '  int i = 0;', '  int n = ft.length;', '  for(int b = Integer.highestOneBit(n);b != 0 && i < n;b >>= 1){', '   if(i + b < n){', '    int t = i + b;', '    if(v >= ft[t]){', '     i = t;', '     v -= ft[t];', '    }', '   }', '  }', '  return v != 0 ? -(i+1) : i-1;', ' }', ' ', ' public static int valFenwick(int[] ft, int i)', ' {', '  return sumFenwick(ft, i) - sumFenwick(ft, i-1);', ' }', ' ', ' public static int[] restoreFenwick(int[] ft)', ' {', '  int n = ft.length-1;', '  int[] ret = new int[n];', '  for(int i = 0;i < n;i++)ret[i] = sumFenwick(ft, i);', '  for(int i = n-1;i >= 1;i--)ret[i] -= ret[i-1];', '  return ret;', ' }', ' ', ' public static int before(int[] ft, int x)', ' {', '  int u = sumFenwick(ft, x-1);', '  if(u == 0)return -1;', '  return findGFenwick(ft, u-1)+1;', ' }', ' ', ' public static int after(int[] ft, int x)', ' {', '  int u = sumFenwick(ft, x);', '  int f = findGFenwick(ft, u);', '  if(f+1 >= ft.length-1)return -1;', '  return f+1;', ' }', ' ', ' public static int[] buildFenwick(int[] a)', ' {', '  int n = a.length;', '  int[] ft = new int[n+1];', '  System.arraycopy(a, 0, ft, 1, n);', '  for(int k = 2, h = 1;k <= n;k*=2, h*=2){', '   for(int i = k;i <= n;i+=k){', '    ft[i] += ft[i-h];', '   }', '  }', '  return ft;', ' }', ' ', ' ', ' public static int[] buildLCP(char[] str, int[] sa)', ' {', '  int n = str.length;', '  int h = 0;', '  int[] lcp = new int[n];', '  int[] b = new int[n];', '  for(int i = 0;i < n;i++)b[sa[i]] = i;', '  for(int i = 0;i < n;i++){', '   if(b[i] > 0){', '    for(int j = sa[b[i]-1]; j+h<n && i+h<n && str[j+h] == str[i+h]; h++);', '    lcp[b[i]] = h;', '   }else{', '    lcp[b[i]] = 0;', '   }', '   if(h > 0)h--;', '  }', '  return lcp;', ' } ', ' ', ' private static interface BaseArray {', '  public int get(int i);', '', '  public void set(int i, int val);', '', '  public int update(int i, int val);', ' }', '', ' private static class CharArray implements BaseArray {', '  private char[] m_A = null;', '  private int m_pos = 0;', '', '  CharArray(char[] A, int pos) {', '   m_A = A;', '   m_pos = pos;', '  }', '', '  public int get(int i) {', '   return m_A[m_pos + i] & 0xffff;', '  }', '', '  public void set(int i, int val) {', '   m_A[m_pos + i] = (char) (val & 0xffff);', '  }', '', '  public int update(int i, int val) {', '   return m_A[m_pos + i] += val & 0xffff;', '  }', ' }', '', ' private static class IntArray implements BaseArray {', '  private int[] m_A = null;', '  private int m_pos = 0;', '', '  IntArray(int[] A, int pos) {', '   m_A = A;', '   m_pos = pos;', '  }', '', '  public int get(int i) {', '   return m_A[m_pos + i];', '  }', '', '  public void set(int i, int val) {', '   m_A[m_pos + i] = val;', '  }', '', '  public int update(int i, int val) {', '   return m_A[m_pos + i] += val;', '  }', ' }', '', ' /* find the start or end of each bucket */', ' private static void getCounts(BaseArray T, BaseArray C, int n, int k) {', '  int i;', '  for(i = 0;i < k;++i){', '   C.set(i, 0);', '  }', '  for(i = 0;i < n;++i){', '   C.update(T.get(i), 1);', '  }', ' }', '', ' private static void getBuckets(BaseArray C, BaseArray B, int k, boolean end) {', '  int i, sum = 0;', '  if(end != false){', '   for(i = 0;i < k;++i){', '    sum += C.get(i);', '    B.set(i, sum);', '   }', '  }else{', '   for(i = 0;i < k;++i){', '    sum += C.get(i);', '    B.set(i, sum - C.get(i));', '   }', '  }', ' }', '', ' /* sort all type LMS suffixes */', ' private static void LMSsort(BaseArray T, int[] SA, BaseArray C,', '   BaseArray B, int n, int k) {', '  int b, i, j;', '  int c0, c1;', '  /* compute SAl */', '  if(C == B){', '   getCounts(T, C, n, k);', '  }', '  getBuckets(C, B, k, false); /* find starts of buckets */', '  j = n - 1;', '  b = B.get(c1 = T.get(j));', '  --j;', '  SA[b++] = (T.get(j) < c1) ? ~j : j;', '  for(i = 0;i < n;++i){', '   if(0 < (j = SA[i])){', '    if((c0 = T.get(j)) != c1){', '     B.set(c1, b);', '     b = B.get(c1 = c0);', '    }', '    --j;', '    SA[b++] = (T.get(j) < c1) ? ~j : j;', '    SA[i] = 0;', '   }else if(j < 0){', '    SA[i] = ~j;', '   }', '  }', '  /* compute SAs */', '  if(C == B){', '   getCounts(T, C, n, k);', '  }', '  getBuckets(C, B, k, true); /* find ends of buckets */', '  for(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){', '   if(0 < (j = SA[i])){', '    if((c0 = T.get(j)) != c1){', '     B.set(c1, b);', '     b = B.get(c1 = c0);', '    }', '    --j;', '    SA[--b] = (T.get(j) > c1) ? ~(j + 1) : j;', '    SA[i] = 0;', '   }', '  }', ' }', '', ' private static int LMSpostproc(BaseArray T, int[] SA, int n, int m) {', '  int i, j, p, q, plen, qlen, name;', '  int c0, c1;', '  boolean diff;', '', '  /*', '   * compact all the sorted substrings into the first m items of SA 2*m', '   * must be not larger than n (proveable)', '   */', '  for(i = 0;(p = SA[i]) < 0;++i){', '   SA[i] = ~p;', '  }', '  if(i < m){', '   for(j = i, ++i;;++i){', '    if((p = SA[i]) < 0){', '     SA[j++] = ~p;', '     SA[i] = 0;', '     if(j == m){', '      break;', '     }', '    }', '   }', '  }', '', '  /* store the length of all substrings */', '  i = n - 1;', '  j = n - 1;', '  c0 = T.get(n - 1);', '  do{', '   c1 = c0;', '  }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '  for(;0 <= i;){', '   do{', '    c1 = c0;', '   }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));', '   if(0 <= i){', '    SA[m + ((i + 1) >> 1)] = j - i;', '    j = i + 1;', '    do{', '     c1 = c0;', '    }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '   }', '  }', '', '  /* find the lexicographic names of all substrings */', '  for(i = 0, name = 0, q = n, qlen = 0;i < m;++i){', '   p = SA[i];', '   plen = SA[m + (p >> 1)];', '   diff = true;', '   if((plen == qlen) && ((q + plen) < n)){', '    for(j = 0;(j < plen) && (T.get(p + j) == T.get(q + j));++j){', '    }', '    if(j == plen){', '     diff = false;', '    }', '   }', '   if(diff != false){', '    ++name;', '    q = p;', '    qlen = plen;', '   }', '   SA[m + (p >> 1)] = name;', '  }', '', '  return name;', ' }', '', ' /* compute SA and BWT */', ' private static void induceSA(BaseArray T, int[] SA, BaseArray C,', '   BaseArray B, int n, int k) {', '  int b, i, j;', '  int c0, c1;', '  /* compute SAl */', '  if(C == B){', '   getCounts(T, C, n, k);', '  }', '  getBuckets(C, B, k, false); /* find starts of buckets */', '  j = n - 1;', '  b = B.get(c1 = T.get(j));', '  SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;', '  for(i = 0;i < n;++i){', '   j = SA[i];', '   SA[i] = ~j;', '   if(0 < j){', '    if((c0 = T.get(--j)) != c1){', '     B.set(c1, b);', '     b = B.get(c1 = c0);', '    }', '    SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;', '   }', '  }', '  /* compute SAs */', '  if(C == B){', '   getCounts(T, C, n, k);', '  }', '  getBuckets(C, B, k, true); /* find ends of buckets */', '  for(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){', '   if(0 < (j = SA[i])){', '    if((c0 = T.get(--j)) != c1){', '     B.set(c1, b);', '     b = B.get(c1 = c0);', '    }', '    SA[--b] = ((j == 0) || (T.get(j - 1) > c1)) ? ~j : j;', '   }else{', '    SA[i] = ~j;', '   }', '  }', ' }', '', ' /*', '  * find the suffix array SA of T[0..n-1] in {0..k-1}^n use a working space', '  * (excluding T and SA) of at most 2n+O(1) for a constant alphabet', '  */', ' private static void SA_IS(BaseArray T, int[] SA, int fs, int n, int k) {', '  BaseArray C, B, RA;', '  int i, j, b, m, p, q, name, newfs;', '  int c0, c1;', '  int flags = 0;', '', '  if(k <= 256){', '   C = new IntArray(new int[k], 0);', '   if(k <= fs){', '    B = new IntArray(SA, n + fs - k);', '    flags = 1;', '   }else{', '    B = new IntArray(new int[k], 0);', '    flags = 3;', '   }', '  }else if(k <= fs){', '   C = new IntArray(SA, n + fs - k);', '   if(k <= (fs - k)){', '    B = new IntArray(SA, n + fs - k * 2);', '    flags = 0;', '   }else if(k <= 1024){', '    B = new IntArray(new int[k], 0);', '    flags = 2;', '   }else{', '    B = C;', '    flags = 8;', '   }', '  }else{', '   C = B = new IntArray(new int[k], 0);', '   flags = 4 | 8;', '  }', '', '  /*', '   * stage 1: reduce the problem by at least 1/2 sort all the', '   * LMS-substrings', '   */', '  getCounts(T, C, n, k);', '  getBuckets(C, B, k, true); /* find ends of buckets */', '  for(i = 0;i < n;++i){', '   SA[i] = 0;', '  }', '  b = -1;', '  i = n - 1;', '  j = n;', '  m = 0;', '  c0 = T.get(n - 1);', '  do{', '   c1 = c0;', '  }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '  for(;0 <= i;){', '   do{', '    c1 = c0;', '   }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));', '   if(0 <= i){', '    if(0 <= b){', '     SA[b] = j;', '    }', '    b = B.update(c1, -1);', '    j = i;', '    ++m;', '    do{', '     c1 = c0;', '    }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '   }', '  }', '  if(1 < m){', '   LMSsort(T, SA, C, B, n, k);', '   name = LMSpostproc(T, SA, n, m);', '  }else if(m == 1){', '   SA[b] = j + 1;', '   name = 1;', '  }else{', '   name = 0;', '  }', '', '  /*', '   * stage 2: solve the reduced problem recurse if names are not yet', '   * unique', '   */', '  if(name < m){', '   if((flags & 4) != 0){', '    C = null;', '    B = null;', '   }', '   if((flags & 2) != 0){', '    B = null;', '   }', '   newfs = (n + fs) - (m * 2);', '   if((flags & (1 | 4 | 8)) == 0){', '    if((k + name) <= newfs){', '     newfs -= k;', '    }else{', '     flags |= 8;', '    }', '   }', '   for(i = m + (n >> 1) - 1, j = m * 2 + newfs - 1;m <= i;--i){', '    if(SA[i] != 0){', '     SA[j--] = SA[i] - 1;', '    }', '   }', '   RA = new IntArray(SA, m + newfs);', '   SA_IS(RA, SA, newfs, m, name);', '   RA = null;', '', '   i = n - 1;', '   j = m * 2 - 1;', '   c0 = T.get(n - 1);', '   do{', '    c1 = c0;', '   }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '   for(;0 <= i;){', '    do{', '     c1 = c0;', '    }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));', '    if(0 <= i){', '     SA[j--] = i + 1;', '     do{', '      c1 = c0;', '     }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));', '    }', '   }', '', '   for(i = 0;i < m;++i){', '    SA[i] = SA[m + SA[i]];', '   }', '   if((flags & 4) != 0){', '    C = B = new IntArray(new int[k], 0);', '   }', '   if((flags & 2) != 0){', '    B = new IntArray(new int[k], 0);', '   }', '  }', '', '  /* stage 3: induce the result for the original problem */', '  if((flags & 8) != 0){', '   getCounts(T, C, n, k);', '  }', '  /* put all left-most S characters into their buckets */', '  if(1 < m){', '   getBuckets(C, B, k, true); /* find ends of buckets */', '   i = m - 1;', '   j = n;', '   p = SA[m - 1];', '   c1 = T.get(p);', '   do{', '    q = B.get(c0 = c1);', '    while (q < j){', '     SA[--j] = 0;', '    }', '    do{', '     SA[--j] = p;', '     if(--i < 0){', '      break;', '     }', '     p = SA[i];', '    }while ((c1 = T.get(p)) == c0);', '   }while (0 <= i);', '   while (0 < j){', '    SA[--j] = 0;', '   }', '  }', '  induceSA(T, SA, C, B, n, k);', '  C = null;', '  B = null;', ' }', '', ' /* char */', ' public static int[] suffixsort(char[] T) {', '  if(T == null)return null;', '  int n = T.length;', '  int[] SA = new int[n];', '  if(n <= 1){', '   if(n == 1){', '    SA[0] = 0;', '   }', '   return SA;', '  }', '  SA_IS(new CharArray(T, 0), SA, 0, n, 65536);', '  return SA;', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '  static final int maxn = 300000;', '  static final long limit = 1000000000000000000l;', '', '  static boolean[] was = new boolean[30];', '  static long[] srt;', '', '  static class Sfa {', '', '    long[] dp;', '    long[] grundySum;', '    long[] ways;', '', '    int[][] next;', '    int[] len;', '    int[] lnk;', '    int[] grundy;', '', '    int nodes, last;', '', '    Sfa(int n) {', '      dp = new long[maxn * 2 + 3];', '      grundySum = new long[30];', '      ways = new long[maxn * 2 + 3];', '', '      next = new int[26][maxn * 2 + 3];', '      len = new int[maxn * 2 + 3];', '      lnk = new int[maxn * 2 + 3];', '      grundy = new int[maxn * 2 + 3];', '', '      nodes = last = 1;', '      len[1] = lnk[1] = 0;', '    }', '', '    void push(int c) {', '      int cur = ++nodes, p;', '      len[cur] = len[last] + 1;', '      for (p = last; (p > 0) && (next[c][p] == 0); p = lnk[p]) {', '        next[c][p] = cur;', '      }', '      if (p == 0) {', '        lnk[cur] = 1;', '      } else {', '        int q = next[c][p];', '        if (len[p] + 1 == len[q]) {', '          lnk[cur] = q;', '        } else {', '          int clone = ++nodes;', '          len[clone] = len[p] + 1;', '          for (int j = 0; j < 26; j++) {', '            next[j][clone] = next[j][q];', '          }', '          lnk[clone] = lnk[q];', '          for (; (p > 0) && next[c][p] == q; p = lnk[p]) {', '            next[c][p] = clone;', '          }', '          lnk[q] = lnk[cur] = clone;', '        }', '      }', '      last = cur;', '    }', '', '    void grundyPrecalc() {', '      for (int i = 1; i <= nodes; i++) {', '        srt[i] = ((long)len[i]  << 32l) | i;', '      }', '      Arrays.sort(srt, 1, nodes + 1);', '      for (int i = 1; i <= nodes; i++) {', '        int k = (int)(srt[nodes - i + 1] & 0xffffffffL);', '        dp[k] = 1;', '        Arrays.fill(was, false);', '        for (int j = 0; j < 26; j++) {', '          if (next[j][k] > 0) {', '            was[grundy[next[j][k]]] = true;', '          }', '        }', '        for (int j = 0; j < 30; j++) {', '          if (!was[j]) {', '            grundy[k] = j;', '            break;', '          }', '        }', '      }', '    }', '', '    void substrPrecalc() {', '      for (int i = 1; i <= nodes; i++) {', '        srt[i] = ((long)len[i]  << 32l) | i;', '      }', '      Arrays.sort(srt, 1, nodes + 1);', '      for (int i = 1; i <= nodes; i++) {', '        int k = (int)(srt[nodes - i + 1] & 0xffffffffL);', '        dp[k] = 1;', '        for (int j = 0; j < 26; j++) {', '          if (next[j][k] > 0) {', '            dp[k] += dp[next[j][k]];', '          }', '        }', '      }', '      ways[1] = 1;', '      for (int i = 1; i <= nodes; i++) {', '        int k = (int)(srt[i] & 0xffffffffL);', '        for (int j = 0; j < 26; j++) {', '          if (next[j][k] > 0) {', '            ways[next[j][k]] += ways[k];', '          }', '        }', '      }', '      for (int i = 1; i <= nodes; i++) {', '        grundySum[grundy[i]] += ways[i];', '      }', '    }', '', '    void dpRecalc(int badValue) {', '      for (int i = 1; i <= nodes; i++) {', '        srt[i] = ((long)len[i]  << 32l) | i;', '      }', '      Arrays.sort(srt, 1, nodes + 1);', '      for (int i = 1; i <= nodes; i++) {', '        int k = (int)(srt[nodes - i + 1] & 0xffffffffL);', '        dp[k] = grundy[k] != badValue ? 1 : 0;', '        for (int j = 0; j < 26; j++) {', '          if (next[j][k] > 0) {', '            dp[k] += dp[next[j][k]];', '          }', '        }', '      }', '    }', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int n = Integer.parseInt(st.nextToken());', '    int m = Integer.parseInt(st.nextToken());', '    long k = Long.parseLong(st.nextToken());', '', '    srt = new long[maxn * 2 + 3];', '', '    Sfa sfa1 = new Sfa(n);', '', '    char[] a = br.readLine().toCharArray();', '    for (int i = 0; i < n; i++) {', ""      sfa1.push(a[i] - 'a');"", '    }', '', '    Sfa sfa2 = new Sfa(n);', '', '    char[] b = br.readLine().toCharArray();', '    for (int i = 0; i < m; i++) {', ""      sfa2.push(b[i] - 'a');"", '    }', '', '    sfa1.grundyPrecalc();', '    for (int i = 1; i <= (sfa2.nodes > 29 ? 29 : sfa2.nodes); i++) {', '      was[i] = false;', '    }', '', '    sfa2.grundyPrecalc();', '    sfa2.substrPrecalc();', '', '    for (int i = 1; i <= sfa1.nodes; i++) {', '      srt[i] = ((long)sfa1.len[i]  << 32l) | i;', '    }', '    Arrays.sort(srt, 1, sfa1.nodes + 1);', '    for (int i = 1; i <= sfa1.nodes; i++) {', '      int kk = (int)(srt[sfa1.nodes - i + 1] & 0xffffffffL);', '      sfa1.dp[kk] = sfa2.dp[1] - sfa2.grundySum[sfa1.grundy[kk]];', '      for (int j = 0; j < 26; j++) {', '        if (sfa1.next[j][kk] > 0) {', '          sfa1.dp[kk] += sfa1.dp[sfa1.next[j][kk]];', '          if (sfa1.dp[kk] > limit) {', '            sfa1.dp[kk] = limit;', '          }', '        }', '      }', '    }', '', '    if (k > sfa1.dp[1]) {', '      bw.write(""no solution"");', '      bw.newLine();', '', '      bw.close();', '      br.close();', '      return;', '    }', '    int cur = 1;', '    while (k > 0) {', '      if (k <= sfa2.dp[1] - sfa2.grundySum[sfa1.grundy[cur]]) {', '        break;', '      } else {', '        k -= sfa2.dp[1] - sfa2.grundySum[sfa1.grundy[cur]];', '      }', '      for (int j = 0; j < 26; j++)', '        if (k > sfa1.dp[sfa1.next[j][cur]])', '          k -= sfa1.dp[sfa1.next[j][cur]];', '        else {', ""          bw.write('a' + j);"", '          cur = sfa1.next[j][cur];', '          break;', '        }', '    }', '    bw.newLine();', '', '    int badValue = sfa1.grundy[cur];', '    sfa2.dpRecalc(badValue);', '    cur = 1;', '    while (k > 0) {', '      if (sfa2.grundy[cur] != badValue) {', '        --k;', '        if (k == 0) {', '          break;', '        }', '      }', '      for (int j = 0; j < 26; j++) {', '        if (k > sfa2.dp[sfa2.next[j][cur]]) {', '          k -= sfa2.dp[sfa2.next[j][cur]];', '        } else {', ""          bw.write('a' + j);"", '          cur = sfa2.next[j][cur];', '          break;', '        }', '      }', '    }', '', '    bw.newLine();', '', '    bw.close();', '    br.close();', '  }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */', '        Scanner in = new Scanner(System.in);', '        if(in.hasNext()){', '            final char[] str = in.next().toCharArray();', '            if(str.length>0 && in.hasNext()){', '                int k = in.nextInt();', '                if(k>0 && k<=str.length){', '                    System.out.println((new FoundSubStrings(str, k)).count());', '                }', '            }', '        }', '    }', '    ', '    static class FoundSubStrings {', '        ', '        private final char[] str;', '        private final int k;', '        private Map<Long, SubString> curr;', '        private Map<Long, SubString> next;', '        private SubString previousSub=null;', '        private int previousSubParentStartIndex = -1;', '        private int previousSubLen = -1;', '', '        public FoundSubStrings(char[] str, int k) {', '            this.str = str;', '            this.k = k;', '            curr = new HashMap<>(str.length>32 ? str.length>>1 : str.length);', '            next = new HashMap<>(str.length>32 ? str.length>>1 : str.length);', '        }', '        ', '        public long count(){', '            long countResult = 0;', '            int startIndex;', '            char lastChar = str[0];', '            int lastCharCount = 0;', '            for(int i=0; i<=str.length; i++){', '                if(i==str.length || lastChar!=str[i]){', '                    if(lastCharCount>1){', '                        for(int j=i-lastCharCount; j<i-1; j++){', '                            this.add(j, lastChar, i-j);', '                        }', '                    }', '                    this.add(i-1, lastChar);', '                    if(i!=str.length){', '                        lastChar = str[i];', '                        lastCharCount = 1;', '                    }', '                } else {', '                    lastCharCount++;', '                }', '            }', '            //', '            this.switchLists();', '            //', '            while(!curr.isEmpty()){', '                for(SubString subStr : curr.values()){', '                    if(subStr.islands==k){', '                        countResult++;', '                        if(k==1 && subStr.size==1){', '                            countResult+=str.length-subStr.startIndex-subStr.len;', '                            continue;', '                        }', '                    } else if(subStr.size<k){', '                        continue;', '                    }', '                    for(int i=0; i<subStr.size && ((startIndex=subStr.indexes[i])<(str.length-subStr.len)); i++){', '                        this.add(subStr.startIndex, startIndex, str[startIndex+subStr.len], subStr.len+1, subStr.size);', '                    }', '                }', '                this.switchLists();', '            }', '            return countResult;', '        }', '        ', '        private void add(int parentStartIndex, int startIndex, char chr, int len, int childsLength){', '            if(previousSubParentStartIndex!=parentStartIndex || previousSubLen!=len || previousSub.chr!=chr){', '                long key = getKey(parentStartIndex, len, chr);', '                previousSub = next.get(key);', '                if(previousSub==null){', '                    previousSub = new SubString(parentStartIndex, startIndex, chr, len, childsLength);', '                    next.put(key, previousSub);', '                }', '                previousSubParentStartIndex = previousSub.parentStartIndex;', '                previousSubLen = len;', '            }', '            previousSub.addIndex(startIndex);', '        }', '        ', '        private void add(int startIndex, char chr, int len){', '            long key = getKey(len, chr);', '            SubString sub = next.get(key);', '            if(sub==null){', '                sub = new SubString(startIndex, chr, len);', '                next.put(key, sub);', '            }', '            sub.addIndex(startIndex);', '        }', '        ', '        private void add(int startIndex, char chr){', '            if(previousSub==null || previousSubLen!=1 || previousSub.chr!=chr){', '               long key = getKey(chr);', '               previousSub = next.get(key);', '                if(previousSub==null){', '                    previousSub = new SubString(startIndex, chr, 1);', '                    next.put(key, previousSub);', '                }', '                previousSubLen = 1;', '            }', '            previousSub.addIndex(startIndex);', '        }', '        ', '        private void switchLists(){', '            previousSubParentStartIndex = -1;', '            previousSub = null;', '            Map<Long, SubString> tmp = curr;', '            curr = next;', '            next = tmp;', '            tmp.clear();', '        }', '        ', '        ', '        public static long getKey(int parentStartIndex, int length, char chr){', '            return (((long)parentStartIndex) | ((long)length<<31) | ((long)chr)<<23);', '        }', '        ', '        public static long getKey(int length, char chr){', '            return (((long)length<<31) | (((long)chr)<<23));', '        }', '        ', '        public static long getKey(char chr){', '            return (((long)chr)<<23);', '        }', '        ', '        class SubString implements Comparable<SubString> {', '', '            private final int parentStartIndex;', '            private final int len;', '            private final char chr;', '            private int startIndex;', '            private int islands = 0;', '            //', '            private int[] indexes;', '            private int size = 0;', '', '            public SubString(int startIndex, char chr, int length) {', '                this(-1, startIndex, chr, length, 16);', '            }', '            ', '            public SubString(int startIndex, char chr, int length, int childsLength) {', '                this(-1, startIndex, chr, length, childsLength);', '            }', '', '            public SubString(int parentStartIndex, int startIndex, char chr, int length, int childsLength) {', '                this.parentStartIndex = parentStartIndex;', '                this.startIndex = startIndex;', '                this.len = length;', '                this.chr = chr;', '                this.indexes = new int[childsLength>16? 16: childsLength+1];', '            }', '', '            public void addIndex(int index){', '                if(size==0 || (indexes[size-1]+len<index)){', '                    islands++;', '                }', '                if(indexes.length==size+1){', '                    int[] tmpArr = new int[indexes.length<<1];', '                    System.arraycopy(indexes, 0, tmpArr, 0, indexes.length);', '                    indexes = tmpArr;', '                }', '                indexes[size++] = index;', '            }', '', '            @Override', '            public int compareTo(SubString o) {', '                return (this.parentStartIndex==o.parentStartIndex) ? chr - o.chr :', '                    this.parentStartIndex - o.parentStartIndex;', '            }', '', '            @Override', '            public String toString() {', '                StringBuilder sb = new StringBuilder(100);', '                sb.append(""SubString{startIndex="").append(startIndex).append("", length="")', '                        .append(len).append("", islands="")', '                        .append(islands).append("", numberOfIndexes="")', '                        .append(size).append("", arr="");', '                for(int i=startIndex; i<startIndex+len; i++){', ""                    sb.append(str[i]).append(',');"", '                }', ""                sb.setCharAt(sb.length()-1,'}');"", '                return sb.toString();', '            }', '        }', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', '', 'public class Solution {', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        if(in.hasNext()){', '            final char[] str = in.next().toCharArray();', '            if(str.length>0 && in.hasNext()){', '                int k = in.nextInt();', '                if(k>0 && k<=str.length){', '                    System.out.println((new FoundSubStrings(str, k)).count());', '                }', '            }', '        }', '    }', '    ', '    static class FoundSubStrings {', '        ', '        private final char[] str;', '        private final int k;', '        private Map<Long, SubString> curr;', '        private Map<Long, SubString> next;', '        private SubString previousSub=null;', '        private int previousSubParentStartIndex = -1;', '        private int previousSubLen = -1;', '', '        public FoundSubStrings(char[] str, int k) {', '            this.str = str;', '            this.k = k;', '            curr = new HashMap<>(str.length>32 ? str.length>>1 : str.length);', '            next = new HashMap<>(str.length>32 ? str.length>>1 : str.length);', '        }', '        ', '        public long count(){', '            long countResult = 0;', '            int startIndex;', '            char lastChar = str[0];', '            int lastCharCount = 0;', '            for(int i=0; i<=str.length; i++){', '                if(i==str.length || lastChar!=str[i]){', '                    if(lastCharCount>1){', '                        for(int j=i-lastCharCount; j<i-1; j++){', '                            this.add(j, lastChar, i-j);', '                        }', '                    }', '                    this.add(i-1, lastChar);', '                    if(i!=str.length){', '                        lastChar = str[i];', '                        lastCharCount = 1;', '                    }', '                } else {', '                    lastCharCount++;', '                }', '            }', '', '            this.switchLists();', '', '            while(!curr.isEmpty()){', '                for(SubString subStr : curr.values()){', '                    if(subStr.islands==k){', '                        countResult++;', '                        if(k==1 && subStr.size==1){', '                            countResult+=str.length-subStr.startIndex-subStr.len;', '                            continue;', '                        }', '                    } else if(subStr.size<k){', '                        continue;', '                    }', '                    for(int i=0; i<subStr.size && ((startIndex=subStr.indexes[i])<(str.length-subStr.len)); i++){', '                        this.add(subStr.startIndex, startIndex, str[startIndex+subStr.len], subStr.len+1, subStr.size);', '                    }', '                }', '                this.switchLists();', '            }', '            return countResult;', '        }', '        ', '        private void add(int parentStartIndex, int startIndex, char chr, int len, int childsLength){', '            if(previousSubParentStartIndex!=parentStartIndex || previousSubLen!=len || previousSub.chr!=chr){', '                long key = getKey(parentStartIndex, len, chr);', '                previousSub = next.get(key);', '                if(previousSub==null){', '                    previousSub = new SubString(parentStartIndex, startIndex, chr, len, childsLength);', '                    next.put(key, previousSub);', '                }', '                previousSubParentStartIndex = previousSub.parentStartIndex;', '                previousSubLen = len;', '            }', '            previousSub.addIndex(startIndex);', '        }', '        ', '        private void add(int startIndex, char chr, int len){', '            long key = getKey(len, chr);', '            SubString sub = next.get(key);', '            if(sub==null){', '                sub = new SubString(startIndex, chr, len);', '                next.put(key, sub);', '            }', '            sub.addIndex(startIndex);', '             }', '        ', '        private void add(int startIndex, char chr){', '            if(previousSub==null || previousSubLen!=1 || previousSub.chr!=chr){', '               long key = getKey(chr);', '               previousSub = next.get(key);', '                if(previousSub==null){', '                    previousSub = new SubString(startIndex, chr, 1);', '                    next.put(key, previousSub);', '                }', '                previousSubLen = 1;', '            }', '            previousSub.addIndex(startIndex);', '        }', '        ', '        private void switchLists(){', '            previousSubParentStartIndex = -1;', '            previousSub = null;', '            Map<Long, SubString> tmp = curr;', '            curr = next;', '            next = tmp;', '            tmp.clear();', '        }', '        ', '        ', '        public static long getKey(int parentStartIndex, int length, char chr){', '            return (((long)parentStartIndex) | ((long)length<<31) | ((long)chr)<<23);', '        }', '        ', '        public static long getKey(int length, char chr){', '            return (((long)length<<31) | (((long)chr)<<23));', '        }', '        public static long getKey(char chr){', '            return (((long)chr)<<23);', '        }', '        ', '        class SubString implements Comparable<SubString> {', '', '            private final int parentStartIndex;', '            private final int len;', '            private final char chr;', '            private int startIndex;', '            private int islands = 0;', '            private int[] indexes;', '            private int size = 0;', '', '            public SubString(int startIndex, char chr, int length) {', '                this(-1, startIndex, chr, length, 16);', '            }', '            ', '            public SubString(int startIndex, char chr, int length, int childsLength) {', '                this(-1, startIndex, chr, length, childsLength);', '            }', '', '            public SubString(int parentStartIndex, int startIndex, char chr, int length, int childsLength) {', '                this.parentStartIndex = parentStartIndex;', '                this.startIndex = startIndex;', '                this.len = length;', '                this.chr = chr;', '                this.indexes = new int[childsLength>16? 16: childsLength+1];', '            }', '', '            public void addIndex(int index){', '                if(size==0 || (indexes[size-1]+len<index)){', '                    islands++;', '                }', '                if(indexes.length==size+1){', '                    int[] tmpArr = new int[indexes.length<<1];', '                    System.arraycopy(indexes, 0, tmpArr, 0, indexes.length);', '                    indexes = tmpArr;', '                }', '                indexes[size++] = index;', '            }', '', '            @Override', '            public int compareTo(SubString o) {', '                return (this.parentStartIndex==o.parentStartIndex) ? chr - o.chr :', '                    this.parentStartIndex - o.parentStartIndex;', '            }', '', '            @Override', '            public String toString() {', '                StringBuilder sb = new StringBuilder(100);', '                sb.append(""SubString{startIndex="").append(startIndex).append("", length="")', '                        .append(len).append("", islands="")', '                        .append(islands).append("", numberOfIndexes="")', '                        .append(size).append("", arr="");', '                for(int i=startIndex; i<startIndex+len; i++){', ""                    sb.append(str[i]).append(',');"", '                }', ""                sb.setCharAt(sb.length()-1,'}');"", '                return sb.toString();', '            }', '        }', '    }', '}']"
"['/* HackerRank Template v0.21 by Sergey Esipenko', ' * ', ' * v0.21', ' *   - fixed RuntimeError', ' *  */', '', 'import java.io.*;', 'import java.math.*;', 'import java.util.*;', '', 'import static java.lang.Math.*;', 'import static java.util.Arrays.binarySearch;', 'import static java.util.Arrays.fill;', 'import static java.util.Arrays.sort;', '', 'public class Solution implements Runnable {', ' ', ' /* START OF SOLUTION */', '', ' static final Random RND = new Random(7777L);', ' static final int MAX_LENGTH = 100000;', ' static final int ALPHA_SIZE = 26;', ' static final int HASH_BASE = BigInteger.probablePrime(17, RND).intValue();', ' static final int[] HASH_BASE_POWS = new int [MAX_LENGTH * 2];', ' ', ' static {', '  HASH_BASE_POWS[0] = 1;', '  for (int i = 1; i < HASH_BASE_POWS.length; i++) {', '   HASH_BASE_POWS[i] = HASH_BASE_POWS[i - 1] * HASH_BASE;', '  }', ' }', ' ', ' char[] s;', ' int length;', ' int[][] charMaps;', ' int[][] charPerms;', ' int[][] distributedHashes;', ' int[] hashPrefixes;', ' ', ' final Map<Long, Integer> lcpCache = new HashMap<Long, Integer>();', ' ', ' void solve() throws IOException  {', '', '  s = new StringBuilder(in.readLine()).reverse().toString().toCharArray();', '  length = s.length;', '  charMaps = getCharMaps(s);', '  charPerms = getCharPermutations(charMaps);', '  distributedHashes = getDistributedHashes(s);', '  hashPrefixes = precalcHashPrefixes(charPerms, distributedHashes);', '  ', '  final Integer[] suffixArray = getSuffixArray();', '  final int[] suffixIndex = new int [length];', '  for (int i = 0; i < length; i++) {', '   suffixIndex[suffixArray[i]] = i;', '  }', '  final NavigableSet<Integer> viewedSuffixes = new TreeSet<Integer>(new Comparator<Integer>() {', '   @Override', '   public int compare(Integer pos1, Integer pos2) {', '    return suffixIndex[pos1] - suffixIndex[pos2];', '   }', '  });', '  ', '  final long[] counts = new long [length + 1];', '  for (int pos = length - 1; pos >= 0; pos--) {', '   long intersectionSize = 0L;', '   /* check lower suffix */ {', '    final Integer neigbourPos = viewedSuffixes.lower(pos);', '    if (neigbourPos != null) {', '     intersectionSize = max(intersectionSize, lcp(pos, neigbourPos));', '    }', '   }', '   /* check higher suffix */ {', '    final Integer neigbourPos = viewedSuffixes.higher(pos);', '    if (neigbourPos != null) {', '     intersectionSize = max(intersectionSize, lcp(pos, neigbourPos));', '    }', '   }', '   counts[pos] = counts[pos + 1] + length - pos - intersectionSize;', '   viewedSuffixes.add(pos);', '  }', '  ', '  for (int i = 0; i < length; i++) {', '   out.println(counts[length - 1 - i]);', '  }', ' }', '', ' Integer[] getSuffixArray() {', '  final Integer[] suffixArray = new Integer [length];', '  for (int i = 0; i < length; i++) {', '   suffixArray[i] = i;', '  }', '  sort(suffixArray, new Comparator<Integer>() {', '   @Override', '   public int compare(Integer pos1, Integer pos2) {', '    if (pos1.equals(pos2)) return 0;', '    final int lcp = lcp(pos1, pos2);', '    if (lcp == length - pos1) return -1;', '    if (lcp == length - pos2) return +1;', ""    return charMaps[pos1][s[pos1 + lcp] - 'a'] - charMaps[pos2][s[pos2 + lcp] - 'a'];"", '   }', '  });', '  return suffixArray;', ' }', '', '// int cachedLcp(int pos1, int pos2) {', '//  if (pos1 > pos2) return cachedLcp(pos2, pos1);', '//  final long key = pos1 * 200000L + pos2;', '//  Integer lcp = lcpCache.get(key);', '//  if (lcp == null) {', '//   lcpCache.put(key, lcp = lcp(pos1, pos2));', '//  }', '//  return lcp;', '// }', ' ', ' int lcp(int pos1, int pos2) {', '  if (pos1 > pos2) return lcp(pos2, pos1);', '  int leftBound = 0;', '  int rightBound = length - pos2;', '  int lcp = naiveLcp(pos1, pos2, min(120, rightBound));', '  if (lcp == -1) {', '   leftBound = min(15, rightBound);', '   while (leftBound <= rightBound) {', '    final int middlePoint = (leftBound + rightBound) >> 1;', '    if (equals(pos1, pos2, middlePoint)) {', '     lcp = max(lcp, middlePoint);', '     leftBound = middlePoint + 1;', '    } else {', '     rightBound = middlePoint - 1;', '    }', '   }', '  }', '  return lcp;', ' }', ' ', ' int naiveLcp(int pos1, int pos2, int len) {', '  final int[] map1 = charMaps[pos1];', '  final int[] map2 = charMaps[pos2];', '  for (int i = 0; i < len; i++) {', ""   if (map1[s[pos1 + i] - 'a'] != map2[s[pos2 + i] - 'a']) {"", '    return i;', '   }', '  }', '  return -1;', ' }', '', ' boolean equals(final int pos1, final int pos2, final int length) {', '  if (pos1 > pos2) return equals(pos2, pos1, length);', '  final int hash1 = hash(pos1, length);', '  final int hash2 = hash(pos2, length);', '  final int hashAlingmentPower = HASH_BASE_POWS[pos2 - pos1];', '  return hashAlingmentPower * hash1 == hash2;', ' }', ' ', '// int hash(int pos, int length) {', '//  final int[] map = charMaps[pos];', '//  final int[] hashL = distributedHashes[pos];', '//  final int[] hashR = distributedHashes[pos + length];', '//  int hash = 0;', '//  for (char ch = 0; ch < ALPHA_SIZE; ch++) {', '//   final int index = map[ch];', '//   if (index != -1) {', '//    hash += (hashR[ch] - hashL[ch]) * (index + 1);', '//   }', '//  }', '//  return hash;', '// }', ' ', ' int hash(int pos, int length) {', '  final int[] perm = charPerms[pos];', '  final int[] hashes = distributedHashes[pos + length];', '  int hash = -hashPrefixes[pos];', '  for (int rank = 0; rank < perm.length; rank++) {', '   hash += hashes[perm[rank]] * rank;', '  }', '  return hash;', ' }', ' ', ' static int[][] getCharMaps(char[] s) {', '  final int length = s.length;', '  final int[][] linksToNext = getLinksToNext(s);', '  final int[][] maps = new int [length][ALPHA_SIZE];', '  for (int offset = 0; offset < length; offset++) {', '   final int[] map = maps[offset];', '   fill(map, -1);', '   int mapped = 0;', ""   map[s[offset] - 'a'] = mapped++;"", '   for (int pos = offset; pos < length; ) {', '    int nextPos = length;', '    int nextChar = -1;', '    for (int ch = 0; ch < ALPHA_SIZE; ch++) {', '     if (map[ch] == -1) {', '      if (nextPos > linksToNext[pos][ch]) {', '       nextPos = linksToNext[pos][ch];', '       nextChar = ch;', '      }', '     }', '    }', '    if (nextChar == -1) break;', '    map[nextChar] = mapped++;', '    pos = nextPos;', '   }', '  }', '  return maps;', ' }', '', ' static int[][] getLinksToNext(char[] s) {', '  final int length = s.length;', '  final int[][] linksToNext = new int [length][ALPHA_SIZE];', '  for (int[] row : linksToNext) fill(row, length);', '  for (int i = length - 2; i >= 0; i--) {', '   System.arraycopy(linksToNext[i + 1], 0, linksToNext[i], 0, ALPHA_SIZE);', ""   linksToNext[i][s[i + 1] - 'a'] = i + 1;"", '  }', '  return linksToNext;', ' }', '', ' static int[][] getDistributedHashes(char[] s) {', '  final int length = s.length;', '  final int[][] distributedHashes = new int [length + 1][ALPHA_SIZE];', '  for (int i = 0; i < length; i++) {', '   System.arraycopy(distributedHashes[i], 0, distributedHashes[i + 1], 0, ALPHA_SIZE);', ""   distributedHashes[i + 1][s[i] - 'a'] += HASH_BASE_POWS[i];"", '  }', '  return distributedHashes;', ' }', '', ' static int[][] getCharPermutations(int[][] charMaps) {', '  final int lenght = charMaps.length;', '  final int[][] charPerms = new int [lenght][];', '  for (int pos = 0; pos < lenght; pos++) {', '   charPerms[pos] = getCharPermutation(charMaps[pos]);', '  }', '  return charPerms;', ' }', ' ', ' static int[] getCharPermutation(int[] map) {', '  final int[] permutation = new int [ALPHA_SIZE];', '  int last = 0;', '  for (int ch = 0; ch < ALPHA_SIZE; ch++) {', '   if (map[ch] != -1) {', '    permutation[map[ch]] = ch;', '    last = max(last, map[ch]);', '   }', '  }', '  return Arrays.copyOf(permutation, last + 1);', ' }', '', ' static int[] precalcHashPrefixes(int[][] charPerms, int[][] distributedHashes) {', '  final int length = charPerms.length;', '  final int[] hashPreffixes = new int [length];', '  for (int pos = 0; pos < length; pos++) {', '   final int[] hashes = distributedHashes[pos];', '   final int[] perm = charPerms[pos];', '   for (int rank = 0; rank < charPerms[pos].length; rank++) {', '    hashPreffixes[pos] += hashes[perm[rank]] * rank;', '   }', '  }', '  return hashPreffixes;', ' }', ' ', ' /* END OF SOLUTION */', '', ' /************************************************************************** ', '  * Entry point', '  *************************************************************************/', ' ', ' static final Solution INSTANCE = new Solution();', ' static final boolean WRITE_LOG = true;', ' static final long STACK_SIZE = -1; // < 0 to default stack size', ' ', ' static long initTime;', ' static boolean localRun = false;', ' ', ' @SuppressWarnings(""unused"")', ' public static void main(String[] args) throws IOException {', '  try {', '   initTime = System.currentTimeMillis();', '   try {', '    localRun = ""true"".equals(System.getProperty(""LOCAL_RUN_7777""));', '    if (localRun && new File(""input.txt"").exists())', '     System.setIn(new FileInputStream(""input.txt""));', '   } catch (SecurityException e) {', ""    // Can't get property. It seems that solution is running in secure"", '    // environment', '   }', '   if (STACK_SIZE < 0L) {', '    INSTANCE.run();', '   } else {', '    new Thread(null, INSTANCE, ""Solver"", 1L << 24).start();', '   }', '  } catch (Throwable e) {', '   e.printStackTrace();', '   System.exit(999);', '  }', ' }', '', ' @Override', ' public void run() {', '  try {', '   in = new BufferedReader(new InputStreamReader(System.in));', '   out = new PrintWriter(System.out);', '   solve();', '   out.close();', '   in.close();', '   writeLog(""Total time: ""', '     + (System.currentTimeMillis() - initTime) + "" ms"");', '   writeLog(""Memory status: "" + memoryStatus());', '  } catch (Throwable e) {', '   e.printStackTrace();', '   System.exit(999);', '  }', ' }', ' ', ' /**************************************************************************', '  * Input ', '  *************************************************************************/', ' BufferedReader in;', ' PrintWriter out;', ' StringTokenizer st = new StringTokenizer("""");', ' ', ' String nextToken() throws IOException {', '  while (!st.hasMoreTokens())', '   st = new StringTokenizer(in.readLine());', '  return st.nextToken();', ' }', ' ', ' int nextInt() throws IOException {', '  return Integer.parseInt(nextToken());', ' }', ' ', ' long nextLong() throws IOException {', '  return Long.parseLong(nextToken());', ' }', ' ', ' double nextDouble() throws IOException {', '  return Double.parseDouble(nextToken());', ' }', ' ', ' int[] nextIntArray(int size) throws IOException {', '  int[] ret = new int [size];', '  for (int i = 0; i < size; i++)', '   ret[i] = nextInt();', '  return ret;', ' }', ' ', ' long[] nextLongArray(int size) throws IOException {', '  long[] ret = new long [size];', '  for (int i = 0; i < size; i++)', '   ret[i] = nextLong();', '  return ret;', ' }', ' ', ' double[] nextDoubleArray(int size) throws IOException {', '  double[] ret = new double [size];', '  for (int i = 0; i < size; i++)', '   ret[i] = nextDouble();', '  return ret;', ' }', ' ', ' String nextLine() throws IOException {', '  st = new StringTokenizer("""");', '  return in.readLine();', ' }', ' ', ' boolean isEof() throws IOException {', '  while (!st.hasMoreTokens()) {', '   String s = in.readLine();', '   if (s == null)', '    return true;', '   st = new StringTokenizer(s);', '  }', '  return false;', ' }', ' ', ' /************************************************************************** ', '  * Output ', '  *************************************************************************/', ' void printRepeat(String s, int count) {', '  for (int i = 0; i < count; i++)', '   out.print(s);', ' }', ' ', ' void printArray(int[] array) {', '  if (array == null || array.length == 0)', '   return;', '  for (int i = 0; i < array.length; i++) {', ""   if (i > 0) out.print(' ');"", '   out.print(array[i]);', '  }', '  out.println();', ' }', ' ', ' void printArray(long[] array) {', '  if (array == null || array.length == 0)', '   return;', '  for (int i = 0; i < array.length; i++) {', ""   if (i > 0) out.print(' ');"", '   out.print(array[i]);', '  }', '  out.println();', ' }', ' ', ' void printArray(double[] array) {', '  if (array == null || array.length == 0)', '   return;', '  for (int i = 0; i < array.length; i++) {', ""   if (i > 0) out.print(' ');"", '   out.print(array[i]);', '  }', '  out.println();', ' }', ' ', ' void printArray(double[] array, String spec) {', '  if (array == null || array.length == 0)', '   return;', '  for (int i = 0; i < array.length; i++) {', ""   if (i > 0) out.print(' ');"", '   out.printf(Locale.US, spec, array[i]);', '  }', '  out.println();', ' }', ' ', ' void printArray(Object[] array) {', '  if (array == null || array.length == 0)', '   return;', '  boolean blank = false;', '  for (Object x : array) {', ""   if (blank) out.print(' '); else blank = true;"", '   out.print(x);', '  }', '  out.println();', ' }', ' ', ' @SuppressWarnings(""rawtypes"")', ' void printCollection(Collection collection) {', '  if (collection == null || collection.isEmpty())', '   return;', '  boolean blank = false;', '  for (Object x : collection) {', ""   if (blank) out.print(' '); else blank = true;"", '   out.print(x);', '  }', '  out.println();', ' }', ' ', ' /**************************************************************************', '  * Utility', '  *************************************************************************/', ' ', ' static String memoryStatus() {', '  return (Runtime.getRuntime().totalMemory()', '    - Runtime.getRuntime().freeMemory() >> 20)', '    + ""/"" + (Runtime.getRuntime().totalMemory() >> 20) + "" MB"";', ' }', ' ', ' static void checkMemory() {', '  System.err.println(memoryStatus());', ' }', ' ', ' static long prevTimeStamp = Long.MIN_VALUE;', ' ', ' static void updateTimer() {', '  prevTimeStamp = System.currentTimeMillis();', ' }', ' ', ' static long elapsedTime() {', '  return (System.currentTimeMillis() - prevTimeStamp);', ' }', ' ', ' static void checkTimer() {', '  System.err.println(elapsedTime() + "" ms"");', ' }', ' ', ' static void chk(boolean f) {', '  if (!f) throw new RuntimeException(""Assert failed"");', ' }', ' ', ' static void chk(boolean f, String format, Object ... args) {', '  if (!f) throw new RuntimeException(String.format(format, args));', ' }', ' ', ' static void writeLog(String format, Object... args) {', '  if (localRun && WRITE_LOG)', '   System.err.println(String.format(Locale.US, format, args));', ' }', ' ', ' static void swap(int[] a, int i, int j) {', '  int tmp = a[i];', '  a[i] = a[j];', '  a[j] = tmp;', ' }', ' ', ' static void swap(long[] a, int i, int j) {', '  long tmp = a[i];', '  a[i] = a[j];', '  a[j] = tmp;', ' }', ' ', ' static void swap(double[] a, int i, int j) {', '  double tmp = a[i];', '  a[i] = a[j];', '  a[j] = tmp;', ' }', ' ', ' static void shuffle(int[] a, int from, int to) {', '  for (int i = from; i < to; i++)', '   swap(a, i, RND.nextInt(a.length));', ' }', ' ', ' static void shuffle(long[] a, int from, int to) {', '  for (int i = from; i < to; i++)', '   swap(a, i, RND.nextInt(a.length));', ' }', ' ', ' static void shuffle(double[] a, int from, int to) {', '  for (int i = from; i < to; i++)', '   swap(a, i, RND.nextInt(a.length));', ' }', ' ', ' static void shuffle(int[] a) {', '  if (a == null) return;', '  shuffle(a, 0, a.length);', ' }', ' ', ' static void shuffle(long[] a) {', '  if (a == null) return;', '  shuffle(a, 0, a.length);', ' }', ' ', ' static void shuffle(double[] a) {', '  if (a == null) return;', '  shuffle(a, 0, a.length);', ' }', ' ', ' static long[] getPartialSums(int[] a) {', '  final long[] sums = new long [a.length + 1];', '  for (int i = 0; i < a.length; i++)', '   sums[i + 1] = sums[i] + a[i];', '  return sums;', ' }', ' ', ' static long[] getPartialSums(long[] a) {', '  final long[] sums = new long [a.length + 1];', '  for (int i = 0; i < a.length; i++)', '   sums[i + 1] = sums[i] + a[i];', '  return sums;', ' }', ' ', ' static int[] getOrderedSet(int[] a) {', '  final int[] set = Arrays.copyOf(a, a.length);', '  if (a.length == 0) return set;', '  shuffle(set);', '  sort(set);', '  int k = 1;', '  int prev = set[0];', '  for (int i = 1; i < a.length; i++) {', '   if (prev != set[i]) {', '    set[k++] = prev = set[i];', '   }', '  }', '  return Arrays.copyOf(set, k);', ' }', ' ', ' static long[] getOrderedSet(long[] a) {', '  final long[] set = Arrays.copyOf(a, a.length);', '  if (a.length == 0) return set;', '  shuffle(set);', '  sort(set);', '  int k = 1;', '  long prev = set[0];', '  for (int i = 1; i < a.length; i++) {', '   if (prev != set[i]) {', '    set[k++] = prev = set[i];', '   }', '  }', '  return Arrays.copyOf(set, k);', ' }', ' ', ' static int gcd(int x, int y) {', '  x = abs(x);', '  y = abs(y);', '  while (x > 0 && y > 0) {', '   if (x > y) {', '    x %= y;', '   } else {', '    y %= x;', '   }', '  }', '  return x + y;', ' }', ' ', ' static long gcd(long x, long y) {', '  x = abs(x);', '  y = abs(y);', '  while (x > 0 && y > 0) {', '   if (x > y) {', '    x %= y;', '   } else {', '    y %= x;', '   }', '  }', '  return x + y;', ' }', ' ', '}']","['import java.io.BufferedReader;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.io.PrintWriter;', 'import java.math.BigInteger;', 'import java.util.Arrays;', 'import java.util.Collection;', 'import java.util.Comparator;', 'import java.util.HashMap;', 'import java.util.Locale;', 'import java.util.Map;', 'import java.util.NavigableSet;', 'import java.util.Random;', 'import java.util.StringTokenizer;', 'import java.util.TreeSet;', '', 'public class Solution implements Runnable {', '    static Random RND = new Random(7777L);', '    static int MAX_LENGTH = 100000;', '    static int ALPHA_SIZE = 26;', '    static int HASH_BASE = BigInteger.probablePrime(17, RND).intValue();', '    static int[] HASH_BASE_POWS = new int[MAX_LENGTH * 2];', '', '    static {', '        HASH_BASE_POWS[0] = 1;', '', '        for (int i = 1; i < HASH_BASE_POWS.length; i++) {', '            HASH_BASE_POWS[i] = HASH_BASE_POWS[i - 1] * HASH_BASE;', '        }', '    }', '', '    char[] s;', '    int length;', '    int[][] charMaps;', '    int[][] charPerms;', '    int[][] distributedHashes;', '    int[] hashPrefixes;', '    Map<Long, Integer> lcpCache = new HashMap<Long, Integer>();', '', '    void solve() throws IOException {', '        s = new StringBuilder(in.readLine()).reverse().toString().toCharArray();', '        length = s.length;', '        charMaps = getCharMaps(s);', '        charPerms = getCharPermutations(charMaps);', '        distributedHashes = getDistributedHashes(s);', '        hashPrefixes = precalcHashPrefixes(charPerms, distributedHashes);', '        Integer[] suffixArray = getSuffixArray();', '        final int[] suffixIndex = new int[length];', '', '        for (int i = 0; i < length; i++) {', '            suffixIndex[suffixArray[i]] = i;', '        }', '', 'NavigableSet<Integer> viewedSuffixes = new TreeSet<Integer>(', 'new Comparator<Integer>() {', '@Override', 'public int compare(Integer pos1, Integer pos2) {', 'return (suffixIndex[pos1] - suffixIndex[pos2]);', '                    }', '                });', '', '        long[] counts = new long[length + 1];', '', '        for (int pos = length - 1; pos >= 0; pos--) {', '            long intersectionSize = 0L;', '', '            {', '                Integer neigbourPos = viewedSuffixes.lower(pos);', '', '                if (neigbourPos != null) {', '    intersectionSize = Math.max(intersectionSize,', '        lcp(pos, neigbourPos));', '                }', '            }', '', '            {', '                Integer neigbourPos = viewedSuffixes.higher(pos);', '', '                if (neigbourPos != null) {', '                    intersectionSize = Math.max(intersectionSize,', '                            lcp(pos, neigbourPos));', '                }', '            }', '', '            counts[pos] = counts[pos + 1] + length - pos - intersectionSize;', '            viewedSuffixes.add(pos);', '        }', '', '        for (int i = 0; i < length; i++) {', '            out.println(counts[length - 1 - i]);', '        }', '    }', '', '    Integer[] getSuffixArray() {', '        Integer[] suffixArray = new Integer[length];', '', '        for (int i = 0; i < length; i++) {', '            suffixArray[i] = i;', '        }', '', '        Arrays.sort(suffixArray, new Comparator<Integer>() {', '            @Override', '            public int compare(Integer pos1, Integer pos2) {', '                if (pos1.equals(pos2)) {', '                    return 0;', '                }', '', '                int lcp = lcp(pos1, pos2);', '', '                if (lcp == length - pos1) {', '                    return -1;', '                }', '', '                if (lcp == length - pos2) {', '                    return +1;', '                }', '', ""                return charMaps[pos1][s[pos1 + lcp] - 'a']"", ""                        - charMaps[pos2][s[pos2 + lcp] - 'a'];"", '            }', '        });', '', '        return suffixArray;', '    }', '', '    int lcp(int pos1, int pos2) {', '        if (pos1 > pos2) {', '            return lcp(pos2, pos1);', '        }', '', '        int leftBound = 0;', '        int rightBound = length - pos2;', '        int lcp = naiveLcp(pos1, pos2, Math.min(120, rightBound));', '', '        if (lcp == -1) {', '            leftBound = Math.min(15, rightBound);', '', '            while (leftBound <= rightBound) {', '                int middlePoint = (leftBound + rightBound) >> 1;', '', '                if (equals(pos1, pos2, middlePoint)) {', '                    lcp = Math.max(lcp, middlePoint);', '                    leftBound = middlePoint + 1;', '                } else {', '                    rightBound = middlePoint - 1;', '                }', '            }', '        }', '', '        return lcp;', '    }', '', '    int naiveLcp(int pos1, int pos2, int len) {', '        int[] map1 = charMaps[pos1];', '        int[] map2 = charMaps[pos2];', '', '        for (int i = 0; i < len; i++) {', ""            if (map1[s[pos1 + i] - 'a'] != map2[s[pos2 + i] - 'a']) {"", '                return i;', '            }', '        }', '', '        return -1;', '    }', '', '    boolean equals(int pos1, int pos2, int length) {', '        if (pos1 > pos2) {', '            return equals(pos2, pos1, length);', '        }', '', '        int hash1 = hash(pos1, length);', '        int hash2 = hash(pos2, length);', '        int hashAlingmentPower = HASH_BASE_POWS[pos2 - pos1];', '', '        return hashAlingmentPower * hash1 == hash2;', '    }', '', '    int hash(int pos, int length) {', '        int[] perm = charPerms[pos];', '        int[] hashes = distributedHashes[pos + length];', '        int hash = -hashPrefixes[pos];', '', '        for (int rank = 0; rank < perm.length; rank++) {', '            hash += hashes[perm[rank]] * rank;', '        }', '', '        return hash;', '    }', '', '    static int[][] getCharMaps(char[] s) {', '        int length = s.length;', '        int[][] linksToNext = getLinksToNext(s);', '        int[][] maps = new int[length][ALPHA_SIZE];', '', '        for (int offset = 0; offset < length; offset++) {', '            int[] map = maps[offset];', '            Arrays.fill(map, -1);', '            int mapped = 0;', ""            map[s[offset] - 'a'] = mapped++;"", '', '            for (int pos = offset; pos < length;) {', '                int nextPos = length;', '                int nextChar = -1;', '', '                for (int ch = 0; ch < ALPHA_SIZE; ch++) {', '                    if (map[ch] == -1) {', '                        if (nextPos > linksToNext[pos][ch]) {', '                            nextPos = linksToNext[pos][ch];', '                            nextChar = ch;', '                        }', '                    }', '                }', '', '                if (nextChar == -1) {', '                    break;', '                }', '', '                map[nextChar] = mapped++;', '                pos = nextPos;', '            }', '        }', '', '        return maps;', '    }', '', '    static int[][] getLinksToNext(char[] s) {', '        int length = s.length;', '        int[][] linksToNext = new int[length][ALPHA_SIZE];', '', '        for (int[] row : linksToNext) {', '            Arrays.fill(row, length);', '        }', '', '        for (int i = length - 2; i >= 0; i--) {', '            System.arraycopy(linksToNext[i + 1], 0, linksToNext[i], 0,', '                    ALPHA_SIZE);', ""            linksToNext[i][s[i + 1] - 'a'] = i + 1;"", '        }', '', '        return linksToNext;', '    }', '', '    static int[][] getDistributedHashes(char[] s) {', '        int length = s.length;', '        int[][] distributedHashes = new int[length + 1][ALPHA_SIZE];', '', '        for (int i = 0; i < length; i++) {', '            System.arraycopy(distributedHashes[i], 0, distributedHashes[i + 1],', '                    0, ALPHA_SIZE);', ""            distributedHashes[i + 1][s[i] - 'a'] += HASH_BASE_POWS[i];"", '        }', '', '        return distributedHashes;', '    }', '', '    static int[][] getCharPermutations(int[][] charMaps) {', '        int lenght = charMaps.length;', '        int[][] charPerms = new int[lenght][];', '', '        for (int pos = 0; pos < lenght; pos++) {', '            charPerms[pos] = getCharPermutation(charMaps[pos]);', '        }', '', '        return charPerms;', '    }', '', '    static int[] getCharPermutation(int[] map) {', '        int[] permutation = new int[ALPHA_SIZE];', '        int last = 0;', '', '        for (int ch = 0; ch < ALPHA_SIZE; ch++) {', '            if (map[ch] != -1) {', '                permutation[map[ch]] = ch;', '                last = Math.max(last, map[ch]);', '            }', '        }', '', '        return Arrays.copyOf(permutation, last + 1);', '    }', '', '    static int[] precalcHashPrefixes(int[][] charPerms,', '            int[][] distributedHashes) {', '        int length = charPerms.length;', '        int[] hashPreffixes = new int[length];', '', '        for (int pos = 0; pos < length; pos++) {', '            int[] hashes = distributedHashes[pos];', '            int[] perm = charPerms[pos];', '', '            for (int rank = 0; rank < charPerms[pos].length; rank++) {', '                hashPreffixes[pos] += hashes[perm[rank]] * rank;', '            }', '        }', '', '        return hashPreffixes;', '    }', '', '    static Solution INSTANCE = new Solution();', '    static boolean WRITE_LOG = true;', '    static long STACK_SIZE = -1;', '', '    public static void main(String[] args) throws IOException {', '        try {', '            if (STACK_SIZE < 0L) {', '                INSTANCE.run();', '            } else {', '                new Thread(null, INSTANCE, ""Solver"", 1L << 24).start();', '            }', '        } catch (Throwable e) {', '            e.printStackTrace();', '            System.exit(999);', '        }', '    }', '', '    @Override', '    public void run() {', '        try {', '            in = new BufferedReader(new InputStreamReader(System.in));', '            out = new PrintWriter(System.out);', '            solve();', '            out.close();', '            in.close();', '        } catch (Throwable e) {', '            e.printStackTrace();', '            System.exit(999);', '        }', '    }', '', '    BufferedReader in;', '    PrintWriter out;', '    StringTokenizer st = new StringTokenizer("""");', '', '    String nextToken() throws IOException {', '        while (!st.hasMoreTokens()) {', '            st = new StringTokenizer(in.readLine());', '        }', '', '        return st.nextToken();', '    }', '', '    int nextInt() throws IOException {', '        return Integer.parseInt(nextToken());', '    }', '', '    long nextLong() throws IOException {', '        return Long.parseLong(nextToken());', '    }', '', '    double nextDouble() throws IOException {', '        return Double.parseDouble(nextToken());', '    }', '', '    int[] nextIntArray(int size) throws IOException {', '        int[] ret = new int[size];', '', '        for (int i = 0; i < size; i++) {', '            ret[i] = nextInt();', '        }', '', '        return ret;', '    }', '', '    long[] nextLongArray(int size) throws IOException {', '        long[] ret = new long[size];', '', '        for (int i = 0; i < size; i++) {', '            ret[i] = nextLong();', '        }', '', '        return ret;', '    }', '', '    double[] nextDoubleArray(int size) throws IOException {', '        double[] ret = new double[size];', '', '        for (int i = 0; i < size; i++) {', '            ret[i] = nextDouble();', '        }', '', '        return ret;', '    }', '', '    String nextLine() throws IOException {', '        st = new StringTokenizer("""");', '', '        return in.readLine();', '    }', '', '    boolean isEof() throws IOException {', '        while (!st.hasMoreTokens()) {', '            String s = in.readLine();', '', '            if (s == null) {', '                return true;', '            }', '', '            st = new StringTokenizer(s);', '        }', '', '        return false;', '    }', '', '    void printRepeat(String s, int count) {', '        for (int i = 0; i < count; i++) {', '            out.print(s);', '        }', '    }', '', '    void printArray(int[] array) {', '        if (array == null || array.length == 0) {', '            return;', '        }', '', '        for (int i = 0; i < array.length; i++) {', '            if (i > 0) {', ""                out.print(' ');"", '            }', '', '            out.print(array[i]);', '        }', '', '        out.println();', '    }', '', '    void printArray(long[] array) {', '        if (array == null || array.length == 0) {', '            return;', '        }', '', '        for (int i = 0; i < array.length; i++) {', '            if (i > 0) {', ""                out.print(' ');"", '            }', '', '            out.print(array[i]);', '        }', '', '        out.println();', '    }', '', '    void printArray(double[] array) {', '        if (array == null || array.length == 0) {', '            return;', '        }', '', '        for (int i = 0; i < array.length; i++) {', '            if (i > 0) {', ""                out.print(' ');"", '            }', '', '            out.print(array[i]);', '        }', '', '        out.println();', '    }', '', '    void printArray(double[] array, String spec) {', '        if (array == null || array.length == 0) {', '            return;', '        }', '', '        for (int i = 0; i < array.length; i++) {', '            if (i > 0) {', ""                out.print(' ');"", '            }', '', '            out.printf(Locale.US, spec, array[i]);', '        }', '', '        out.println();', '    }', '', '    void printArray(Object[] array) {', '        if (array == null || array.length == 0) {', '            return;', '        }', '', '        boolean blank = false;', '', '        for (Object x : array) {', '            if (blank) {', ""                out.print(' ');"", '            } else {', '                blank = true;', '            }', '', '            out.print(x);', '        }', '', '        out.println();', '    }', '', '    @SuppressWarnings(""rawtypes"")', '    void printCollection(Collection collection) {', '        if (collection == null || collection.isEmpty()) {', '            return;', '        }', '', '        boolean blank = false;', '', '        for (Object x : collection) {', '            if (blank) {', ""                out.print(' ');"", '            } else {', '                blank = true;', '            }', '', '            out.print(x);', '        }', '', '        out.println();', '    }', '', '    static void swap(int[] a, int i, int j) {', '        int tmp = a[i];', '        a[i] = a[j];', '        a[j] = tmp;', '    }', '', '    static void swap(long[] a, int i, int j) {', '        long tmp = a[i];', '        a[i] = a[j];', '        a[j] = tmp;', '    }', '', '    static void swap(double[] a, int i, int j) {', '        double tmp = a[i];', '        a[i] = a[j];', '        a[j] = tmp;', '    }', '', '    static void shuffle(int[] a, int from, int to) {', '        for (int i = from; i < to; i++) {', '            swap(a, i, RND.nextInt(a.length));', '        }', '    }', '', '    static void shuffle(long[] a, int from, int to) {', '        for (int i = from; i < to; i++) {', '            swap(a, i, RND.nextInt(a.length));', '        }', '    }', '', '    static void shuffle(double[] a, int from, int to) {', '        for (int i = from; i < to; i++) {', '            swap(a, i, RND.nextInt(a.length));', '        }', '    }', '', '    static void shuffle(int[] a) {', '        if (a == null) {', '            return;', '        }', '', '        shuffle(a, 0, a.length);', '    }', '', '    static void shuffle(long[] a) {', '        if (a == null) {', '            return;', '        }', '', '        shuffle(a, 0, a.length);', '    }', '', '    static void shuffle(double[] a) {', '        if (a == null) {', '            return;', '        }', '', '        shuffle(a, 0, a.length);', '    }', '', '    static long[] getPartialSums(int[] a) {', '        long[] sums = new long[a.length + 1];', '', '        for (int i = 0; i < a.length; i++) {', '            sums[i + 1] = sums[i] + a[i];', '        }', '', '        return sums;', '    }', '', '    static long[] getPartialSums(long[] a) {', '        long[] sums = new long[a.length + 1];', '', '        for (int i = 0; i < a.length; i++) {', '            sums[i + 1] = sums[i] + a[i];', '        }', '', '        return sums;', '    }', '', '    static int[] getOrderedSet(int[] a) {', '        int[] set = Arrays.copyOf(a, a.length);', '', '        if (a.length == 0) {', '            return set;', '        }', '', '        shuffle(set);', '        Arrays.sort(set);', '        int k = 1;', '        int prev = set[0];', '', '        for (int i = 1; i < a.length; i++) {', '            if (prev != set[i]) {', '                set[k++] = prev = set[i];', '            }', '        }', '', '        return Arrays.copyOf(set, k);', '    }', '', '    static long[] getOrderedSet(long[] a) {', '        long[] set = Arrays.copyOf(a, a.length);', '', '        if (a.length == 0) {', '            return set;', '        }', '', '        shuffle(set);', '        Arrays.sort(set);', '        int k = 1;', '        long prev = set[0];', '', '        for (int i = 1; i < a.length; i++) {', '            if (prev != set[i]) {', '                set[k++] = prev = set[i];', '            }', '        }', '', '        return Arrays.copyOf(set, k);', '    }', '', '    static int gcd(int x, int y) {', '        x = Math.abs(x);', '        y = Math.abs(y);', '', '        while (x > 0 && y > 0) {', '            if (x > y) {', '                x %= y;', '            } else {', '                y %= x;', '            }', '        }', '', '        return x + y;', '    }', '', '    static long gcd(long x, long y) {', '        x = Math.abs(x);', '        y = Math.abs(y);', '', '        while (x > 0 && y > 0) {', '            if (x > y) {', '                x %= y;', '            } else {', '                y %= x;', '            }', '        }', '', '        return x + y;', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.ArrayList;', 'import java.util.Arrays;', 'import java.util.Comparator;', 'import java.util.InputMismatchException;', 'import java.util.List;', '', 'public class G2 {', ' InputStream is;', ' PrintWriter out;', ' String INPUT = """";', ' ', ' void solve()', ' {', '  int n = ni(), Q = ni();', '  char[] s = ns(n);', '  int[][] qs = new int[Q][];', '  for(int z = 0;z < Q;z++){', '   qs[z] = new int[]{ni(), ni(), z};', '  }', '  Arrays.sort(qs, new Comparator<int[]>() {', '   public int compare(int[] a, int[] b) {', '    return a[1] - b[1];', '   }', '  });', '//  ', '//  {', '//   int sup = 5, inf = 3;', '//   long[] f0 = new long[10];', '//   long[] f1 = new long[10];', '//   addFenwick(f0, 0, -(sup-inf));', '//   addFenwick(f0, sup+1, +(sup-inf));', '//   addFenwick(f0, inf+1, -(inf+1));', '//   addFenwick(f0, sup+1, +inf+1);', '//   addFenwick(f1, inf+1, 1);', '//   addFenwick(f1, sup+1, -1);', '//   tr(restoreRangeFenwick(f0, f1));', '//  }', ' ', '  ', '  SuffixAutomatonOfBit sa = SuffixAutomatonOfBit.build(s);', '  sa.sortTopologically();', '  SuffixAutomatonOfBit.Node[] nodes = sa.nodes;', '  int[] from = new int[nodes.length-1];', '  int[] to = new int[nodes.length-1];', '  int p = 0;', '  for(SuffixAutomatonOfBit.Node node : nodes){', '   if(node.id >= 1){', '    from[p] = node.link.id; to[p] = node.id; p++;', '   }', '  }', '  assert p == nodes.length-1;', '  int[][] g = packU(nodes.length, from, to);', '  int[][] pars = parents3(g, 0);', '  int[] par = pars[0], ord = pars[1], dep = pars[2];', '  HeavyLightDecomposition hld = new HeavyLightDecomposition(g, par, ord, dep);', '  int m = hld.cluspath.length;', '  SegmentTreeOverwrite[] sts = new SegmentTreeOverwrite[m];', '  for(int i = 0;i < m;i++){', '   sts[i] = new SegmentTreeOverwrite(hld.cluspath[i].length);', '  }', '  ', '  int[] base = new int[n];', '  int qp = 0;', '  int np = 0;', '  long[] ft0 = new long[n+3];', '  long[] ft1 = new long[n+3];', '  long[] ans = new long[Q];', '  for(int i = 0;i < n;i++){', '   while(!(nodes[np].len == i+1 && nodes[np].original == null))np++;', '   base[i] = np;', '//   tr(""base"", base[i]);', '   ', '   // 5 3 1 0', '   // 5 3 1 0', '   // 8 6 3 1 0 ?', '   // aaba', '   ', '   // delete', '   int cur = 0;', '   int ppos = 0;', '   while(true){', '    int last = sts[hld.clus[cur]].get(hld.clusiind[cur]);', '    if(last == -1)break;', '    int lca = hld.lca(base[last], base[i]);', '    // delete from lca to cur', ' //   nodes[cur].len, nodes[lca].len;', '    int inf = last-nodes[lca].len+1;', '    int sup = last-ppos+1;', '//    tr(""del"", last, ppos, nodes[lca].len, inf, sup);', '    // _/', '    addFenwick(ft0, 0, -(sup-inf));', '    addFenwick(ft0, sup+1, +(sup-inf));', '    addFenwick(ft0, inf+1, -(inf+1));', '    addFenwick(ft0, sup+1, +inf+1);', '    addFenwick(ft1, inf+1, 1);', '    addFenwick(ft1, sup+1, -1);', '//    tr(i, restoreRangeFenwick(ft0, ft1));', '    ppos = nodes[lca].len;', '    assert dep[base[i]]-dep[lca]-1 >= 0;', '    cur = hld.ancestor(base[i], dep[base[i]]-dep[lca]-1);', '   }', '   // x', '   //b a', '   //   a', '   ', '   // paint', '   int cx = hld.clus[base[i]]; // cluster', '   int ind = hld.clusiind[base[i]]; // pos in cluster', '   while(true){', '    sts[cx].update(0, ind+1, i);', '    int con = par[hld.cluspath[cx][0]];', '    if(con == -1)break;', '    ind = hld.clusiind[con];', '    cx = hld.clus[con];', '   }', '   ', '//   tr(i, restoreRangeFenwick(ft0, ft1));', '   addFenwick(ft0, 0, i+1+1);', '   addFenwick(ft0, i+1+1, -(i+1+1));', '   addFenwick(ft1, 0, -1);', '   addFenwick(ft1, i+1+1, 1);', '//   tr(i, restoreRangeFenwick(ft0, ft1));', '   ', '   while(qp < Q && qs[qp][1] <= i){', '//    tr(qs[qp]);', '    ans[qs[qp][2]] = sumRangeFenwick(ft0, ft1, qs[qp][0]);', '    qp++;', '   }', '  }', '  for(long an : ans){', '   out.println(an);', '  }', ' }', ' ', ' public static long sumFenwick(long[] ft, int i)', ' {', '  long sum = 0;', '  for(i++;i > 0;i -= i&-i)sum += ft[i];', '  return sum;', ' }', ' ', ' public static void addFenwick(long[] ft, int i, long v)', ' {', '  if(v == 0)return;', '  int n = ft.length;', '  for(i++;i < n;i += i&-i)ft[i] += v;', ' }', ' ', ' public static int firstGEFenwick(long[] ft, long v)', ' {', '  int i = 0, n = ft.length;', '  for(int b = Integer.highestOneBit(n);b != 0;b >>= 1){', '   if((i|b) < n && ft[i|b] < v){', '    i |= b;', '    v -= ft[i];', '   }', '  }', '  return i;', ' }', ' ', ' public static long[] restoreFenwick(long[] ft)', ' {', '  int n = ft.length-1;', '  long[] ret = new long[n];', '  for(int i = 0;i < n;i++)ret[i] = sumFenwick(ft, i);', '  for(int i = n-1;i >= 1;i--)ret[i] -= ret[i-1];', '  return ret;', ' }', ' ', ' public static int findGFenwick(long[] ft, long v)', ' {', '  int i = 0;', '  int n = ft.length;', '  for(int b = Integer.highestOneBit(n);b != 0 && i < n;b >>= 1){', '   if(i + b < n){', '    int t = i + b;', '    if(v >= ft[t]){', '     i = t;', '     v -= ft[t];', '    }', '   }', '  }', '  return v != 0 ? -(i+1) : i-1;', ' }', ' ', ' public static long[] buildFenwick(long[] a)', ' {', '  int n = a.length;', '  long[] ft = new long[n+1];', '  System.arraycopy(a, 0, ft, 1, n);', '  for(int k = 2, h = 1;k <= n;k*=2, h*=2){', '   for(int i = k;i <= n;i+=k){', '    ft[i] += ft[i-h];', '   }', '  }', '  return ft;', ' }', ' ', ' public static void addRangeFenwick(long[] ft0, long[] ft1, int i, long v)', ' {', '  addFenwick(ft1, i+1, -v);', '  addFenwick(ft1, 0, v);', '  addFenwick(ft0, i+1, v*(i+1));', ' }', ' ', ' public static void addRangeFenwick(long[] ft0, long[] ft1, int a, int b, long v)', ' {', '  if(a <= b){', '   addFenwick(ft1, b+1, -v);', '   addFenwick(ft0, b+1, v*(b+1));', '   addFenwick(ft1, a, v);', '   addFenwick(ft0, a, -v*a);', '  }', ' }', ' ', ' public static long sumRangeFenwick(long[] ft0, long[] ft1, int i)', ' {', '  return sumFenwick(ft1, i) * (i+1) + sumFenwick(ft0, i);', ' }', ' ', ' public static long[] restoreRangeFenwick(long[] ft0, long[] ft1)', ' {', '  int n = ft0.length-1;', '  long[] ret = new long[n];', '  for(int i = 0;i < n;i++)ret[i] = sumRangeFenwick(ft0, ft1, i);', '  for(int i = n-1;i >= 1;i--)ret[i] -= ret[i-1];', '  return ret;', ' }', '', ' ', ' public static class SegmentTreeOverwrite {', '  public int M, H, N;', '  public int[] cover;', '  public int I = Integer.MAX_VALUE;', '  ', '  public SegmentTreeOverwrite(int len)', '  {', '   N = len;', '   M = Integer.highestOneBit(Math.max(N-1, 1))<<2;', '   H = M>>>1;', '   cover = new int[M];', '   Arrays.fill(cover, I);', '   for(int i = 0;i < N;i++){', '    cover[H+i] = -1;', '   }', '   for(int i = H-1;i >= 1;i--){', '    propagate(i);', '   }', '  }', '  ', '  private void propagate(int i){}', '  ', '  public void update(int l, int r, int v){ update(l, r, v, 0, H, 1); }', '  ', '  private void update(int l, int r, int v, int cl, int cr, int cur)', '  {', '   if(l <= cl && cr <= r){', '    cover[cur] = v;', '    propagate(cur);', '   }else{', '    int mid = cl+cr>>>1;', '    if(cover[cur] != I){ // back-propagate', '     cover[2*cur] = cover[2*cur+1] = cover[cur];', '     cover[cur] = I;', '     propagate(2*cur);', '     propagate(2*cur+1);', '    }', '    if(cl < r && l < mid){', '     update(l, r, v, cl, mid, 2*cur);', '    }', '    if(mid < r && l < cr){', '     update(l, r, v, mid, cr, 2*cur+1);', '    }', '    propagate(cur);', '   }', '  }', '  ', '  public int get(int x){ ', '   int val = I;', '   for(int i = H+x;i >= 1;i>>>=1){', '    if(cover[i] != I)val = cover[i];', '   }', '   return val;', '  }', ' }', '', ' ', ' public static class HeavyLightDecomposition {', '  public int[] clus;', '  public int[][] cluspath;', '  public int[] clusiind;', '  public int[] par, dep;', '  ', '  public HeavyLightDecomposition(int[][] g, int[] par, int[] ord, int[] dep)', '  {', '   init(g, par, ord, dep);', '  }', '  ', '  public void init(int[][] g, int[] par, int[] ord, int[] dep)', '  {', '   clus = decomposeToHeavyLight(g, par, ord);', '   cluspath = clusPaths(clus, ord);', '   clusiind = clusIInd(cluspath, g.length);', '   this.par = par;', '   this.dep = dep;', '  }', '  ', '  public static int[] decomposeToHeavyLight(int[][] g, int[] par, int[] ord)', '  {', '   int n = g.length;', '   int[] size = new int[n];', '   Arrays.fill(size, 1);', '   for(int i = n-1;i > 0;i--)size[par[ord[i]]] += size[ord[i]];', '   ', '   int[] clus = new int[n];', '   Arrays.fill(clus, -1);', '   int p = 0;', '   for(int i = 0;i < n;i++){', '    int u = ord[i];', '    if(clus[u] == -1)clus[u] = p++;', '    // centroid path (not heavy path)', '    int argmax = -1;', '    for(int v : g[u]){', '     if(par[u] != v && (argmax == -1 || size[v] > size[argmax]))argmax = v;', '    }', '    if(argmax != -1)clus[argmax] = clus[u];', '   }', '   return clus;', '  }', '  ', '  public static int[][] clusPaths(int[] clus, int[] ord)', '  {', '   int n = clus.length;', '   int[] rp = new int[n];', '   int sup = 0;', '   for(int i = 0;i < n;i++){', '    rp[clus[i]]++;', '    sup = Math.max(sup, clus[i]);', '   }', '   sup++;', '   ', '   int[][] row = new int[sup][];', '   for(int i = 0;i < sup;i++)row[i] = new int[rp[i]];', '   ', '   for(int i = n-1;i >= 0;i--){', '    row[clus[ord[i]]][--rp[clus[ord[i]]]] = ord[i];', '   }', '   return row;', '  }', '  ', '  public static int[] clusIInd(int[][] clusPath, int n)', '  {', '   int[] iind = new int[n];', '   for(int[] path : clusPath){', '    for(int i = 0;i < path.length;i++){', '     iind[path[i]] = i;', '    }', '   }', '   return iind;', '  }', '  ', '  public int lca(int x, int y)', '  {', '   int rx = cluspath[clus[x]][0];', '   int ry = cluspath[clus[y]][0];', '   while(clus[x] != clus[y]){', '    if(dep[rx] > dep[ry]){', '     x = par[rx];', '     rx = cluspath[clus[x]][0];', '    }else{', '     y = par[ry];', '     ry = cluspath[clus[y]][0];', '    }', '   }', '   return clusiind[x] > clusiind[y] ? y : x;', '  }', '  ', '  public int ancestor(int x, int v)', '  {', '   while(x != -1){', '    if(v <= clusiind[x])return cluspath[clus[x]][clusiind[x]-v];', '    v -= clusiind[x]+1;', '    x = par[cluspath[clus[x]][0]];', '   }', '   return x;', '  }', ' }', '', ' ', ' public static int lca2(int a, int b, int[][] spar, int[] depth) {', '  if (depth[a] < depth[b]) {', '   b = ancestor(b, depth[b] - depth[a], spar);', '  } else if (depth[a] > depth[b]) {', '   a = ancestor(a, depth[a] - depth[b], spar);', '  }', '', '  if (a == b)', '   return a;', '  int sa = a, sb = b;', '  for (int low = 0, high = depth[a], t = Integer.highestOneBit(high), k = Integer', '    .numberOfTrailingZeros(t); t > 0; t >>>= 1, k--) {', '   if ((low ^ high) >= t) {', '    if (spar[k][sa] != spar[k][sb]) {', '     low |= t;', '     sa = spar[k][sa];', '     sb = spar[k][sb];', '    } else {', '     high = low | t - 1;', '    }', '   }', '  }', '  return spar[0][sa];', ' }', '', ' protected static int ancestor(int a, int m, int[][] spar) {', '  for (int i = 0; m > 0 && a != -1; m >>>= 1, i++) {', '   if ((m & 1) == 1)', '    a = spar[i][a];', '  }', '  return a;', ' }', '', ' public static int[][] logstepParents(int[] par) {', '  int n = par.length;', '  int m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1;', '  int[][] pars = new int[m][n];', '  pars[0] = par;', '  for (int j = 1; j < m; j++) {', '   for (int i = 0; i < n; i++) {', '    pars[j][i] = pars[j - 1][i] == -1 ? -1 : pars[j - 1][pars[j - 1][i]];', '   }', '  }', '  return pars;', ' }', '', ' ', ' public static int[][] parents3(int[][] g, int root) {', '  int n = g.length;', '  int[] par = new int[n];', '  Arrays.fill(par, -1);', '', '  int[] depth = new int[n];', '  depth[0] = 0;', '', '  int[] q = new int[n];', '  q[0] = root;', '  for (int p = 0, r = 1; p < r; p++) {', '   int cur = q[p];', '   for (int nex : g[cur]) {', '    if (par[cur] != nex) {', '     q[r++] = nex;', '     par[nex] = cur;', '     depth[nex] = depth[cur] + 1;', '    }', '   }', '  }', '  return new int[][] { par, q, depth };', ' }', '', ' ', ' static int[][] packU(int n, int[] from, int[] to) {', '  int[][] g = new int[n][];', '  int[] p = new int[n];', '  for (int f : from)', '   p[f]++;', '  for (int t : to)', '   p[t]++;', '  for (int i = 0; i < n; i++)', '   g[i] = new int[p[i]];', '  for (int i = 0; i < from.length; i++) {', '   g[from[i]][--p[from[i]]] = to[i];', '   g[to[i]][--p[to[i]]] = from[i];', '  }', '  return g;', ' }', ' ', ' public static class SuffixAutomatonOfBit {', '  public Node t0;', '  public int len;', '  public Node[] nodes;', '  public int gen;', '  private boolean sortedTopologically = false;', '  private boolean lexsorted = false;', '  ', '  private SuffixAutomatonOfBit(int n)', '  {', '   gen = 0;', '   nodes = new Node[2*n];', '   this.t0 = makeNode(0, null);', '  }', '  ', '  private Node makeNode(int len, Node original)', '  {', '   Node node = new Node();', '   node.id = gen;', '   node.original = original;', '   node.len = len;', '   nodes[gen++] = node;', '   return node;', '  }', '  ', '  public static class Node', '  {', '   public int id;', '   public int len;', '   public char key;', '   public Node link;', '   private Node[] next = new Node[3];', '   public Node original;', '   public int np = 0;', '   public int hit = 0;', '   ', '   public void putNext(char c, Node to)', '   {', '    to.key = c;', ""    if(hit<<~(c-'a')<0){"", '     for(int i = 0;i < np;i++){', '      if(next[i].key == c){', '       next[i] = to;', '       return;', '      }', '     }', '    }', ""    hit |= 1<<c-'a';"", '    if(np == next.length){', '     next = Arrays.copyOf(next, np*2);', '    }', '    next[np++] = to;', '   }', '   ', '   public boolean containsKeyNext(char c)', '   {', ""    return hit<<~(c-'a')<0;"", '//    for(int i = 0;i < np;i++){', '//     if(next[i].key == c)return true;', '//    }', '//    return false;', '   }', '   ', '   public Node getNext(char c)', '   {', ""    if(hit<<~(c-'a')<0){"", '     for(int i = 0;i < np;i++){', '      if(next[i].key == c)return next[i];', '     }', '    }', '    return null;', '   }', '   ', '   public List<String> suffixes(char[] s)', '   {', '    List<String> list = new ArrayList<String>();', '    if(id == 0)return list;', '    int first = original != null ? original.len : len;', '    for(int i = link.len + 1;i <= len;i++){', '     list.add(new String(s, first - i, i));', '    }', '    return list;', '   }', '  }', '', '  public static SuffixAutomatonOfBit build(char[] str)', '  {', '   int n = str.length;', '   SuffixAutomatonOfBit sa = new SuffixAutomatonOfBit(n);', '   sa.len = str.length;', '   ', '   Node last = sa.t0;', '   for(char c : str){', '    last = sa.extend(last, c);', '   }', '   ', '   return sa;', '  }', '  ', '  public Node extend(Node last, char c)', '  {', '   Node cur = makeNode(last.len+1, null);', '   Node p;', '   for(p = last; p != null && !p.containsKeyNext(c);p = p.link){', '    p.putNext(c, cur);', '   }', '   if(p == null){', '    cur.link = t0;', '   }else{', '    Node q = p.getNext(c); // not null', '    if(p.len + 1 == q.len){', '     cur.link = q;', '    }else{', '     Node clone = makeNode(p.len+1, q);', '     clone.next = Arrays.copyOf(q.next, q.next.length);', '     clone.hit = q.hit;', '     clone.np = q.np;', '     clone.link = q.link;', '     for(;p != null && q.equals(p.getNext(c)); p = p.link){', '      p.putNext(c, clone);', '     }', '     q.link = cur.link = clone;', '    }', '   }', '   return cur;', '  }', '  ', '  public SuffixAutomatonOfBit lexSort()', '  {', '   for(int i = 0;i < gen;i++){', '    Node node = nodes[i];', '    Arrays.sort(node.next, 0, node.np, new Comparator<Node>() {', '     public int compare(Node a, Node b) {', '      return a.key - b.key;', '     }', '    });', '   }', '   lexsorted = true;', '   return this;', '  }', '  ', '  public SuffixAutomatonOfBit sortTopologically()', '  {', '   int[] indeg = new int[gen];', '   for(int i = 0;i < gen;i++){', '    for(int j = 0;j < nodes[i].np;j++){', '     indeg[nodes[i].next[j].id]++;', '    }', '   }', '   Node[] sorted = new Node[gen];', '   sorted[0] = t0;', '   int p = 1;', '   for(int i = 0;i < gen;i++){', '    Node cur = sorted[i];', '    for(int j = 0;j < cur.np;j++){', '     if(--indeg[cur.next[j].id] == 0){', '      sorted[p++] = cur.next[j];', '     }', '    }', '   }', '   ', '   for(int i = 0;i < gen;i++)sorted[i].id = i;', '   nodes = sorted;', '   sortedTopologically = true;', '   return this;', '  }', '  ', '  // visualizer', '  ', '  public String toString()', '  {', '   StringBuilder sb = new StringBuilder();', '   for(Node n : nodes){', '    if(n != null){', '     sb.append(String.format(""{id:%d, len:%d, link:%d, cloned:%b, "",', '       n.id,', '       n.len,', '       n.link != null ? n.link.id : null,', '       n.original.id));', '     sb.append(""next:{"");', '     for(int i = 0;i < n.np;i++){', '      sb.append(n.next[i].key + "":"" + n.next[i].id + "","");', '     }', '     sb.append(""}"");', '     sb.append(""}"");', '     sb.append(""\\n"");', '    }', '   }', '   return sb.toString();', '  }', '  ', '  public String toGraphviz(boolean next, boolean suffixLink)', '  {', '   StringBuilder sb = new StringBuilder(""http://chart.apis.google.com/chart?cht=gv:dot&chl="");', '   sb.append(""digraph{"");', '   for(Node n : nodes){', '    if(n != null){', '     if(suffixLink && n.link != null){', '      sb.append(n.id)', '      .append(""->"")', '      .append(n.link.id)', '      .append(""[style=dashed],"");', '     }', '     ', '     if(next && n.next != null){', '      for(int i = 0;i < n.np;i++){', '       sb.append(n.id)', '       .append(""->"")', '       .append(n.next[i].id)', '       .append(""[label="")', '       .append(n.next[i].key)', '       .append(""],"");', '      }', '     }', '    }', '   }', '   sb.append(""}"");', '   return sb.toString();', '  }', '  ', '  public String label(Node n)', '  {', '   if(n.original != null){', '    return n.id + ""C"";', '   }else{', '    return n.id + """";', '   }', '  }', '  ', '  public String toDot(boolean next, boolean suffixLink)', '  {', '   StringBuilder sb = new StringBuilder(""digraph{\\n"");', '   sb.append(""graph[rankdir=LR];\\n"");', '   sb.append(""node[shape=circle];\\n"");', '   for(Node n : nodes){', '    if(n != null){', '     if(suffixLink && n.link != null){', '      sb.append(""\\"""" + label(n) + ""\\"""")', '      .append(""->"")', '      .append(""\\"""" + label(n.link) + ""\\"""")', '      .append(""[style=dashed];\\n"");', '     }', '     ', '     if(next && n.next != null){', '      for(int i = 0;i < n.np;i++){', '       sb.append(""\\"""" + label(n) + ""\\"""")', '       .append(""->"")', '       .append(""\\"""" + label(n.next[i]) + ""\\"""")', '       .append(""[label=\\"""")', '       .append(n.next[i].key)', '       .append(""\\""];\\n"");', '      }', '     }', '    }', '   }', '   sb.append(""}\\n"");', '   return sb.toString();', '  }', ' }', ' ', ' void run() throws Exception', ' {', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  long s = System.currentTimeMillis();', '  solve();', '  out.flush();', '  if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', ' }', ' ', ' public static void main(String[] args) throws Exception { new G2().run(); }', ' ', ' private byte[] inbuf = new byte[1024];', ' public int lenbuf = 0, ptrbuf = 0;', ' ', ' private int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private double nd() { return Double.parseDouble(ns()); }', ' private char nc() { return (char)skip(); }', ' ', ' private String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.ArrayList;', 'import java.util.Arrays;', 'import java.util.Comparator;', 'import java.util.InputMismatchException;', 'import java.util.List;', '', 'public class How_Many_Substrings {', '    InputStream is;', '    PrintWriter out;', '    String INPUT = """";', '    ', '    void solve()', '    {', '        int n = ni(), Q = ni();', '        char[] s = ns(n);', '        int[][] qs = new int[Q][];', '        for(int z = 0;z < Q;z++){', '            qs[z] = new int[]{ni(), ni(), z};', '        }', '        Arrays.sort(qs, new Comparator<int[]>() {', '            public int compare(int[] a, int[] b) {', '                return a[1] - b[1];', '            }', '        });', '', '        SuffixAutomatonOfBit sa = SuffixAutomatonOfBit.build(s);', '        sa.sortTopologically();', '        SuffixAutomatonOfBit.Node[] nodes = sa.nodes;', '        int[] from = new int[nodes.length-1];', '        int[] to = new int[nodes.length-1];', '        int p = 0;', '        for(SuffixAutomatonOfBit.Node node : nodes){', '            if(node.id >= 1){', '                from[p] = node.link.id; to[p] = node.id; p++;', '            }', '        }', '        assert p == nodes.length-1;', '        int[][] g = packU(nodes.length, from, to);', '        int[][] pars = parents3(g, 0);', '        int[] par = pars[0], ord = pars[1], dep = pars[2];', '        HeavyLightDecomposition hld = new HeavyLightDecomposition(g, par, ord, dep);', '        int m = hld.cluspath.length;', '        SegmentTreeOverwrite[] sts = new SegmentTreeOverwrite[m];', '        for(int i = 0;i < m;i++){', '            sts[i] = new SegmentTreeOverwrite(hld.cluspath[i].length);', '        }', '        ', '        int[] base = new int[n];', '        int qp = 0;', '        int np = 0;', '        long[] ft0 = new long[n+3];', '        long[] ft1 = new long[n+3];', '        long[] ans = new long[Q];', '        for(int i = 0;i < n;i++){', '            while(!(nodes[np].len == i+1 && nodes[np].original == null))np++;', '            base[i] = np;', '//            tr(""base"", base[i]);', '            ', '            // 5 3 1 0', '            // 5 3 1 0', '            // 8 6 3 1 0 ?', '            // aaba', '            ', '            // delete', '            int cur = 0;', '            int ppos = 0;', '            while(true){', '                int last = sts[hld.clus[cur]].get(hld.clusiind[cur]);', '                if(last == -1)break;', '                int lca = hld.lca(base[last], base[i]);', '                // delete from lca to cur', '    //            nodes[cur].len, nodes[lca].len;', '                int inf = last-nodes[lca].len+1;', '                int sup = last-ppos+1;', '//                tr(""del"", last, ppos, nodes[lca].len, inf, sup);', '                // _/', '                addFenwick(ft0, 0, -(sup-inf));', '                addFenwick(ft0, sup+1, +(sup-inf));', '                addFenwick(ft0, inf+1, -(inf+1));', '                addFenwick(ft0, sup+1, +inf+1);', '                addFenwick(ft1, inf+1, 1);', '                addFenwick(ft1, sup+1, -1);', '//                tr(i, restoreRangeFenwick(ft0, ft1));', '                ppos = nodes[lca].len;', '                assert dep[base[i]]-dep[lca]-1 >= 0;', '                cur = hld.ancestor(base[i], dep[base[i]]-dep[lca]-1);', '            }', '            // x', '            //b a', '            //   a', '            ', '            // paint', '            int cx = hld.clus[base[i]]; // cluster', '            int ind = hld.clusiind[base[i]]; // pos in cluster', '            while(true){', '                sts[cx].update(0, ind+1, i);', '                int con = par[hld.cluspath[cx][0]];', '                if(con == -1)break;', '                ind = hld.clusiind[con];', '                cx = hld.clus[con];', '            }', '            ', '//            tr(i, restoreRangeFenwick(ft0, ft1));', '            addFenwick(ft0, 0, i+1+1);', '            addFenwick(ft0, i+1+1, -(i+1+1));', '            addFenwick(ft1, 0, -1);', '            addFenwick(ft1, i+1+1, 1);', '//            tr(i, restoreRangeFenwick(ft0, ft1));', '            ', '            while(qp < Q && qs[qp][1] <= i){', '//                tr(qs[qp]);', '                ans[qs[qp][2]] = sumRangeFenwick(ft0, ft1, qs[qp][0]);', '                qp++;', '            }', '        }', '        for(long an : ans){', '            out.println(an);', '        }', '    }', '    ', '    public static long sumFenwick(long[] ft, int i)', '    {', '        long sum = 0;', '        for(i++;i > 0;i -= i&-i)sum += ft[i];', '        return sum;', '    }', '    ', '    public static void addFenwick(long[] ft, int i, long v)', '    {', '        if(v == 0)return;', '        int n = ft.length;', '        for(i++;i < n;i += i&-i)ft[i] += v;', '    }', '    ', '    public static int firstGEFenwick(long[] ft, long v)', '    {', '        int i = 0, n = ft.length;', '        for(int b = Integer.highestOneBit(n);b != 0;b >>= 1){', '            if((i|b) < n && ft[i|b] < v){', '                i |= b;', '                v -= ft[i];', '            }', '        }', '        return i;', '    }', '    ', '    public static long[] restoreFenwick(long[] ft)', '    {', '        int n = ft.length-1;', '        long[] ret = new long[n];', '        for(int i = 0;i < n;i++)ret[i] = sumFenwick(ft, i);', '        for(int i = n-1;i >= 1;i--)ret[i] -= ret[i-1];', '        return ret;', '    }', '    ', '    public static int findGFenwick(long[] ft, long v)', '    {', '        int i = 0;', '        int n = ft.length;', '        for(int b = Integer.highestOneBit(n);b != 0 && i < n;b >>= 1){', '            if(i + b < n){', '                int t = i + b;', '                if(v >= ft[t]){', '                    i = t;', '                    v -= ft[t];', '                }', '            }', '        }', '        return v != 0 ? -(i+1) : i-1;', '    }', '    ', '    public static long[] buildFenwick(long[] a)', '    {', '        int n = a.length;', '        long[] ft = new long[n+1];', '        System.arraycopy(a, 0, ft, 1, n);', '        for(int k = 2, h = 1;k <= n;k*=2, h*=2){', '            for(int i = k;i <= n;i+=k){', '                ft[i] += ft[i-h];', '            }', '        }', '        return ft;', '    }', '    ', '    public static void addRangeFenwick(long[] ft0, long[] ft1, int i, long v)', '    {', '        addFenwick(ft1, i+1, -v);', '        addFenwick(ft1, 0, v);', '        addFenwick(ft0, i+1, v*(i+1));', '    }', '    ', '    public static void addRangeFenwick(long[] ft0, long[] ft1, int a, int b, long v)', '    {', '        if(a <= b){', '            addFenwick(ft1, b+1, -v);', '            addFenwick(ft0, b+1, v*(b+1));', '            addFenwick(ft1, a, v);', '            addFenwick(ft0, a, -v*a);', '        }', '    }', '    ', '    public static long sumRangeFenwick(long[] ft0, long[] ft1, int i)', '    {', '        return sumFenwick(ft1, i) * (i+1) + sumFenwick(ft0, i);', '    }', '    ', '    public static long[] restoreRangeFenwick(long[] ft0, long[] ft1)', '    {', '        int n = ft0.length-1;', '        long[] ret = new long[n];', '        for(int i = 0;i < n;i++)ret[i] = sumRangeFenwick(ft0, ft1, i);', '        for(int i = n-1;i >= 1;i--)ret[i] -= ret[i-1];', '        return ret;', '    }', '', '    ', '    public static class SegmentTreeOverwrite {', '        public int M, H, N;', '        public int[] cover;', '        public int I = Integer.MAX_VALUE;', '        ', '        public SegmentTreeOverwrite(int len)', '        {', '            N = len;', '            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;', '            H = M>>>1;', '            cover = new int[M];', '            Arrays.fill(cover, I);', '            for(int i = 0;i < N;i++){', '                cover[H+i] = -1;', '            }', '            for(int i = H-1;i >= 1;i--){', '                propagate(i);', '            }', '        }', '        ', '        private void propagate(int i){}', '        ', '        public void update(int l, int r, int v){ update(l, r, v, 0, H, 1); }', '        ', '        private void update(int l, int r, int v, int cl, int cr, int cur)', '        {', '            if(l <= cl && cr <= r){', '                cover[cur] = v;', '                propagate(cur);', '            }else{', '                int mid = cl+cr>>>1;', '                if(cover[cur] != I){ // back-propagate', '                    cover[2*cur] = cover[2*cur+1] = cover[cur];', '                    cover[cur] = I;', '                    propagate(2*cur);', '                    propagate(2*cur+1);', '                }', '                if(cl < r && l < mid){', '                    update(l, r, v, cl, mid, 2*cur);', '                }', '                if(mid < r && l < cr){', '                    update(l, r, v, mid, cr, 2*cur+1);', '                }', '                propagate(cur);', '            }', '        }', '        ', '        public int get(int x){ ', '            int val = I;', '            for(int i = H+x;i >= 1;i>>>=1){', '                if(cover[i] != I)val = cover[i];', '            }', '            return val;', '        }', '    }', '', '    ', '    public static class HeavyLightDecomposition {', '        public int[] clus;', '        public int[][] cluspath;', '        public int[] clusiind;', '        public int[] par, dep;', '        ', '        public HeavyLightDecomposition(int[][] g, int[] par, int[] ord, int[] dep)', '        {', '            init(g, par, ord, dep);', '        }', '        ', '        public void init(int[][] g, int[] par, int[] ord, int[] dep)', '        {', '            clus = decomposeToHeavyLight(g, par, ord);', '            cluspath = clusPaths(clus, ord);', '            clusiind = clusIInd(cluspath, g.length);', '            this.par = par;', '            this.dep = dep;', '        }', '        ', '        public static int[] decomposeToHeavyLight(int[][] g, int[] par, int[] ord)', '        {', '            int n = g.length;', '            int[] size = new int[n];', '            Arrays.fill(size, 1);', '            for(int i = n-1;i > 0;i--)size[par[ord[i]]] += size[ord[i]];', '            ', '            int[] clus = new int[n];', '            Arrays.fill(clus, -1);', '            int p = 0;', '            for(int i = 0;i < n;i++){', '                int u = ord[i];', '                if(clus[u] == -1)clus[u] = p++;', '                // centroid path (not heavy path)', '                int argmax = -1;', '                for(int v : g[u]){', '                    if(par[u] != v && (argmax == -1 || size[v] > size[argmax]))argmax = v;', '                }', '                if(argmax != -1)clus[argmax] = clus[u];', '            }', '            return clus;', '        }', '        ', '        public static int[][] clusPaths(int[] clus, int[] ord)', '        {', '            int n = clus.length;', '            int[] rp = new int[n];', '            int sup = 0;', '            for(int i = 0;i < n;i++){', '                rp[clus[i]]++;', '                sup = Math.max(sup, clus[i]);', '            }', '            sup++;', '            ', '            int[][] row = new int[sup][];', '            for(int i = 0;i < sup;i++)row[i] = new int[rp[i]];', '            ', '            for(int i = n-1;i >= 0;i--){', '                row[clus[ord[i]]][--rp[clus[ord[i]]]] = ord[i];', '            }', '            return row;', '        }', '        ', '        public static int[] clusIInd(int[][] clusPath, int n)', '        {', '            int[] iind = new int[n];', '            for(int[] path : clusPath){', '                for(int i = 0;i < path.length;i++){', '                    iind[path[i]] = i;', '                }', '            }', '            return iind;', '        }', '        ', '        public int lca(int x, int y)', '        {', '            int rx = cluspath[clus[x]][0];', '            int ry = cluspath[clus[y]][0];', '            while(clus[x] != clus[y]){', '                if(dep[rx] > dep[ry]){', '                    x = par[rx];', '                    rx = cluspath[clus[x]][0];', '                }else{', '                    y = par[ry];', '                    ry = cluspath[clus[y]][0];', '                }', '            }', '            return clusiind[x] > clusiind[y] ? y : x;', '        }', '        ', '        public int ancestor(int x, int v)', '        {', '            while(x != -1){', '                if(v <= clusiind[x])return cluspath[clus[x]][clusiind[x]-v];', '                v -= clusiind[x]+1;', '                x = par[cluspath[clus[x]][0]];', '            }', '            return x;', '        }', '    }', '', '    ', '    public static int lca2(int a, int b, int[][] spar, int[] depth) {', '        if (depth[a] < depth[b]) {', '            b = ancestor(b, depth[b] - depth[a], spar);', '        } else if (depth[a] > depth[b]) {', '            a = ancestor(a, depth[a] - depth[b], spar);', '        }', '', '        if (a == b)', '            return a;', '        int sa = a, sb = b;', '        for (int low = 0, high = depth[a], t = Integer.highestOneBit(high), k = Integer', '                .numberOfTrailingZeros(t); t > 0; t >>>= 1, k--) {', '            if ((low ^ high) >= t) {', '                if (spar[k][sa] != spar[k][sb]) {', '                    low |= t;', '                    sa = spar[k][sa];', '                    sb = spar[k][sb];', '                } else {', '                    high = low | t - 1;', '                }', '            }', '        }', '        return spar[0][sa];', '    }', '', '    protected static int ancestor(int a, int m, int[][] spar) {', '        for (int i = 0; m > 0 && a != -1; m >>>= 1, i++) {', '            if ((m & 1) == 1)', '                a = spar[i][a];', '        }', '        return a;', '    }', '', '    public static int[][] logstepParents(int[] par) {', '        int n = par.length;', '        int m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1;', '        int[][] pars = new int[m][n];', '        pars[0] = par;', '        for (int j = 1; j < m; j++) {', '            for (int i = 0; i < n; i++) {', '                pars[j][i] = pars[j - 1][i] == -1 ? -1 : pars[j - 1][pars[j - 1][i]];', '            }', '        }', '        return pars;', '    }', '', '    ', '    public static int[][] parents3(int[][] g, int root) {', '        int n = g.length;', '        int[] par = new int[n];', '        Arrays.fill(par, -1);', '', '        int[] depth = new int[n];', '        depth[0] = 0;', '', '        int[] q = new int[n];', '        q[0] = root;', '        for (int p = 0, r = 1; p < r; p++) {', '            int cur = q[p];', '            for (int nex : g[cur]) {', '                if (par[cur] != nex) {', '                    q[r++] = nex;', '                    par[nex] = cur;', '                    depth[nex] = depth[cur] + 1;', '                }', '            }', '        }', '        return new int[][] { par, q, depth };', '    }', '', '    ', '    static int[][] packU(int n, int[] from, int[] to) {', '        int[][] g = new int[n][];', '        int[] p = new int[n];', '        for (int f : from)', '            p[f]++;', '        for (int t : to)', '            p[t]++;', '        for (int i = 0; i < n; i++)', '            g[i] = new int[p[i]];', '        for (int i = 0; i < from.length; i++) {', '            g[from[i]][--p[from[i]]] = to[i];', '            g[to[i]][--p[to[i]]] = from[i];', '        }', '        return g;', '    }', '    ', '    public static class SuffixAutomatonOfBit {', '        public Node t0;', '        public int len;', '        public Node[] nodes;', '        public int gen;', '        private boolean sortedTopologically = false;', '        private boolean lexsorted = false;', '        ', '        private SuffixAutomatonOfBit(int n)', '        {', '            gen = 0;', '            nodes = new Node[2*n];', '            this.t0 = makeNode(0, null);', '        }', '        ', '        private Node makeNode(int len, Node original)', '        {', '            Node node = new Node();', '            node.id = gen;', '            node.original = original;', '            node.len = len;', '            nodes[gen++] = node;', '            return node;', '        }', '        ', '        public static class Node', '        {', '            public int id;', '            public int len;', '            public char key;', '            public Node link;', '            private Node[] next = new Node[3];', '            public Node original;', '            public int np = 0;', '            public int hit = 0;', '            ', '            public void putNext(char c, Node to)', '            {', '                to.key = c;', ""                if(hit<<~(c-'a')<0){"", '                    for(int i = 0;i < np;i++){', '                        if(next[i].key == c){', '                            next[i] = to;', '                            return;', '                        }', '                    }', '                }', ""                hit |= 1<<c-'a';"", '                if(np == next.length){', '                    next = Arrays.copyOf(next, np*2);', '                }', '                next[np++] = to;', '            }', '            ', '            public boolean containsKeyNext(char c)', '            {', ""                return hit<<~(c-'a')<0;"", '//                for(int i = 0;i < np;i++){', '//                    if(next[i].key == c)return true;', '//                }', '//                return false;', '            }', '            ', '            public Node getNext(char c)', '            {', ""                if(hit<<~(c-'a')<0){"", '                    for(int i = 0;i < np;i++){', '                        if(next[i].key == c)return next[i];', '                    }', '                }', '                return null;', '            }', '            ', '            public List<String> suffixes(char[] s)', '            {', '                List<String> list = new ArrayList<String>();', '                if(id == 0)return list;', '                int first = original != null ? original.len : len;', '                for(int i = link.len + 1;i <= len;i++){', '                    list.add(new String(s, first - i, i));', '                }', '                return list;', '            }', '        }', '', '        public static SuffixAutomatonOfBit build(char[] str)', '        {', '            int n = str.length;', '            SuffixAutomatonOfBit sa = new SuffixAutomatonOfBit(n);', '            sa.len = str.length;', '            ', '            Node last = sa.t0;', '            for(char c : str){', '                last = sa.extend(last, c);', '            }', '            ', '            return sa;', '        }', '        ', '        public Node extend(Node last, char c)', '        {', '            Node cur = makeNode(last.len+1, null);', '            Node p;', '            for(p = last; p != null && !p.containsKeyNext(c);p = p.link){', '                p.putNext(c, cur);', '            }', '            if(p == null){', '                cur.link = t0;', '            }else{', '                Node q = p.getNext(c); // not null', '                if(p.len + 1 == q.len){', '                    cur.link = q;', '                }else{', '                    Node clone = makeNode(p.len+1, q);', '                    clone.next = Arrays.copyOf(q.next, q.next.length);', '                    clone.hit = q.hit;', '                    clone.np = q.np;', '                    clone.link = q.link;', '                    for(;p != null && q.equals(p.getNext(c)); p = p.link){', '                        p.putNext(c, clone);', '                    }', '                    q.link = cur.link = clone;', '                }', '            }', '            return cur;', '        }', '        ', '        public SuffixAutomatonOfBit lexSort()', '        {', '            for(int i = 0;i < gen;i++){', '                Node node = nodes[i];', '                Arrays.sort(node.next, 0, node.np, new Comparator<Node>() {', '                    public int compare(Node a, Node b) {', '                        return a.key - b.key;', '                    }', '                });', '            }', '            lexsorted = true;', '            return this;', '        }', '        ', '        public SuffixAutomatonOfBit sortTopologically()', '        {', '            int[] indeg = new int[gen];', '            for(int i = 0;i < gen;i++){', '                for(int j = 0;j < nodes[i].np;j++){', '                    indeg[nodes[i].next[j].id]++;', '                }', '            }', '            Node[] sorted = new Node[gen];', '            sorted[0] = t0;', '            int p = 1;', '            for(int i = 0;i < gen;i++){', '                Node cur = sorted[i];', '                for(int j = 0;j < cur.np;j++){', '                    if(--indeg[cur.next[j].id] == 0){', '                        sorted[p++] = cur.next[j];', '                    }', '                }', '            }', '            ', '            for(int i = 0;i < gen;i++)sorted[i].id = i;', '            nodes = sorted;', '            sortedTopologically = true;', '            return this;', '        }', '        ', '        // visualizer', '        ', '        public String toString()', '        {', '            StringBuilder sb = new StringBuilder();', '            for(Node n : nodes){', '                if(n != null){', '                    sb.append(String.format(""{id:%d, len:%d, link:%d, cloned:%b, "",', '                            n.id,', '                            n.len,', '                            n.link != null ? n.link.id : null,', '                            n.original.id));', '                    sb.append(""next:{"");', '                    for(int i = 0;i < n.np;i++){', '                        sb.append(n.next[i].key + "":"" + n.next[i].id + "","");', '                    }', '                    sb.append(""}"");', '                    sb.append(""}"");', '                    sb.append(""\\n"");', '                }', '            }', '            return sb.toString();', '        }', '        ', '        public String toGraphviz(boolean next, boolean suffixLink)', '        {', '            StringBuilder sb = new StringBuilder(""http://chart.apis.google.com/chart?cht=gv:dot&chl="");', '            sb.append(""digraph{"");', '            for(Node n : nodes){', '                if(n != null){', '                    if(suffixLink && n.link != null){', '                        sb.append(n.id)', '                        .append(""->"")', '                        .append(n.link.id)', '                        .append(""[style=dashed],"");', '                    }', '                    ', '                    if(next && n.next != null){', '                        for(int i = 0;i < n.np;i++){', '                            sb.append(n.id)', '                            .append(""->"")', '                            .append(n.next[i].id)', '                            .append(""[label="")', '                            .append(n.next[i].key)', '                            .append(""],"");', '                        }', '                    }', '                }', '            }', '            sb.append(""}"");', '            return sb.toString();', '        }', '        ', '        public String label(Node n)', '        {', '            if(n.original != null){', '                return n.id + ""C"";', '            }else{', '                return n.id + """";', '            }', '        }', '        ', '        public String toDot(boolean next, boolean suffixLink)', '        {', '            StringBuilder sb = new StringBuilder(""digraph{\\n"");', '            sb.append(""graph[rankdir=LR];\\n"");', '            sb.append(""node[shape=circle];\\n"");', '            for(Node n : nodes){', '                if(n != null){', '                    if(suffixLink && n.link != null){', '                        sb.append(""\\"""" + label(n) + ""\\"""")', '                        .append(""->"")', '                        .append(""\\"""" + label(n.link) + ""\\"""")', '                        .append(""[style=dashed];\\n"");', '                    }', '                    ', '                    if(next && n.next != null){', '                        for(int i = 0;i < n.np;i++){', '                            sb.append(""\\"""" + label(n) + ""\\"""")', '                            .append(""->"")', '                            .append(""\\"""" + label(n.next[i]) + ""\\"""")', '                            .append(""[label=\\"""")', '                            .append(n.next[i].key)', '                            .append(""\\""];\\n"");', '                        }', '                    }', '                }', '            }', '            sb.append(""}\\n"");', '            return sb.toString();', '        }', '    }', '    ', '    void run() throws Exception', '    {', '        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        long s = System.currentTimeMillis();', '        solve();', '        out.flush();', '        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', '    }', '    ', '    public static void main(String[] args) throws Exception { ', '        new How_Many_Substrings().run(); ', '    }', '    ', '    private byte[] inbuf = new byte[1024];', '    public int lenbuf = 0, ptrbuf = 0;', '    ', '    private int readByte()', '    {', '        if(lenbuf == -1)throw new InputMismatchException();', '        if(ptrbuf >= lenbuf){', '            ptrbuf = 0;', '            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '            if(lenbuf <= 0)return -1;', '        }', '        return inbuf[ptrbuf++];', '    }', '    ', '    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', '    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', '    ', '    private double nd() { return Double.parseDouble(ns()); }', '    private char nc() { return (char)skip(); }', '    ', '    private String ns()', '    {', '        int b = skip();', '        StringBuilder sb = new StringBuilder();', ""        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '            sb.appendCodePoint(b);', '            b = readByte();', '        }', '        return sb.toString();', '    }', '    ', '    private char[] ns(int n)', '    {', '        char[] buf = new char[n];', '        int b = skip(), p = 0;', '        while(p < n && !(isSpaceChar(b))){', '            buf[p++] = (char)b;', '            b = readByte();', '        }', '        return n == p ? buf : Arrays.copyOf(buf, p);', '    }', '    ', '    private char[][] nm(int n, int m)', '    {', '        char[][] map = new char[n][];', '        for(int i = 0;i < n;i++)map[i] = ns(m);', '        return map;', '    }', '    ', '    private int[] na(int n)', '    {', '        int[] a = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        return a;', '    }', '    ', '    private int ni()', '    {', '        int num = 0, b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private long nl()', '    {', '        long num = 0;', '        int b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.ArrayList;', 'import java.util.Arrays;', 'import java.util.Comparator;', 'import java.util.InputMismatchException;', 'import java.util.List;', '', 'public class B {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  for(int T = ni();T >= 1;T--){', '   int n = ni();', '   long m = nl();', '   long[] a = new long[n+1];', '   for(int i = 0;i < n;i++){', '    a[i+1] = (a[i] + nl()) % m;', '   }', '   long[][] as = new long[n+1][];', '   for(int i = 0;i < n+1;i++){', '    as[i] = new long[]{a[i], i};', '   }', '   Arrays.sort(as, new Comparator<long[]>() {', '    public int compare(long[] a, long[] b) {', '     return Long.compare(a[0], b[0]);', '    }', '   });', '   long[] asv = new long[n+1];', '   int[] ias = new int[n+1];', '   for(int i = 0;i < n+1;i++){', '    ias[(int)as[i][1]] = i;', '    asv[i] = as[i][0]*2;', '   }', '   ', '   LST lst = new LST(n+2);', '   ', '   long max = 0;', '   for(int i = 0;i < n+1;i++){', '    if(i > 0){', '     int wh = Arrays.binarySearch(asv, a[i]*2+1);', '     wh = -wh-1;', '     int nex = lst.next(wh);', '     if(nex == -1){', '      nex = lst.next(0);', '     }', '     max = Math.max(max, (a[i]-as[nex][0]+m)%m);', '    }', '    lst.set(ias[i]);', '   }', '   out.println(max);', '  }', ' }', ' ', ' public static class LST {', '  public long[][] set;', '  public int n;', '//  public int size;', '  ', '  public LST(int n) {', '   this.n = n;', '   int d = 1;', '   for(int m = n;m > 1;m>>>=6, d++);', '   ', '   set = new long[d][];', '   for(int i = 0, m = n>>>6;i < d;i++, m>>>=6){', '    set[i] = new long[m+1];', '   }', '//   size = 0;', '  }', '  ', '  // FIXME ', '  public LST set(int l, int r)', '  {', '   if(0 <= l && l <= r && r <= n){', '    setRange(r);', '    unsetRange(l-1);', '   }', '   return this;', '  }', '  ', '  public LST setRange(int r)', '  {', '   for(int i = 0;i < set.length;i++, r>>>=6){', '    for(int j = 0;j < r>>>6;j++){', '     set[i][j] = -1;', '    }', '    set[i][r>>>6] |= (1L<<r+1)-1;', '   }', '   return this;', '  }', '  ', '  public LST unsetRange(int r)', '  {', '   if(r >= 0){', '    for(int i = 0;i < set.length;i++, r>>>=6){', '     for(int j = 0;j < r>>>6;j++){', '      set[i][j] = 0;', '     }', '     set[i][r>>>6] &= ~((1L<<r+1)-1);', '    }', '   }', '   return this;', '  }', '  ', '  public LST set(int pos)', '  {', '   if(pos >= 0 && pos < n){', '//    if(!get(pos))size++;', '    for(int i = 0;i < set.length;i++, pos>>>=6){', '     set[i][pos>>>6] |= 1L<<pos;', '    }', '   }', '   return this;', '  }', '  ', '  public LST unset(int pos)', '  {', '   if(pos >= 0 && pos < n){', '//    if(get(pos))size--;', '    for(int i = 0;i < set.length && (i == 0 || set[i-1][pos] == 0L);i++, pos>>>=6){', '     set[i][pos>>>6] &= ~(1L<<pos);', '    }', '   }', '   return this;', '  }', '  ', '  public boolean get(int pos)', '  {', '   return pos >= 0 && pos < n && set[0][pos>>>6]<<~pos<0;', '  }', '  ', '  public int prev(int pos)', '  {', '   for(int i = 0;i < set.length && pos >= 0;i++, pos>>>=6, pos--){', '    int pre = prev(set[i][pos>>>6], pos&63);', '    if(pre != -1){', '     pos = pos>>>6<<6|pre;', '     while(i > 0)pos = pos<<6|63-Long.numberOfLeadingZeros(set[--i][pos]);', '     return pos;', '    }', '   }', '   return -1;', '  }', '  ', '  public int next(int pos)', '  {', '   for(int i = 0;i < set.length && pos>>>6 < set[i].length;i++, pos>>>=6, pos++){', '    int nex = next(set[i][pos>>>6], pos&63);', '    if(nex != -1){', '     pos = pos>>>6<<6|nex;', '     while(i > 0)pos = pos<<6|Long.numberOfTrailingZeros(set[--i][pos]);', '     return pos;', '    }', '   }', '   return -1;', '  }', '  ', '  private static int prev(long set, int n)', '  {', '   long h = Long.highestOneBit(set<<~n);', '   if(h == 0L)return -1;', '   return Long.numberOfTrailingZeros(h)-(63-n);', '  }', '  ', '  private static int next(long set, int n)', '  {', '   long h = Long.lowestOneBit(set>>>n);', '   if(h == 0L)return -1;', '   return Long.numberOfTrailingZeros(h)+n;', '  }', '  ', '  @Override', '  public String toString()', '  {', '   List<Integer> list = new ArrayList<Integer>();', '   for(int pos = next(0);pos != -1;pos = next(pos+1)){', '    list.add(pos);', '   }', '   return list.toString();', '  }', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.util.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'maximumSum' function below."", '     *', '     * The function is expected to return a LONG_INTEGER.', '     * The function accepts following parameters:', '     *  1. LONG_INTEGER_ARRAY a', '     *  2. LONG_INTEGER m', '     */', '', '    public static long maximumSum(List<Long> a, long m) {', '        TreeSet<Long> prefixSumSet = new TreeSet<>();', '        long prefixSum = 0;', '        long maxSumModM = 0;', '', '        for (Long num : a) {', '            prefixSum = (prefixSum + num) % m;', '            // Find the smallest element greater than or equal to prefixSum', '            Long higher = prefixSumSet.ceiling(prefixSum);', '            if (higher != null) {', '                maxSumModM = Math.max(maxSumModM, (prefixSum - higher + m) % m);', '            }', '            maxSumModM = Math.max(maxSumModM, prefixSum);', '            prefixSumSet.add(prefixSum);', '        }', '', '        return maxSumModM;', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int q = Integer.parseInt(bufferedReader.readLine().trim());', '', '        for (int qItr = 0; qItr < q; qItr++) {', '            String[] firstMultipleInput = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '            int n = Integer.parseInt(firstMultipleInput[0]);', '', '            long m = Long.parseLong(firstMultipleInput[1]);', '', '            String[] aTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '            List<Long> a = new ArrayList<>();', '', '            for (int i = 0; i < n; i++) {', '                long aItem = Long.parseLong(aTemp[i]);', '                a.add(aItem);', '            }', '', '            long result = Result.maximumSum(a, m);', '', '            bufferedWriter.write(String.valueOf(result));', '            bufferedWriter.newLine();', '        }', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class D {', ' InputStream is;', ' PrintWriter out;', ' String INPUT = """";', ' ', ' void solve()', ' {', '  int n = ni();', '  int x = ni(), y = ni();', '  int[][] co = new int[n][];', '  for(int i = 0;i < n;i++){', '   co[i] = new int[]{ni(), ni(), ni(), ni()};', '  }', '//  Arrays.sort(co, new Comparator<int[]>() {', '//   public int compare(int[] a, int[] b) {', '//    return a[2] - b[2];', '//   }', '//  });', '  StaticRangeTreeRMQ2 st = new StaticRangeTreeRMQ2(co, 200005);', '//  for(int i = 0;i < n;i++){', '//   st.update(co[i][0], co[i][1], Long.MAX_VALUE / 2);', '//  }', '  mergesort(co, 0, n);', '  long max = Long.MIN_VALUE;', '  long[] dp = new long[n];', '  for(int i = 0;i < n;i++){', '   long min = -st.min(co[i][0]-x, co[i][0]+x+1, co[i][1]-y, co[i][1]+y+1);', '   long val = co[i][3] + Math.max(min, 0);', '   dp[i] = val;', '   st.update(co[i][0], co[i][1], -dp[i]);', '   max = Math.max(max, dp[i]);', '  }', '  out.println(max);', ' }', ' ', ' private static int[][] stemp = new int[200005][];', ' ', ' public static void mergesort(int[][] a, int s, int e)', ' {', '  if(e - s <= 1)return;', '  int h = s+e>>1;', '  mergesort(a, s, h);', '  mergesort(a, h, e);', '  int p = 0;', '  int i= s, j = h;', '  for(;i < h && j < e;)stemp[p++] = a[i][2] < a[j][2] ? a[i++] : a[j++];', '  while(i < h)stemp[p++] = a[i++];', '  while(j < e)stemp[p++] = a[j++];', '  System.arraycopy(stemp, 0, a, s, e-s);', ' }', ' ', ' public static void mergesort0(int[][] a, int s, int e)', ' {', '  if(e - s <= 1)return;', '  int h = s+e>>1;', '  mergesort0(a, s, h);', '  mergesort0(a, h, e);', '  int p = 0;', '  int i= s, j = h;', '  for(;i < h && j < e;)stemp[p++] = a[i][0] < a[j][0] || a[i][0] == a[j][0] && a[i][1] < a[j][1] ? a[i++] : a[j++];', '  while(i < h)stemp[p++] = a[i++];', '  while(j < e)stemp[p++] = a[j++];', '  System.arraycopy(stemp, 0, a, s, e-s);', ' }', ' ', ' public static class StaticRangeTreeRMQ2 {', '  public int M, H, N;', '  public SegmentTreeRMQL[] st;', '  public int[][] maps;', '  public long[][] vals;', '  public int[] count;', '  public long I = Long.MAX_VALUE;', '  ', '  public StaticRangeTreeRMQ2(int[][] co, int n)', '  {', '   N = n;', '   M = Integer.highestOneBit(Math.max(N-1, 1))<<2;', '   H = M>>>1;', '   ', '   mergesort0(co, 0, co.length);', '//   Arrays.sort(co, new Comparator<int[]>() { // x asc', '//    public int compare(int[] a, int[] b) {', '//     if(a[0] != b[0])return a[0] - b[0];', '//     return a[1] - b[1];', '//    }', '//   });', '   maps = new int[M][];', '   vals = new long[M][];', '   st = new SegmentTreeRMQL[M];', '   count = new int[M];', '   for(int i = 0;i < co.length;i++){', '    count[H+co[i][0]]++;', '   }', '   int off = 0;', '   for(int i = 0;i < n;i++){', '    maps[H+i] = new int[count[H+i]];', '    for(int j = 0;j < count[H+i];j++,off++){', '     maps[H+i][j] = co[off][1];', '    }', '    st[H+i] = new SegmentTreeRMQL(count[H+i]);', '   }', '   ', '   for(int i = H-1;i >= 1;i--){', '    if(maps[2*i+1] == null){', '     maps[i] = maps[2*i];', '     count[i] = count[2*i];', '    }else{', '     count[i] = count[2*i] + count[2*i+1];', '     maps[i] = new int[count[i]];', '     int l = 0;', '     for(int j = 0, k = 0;j < count[2*i] || k < count[2*i+1];l++){', '      if(j == count[2*i]){', '       maps[i][l] = maps[2*i+1][k++];', '      }else if(k == count[2*i+1]){', '       maps[i][l] = maps[2*i][j++];', '      }else if(maps[2*i][j] < maps[2*i+1][k]){', '       maps[i][l] = maps[2*i][j++];', '      }else if(maps[2*i][j] > maps[2*i+1][k]){', '       maps[i][l] = maps[2*i+1][k++];', '      }else{', '       maps[i][l] = maps[2*i][j++];', '       k++;', '      }', '     }', '     if(l != count[i]){ // uniq', '      count[i] = l;', '      maps[i] = Arrays.copyOf(maps[i], l);', '     }', '    }', '    if(count[i] <= 25){ // 10% faster', '     vals[i] = new long[count[i]];', '     Arrays.fill(vals[i], Long.MAX_VALUE / 2);', '    }else{', '     st[i] = new SegmentTreeRMQL(count[i]);', '    }', '   }', '  }', '  ', '  public void update(int x, int y, long v)', '  {', '   outer:', '   for(int pos = H+x;pos >= 1;pos>>>=1){', '    if(st[pos] != null){', '     int ind = Arrays.binarySearch(maps[pos], y);', '     if(ind >= 0){', '      st[pos].update(ind, v);', '      continue;', '     }', '    }else{', '     for(int i = 0;i < count[pos];i++){', '      if(maps[pos][i] == y){', '       vals[pos][i] = v;', '       continue outer;', '      }', '     }', '    }', '    throw new RuntimeException(String.format(""access to non-existing point : (%d,%d):%d"", x, y, v));', '   }', '  }', '  ', '  public long min(int xl, int xr, int yl, int yr) { return min(xl, xr, yl, yr, 0, H, 1); }', '  ', '  public long min(int xl, int xr, int yl, int yr, int cl, int cr, int cur)', '  {', '   if(xl <= cl && cr <= xr){', '    if(st[cur] != null){', '     int indl = Arrays.binarySearch(maps[cur], yl);', '     int indr = Arrays.binarySearch(maps[cur], yr);', '     if(indl < 0)indl = -indl - 1;', '     if(indr < 0)indr = -indr - 1;', '     return st[cur].minx(indl, indr);', '    }else{', '     long min = I;', '     for(int i = 0;i < count[cur] && maps[cur][i] < yr;i++){', '      if(maps[cur][i] >= yl && vals[cur][i] < min) min = vals[cur][i];', '     }', '     return min;', '    }', '   }else{', '    int mid = cl+cr>>>1;', '    long ret = I;', '    if(cl < xr && xl < mid)ret = Math.min(ret, min(xl, xr, yl, yr, cl, mid, 2*cur));', '    if(mid < xr && xl < cr)ret = Math.min(ret, min(xl, xr, yl, yr, mid, cr, 2*cur+1));', '    return ret;', '   }', '  }', ' }', ' ', ' public static class SegmentTreeRMQL {', '  public int M, H, N;', '  public long[] st;', '  ', '  public SegmentTreeRMQL(int n)', '  {', '   N = n;', '   M = Integer.highestOneBit(Math.max(N-1, 1))<<2;', '   H = M>>>1;', '   st = new long[M];', '   Arrays.fill(st, 0, M, Long.MAX_VALUE/2);', '  }', '  ', '  public SegmentTreeRMQL(long[] a)', '  {', '   N = a.length;', '   M = Integer.highestOneBit(Math.max(N-1, 1))<<2;', '   H = M>>>1;', '   st = new long[M];', '   for(int i = 0;i < N;i++){', '    st[H+i] = a[i];', '   }', '   Arrays.fill(st, H+N, M, Long.MAX_VALUE);', '   for(int i = H-1;i >= 1;i--)propagate(i);', '  }', '  ', '  public void update(int pos, long x)', '  {', '   st[H+pos] = x;', '   for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);', '  }', '  ', '  private void propagate(int i)', '  {', '   st[i] = Math.min(st[2*i], st[2*i+1]);', '  }', '  ', '  public long minx(int l, int r){', '   long min = Long.MAX_VALUE;', '   if(l >= r)return min;', '   while(l != 0){', '    int f = l&-l;', '    if(l+f > r)break;', '    long v = st[(H+l)/f];', '    if(v < min)min = v;', '    l += f;', '   }', '   ', '   while(l < r){', '    int f = r&-r;', '    long v = st[(H+r)/f-1];', '    if(v < min)min = v;', '    r -= f;', '   }', '   return min;', '  }', '  ', '  public long min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}', '  ', '  private long min(int l, int r, int cl, int cr, int cur)', '  {', '   if(l <= cl && cr <= r){', '    return st[cur];', '   }else{', '    int mid = cl+cr>>>1;', '    long ret = Long.MAX_VALUE;', '    if(cl < r && l < mid){', '     ret = Math.min(ret, min(l, r, cl, mid, 2*cur));', '    }', '    if(mid < r && l < cr){', '     ret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));', '    }', '    return ret;', '   }', '  }', '  ', '  public int firstle(int l, long v) {', '   int cur = H+l;', '   while(true){', '    if(st[cur] <= v){', '     if(cur < H){', '      cur = 2*cur;', '     }else{', '      return cur-H;', '     }', '    }else{', '     cur++;', '     if((cur&cur-1) == 0)return -1;', '     if((cur&1)==0)cur>>>=1;', '    }', '   }', '  }', '  ', '  public int lastle(int l, long v) {', '   int cur = H+l;', '   while(true){', '    if(st[cur] <= v){', '     if(cur < H){', '      cur = 2*cur+1;', '     }else{', '      return cur-H;', '     }', '    }else{', '     if((cur&cur-1) == 0)return -1;', '     cur--;', '     if((cur&1)==1)cur>>>=1;', '    }', '   }', '  }', ' }', '', ' ', ' void run() throws Exception', ' {', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  long s = System.currentTimeMillis();', '  solve();', '  out.flush();', '  if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', ' }', ' ', ' public static void main(String[] args) throws Exception { new D().run(); }', ' ', ' private byte[] inbuf = new byte[1024];', ' public int lenbuf = 0, ptrbuf = 0;', ' ', ' private int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private double nd() { return Double.parseDouble(ns()); }', ' private char nc() { return (char)skip(); }', ' ', ' private String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']","['import java.util.*;', '', 'public class Solution1 {', '    ', '    public static class Point {', '          public int l;', '          public int r;', '          public int xt;', '          public int yt;', '          public long tot;', '', '          public Point(int l, int r, int xt, int yt) {', '              this.l = l;', '              this.r = r;', '              this.xt = xt;', '              this.yt = yt;', '              this.tot = 0;', '          }', '      }', '    ', '  static final Scanner scanner = new Scanner(System.in);', '  public static void main(String[] args) {', '          int n = scanner.nextInt(), x = scanner.nextInt(), y = scanner.nextInt();', '          HashMap<Integer, ArrayList<Point>> blocks = new HashMap<>();', '          long maxPoints = Long.MIN_VALUE;', '          int MAXIMUM = 200000;', '          Point[] points = new Point[MAXIMUM];', '          Arrays.fill(points, null);', '          ', '          for (int i = 0; i < n; i++) {', '              int l = scanner.nextInt(), r = scanner.nextInt(),xt = scanner.nextInt(), yt = scanner.nextInt();', '              Point point = new Point(l, r, xt, yt);', '              points[xt - 1] = point;', '          }', '          ', '          for (int i = 0; i < MAXIMUM; i++) {', '              Point curPoint = points[i];', '              if (points[i] != null) {', '                  int blockNumber = points[i].l / x;', '                  Point curMax = null;', '                  Point max = null;', '                  ArrayList<Point> prevBlock = getBlock(blockNumber - 1, blocks);', '                  ArrayList<Point> curBlock = getBlock(blockNumber, blocks);', '                  ArrayList<Point> nextBlock = getBlock(blockNumber + 1, blocks);', '                  if (prevBlock != null) {', '                      curMax = findMax(prevBlock, curPoint, x, y);', '                      max = curMax;', '                  }', '                  curMax = findMax(curBlock, curPoint, x, y);', '                  if (max == null) {', '                      max = curMax;', '                  } else {', '                      if (curMax != null && curMax.tot >= max.tot) {', '                          max = curMax;', '                      }', '                  }', '                  curMax = findMax(nextBlock, curPoint, x, y);', '                  if (max == null) {', '                      max = curMax;', '                  } else {', '                      if (curMax != null && curMax.tot >= max.tot) {', '                          max = curMax;', '                      }', '                  }', '                  curPoint.tot = (max != null ? max.tot + curPoint.yt : curPoint.yt);', '                  addPoint(curBlock, curPoint, 0, curBlock.size() - 1);', '                  if (maxPoints < curPoint.tot) {', '                      maxPoints = curPoint.tot;', '                  }', '              }', '          }', '          ', '          if (maxPoints == Long.MIN_VALUE) {', '              System.out.println(0);', '          } else {', '              System.out.println(maxPoints);', '          }', '  }', '', '  private static ArrayList<Point> getBlock(int blockNumber, HashMap<Integer, ArrayList<Point>> blocks) {', '      if (blockNumber < 0) {', '          return null;', '      }', '      ArrayList<Point> block = blocks.get(blockNumber);', '      if (block == null) {', '          block = new ArrayList<>();', '          blocks.put(blockNumber, block);', '      }', '      return block;', '  }', '', '  private static Point findMax(ArrayList<Point> block, Point point, int ld, int rd) {', '      for (int i = block.size(); i > 0; i--) {', '          Point prevPoint = block.get(i - 1);', '          if (Math.abs(prevPoint.r - point.r) <= rd', '                  && Math.abs(prevPoint.l - point.l) <= ld) {', '              return prevPoint;', '          }', '      }', '      return null;', '  }', '', '  private static void addPoint(ArrayList<Point> block, Point point, int left, int right) {', '      final long value = point.tot;', '      if (block.isEmpty()) {', '          block.add(point);', '      } else if (right - left <= 1) {', '          long leftValue = block.get(left).tot;', '          long rightValue = block.get(right).tot;', '          if (value < leftValue) {', '              block.add(left, point);', '          } else if (value >= leftValue && value <= rightValue) {', '              block.add(right, point);', '          } else {', '              if (block.size() - 1 == right) {', '                  block.add(point);', '              } else {', '                  int index = right + 1;', '                  block.add(index, point);', '              }', '          }', '      } else {', '          int middle = (right + left) / 2;', '          long middleValue = block.get(middle).tot;', '          if (middleValue <= value) {', '              addPoint(block, point, middle, right);', '          } else {', '              addPoint(block, point, left, middle);', '          }', '      }', '  }', '}']"
 , 
"['import java.io.BufferedReader;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.util.ArrayList;', 'import java.util.Collections;', 'import java.util.Iterator;', 'import java.util.LinkedList;', '', 'public class Solution {', ' static BufferedReader in = new BufferedReader(new InputStreamReader(', '   System.in));', ' static StringBuilder out = new StringBuilder();', '', ' private static Node source;', ' private static Node sink;', ' private static Node[] bikers;', ' private static Node[] bikes;', ' ', ' ', ' public static void main(String[] args) throws IOException {', '  String line = in.readLine();', '  String[] data = line.split(""\\\\s+"");', '  int numBikers = Integer.parseInt(data[0]);', '  int numBikes = Integer.parseInt(data[1]);', '  int numRequired = Integer.parseInt(data[2]);', '', '  source = new Node();', '  sink = new Node(true);', '  bikers = new Node[numBikers];', '  bikes = new Node[numBikes];', '  ', '  Coordinate[] bikerPos = new Coordinate[numBikers];', '  ', '  for(int i = 0; i < numBikers; i ++)', '  {', '   bikers[i] = new Node();', '   source.addConnection(bikers[i]);', '   line = in.readLine();', '   data = line.split(""\\\\s+"");', '   bikerPos[i] = new Coordinate(Integer.parseInt(data[0]), Integer.parseInt(data[1]));', '  }', '  ', '  ArrayList<BikerBikeDistance> bbd = new ArrayList<>();', '  ', '  for(int j = 0; j < numBikes; j ++)', '  {', '   bikes[j] = new Node();', '   bikes[j].addConnection(sink);', '   line = in.readLine();', '   data = line.split(""\\\\s+"");', '   int bx = Integer.parseInt(data[0]);', '   int by = Integer.parseInt(data[1]);', '   for(int i = 0; i < numBikers; i ++)', '   {', '    bbd.add(new BikerBikeDistance(i, j, getCost(bx, by, bikerPos[i].x, bikerPos[i].y)));', '   }', '  }', '  ', '  Collections.sort(bbd);', '  ', '  ', '  int total = 0;', '  long dist = 0;', '  for(int i = 0; total < numRequired; i ++)', '  {', '   BikerBikeDistance cbbd = bbd.get(i);', '   dist = cbbd.cost;', '   bikers[cbbd.biker].addConnection(bikes[cbbd.bike]);', '   if(source.dfsAndReverse(i))', '   {', '    total ++;', '   }', '  }', '  System.out.println(dist);', ' }', ' ', ' ', ' private static long getCost(long x1, long y1, long x2, long y2)', ' {', '  return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);', ' }', ' ', ' private static class Coordinate', ' {', '  final int x;', '  final int y;', '  ', '  public Coordinate(int x, int y)', '  {', '   this.x = x;', '   this.y = y;', '  }', ' }', ' ', ' private static class BikerBikeDistance implements Comparable<BikerBikeDistance>', ' {', '  final int biker;', '  final int bike;', '  final long cost;', '  String name;', '  ', '  public BikerBikeDistance(int biker, int bike, long cost)', '  {', '   this.biker = biker;', '   this.bike = bike;', '   this.cost = cost;', '  }', '', '  @Override', '  public int compareTo(BikerBikeDistance o) {', '   if(cost < o.cost)', '   {', '    return -1;', '   }', '   if(cost > o.cost)', '   {', '    return 1;', '   }', '   return 0;', '  }', ' }', ' ', ' private static class Node', ' {', '  private LinkedList<Node> connections;', '  private int visitedNum;', '  private boolean isTerminus;', '  ', '  public Node()', '  {', '   connections = new LinkedList<Node>();', '   visitedNum = -999;', '   isTerminus = false;', '  }', '  ', '  public Node(boolean terminus)', '  {', '   connections = new LinkedList<Node>();', '   visitedNum = -999;', '   isTerminus = terminus;', '  }', '  ', '  public int getVisited()', '  {', '   return visitedNum;', '  }', '  ', '  public void addConnection(Node n)', '  {', '   connections.add(n);', '  }', '  ', '  public boolean dfsAndReverse(int v)', '  {', '   if(isTerminus)', '   {', '    return true;', '   }', '   visitedNum = v;', '   Iterator<Node> i = connections.iterator();', '   while(i.hasNext())', '   {', '    Node n = i.next();', '    if(n.getVisited()!=v)', '    {', '     if(n.dfsAndReverse(v))', '     {', '      n.addConnection(this);', '      i.remove();', '      return true;', '     }', '    }', '   }', '   return false;', '  }', ' }', '}']","['import java.io.BufferedReader;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.util.ArrayList;', 'import java.util.Collections;', 'import java.util.Iterator;', 'import java.util.LinkedList;', '', 'public class Solution {', '    static BufferedReader in = new BufferedReader(new InputStreamReader(', '            System.in));', '    static StringBuilder out = new StringBuilder();', '', '    private static Node source;', '    private static Node sink;', '    private static Node[] bikers;', '    private static Node[] bikes;', '    ', '    ', '    public static void main(String[] args) throws IOException {', '        String line = in.readLine();', '        String[] data = line.split(""\\\\s+"");', '        int numBikers = Integer.parseInt(data[0]);', '        int numBikes = Integer.parseInt(data[1]);', '        int numRequired = Integer.parseInt(data[2]);', '', '        source = new Node();', '        sink = new Node(true);', '        bikers = new Node[numBikers];', '        bikes = new Node[numBikes];', '        ', '        Coordinate[] bikerPos = new Coordinate[numBikers];', '        ', '        for(int i = 0; i < numBikers; i ++)', '        {', '            bikers[i] = new Node();', '            source.addConnection(bikers[i]);', '            line = in.readLine();', '            data = line.split(""\\\\s+"");', '            bikerPos[i] = new Coordinate(Integer.parseInt(data[0]), Integer.parseInt(data[1]));', '        }', '        ', '        ArrayList<BikerBikeDistance> bbd = new ArrayList<>();', '        ', '        for(int j = 0; j < numBikes; j ++)', '        {', '            bikes[j] = new Node();', '            bikes[j].addConnection(sink);', '            line = in.readLine();', '            data = line.split(""\\\\s+"");', '            int bx = Integer.parseInt(data[0]);', '            int by = Integer.parseInt(data[1]);', '            for(int i = 0; i < numBikers; i ++)', '            {', '                bbd.add(new BikerBikeDistance(i, j, getCost(bx, by, bikerPos[i].x, bikerPos[i].y)));', '            }', '        }', '        ', '        Collections.sort(bbd);', '        ', '        ', '        int total = 0;', '        long dist = 0;', '        for(int i = 0; total < numRequired; i ++)', '        {', '            BikerBikeDistance cbbd = bbd.get(i);', '            dist = cbbd.cost;', '            bikers[cbbd.biker].addConnection(bikes[cbbd.bike]);', '            if(source.dfsAndReverse(i))', '            {', '                total ++;', '            }', '        }', '        System.out.println(dist);', '    }', '    ', '    ', '    private static long getCost(long x1, long y1, long x2, long y2)', '    {', '        return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);', '    }', '    ', '    private static class Coordinate', '    {', '        final int x;', '        final int y;', '        ', '        public Coordinate(int x, int y)', '        {', '            this.x = x;', '            this.y = y;', '        }', '    }', '    ', '    private static class BikerBikeDistance implements Comparable<BikerBikeDistance>', '    {', '        final int biker;', '        final int bike;', '        final long cost;', '        String name;', '        ', '        public BikerBikeDistance(int biker, int bike, long cost)', '        {', '            this.biker = biker;', '            this.bike = bike;', '            this.cost = cost;', '        }', '', '        @Override', '        public int compareTo(BikerBikeDistance o) {', '            if(cost < o.cost)', '            {', '                return -1;', '            }', '            if(cost > o.cost)', '            {', '                return 1;', '            }', '            return 0;', '        }', '    }', '    ', '    private static class Node', '    {', '        private LinkedList<Node> connections;', '        private int visitedNum;', '        private boolean isTerminus;', '        ', '        public Node()', '        {', '            connections = new LinkedList<Node>();', '            visitedNum = -999;', '            isTerminus = false;', '        }', '        ', '        public Node(boolean terminus)', '        {', '            connections = new LinkedList<Node>();', '            visitedNum = -999;', '            isTerminus = terminus;', '        }', '        ', '        public int getVisited()', '        {', '            return visitedNum;', '        }', '        ', '        public void addConnection(Node n)', '        {', '            connections.add(n);', '        }', '        ', '        public boolean dfsAndReverse(int v)', '        {', '            if(isTerminus)', '            {', '                return true;', '            }', '            visitedNum = v;', '            Iterator<Node> i = connections.iterator();', '            while(i.hasNext())', '            {', '                Node n = i.next();', '                if(n.getVisited()!=v)', '                {', '                    if(n.dfsAndReverse(v))', '                    {', '                        n.addConnection(this);', '                        i.remove();', '                        return true;', '                    }', '                }', '            }', '            return false;', '        }', '    }', '}']"
"['import java.util.*;', 'import java.io.*;', '', 'class Solution', '{', ' BufferedReader input;', ' BufferedWriter out;', ' StringTokenizer token;', '', ' int[] ST;', ' int[] add;', '', ' void update(int s,int e,int x,int a,int b,int v)', ' {', '  if(s > b || e < a)return;', '  if(s >= a && e <= b)', '  {', '   add[x] += v;', '   return;', '  }', '  add[2*x+1] += add[x];', '  add[2*x+2] += add[x];', '  add[x] = 0;', '  update(s,(s+e)/2,2*x+1,a,b,v);', '  update((s+e)/2+1,e,2*x+2,a,b,v);', '  ST[x] = Math.max(ST[2*x+1]+add[2*x+1],ST[2*x+2]+add[2*x+2]);', ' }', '', ' void build(int s,int e,int x)', ' {', '  if(s==e)', '  {', '   ST[x] = -s;', '   return;', '  }', '  build(s,(s+e)/2,2*x+1);', '  build((s+e)/2+1,e,2*x+2);', '  ST[x] = Math.max(ST[2*x+1],ST[2*x+2]);', ' }', '', ' int query(int s,int e,int x,int a,int b)', ' {', '  if(s > b || e < a)return 0;', '  if(s >= a && e <= b)', '  {', '   return ST[x]+add[x];', '  }', '  add[2*x+1] += add[x];', '  add[2*x+2] += add[x];', '  add[x] = 0;', '  ST[x] = Math.max(ST[2*x+1]+add[2*x+1],ST[2*x+2]+add[2*x+2]);', '  int first = query(s,(s+e)/2,2*x+1,a,b);', '  int second = query((s+e)/2+1,e,2*x+2,a,b);', '  return Math.max(first,second);', ' }', '', ' void solve() throws IOException', ' {', '  input = new BufferedReader(new InputStreamReader(System.in));', '  out = new BufferedWriter(new OutputStreamWriter(System.out));', '  int T = nextInt();', '  int maxD = 4*(100000+3);', '  ST = new int[maxD];', '  add = new int[maxD];', '  build(0,100000,0);', '  for(int t = 0; t < T; t++)', '  {', '   int D = nextInt();', '   int M = nextInt();', '   update(0,100000,0,D,100000,M);', '   out.write(""""+query(0,100000,0,0,100000));', '   out.newLine();', '  }', '  out.flush();', ' }', '', ' int nextInt() throws IOException', ' {', '  if(token == null || !token.hasMoreTokens())', '   token = new StringTokenizer(input.readLine());', '  return Integer.parseInt(token.nextToken());', ' }', '', ' Long nextLong() throws IOException', ' {', '  if(token == null || !token.hasMoreTokens())', '   token = new StringTokenizer(input.readLine());', '  return Long.parseLong(token.nextToken());', ' }', '', ' String next() throws IOException', ' {', '  if(token == null || !token.hasMoreTokens())', '   token = new StringTokenizer(input.readLine());', '  return token.nextToken();', ' }', '', ' public static void main(String[] args) throws Exception', ' {', '  new Solution().solve();', ' }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', 'class Task implements Comparable<Task> {', '', '    public long D;', '    public long M;', '', '    public Task(long D, long M) {', '        this.D = D;', '        this.M = M;', '    }', '', '    public int compareTo(Task task) {', '        if (this.D < task.D) {', '            return -1;', '        } else if (this.D > task.D) {', '            return 1;', '        } else {', '            return 0;', '        }', '    }', '}', 'public class Solution {', '', '    /*', '     * Complete the solve function below.', '     */', '     public static Map<Long, Long> map = new HashMap<Long, Long>();', '    public static long maxSoFar = -1;', '    public static long deadlineOfMax = -1;', '    static long solve(List<Long> tasks, long D, long M, int upIndex) {', '        /*', '         * Write your code here.', '         */', '          if (maxSoFar >= 0 && D <= deadlineOfMax) {', '            map.put(deadlineOfMax, map.get(deadlineOfMax) + M);', '            maxSoFar += M;', '            return Math.max(0, maxSoFar);', '        }', '', '', '        if (!map.containsKey(D)) {', '            map.put(D, M);', '        } else {', '           map.put(D, map.get(D) + M);', '        }', '', '        if (tasks.size() == 0) {', '            tasks.add(D);', '            return Math.max(0, M - D);', '        } else {', '            long total = 0;', '            int index = 0;', '            long max = -1;', '            boolean found = false;', '            while (index < tasks.size() &&', '                    tasks.get(index) <= D) {', '                if (tasks.get(index) == D)', '                    found = true;', '                total += map.get(tasks.get(index));', '                long diff = total - tasks.get(index);', '                if (diff > max) {', '                    max = diff;', '                    maxSoFar = max;', '                    deadlineOfMax = tasks.get(index);', '                }', '                index++;', '            }', '            if (!found)', '                tasks.add(index, D);       // linear, can we avoid this?', '            while (index < tasks.size()) {', '                total += map.get(tasks.get(index));', '                long diff = total - tasks.get(index);', '                if (diff > max) {', '                    max = diff;', '                    maxSoFar = max;', '                    deadlineOfMax = tasks.get(index);', '                }', '                index++;', '            }', '            return Math.max(0, max);', '        }', '', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int t = Integer.parseInt(scanner.nextLine().trim());', 'List<Long> tasks = new ArrayList<Long>(t);', '        for (int tItr = 0; tItr < t; tItr++) {', '            String[] dm = scanner.nextLine().split("" "");', '', '            int d = Integer.parseInt(dm[0].trim());', '', '            int m = Integer.parseInt(dm[1].trim());', '', '            long result = solve(tasks,d, m, tItr);', '', '            bufferedWriter.write(String.valueOf(result));', '            bufferedWriter.newLine();', '        }', '', '        bufferedWriter.close();', '    }', '}']"
"['import java.awt.Point;', 'import java.io.*;', 'import java.math.BigInteger;', 'import java.util.*;', 'import static java.lang.Math.*;', '', 'public class Solution implements Runnable {', '', '    BufferedReader in;', '    PrintWriter out;', '    StringTokenizer tok = new StringTokenizer("""");', '', '    public static void main(String[] args) {', '        new Thread(null, new Solution(), """", 256 * (1L << 20)).start();', '    }', '', '    public void run() {', '        try {', '            long t1 = System.currentTimeMillis();', '            in = new BufferedReader(new InputStreamReader(System.in));', '            out = new PrintWriter(System.out);', '', '          //  in = new BufferedReader(new FileReader(""src/input.txt""));', '', '            Locale.setDefault(Locale.US);', '            solve();', '            in.close();', '            out.close();', '            long t2 = System.currentTimeMillis();', '            System.err.println(""Time = "" + (t2 - t1));', '        } catch (Throwable t) {', '            t.printStackTrace(System.err);', '            System.exit(-1);', '        }', '    }', '', '    String readString() throws IOException {', '        while (!tok.hasMoreTokens()) {', '            tok = new StringTokenizer(in.readLine());', '        }', '        return tok.nextToken();', '    }', '', '    int readInt() throws IOException {', '        return Integer.parseInt(readString());', '    }', '', '    long readLong() throws IOException {', '        return Long.parseLong(readString());', '    }', '', '    double readDouble() throws IOException {', '        return Double.parseDouble(readString());', '    }', '    Edge[] first;', '    FenwickTree sum;', '    long result;', '', '    void solve() throws IOException {', '        int n = readInt();', '        int k = readInt();', '        first = new Edge[n];', '        boolean[] root = new boolean[n];', '        Arrays.fill(root, true);', '        for (int i = 0; i < n - 1; i++) {', '            int from = readInt() - 1;', '            int to = readInt() - 1;', '            root[to] = false;', '            first[from] = new Edge(from, to, first[from]);', '        }', '        sum = new FenwickTree(n);', '        result = 0;', '        for (int i = 0; i < n; i++) {', '            if (root[i]) {', '                dfs(i, k);', '                break;', '            }', '        }', '        out.println(result);', '    }', '    ', '    void dfs(int x, int k)', '    {', '        result += sum.find(x + k) - sum.find(x - k - 1);', '        sum.increase(x, +1);', '        for (Edge edge = first[x]; edge != null; edge = edge.next)', '        {', '            dfs(edge.b, k);', '        }', '        sum.increase(x, -1);', '    }', '    ', '', '    class Edge {', '', '        int a;', '        int b;', '        Edge next;', '', '        Edge(int a, int b, Edge next) {', '            this.a = a;', '            this.b = b;', '            this.next = next;', '        }', '    }', '', '    class FenwickTree {', '', '        private int[] sum;', '', '        FenwickTree(int size) {', '            sum = new int[size + 10];', '        }', '', '        private int prev(int x) {', '            return x & (x - 1);', '        }', '', '        private int next(int x) {', '            return 2 * x - prev(x);', '        }', '', '        void increase(int id, int value) {', '            id++;', '            while (id < sum.length) {', '                sum[id] += value;', '                id = next(id);', '            }', '        }', '', '        long find(int id) {', '            id++;', '            id = Math.min(sum.length - 1, id);', '            long res = 0;', '            if (id <= 0) {', '                return 0;', '            }', '            while (id > 0) {', '                res += sum[id];', '                id = prev(id);', '            }', '            return res;', '        }', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'public class Solution {', ' public static LinkedList<Integer>[] nodes = new LinkedList[100002];  ', '    static int n , t, root;  ', '  ', '      ', '  ', '    public static void main(String[] args) {  ', '        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */  ', '          ', '        Scanner scan = new Scanner(System.in);  ', '          ', '        n = scan.nextInt();  ', '        t = scan.nextInt();  ', '        long[] stree = new long[4*n+1];  ', '          ', '        for(int i=1;i<=n;i++)  ', '            nodes[i] = new LinkedList<Integer>();  ', '          ', '        int[] idegree = new int[n+1];  ', '          ', '        for(int i=1;i<n;i++)  ', '        {  ', '            int par = scan.nextInt();  ', '            int chd = scan.nextInt();  ', '              ', '            nodes[par].addFirst(chd);  ', '            idegree[chd]++;  ', '        }  ', '          ', '        for(int i=1;i<=n;i++)  ', '        {  ', '            if(idegree[i] == 0)  ', '            {  ', '                root = i;  ', '                break;  ', '            }  ', '        }  ', '          ', '        long[] pairs = new long[1];  ', '          ', '        depthSearch(root,stree,pairs);  ', '          ', '        System.out.println(pairs[0]);  ', '          ', '    }  ', '      ', '    public static void depthSearch(int nodeval, long[] stree, long[] pairs){  ', '          ', '        int min = (nodeval - t < 1) ? 1 : nodeval - t;  ', '        int max = (nodeval + t > n) ? n : nodeval + t;  ', '          ', '        pairs[0] += query(stree,1,1,n,min, max);  ', '          ', '        updateTree(stree,1,1,n,nodeval,1);  ', '          ', '        for(int chd : nodes[nodeval]){  ', '            depthSearch(chd, stree, pairs);  ', '        }  ', '          ', '        updateTree(stree,1,1,n,nodeval,-1);  ', '    }    ', '      ', '    public static void updateTree(long[] tree, int node,int tl, int tr, int val, long opt){  ', '            if(val < tl || val > tr || tl > tr)  ', '                return;  ', '              ', '            tree[node] += opt;  ', '              ', '            int m = (tl + tr) >> 1;  ', '              ', '            if(tl == tr)  ', '                return;  ', '            else if(val <= m)  ', '                updateTree(tree,node<<1,tl,m,val,opt);  ', '            else  ', '                updateTree(tree,node<<1|1,m+1,tr,val,opt);  ', '    }  ', '      ', '    public static long query(long[] tree, int node, int tl, int tr, int min, int max){  ', '          ', '        if(max < tl || min > tr)  ', '            return 0;  ', '          ', '        else if(max == tr && min == tl)  ', '            return tree[node];  ', '          ', '        else{  ', '            int mid = (tl + tr) >> 1;  ', '            int lmax = (mid < max) ? mid : max;  ', '            int rmin = (min > mid) ? min : mid + 1;  ', '            return query(tree,node<<1, tl, mid, min, lmax) + query(tree,node<<1|1, mid+1, tr, rmin, max);  ', '        }  ', '    } ', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class C {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  int n = ni();', '  long[] a = new long[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  Arrays.sort(a);', '  long[] cum =new long[n+1];', '  for(int i = 0;i < n;i++){', '   cum[i+1] = cum[i] + a[i];', '  }', '  long h = 0;', '  for(int Q = ni();Q >= 1;Q--){', '   int x = ni();', '   h -= x;', '   int ind = Arrays.binarySearch(a, h);', '   if(ind < 0)ind = -ind-2;', '   long ret = 0;', '   ret += cum[n]-cum[ind+1]-h*(n-(ind+1));', '   ret += -cum[ind+1]+h*(ind+1);', '   out.println(ret);', '  }', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '', '        int n = in.nextInt();', '        int[] A = new int[n];', '        long sum = 0;', '        for (int i = 0; i < n; i++) {', '            A[i] = in.nextInt();', '            sum += A[i];', '        }', '        Arrays.sort(A);', '', '        int q = in.nextInt();', '        long[] values = new long[q];', '        long last = 0;', '        for (int i = 0; i < q; i++) {', '            values[i] = in.nextInt() + last;', '            last = values[i];', '        }', '', '        for (int i = 0; i < q; i++) {', '            if (values[i] >= 0) {', '                long neg = 0;', '                int index = -1;', '                for (int j = 0; A[j] * -1 > values[i]; j++) {', '                    neg += A[j];', '                    index = j;', '                }', '                long res = (values[i] * (index + 1) + neg) * -1 + (values[i] * (n - index - 1) + sum - neg);', '                System.out.println(res);', '            }', '            else {', '                long pos = 0;', '                int index = n;', '                for (int j = n - 1; A[j] * -1 < values[i]; j--) {', '                    pos += A[j];', '                    index = j;', '                }', '                long res = (values[i] * (n - index) + pos) + (values[i] * index + sum - pos) * -1;', '                System.out.println(res);', '            }', '        }', '    }', '    ', '}']"
 , 
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '        ', '    public static void main(String[] args) {', '        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */', '        Scanner std = new Scanner(System.in);', '        int n1 = std.nextInt();', '        int q1 = std.nextInt();', '        int k1 = std.nextInt();', '        int[] arr = new int[n1];', '         for(int i=0;i<n1;i++){', '            arr[i] = std.nextInt();', '        }', '        ArrayList<Integer> myarry1 = new ArrayList<>();', '        int[] tuphela = new int[q1];', '        int[] tudussra = new int[q1];', '        for(int iterate_kr_saale=0; iterate_kr_saale < q1; iterate_kr_saale++){', '            tuphela[iterate_kr_saale] = std.nextInt();', '            tudussra[iterate_kr_saale] = std.nextInt();', '        }', '        int nihi_dunga = k1;', '        int kihal_ji = k1;', '        for(int iterate_kr_saale=q1-1;iterate_kr_saale>=0;iterate_kr_saale--){', '            if((tuphela[iterate_kr_saale]<=nihi_dunga && tudussra[iterate_kr_saale]>=nihi_dunga) || (tuphela[iterate_kr_saale]<=kihal_ji && tudussra[iterate_kr_saale]>=kihal_ji)){', '                if(tuphela[iterate_kr_saale]<nihi_dunga){', '                    nihi_dunga = tuphela[iterate_kr_saale];', '                }', '                if(tudussra[iterate_kr_saale]>kihal_ji){', '                    kihal_ji = tudussra[iterate_kr_saale];', '                }', '                myarry1.add(iterate_kr_saale);', '            }', '        }', '        if(nihi_dunga==0 && kihal_ji==n1-1){', '            Arrays.sort(arr);', '        }', '        else{', '            for(int iterate_kr_saale=myarry1.size()-1;iterate_kr_saale>=0;iterate_kr_saale--){', '                int ff = myarry1.get(iterate_kr_saale);', '                Arrays.sort(arr, tuphela[ff], tudussra[ff]+1);', '            }', '        }', '        System.out.println(""""+arr[k1]);', '    }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', ' static Scanner std = new Scanner(System.in);', '        ', '    public static int nI(){', '        return std.nextInt();', '    }', '', '    public static long nL(){', '        return std.nextLong();', '    }', '', '    public static String next(){', '        return std.next();', '    }', '', '    public static String nextL(){', '        return std.nextLine();', '    }', '    ', '    public static int[] nA(int n){', '        int[] arr = new int[n];', '        for(int i=0;i<n;i++){', '            arr[i] = nI();', '        }', '        return arr;', '    }', '    ', '    public static long fact(int n){', '        if(n==1) return 1;', '        return n*fact(n-1);', '    }', '', '    public static void printArray(int[] arr, int n ){', '        for(int i=0;i<n;i++) System.out.print(arr[i]+"" "");', '        System.out.println();', '    }', '', '    public static void printArray2(int[][] arr, int n, int m){', '        for(int i=0;i<n;i++) for(int j=0;j<m;j++) System.out.print(arr[i][j]+"" ""); System.out.println();        ', '    }', '', '', '    public static void print(String str){', '        System.out.print(""""+str+"" "");', '    }', '', '    public static void pln(String str){', '        System.out.println(""""+str);', '    }', '', '    private static int gcd(int number1, int number2) //Finds GCD of 2 numbers.', '    {', '        if(number2 == 0)', '        {', '            return number1;', '        }', '        return gcd(number2, number1%number2);', '    }', '', '    public static int dcf(int p, int k){', '        int t=0;', '        while(t*p<k){', '            t++;', '        }', '        if(t*p==k){', '            return t*p;', '        }', '        else{', '            return (t-1)*p;', '        }', '    }', '', '    public static int pf(int g){', '        for(int i=2;i<=(g/2+1);i++){', '            if(g%i==0){', '                return i;', '            }', '        }', '        return g;', '    }', '', '    public static void main(String[] args) {', '        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */', '        int n = nI();', '        int q = nI();', '        int k = nI();', '        int[] arr = nA(n);', '        ArrayList<Integer> a1 = new ArrayList<>();', '        int[] arr1 = new int[q];', '        int[] arr2 = new int[q];', '        for(int h=0;h<q;h++){', '            arr1[h] = nI();', '            arr2[h] = nI();', '        }', '        int dd = k;', '        int ee = k;', '        for(int h=q-1;h>=0;h--){', '            if(dd<=arr1[h] && ee>=arr2[h]){', '                continue;', '            }', '            if((arr1[h]<=dd && arr2[h]>=dd) || (arr1[h]<=ee && arr2[h]>=ee)){', '                if(arr1[h]<dd){', '                    dd = arr1[h];', '                }', '                if(arr2[h]>ee){', '                    ee = arr2[h];', '                }', '                a1.add(h);', '            }', '        }', '        if(dd==0 && ee == n-1){', '            Arrays.sort(arr);', '        }', '        else{', '            for(int h=a1.size()-1;h>=0;h--){', '                int ff = a1.get(h);', '                Arrays.sort(arr, arr1[ff], arr2[ff]+1);', '               // printArray(arr,n);', '            }', '        }', '        pln(""""+arr[k]);', '    }', '}']"
"['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    static Pair[] pairs;', '    static int n, c;', '    ', '    static class Pair{', '        int a;', '        int b;', '        int length; ', '        ', '        Pair(int a, int b){', '            this.a = Math.min(a, b);', '            this.b = Math.max(a, b);', '            length = Math.min(this.b-this.a, c - (this.b-this.a));', '        }', '    }', '', '    static class SegmentTree {', '', '        int n;', '        int[] t;', '        ', '        SegmentTree(int n) {', '            this.n = n;', '            t = new int[4 * n];', '        }', '', '        void build(int a[], int v, int tl, int tr) {', '            if (tl == tr) {', '                t[v] = a[tl];', '            } else {', '                int tm = (tl + tr) / 2;', '                build(a, v * 2, tl, tm);', '                build(a, v * 2 + 1, tm + 1, tr);', '                t[v] = Math.max(t[v * 2], t[v * 2 + 1]);', '            }', '        }', '', '        void update(int v, int tl, int tr, int pos, int newVal) {', '            if (tl == tr) {', '                t[v] = newVal;', '            } else {', '                int tm = (tl + tr) / 2;', '                if (pos <= tm) {', '                    update(v*2, tl, tm, pos, newVal);', '                }else {', '                    update(v*2+1, tm+1, tr, pos, newVal);', '                }', '                t[v] = Math.max(t[v * 2], t[v * 2 + 1]);', '            }', '        }', '', '        int query(int v, int tl, int tr, int l, int r) {', '            if (l > r) {', '                return Integer.MIN_VALUE;', '            }', '            if (l <= tl && tr <= r) {', '                return t[v];', '            }', '            int tm = (tl + tr) / 2;', '            return Math.max(query(v * 2, tl, tm, l, Math.min(r, tm)),', '                    query(v * 2 + 1, tm + 1, tr, Math.max(l, tm + 1), r));', '        }', '    }', '', '    ', '    static boolean existDistP(int d) {', '        int ptr = 0;', '        SegmentTree st = new SegmentTree(c);', '        for(int i = 0;i < n;i++) {', '            Pair p = pairs[i];', '            if(p.length < d) {', '                continue;', '            }', '            while(p.a >= pairs[ptr].a+d) {', '                Pair p2 = pairs[ptr]; ', '                if(p2.length >= d) {', '                    st.update(1, 0, c-1, p2.b, p2.a+1);', '                }', '                ptr++;', '            }', '            ', '            int ma = st.query(1, 0, c-1, Math.max(0,p.b+d-c), p.a-d);', '            ma=Math.max(ma, st.query(1, 0, c-1, p.a+d, p.b-d));', '            ma=Math.max(ma, st.query(1, 0, c-1, p.b+d, Math.min(c,p.a-d+c)));', '            if(ma>=1 && ma-1+c >= p.b+d) {', '                return true;', '            }', '        }', '        return false;', '    }', '', '    static int distantPairs() {', '        Arrays.sort(pairs, new Comparator<Pair>() {', '', '            @Override', '            public int compare(Pair o1, Pair o2) {', '                return o1.a-o2.a;', '            }});', '        int ret=0;', '        for(int i=20;i>=0;i--) {', '            if(existDistP(ret+(1<<i))) {', '                ret+=1<<i;', '            }', '        }', '        return ret;', '    }', '', '    public static void main(String[] args) throws IOException {', '        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 2 * 4096 * 4096);', '        String[] nc = reader.readLine().trim().split("" "");', '        n = Integer.parseInt(nc[0]);', '        c = Integer.parseInt(nc[1]);', '        pairs = new Pair[n];', '        for (int i = 0; i < n; i++) {', '            String[] pointsRowItems = reader.readLine().trim().split("" "");', '            int a = Integer.parseInt(pointsRowItems[0]);', '            int b = Integer.parseInt(pointsRowItems[1]);', '            pairs[i] = new Pair(a, b);', '        }', '        int result = distantPairs();', '        System.out.println(result);', '        reader.close();', '    }', '}']","['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class E2 {', '    InputStream is;', '    PrintWriter out;', '    String INPUT = """";', '    ', '    int L;', '    ', '    void solve()', '    {', '        int n = ni();', '        L = ni();', '        int[][] rs = new int[n][];', '        for(int i = 0;i < n;i++){', '            rs[i] = new int[]{ni(), ni(), 0};', '            if(rs[i][0] > rs[i][1]){', '                int d = rs[i][0]; rs[i][0] = rs[i][1]; rs[i][1] = d;', '            }', '        }', '        int low = 0, high = L+1;', '        while(high - low > 1){', '            int h = high+low>>>1;', '            int[][] sed = new int[n][];', '            int p = 0;', '            for(int i = 0;i < n;i++){', '                if(d(rs[i][0], rs[i][1]) >= h){', '                    sed[p++] = rs[i];', '                }', '            }', '            long[] es = new long[7*p];', '            int q = 0;', '            int[][] zs = new int[p][];', '            int[] temp = new int[6];', '            for(int i = 0;i < p;i++){', '                int[] e = sed[i];', '                // [e[0]+h,e[1]-h], [0,e[0]-h],[e[1]+h,L]', '                int u = 0;', '                if(Math.max(e[1]+h-L, 0) <=  e[0]-h){', '                    temp[u++] = Math.max(e[1]+h-L, 0);', '                    temp[u++] = e[0]-h;', '                }', '                if(e[0]+h <= e[1]-h){', '                    temp[u++] = e[0]+h;', '                    temp[u++] = e[1]-h;', '                }', '                if(e[1]+h <=  Math.min(L-1, e[0]+L-h)){', '                    temp[u++] = e[1]+h;', '                    temp[u++] = Math.min(L-1, e[0]+L-h);', '                }', '                zs[i] = Arrays.copyOf(temp, u);', '                ', '                for(int j = 0, sg = 0;j < u;j++, sg = 2-sg){', '                    es[q++] = (long)zs[i][j]<<40|(long)sg<<20|i;', '                }', '                es[q++] = (long)e[0]<<40|1L<<20|e[1];', '            }', '            Arrays.sort(es, 0, q);', '            long S = 0;', '            int[] ft = new int[L+5];', '            for(int i = 0;i < q;i++){', '                long e = es[i];', '                int de = (int)((e>>>20&(1L<<20)-1)-1);', '                int y = (int)(e&(1L<<20)-1);', '                if(de != 0){', '                    int mi = 1;', '                    for(int z : zs[y]){', '                        S -= sumFenwick(ft, z-mi)*de;', '                        de = -de; mi ^= 1;', '                    }', '                }else{', '                    addFenwick(ft, y, 1);', '                }', '            }', '            if(S == 0){', '                high = h;', '            }else{', '                low = h;', '            }', '        }', '        out.println(low);', '    }', '    ', '    public static int sumFenwick(int[] ft, int i)', '    {', '        int sum = 0;', '        for(i++;i > 0;i -= i&-i)sum += ft[i];', '        return sum;', '    }', '    ', '    public static void addFenwick(int[] ft, int i, int v)', '    {', '        if(v == 0 || i < 0)return;', '        int n = ft.length;', '        for(i++;i < n;i += i&-i)ft[i] += v;', '    }', '', '    ', '    ', '    ', '    int d(int a, int b)', '    {', '        assert a <= b;', '        return Math.min(b-a, a+L-b);', '    }', '    ', '    void run() throws Exception', '    {', '        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        long s = System.currentTimeMillis();', '        solve();', '        out.flush();', '        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', '    }', '    ', '    public static void main(String[] args) throws Exception { new E2().run(); }', '    ', '    private byte[] inbuf = new byte[1024];', '    public int lenbuf = 0, ptrbuf = 0;', '    ', '    private int readByte()', '    {', '        if(lenbuf == -1)throw new InputMismatchException();', '        if(ptrbuf >= lenbuf){', '            ptrbuf = 0;', '            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '            if(lenbuf <= 0)return -1;', '        }', '        return inbuf[ptrbuf++];', '    }', '    ', '    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', '    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', '    ', '    private double nd() { return Double.parseDouble(ns()); }', '    private char nc() { return (char)skip(); }', '    ', '    private String ns()', '    {', '        int b = skip();', '        StringBuilder sb = new StringBuilder();', ""        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '            sb.appendCodePoint(b);', '            b = readByte();', '        }', '        return sb.toString();', '    }', '    ', '    private char[] ns(int n)', '    {', '        char[] buf = new char[n];', '        int b = skip(), p = 0;', '        while(p < n && !(isSpaceChar(b))){', '            buf[p++] = (char)b;', '            b = readByte();', '        }', '        return n == p ? buf : Arrays.copyOf(buf, p);', '    }', '    ', '    private char[][] nm(int n, int m)', '    {', '        char[][] map = new char[n][];', '        for(int i = 0;i < n;i++)map[i] = ns(m);', '        return map;', '    }', '    ', '    private int[] na(int n)', '    {', '        int[] a = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        return a;', '    }', '    ', '    private int ni()', '    {', '        int num = 0, b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private long nl()', '    {', '        long num = 0;', '        int b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(System.in);', '        int n = sc.nextInt();', '        int s = sc.nextInt();', '        long[] a = new long[s+1];', '        long[] b = new long[s+1];', '        long[] d = new long[s+1];', '        long[] tln = new long[s+1];', '        a[0] = 1;', '        b[0] = 1;', '        d[0] = n-1;', '        for (int i = 1; i <= s; i++) {', '            a[i] = sc.nextInt();', '            b[i] = sc.nextInt();', '            d[i] = sc.nextInt();', '            if (i%4==1) {', '                tln[i] = tln[i-1]+(a[i]-a[i-1])*n+(b[i]-b[i-1]);', '            } else if (i%4==2) {', '                tln[i] = tln[i-1]+((b[i-1]+d[i-1])-(b[i]+d[i]))*n+(a[i]-a[i-1]);', '            } else if (i%4==3) {', '                tln[i] = tln[i-1]+((a[i-1]+d[i-1])-(a[i]+d[i]))*n+((b[i-1]+d[i-1])-(b[i]+d[i]));', '            } else if (i%4==0) {', '                tln[i] = tln[i-1]+(b[i]-b[i-1])*n+((a[i-1]+d[i-1])-(a[i]+d[i]));', '            }', '        }', '        ', '        int l = sc.nextInt();', '        long[] w = new long[l];', '        for (int i = 0; i < l; i++) {', '            w[i] = sc.nextLong();', '            int low = 0;', '            int high = s;', '            while (low != high) {', '                int mid = (low+high+1)/2;', '                if (w[i] >= tln[mid] && w[i] < tln[mid]+(d[mid]+1)*n && w[i]%n >= tln[mid]%n && w[i]%n <= (tln[mid]%n)+d[mid])', '                    low = mid;', '                else', '                    high = mid-1;', '            }', '            long off1 = (w[i]-tln[low])/n;', '            long off2 = (w[i]-tln[low])%n;', '            if (low%4==0) {', '                System.out.println((a[low]+off1)+"" ""+(b[low]+off2));', '            } else if (low%4==1) {', '                System.out.println((a[low]+off2)+"" ""+(b[low]+d[low]-off1));', '            } else if (low%4==2) {', '                System.out.println((a[low]+d[low]-off1)+"" ""+(b[low]+d[low]-off2));', '            } else if (low%4==3) {', '                System.out.println((a[low]+d[low]-off2)+"" ""+(b[low]+off1));', '            }', '        }', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution2 {', '', '  static class Drill {', '    int x1;', '    int y1;', '    int z;', '', '    int num = 1;', '    long sumX;', '    long sumY;', '', '    int invX1;', '    int invY1;', '    long invSumX;', '    long invSumY;', '    int inNum = 0;', '', '    Drill(int x1, int y1, int z) {', '      this.x1 = x1;', '      this.y1 = y1;', '      this.z = z;', '      this.sumX = x1 - y1;', '      this.sumY = (long) y1 + z + x1;', '', '      this.invX1 = x1;', '      this.invY1 = y1;', '      this.invSumX = (long) y1 + z + x1;', '      this.invSumY = y1 - x1;', '    }', '', '    @Override', '    public boolean equals(Object obj) {', '      Drill c = (Drill) obj;', '      return x1 == c.x1 && y1 == c.y1 && z == c.z;', '    }', '', '    void addInvRotation(Drill c) {', '      sumX += c.sumY;', '      sumY -= c.sumX;', '      num = (num + c.num) % 4;', '', '      long tinvSumX = invSumX;', '      inNum = (c.inNum + 1) % 4;', '      int x = invX1;', '      int y = invY1;', '      invX1 = (int) c.invSumX;', '      invY1 = (int) c.invSumY;', '      switch (inNum) {', '        case 0:', '          invSumX = c.invSumX + invSumX;', '          invSumY = c.invSumY + invSumY;', '', '          invX1 += x;', '          invY1 += y;', '          break;', '', '        case 1:', '          invSumX = c.invSumX - invSumY;', '          invSumY = c.invSumY + tinvSumX;', '', '          invX1 -= y + z;', '          invY1 += x;', '          break;', '', '        case 2:', '          invSumX = c.invSumX - invSumX;', '          invSumY = c.invSumY - invSumY;', '', '          invX1 -= x + z;', '          invY1 -= y + z;', '          break;', '', '        case 3:', '          invSumX = c.invSumX + invSumY;', '          invSumY = c.invSumY - tinvSumX;', '', '          invX1 += y;', '          invY1 -= x + z;', '          break;', '      }', '    }', '', '    boolean check(int x, int y) {', '      return (x >= invX1 && x <= invX1 + z && y >= invY1 && y <= invY1 + z);', '    }', '  }', '', '  static Drill findDrill(Drill[] commands, int sCount, int x, int y) {', '      if (!commands[0].check(x, y)) {', '          return null;', '      }', '      int last = sCount - 1;', '      if (commands[last].check(x, y)) {', '          return commands[last];', '      }', '      int first = 0;', '      while (first < last - 1) {', '          int pivot = first + (last - first) / 2; ', '          if (commands[pivot].check(x, y)) {', '              first = pivot;', '          } else {', '              last = pivot;', '          }', '      }', '', '    return commands[first];', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int n = Integer.parseInt(st.nextToken());', '', '    st = new StringTokenizer(br.readLine());', '    int s = Integer.parseInt(st.nextToken());', '', '    Drill[] commands = new Drill[s];', '    int sCount = 0;', '    for (int i = 0; i < s; i++) {', '      st = new StringTokenizer(br.readLine());', '      int x = Integer.parseInt(st.nextToken()) - 1;', '      int y = Integer.parseInt(st.nextToken()) - 1;', '      int z = Integer.parseInt(st.nextToken());', '', '      if (z == 0) {', '        continue;', '      }', '', '      Drill c = new Drill(x, y, z);', '      if (sCount == 0) {', '        commands[0] = c;', '        sCount++;', '      } else {', '        c.addInvRotation(commands[sCount - 1]);', '        if (commands[sCount - 1].equals(c)) {', '          commands[sCount - 1] = c;', '        } else {', '          commands[sCount] = c;', '          sCount++;', '        }', '      }', '    }', '', '    st = new StringTokenizer(br.readLine());', '    int l = Integer.parseInt(st.nextToken());', '    for (int i = 0; i < l; i++) {', '      st = new StringTokenizer(br.readLine());', '      long item = Long.parseLong(st.nextToken());', '      int x = (int) (item / n);', '      int y = (int) (item % n);', '', '      Drill c = findDrill(commands, sCount, x, y);', '', '      if (c != null) {', '        long mx = c.sumX;', '        long my = c.sumY;', '        switch (c.num) {', '          case 0:', '            mx += x;', '            my += y;', '            break;', '', '          case 1:', '            mx += y;', '            my -= x;', '            break;', '', '          case 2:', '            mx -= x;', '            my -= y;', '            break;', '', '          case 3:', '            mx -= y;', '            my += x;', '            break;', '        }', '        x = (int) mx;', '        y = (int) my;', '      }', '      bw.write((x + 1) + "" "" + (y + 1) + ""\\n"");', '    }', '', '    bw.newLine();', '    bw.close();', '    br.close();', '  }', '}']"
"['import java.io.OutputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.OutputStream;', 'import java.io.PrintWriter;', 'import java.io.BufferedWriter;', 'import java.io.Writer;', 'import java.io.OutputStreamWriter;', 'import java.util.InputMismatchException;', 'import java.io.IOException;', 'import java.io.InputStream;', '', '/**', ' * Built using CHelper plug-in', ' * Actual solution is at the top', ' */', 'public class Solution {', '    public static void main(String[] args) {', '        InputStream inputStream = System.in;', '        OutputStream outputStream = System.out;', '        InputReader in = new InputReader(inputStream);', '        OutputWriter out = new OutputWriter(outputStream);', '        FrogInMaze solver = new FrogInMaze();', '        solver.solve(1, in, out);', '        out.close();', '    }', '', '    static class FrogInMaze {', '        public int[] dx = {-1, 0, 1, 0};', '        public int[] dy = {0, -1, 0, 1};', '        public int[][] ts;', '', '        public void solve(int testNumber, InputReader in, OutputWriter out) {', '            int n = in.nextInt(), m = in.nextInt(), k = in.nextInt();', '            char[][] grid = new char[n][m];', '            for (int i = 0; i < n; i++) {', '                grid[i] = in.next().toCharArray();', '            }', '            int[][][] neighbor = new int[n][m][];', '            ts = new int[k][4];', '            for (int i = 0; i < k; i++) {', '                for (int j = 0; j < 4; j++)', '                    ts[i][j] = in.nextInt() - 1;', '                neighbor[ts[i][0]][ts[i][1]] = new int[]{ts[i][2], ts[i][3]};', '                neighbor[ts[i][2]][ts[i][3]] = new int[]{ts[i][0], ts[i][1]};', '            }', '', '            double[][] mat = new double[n * m][n * m + 1];', '            int sx = 0, sy = 0;', '            for (int i = 0; i < n; i++) {', '                for (int j = 0; j < m; j++) {', '                    mat[i * m + j][i * m + j] = 1;', '', ""                    if (grid[i][j] == '%') {"", '                        mat[i * m + j][n * m] = 1;', '                        continue;', '                    }', ""                    if (grid[i][j] == '*' || grid[i][j] == '#') {"", '                        mat[i * m + j][n * m] = 0;', '                        continue;', '                    }', '', ""                    if (grid[i][j] == 'A') {"", '                        sx = i;', '                        sy = j;', '                    }', '', '', '                    int avail = 0;', '                    for (int r = 0; r < 4; r++) {', '                        int ni = i + dx[r], nj = j + dy[r];', ""                        if (ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] != '#') {"", '                            avail++;', '                        }', '                    }', '', '                    for (int r = 0; r < 4; r++) {', '                        int ni = i + dx[r], nj = j + dy[r];', ""                        if (ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] != '#') {"", '                            if (neighbor[ni][nj] != null) {', '                                int[] x = neighbor[ni][nj];', '                                ni = x[0];', '                                nj = x[1];', '                            }', '                            mat[i * m + j][ni * m + nj] -= 1.0 / avail;', '                        }', '                    }', '', '                }', '            }', '', '            RowReduce.rref(mat);', '', '            for (int i = 0; i < n * m; i++) {', '                if (mat[i][sx * m + sy] > 1e-8) {', '                    out.printf(""%.10f\\n"", mat[i][n * m]);', '                    return;', '                }', '            }', '            out.println(0);', '        }', '', '    }', '', '    static class RowReduce {', '        public static void rref(double[][] M) {', '            int row = M.length;', '            if (row == 0)', '                return;', '', '            int col = M[0].length;', '', '            int lead = 0;', '            for (int r = 0; r < row; r++) {', '                if (lead >= col)', '                    return;', '', '                int k = r;', '                while (M[k][lead] == 0) {', '                    k++;', '                    if (k == row) {', '                        k = r;', '                        lead++;', '                        if (lead == col)', '                            return;', '                    }', '                }', '                double[] temp = M[r];', '                M[r] = M[k];', '                M[k] = temp;', '', '                double lv = M[r][lead];', '                for (int j = 0; j < col; j++)', '                    M[r][j] /= lv;', '', '                for (int i = 0; i < row; i++) {', '                    if (i != r) {', '                        lv = M[i][lead];', '                        for (int j = 0; j < col; j++)', '                            M[i][j] -= lv * M[r][j];', '                    }', '                }', '                lead++;', '            }', '        }', '', '    }', '', '    static class InputReader {', '        private InputStream stream;', '        private byte[] buf = new byte[1024];', '        private int curChar;', '        private int numChars;', '', '        public InputReader(InputStream stream) {', '            this.stream = stream;', '        }', '', '        public int read() {', '            if (this.numChars == -1) {', '                throw new InputMismatchException();', '            } else {', '                if (this.curChar >= this.numChars) {', '                    this.curChar = 0;', '', '                    try {', '                        this.numChars = this.stream.read(this.buf);', '                    } catch (IOException var2) {', '                        throw new InputMismatchException();', '                    }', '', '                    if (this.numChars <= 0) {', '                        return -1;', '                    }', '                }', '', '                return this.buf[this.curChar++];', '            }', '        }', '', '        public int nextInt() {', '            int c;', '            for (c = this.read(); isSpaceChar(c); c = this.read()) {', '                ;', '            }', '', '            byte sgn = 1;', '            if (c == 45) {', '                sgn = -1;', '                c = this.read();', '            }', '', '            int res = 0;', '', '            while (c >= 48 && c <= 57) {', '                res *= 10;', '                res += c - 48;', '                c = this.read();', '                if (isSpaceChar(c)) {', '                    return res * sgn;', '                }', '            }', '', '            throw new InputMismatchException();', '        }', '', '        public String next() {', '            int c;', '            while (isSpaceChar(c = this.read())) {', '                ;', '            }', '', '            StringBuilder result = new StringBuilder();', '            result.appendCodePoint(c);', '', '            while (!isSpaceChar(c = this.read())) {', '                result.appendCodePoint(c);', '            }', '', '            return result.toString();', '        }', '', '        public static boolean isSpaceChar(int c) {', '            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;', '        }', '', '    }', '', '    static class OutputWriter {', '        private final PrintWriter writer;', '', '        public OutputWriter(OutputStream outputStream) {', '            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));', '        }', '', '        public OutputWriter(Writer writer) {', '            this.writer = new PrintWriter(writer);', '        }', '', '        public void printf(String format, Object... objects) {', '            writer.printf(format, objects);', '        }', '', '        public void close() {', '            writer.close();', '        }', '', '        public void println(int i) {', '            writer.println(i);', '        }', '', '    }', '}']","['import java.util.Arrays;', '', 'public class Solution002 {', '        static final int EXIT = Integer.MAX_VALUE;', '        public static void main(String[] args) {', '                java.util.Scanner sc = new java.util.Scanner(System.in);', '                int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();', '                sc.nextLine();', '                int[][] nextAry2 = new int[n + 2][m + 2];', '                int[][] ids = new int[n + 2][m + 2];', '                int ax = -1, ay = -1, id = 0;', '                for (int i = 1; i <= n; ++i) {', '                        char[] typeLine = sc.nextLine().toCharArray();', '                        for (int j = 1; j <= m; ++j) {', '                                switch (typeLine[j - 1]) {', ""                                case '*':"", '                                        nextAry2[i][j] = 1;', '                                        break;                                        ', ""                                case '#':"", '                                        nextAry2[i][j] = 0;', '                                        break;', ""                                case '%':"", '                                        nextAry2[i][j] = EXIT;', '                                        break;', ""                                case 'A':"", '                                        ax = i;', '                                        ay = j;', '                                default:', '                                        nextAry2[i][j] = (i << 16) | j;', '                                }', '                        }', '                }', '                for (int i = 0; i < k; ++i) {', '                        int x0 = sc.nextInt(), y0 = sc.nextInt(), x1 = sc.nextInt(), y1 = sc.nextInt();', '                        nextAry2[x0][y0] = (x1 << 16) | y1;', '                        nextAry2[x1][y1] = (x0 << 16) | y0;', '                }', '                for (int i = 1; i <= n; ++i)', '                        for (int j = 1; j <= m; ++j) ', '                                ids[i][j] = nextAry2[i][j] > 1 ? id++ : -1;', '                                ', '                double[][] T = new double[id][id];', '                for (int i = 1; i <= n; ++i) {', '                        int[] nextAry2i = nextAry2[i];', '                        int[] idi = ids[i];', '                        for (int j = 1; j <= m; ++j) {', '                                int cid = idi[j];', '                                if (idi[j] < 0) continue;', '                                int v = nextAry2i[j];', '                                if (v != EXIT) {', '                                        int a=v>>16,b=v&0xffff;', '                                        if(a!=i || b!=j) {', '                                                a = i;', '                                                b = j;', '                                        }                                                ', '                                        int w0 = nextAry2[a][b - 1], w1 = nextAry2[a - 1][b], w2 = nextAry2[a][b + 1],w3 = nextAry2[a + 1][b];', '                                        int c = (w0 > 0 ? 1 : 0) + (w1 > 0 ? 1 : 0) + (w2 > 0 ? 1 : 0) + (w3 > 0 ? 1 : 0);', '                                        if (c == 0) continue;', '                                        double c1 = 1.0 / c;', '                                        if(w0==EXIT) T[cid][ids[a][b-1]] = c1; else if(w0 > 1) T[cid][ids[w0 >> 16][w0 & 0xffff]] = c1;', '                                        if(w1==EXIT) T[cid][ids[a-1][b]] = c1; else if (w1 > 1) T[cid][ids[w1 >> 16][w1 & 0xffff]] = c1;', '                                        if(w2==EXIT) T[cid][ids[a][b+1]] = c1; else if (w2 > 1) T[cid][ids[w2 >> 16][w2 & 0xffff]] = c1;', '                                        if(w3==EXIT) T[cid][ids[a+1][b]] = c1; else if (w3 > 1) T[cid][ids[w3 >> 16][w3 & 0xffff]] = c1;', '                                        continue;', '                                }', '                                T[cid][cid] = 1.0;', '                        }', '                }', '        //        print(T);        ', '                double[][] TP = pow(T, id, 0x10000L);', '                int ida = ids[ax][ay];', '                double rs = 0;', '                for (int i = 1; i <= n; ++i)', '                        for (int j = 1; j <= m; ++j)', '                                if (nextAry2[i][j] == EXIT) rs += TP[ida][ids[i][j]];', '        //        print(TP);', '                System.out.println(rs);', '        }', '        public static void print(double[][] x) {', '                System.out.println(""["");', '                for(int i=0;i<x.length;++i) {', '                        if(i!=0) {', '                                System.out.print("","");', '                        }', '                        System.out.println(Arrays.toString(x[i]));', '                }', '                System.out.println(""]"");', '                ', '                for (int i = 0; i < x.length; ++i) {', '                        if (i > 0) {', '                                System.out.println(""\\n"");', '                        }', '                        for (int j = 0; j < x[i].length; ++j) {', '                                if (j > 0) {', ""                                        System.out.print(' ');"", '                                }', '                                System.out.print(String.format(""%.20f"", x[i][j]));', '                        }', '                }', '', '                System.out.println();', '                System.out.println(""----------------"");', '                System.out.println();', '        }', '        ', '        static void print(Object...args) {', '                System.out.println(Arrays.toString(args));', '        }', '        ', '        static void mul(double[][] A, double[][] B, double[][] R, int n) {', '                for (int i = 0,k=0; i < n; i++) {', '                        double[] Ri = R[i],Ai = A[i];', '                        for (int j = 0; j < n; j++)', '                                for (k =0, Ri[j]=0; k < n; k++) Ri[j] += Ai[k] * B[k][j];', '                }', '        }', '        static double[][] pow(double[][] A, int n, long p) {', '                double[][] C = new double[n][n],R = new double[n][n], t = null;', '                for (int i = 0; i < n; i++) R[i][i] = 1;', '                while (p != 0) {', '                        if (p % 2 == 1) {', '                                mul(A, R, C, n);', '                                t = C;', '                                C = R;', '                                R = t;', '                        }', '                        mul(A, A, C, n);', '                        t = C;', '                        C = A;', '                        A = t;', '                        p >>= 1;', '                }', '                return R;', '        }', '}']"
"['import java.io.*;', 'import java.math.BigInteger;', '', 'public class Solution {', '', '    static int col = 0;', '    static long[] a;', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        int n = in.nextInt();', '        a = new long[n];', '        for (int i = 0; i < n; ++i) {', '            a[i] = new BigInteger(in.next()).longValue();', '        }', '        int ans = 0;', '        for (int mask = 0; mask < 1 << n; ++mask) {', '            col = 0;', '            int countBits = 64;', '            int add = 0;', '            for (int i = 0; i < n; ++i) {', '                if (((mask & ~col) & (1 << i)) != 0) {', '                    long mask1 = dfs(i, mask);', '                    if (mask1 != 0) {', '                        add++;', '                        countBits -= Long.bitCount(mask1);', '                    }', '                }', '            }', '            add += countBits;', '            ans += add;', '        }', '        out.println(ans);', '    }', '', '    private static long dfs(int i, int mask) {', '        if ((col & (1 << i)) != 0) {', '            return 0;', '        }', '        col |= 1 << i;', '        long ret = a[i];', '        for (int j = 0; j < a.length; ++j) {', '            if ((mask & (1 << j)) != 0 && (a[i] & a[j]) != 0) {', '                ret |= dfs(j, mask);', '            }', '        }', '        return ret;', '    }', '', '    public static void main(String[] args) throws IOException {', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    private static int findConnectedComponents(long[] nums) {', '        Result result = new Result();', '        int n = nums.length;', '        UF[] mem = new UF[0x000F_FFFF + 1];', '        mem[0] = new UF(64);', '        generateAndAdd(0, n, nums, 0, mem, result);', '        return result.sum;', '    }', '    ', '    private static void generateAndAdd(int i, int n, long[] nums,', '                                       int indices, UF[] mem, Result result) {', '        if (i == n) {', '            if (indices == 0) {', '                result.sum += mem[0].components;', '                return;', '            }', '            int index = 19;', '            while (index >= 0 && ((1 << index) & indices) == 0) {', '                index--;', '            }', '            mem[indices] = new UF(mem[indices & ~(1 << index)]);', '            for (int l = 0; l < 63; l++) {', '                if ((nums[index] & (1l << l)) == 0) {', '                    continue;', '                }', '                for (int h = l + 1; h < 64; h++) {', '                    if ((nums[index] & (1l << h)) > 0) {', '                        mem[indices].union(l, h);', '                    }', '                }', '            }', '            //System.out.println(""sum = "" + mem[indices].components);', '            result.sum += mem[indices].components;', '            return;', '        }', '        // no add', '        generateAndAdd(i + 1, n, nums, indices, mem, result);', '        // with add', '        indices |= (1 << i);', '        generateAndAdd(i + 1, n, nums, indices, mem, result);', '        indices &= ~(1 << i);', '    }', '    ', '    private static class Result {', '        private int sum = 0;', '    }', '', '    private static class UF {', '        int[] uf;', '        int[] size;', '        int n;', '        int components;', '        private UF(int n) {', '            this.n = n;', '            uf = new int[n];', '            size = new int[n];', '            components = n;', '            for (int i = 0; i < n; i++) {', '                uf[i] = i;', '                size[i] = 1;', '            }', '        }', '        private UF(UF other) {', '            this.n = other.n;', '            uf = new int[this.n];', '            size = new int[this.n];', '            components = other.components;', '            for (int i = 0; i < this.n; i++) {', '                uf[i] = other.uf[i];', '                size[i] = other.size[i];', '            }', '        }', '        private boolean union(int i, int j) {', '            int iRoot = root(i);', '            int jRoot = root(j);', '            if (iRoot == jRoot) {', '                return false;', '            }', '            components--;', '            if (size[iRoot] <= size[jRoot]) {', '                uf[iRoot] = jRoot;', '                size[jRoot] += size[iRoot];', '            } else {', '                uf[jRoot] = iRoot;', '                size[iRoot] += size[jRoot];', '            }', '            return true;', '        }', '        private int root(int i) {', '            while (uf[i] != i) {', '                i = uf[i];', '            }', '            return i;', '        }', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int dCount = scanner.nextInt();', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])?"");', '', '        long[] d = new long[dCount];', '', '        String[] dItems = scanner.nextLine().split("" "");', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])?"");', '', '        for (int i = 0; i < dCount; i++) {', '            long dItem = Long.parseLong(dItems[i]);', '            d[i] = dItem;', '        }', '', '        int components = findConnectedComponents(d);', '', '        bufferedWriter.write(String.valueOf(components));', '        bufferedWriter.newLine();', '', '        bufferedWriter.close();', '', '        scanner.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'class Node implements Comparable<Node>{', '    int val, cost;', '    Node(int val, int cost){', '        this.val = val; this.cost = cost;', '    }', '    ', '    public int compareTo(Node x){', '        return Integer.compare(this.cost, x.cost);', '    }', '}', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(System.in);', '        int t = sc.nextInt();', '        while(t-- > 0){', '            int n = sc.nextInt(), m = sc.nextInt();', '            ArrayList<ArrayList<Node>> adj = new ArrayList<ArrayList<Node>>(n+1);', '            for(int i=0; i<n+1; i++)adj.add(new ArrayList<Node>(n+1));', '        ', '            while(m-- > 0){', '                int x = sc.nextInt(), y = sc.nextInt(), cost = sc.nextInt();', '                adj.get(x).add(new Node(y, cost));', '                adj.get(y).add(new Node(x, cost));', '            }', '            int s = sc.nextInt();', '            djikstra(s, adj, n);', '        }', '    }', '    ', '    static void djikstra(int s, ArrayList<ArrayList<Node>> adj, int n){', '        int[] dist = new int[n+1];', '        Arrays.fill(dist, Integer.MAX_VALUE);', '        dist[s] = 0;', '        PriorityQueue<Node> pq = new PriorityQueue<Node>();', '        pq.add(new Node(s, 0));', '        while(pq.size() > 0){', '            Node curr = pq.peek(); pq.remove();', '            int currN = curr.val;', '            Iterator<Node> it = adj.get(currN).iterator();', '            while(it.hasNext()){', '                Node temp = it.next();', '                if(dist[temp.val] > dist[currN] + temp.cost){', '                    pq.add(new Node(temp.val, dist[currN]+temp.cost));', '                    dist[temp.val] = dist[currN] + temp.cost;', '                }', '            }', '        }', '        ', '        for(int i=1; i<dist.length; i++){', '            if(i!=s){', '                System.out.print(((dist[i] == Integer.MAX_VALUE)?-1:dist[i]) + "" "");', '            }', '        }', '        System.out.println();', '    }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    static int dist[];', '    static int n;', '    public static void main(String args[]){', '        Scanner sc=new Scanner(System.in);', '        int t=sc.nextInt();', '        while(t--!=0){', '        n=sc.nextInt();', '        int m=sc.nextInt();', '        dist=new int[n];', '        int a[][]=new int[n][n];', '        for(int i=0;i<m;i++){', '            int i1=sc.nextInt();', '            int i2=sc.nextInt();', '            int val=sc.nextInt();', '            if(a[i1-1][i2-1]!=0){', '                if(val<a[i1-1][i2-1]){', '                    a[i1-1][i2-1]=val;', '                    a[i2-1][i1-1]=val;', '                }', '            }', '            else{', '                a[i1-1][i2-1]=val;', '                a[i2-1][i1-1]=val;', '            }', '        }', '        int s=sc.nextInt()-1;', '        dijkstra(a,s);', '        for(int i=0;i<n;i++){', '            if(i!=s){', '                if(dist[i]==Integer.MAX_VALUE)', '                    System.out.print(""-1 "");', '                else', '                    System.out.print(dist[i]+"" "");', '            }', '        }', '        System.out.println();', '        }', '    }', '    ', '    public static void dijkstra(int[][] a,int s){', '        boolean set[] = new boolean[n];', '        for(int i=0;i<n;i++){', '            dist[i]=Integer.MAX_VALUE; ', '            set[i]=false;', '        }', '        dist[s]=0;', '        for(int i=0;i<n-1;i++){', '            int u=minDistance(set);', '            set[u]=true;', '            for(int v=0;v<n;v++){', '                if(!set[v]&&a[u][v]!=0&&dist[u]!=Integer.MAX_VALUE&&dist[u]+a[u][v]<dist[v])', '                    dist[v]=dist[u]+a[u][v];', '            }', '        }', '    }', '    ', '    public static int minDistance(boolean[] set){', '        int min=Integer.MAX_VALUE,min_index=0;', '        for(int i=0;i<n;i++){', '            if(set[i]==false&&dist[i]<=min){', '                min=dist[i];', '                min_index=i;', '            }', '        }', '        return min_index;', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        int e = in.nextInt();', '        ArrayList<ArrayList<Integer>> edges = new ArrayList<ArrayList<Integer>>();', '        for (int i = 0; i < n; i++) {', '            edges.add(new ArrayList<Integer>());', '        }', '        for (int a0 = 0; a0 < e; a0++) {', '            int u = in.nextInt()-1;', '            int v = in.nextInt()-1;', '            int w = in.nextInt()%10;', '            edges.get(u).add(v*10+w);', '            edges.get(v).add(u*10+(10-w)%10);', '        }', '        boolean[] vis = new boolean[n];', '        long[] ans = new long[10];', '        for (int i = 0; i < n; i++) {', '            if (vis[i])', '                continue;', '            vis[i] = true;', '            HashSet<Integer> group = new HashSet<Integer>();', '            ArrayDeque<Integer> q = new ArrayDeque<Integer>();', '            group.add(i*10);', '            q.add(i*10);', '            while (!q.isEmpty()) {', '                int u = q.removeFirst();', '                int wb = u%10;', '                u /= 10;', '                for (int vw : edges.get(u)) {', '                    int v = vw/10;', '                    int w = (wb+(vw%10))%10;', '                    int vwn = v*10+w;', '                    if (!group.contains(vwn)) {', '                        group.add(vwn);', '                        q.add(vwn);', '                        vis[v] = true;', '                    }', '                }', '            }', '            HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();', '            HashMap<Integer, Integer> counts = new HashMap<Integer, Integer>();', '            for (int j : group) {', '                hm.put(j/10, 0);', '            }', '            for (int j : group) {', '                hm.put(j/10, hm.get(j/10)|(1<<j%10));', '            }', '            for (int j : hm.keySet()) {', '                counts.put(hm.get(j), 0);', '            }', '            for (int j : hm.keySet()) {', '                counts.put(hm.get(j), counts.get(hm.get(j))+1);', '            }', '            HashMap<Integer, HashSet<Integer>> atlas = new HashMap<Integer, HashSet<Integer>>();', '            for (int j : counts.keySet()) {', '                atlas.put(j, new HashSet<Integer>());', '                for (int k = 0; k < 10; k++) {', '                    if (((1<<k)&j) > 0)', '                        atlas.get(j).add(k);', '                }', '            }', '            ', '            for (int j : counts.keySet()) {', '                for (int k : counts.keySet()) {', '                    for (int c = 0; c < 10; c++) {', '                        for (int b : atlas.get(k)) {', '                            if (atlas.get(j).contains((c+b)%10)) {', '                                if (j==k)', '                                    ans[c] += (long)counts.get(j)*(counts.get(k)-1);', '                                else', '                                    ans[c] += (long)counts.get(j)*counts.get(k);', '                                break;', '                            }', '                        }', '                    }', '                }', '            }', '        }', '        for (int i = 0; i < 10; i++) {', '            System.out.println(ans[i]);', '        }', '    }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        int e = in.nextInt();', '        ArrayList<ArrayList<Integer>> edges = new ArrayList<ArrayList<Integer>>();', '        for (int i = 0; i < n; i++) {', '            edges.add(new ArrayList<Integer>());', '        }', '        for (int a0 = 0; a0 < e; a0++) {', '            int u = in.nextInt()-1;', '            int v = in.nextInt()-1;', '            int w = in.nextInt()%10;', '            edges.get(u).add(v*10+w);', '            edges.get(v).add(u*10+(10-w)%10);', '        }', '        boolean[] vis = new boolean[n];', '        long[] ans = new long[10];', '        for (int i = 0; i < n; i++) {', '            if (vis[i])', '                continue;', '            vis[i] = true;', '            HashSet<Integer> group = new HashSet<Integer>();', '            ArrayDeque<Integer> q = new ArrayDeque<Integer>();', '            group.add(i*10);', '            q.add(i*10);', '            while (!q.isEmpty()) {', '                int u = q.removeFirst();', '                int wb = u%10;', '                u /= 10;', '                for (int vw : edges.get(u)) {', '                    int v = vw/10;', '                    int w = (wb+(vw%10))%10;', '                    int vwn = v*10+w;', '                    if (!group.contains(vwn)) {', '                        group.add(vwn);', '                        q.add(vwn);', '                        vis[v] = true;', '                    }', '                }', '            }', '            HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();', '            HashMap<Integer, Integer> counts = new HashMap<Integer, Integer>();', '            for (int j : group) {', '                hm.put(j/10, 0);', '            }', '            for (int j : group) {', '                hm.put(j/10, hm.get(j/10)|(1<<j%10));', '            }', '            for (int j : hm.keySet()) {', '                counts.put(hm.get(j), 0);', '            }', '            for (int j : hm.keySet()) {', '                counts.put(hm.get(j), counts.get(hm.get(j))+1);', '            }', '            HashMap<Integer, HashSet<Integer>> atlas = new HashMap<Integer, HashSet<Integer>>();', '            for (int j : counts.keySet()) {', '                atlas.put(j, new HashSet<Integer>());', '                for (int k = 0; k < 10; k++) {', '                    if (((1<<k)&j) > 0)', '                        atlas.get(j).add(k);', '                }', '            }', '            ', '            for (int j : counts.keySet()) {', '                for (int k : counts.keySet()) {', '                    for (int c = 0; c < 10; c++) {', '                        for (int b : atlas.get(k)) {', '                            if (atlas.get(j).contains((c+b)%10)) {', '                                if (j==k)', '                                    ans[c] += (long)counts.get(j)*(counts.get(k)-1);', '                                else', '                                    ans[c] += (long)counts.get(j)*counts.get(k);', '                                break;', '                            }', '                        }', '                    }', '                }', '            }', '        }', '        for (int i = 0; i < 10; i++) {', '            System.out.println(ans[i]);', '        }', '    }', '}']"
"['import java.io.BufferedInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.util.HashMap;', 'import java.util.Map;', '', 'public class Solution {', '', '    private static final Map<Long, long[]> cache = new HashMap<>();', '    private static int N;', '    private static int M;', '    private static int[] C;', '    private static long[] R;', '', '    public static void main(String[] args) {', '        N = readInt();', '        M = readInt();', '        C = new int[N];', '        for (int i = 0; i < N; i++) {', '            C[i] = readInt();', '        }', '        R = new long[N];', '        for (int i = 0; i < M; i++) {', '            int a = readInt() - 1,', '                b = readInt() - 1;', '            R[a] |= 1L << b;', '            R[b] |= 1L << a;', '        }', '        long mask = (1L << N) - 1;', '        long[] result = solve(mask, 0L);', '        System.out.println(result[0] + "" "" + result[1]);', '    }', '', '    private static long[] solve(long mask, long sum) {', '        if (mask == 0) {', '            return new long[] { sum, 1 };', '        }', '        Long maskL = mask;', '        long[] cached = cache.get(maskL);', '        if (cached != null) {', '            return new long[] { cached[0] + sum, cached[1] };', '        }', '        int town = getTown(mask);', '        mask &= ~(1L << town);', '', '        long[] s1 = solve(mask, sum);', '        long[] s2 = solve(mask & ~R[town], sum + C[town]);', '', '        if (s1[0] == s2[0]) {', '            cached = new long[] { s1[0], s1[1] + s2[1] };', '        } else if (s1[0] > s2[0]) {', '            cached = s1;', '        } else {', '            cached = s2;', '        }', '        cache.put(maskL, new long[] { cached[0] - sum, cached[1] });', '        return cached;', '    }', '', '    private static int getTown(long l) {', '        return Long.bitCount(Long.highestOneBit(l) - 1);', '    }', '', '    static InputStream in = new BufferedInputStream(System.in);', '', '    static int readInt() {', '        try {', '            int c = in.read();', '            while (c <= 32) {', '                c = in.read();', '            }', '            boolean minus = false;', ""            if (c == '-') {"", '                minus = true;', '                c = in.read();', '            }', ""            int result = (c - '0');"", '            c = in.read();', ""            while (c >= '0') {"", ""                result = result * 10 + (c - '0');"", '                c = in.read();', '            }', '            return minus ? -result : result;', '        } catch (IOException e) {', '            return -1; // should not happen', '        }', '    }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        //try{in = new Scanner(new FileReader(""test2.txt""));}catch(Exception e){}', '        ', '        int numHouses = in.nextInt();', '        int numRoads = in.nextInt();', '        ', '        house houses[] = new house[numHouses];', '        ', '        ', '        for(int i=0; i<numHouses; i++){ // input houses', '            houses[i] = new house();', '            houses[i].money = in.nextInt();', '        }', '        ', '        for(int i=0; i<numRoads; i++){ // input roads', '            int A = in.nextInt() - 1;', '            int B = in.nextInt() - 1;', '            houses[A].neighbours.add(houses[B]);', '            houses[B].neighbours.add(houses[A]);', '        }', '        ', '        ', '        int defaultprofit = 0;', '        long multiplier = 1;', '        for(house h : houses){', '            if(h.neighbours.isEmpty()){', '                defaultprofit += h.money;', '                h.left = -2;', '                if(0 == h.money){multiplier *= 2;}', '            }', '        }', '        ', '        ', '        plunder(houses,0,0);', '        ', '        System.out.print(bestprofit + defaultprofit);', '        System.out.print("" "");', '        System.out.println(bestprofitperms * multiplier);', '        //System.out.println(combinations);', '        ', '    }', '    ', '    static int bestprofit=0;', '    static long bestprofitperms=0;', '    static long combinations=0;', '    ', '    static void plunder(house[] houses, int depth, int profit){', '        if(depth >= houses.length){', '            if(bestprofit == profit){bestprofitperms++;}', '            ', '            if(bestprofit < profit){', '                bestprofit = profit;', '                bestprofitperms = 1;', '            }', '            //combinations++;', '            return;', '        }', '        ', '        house h = houses[depth];', '        ', '        plunder(houses, depth+1, profit);', '        ', '        if(-1 == h.left){', '            for(house n : h.neighbours){', '                if(-1 == n.left){n.left = depth;}', '            }', '            plunder(houses,depth+1,profit + h.money);', '            for(house n : h.neighbours){', '                if(depth == n.left){n.left = -1;}', '            }', '        }', '    }', '}', '', '', '', '', 'class house{', '    int money;', '    int left;', '    ArrayList<house> neighbours;', '    ', '    house(){', '        left = -1;', '        neighbours = new ArrayList();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(System.in);', '        int t = sc.nextInt();', '        for (int z = 0; z < t; z++) {', '            int n = sc.nextInt();', '            int m = sc.nextInt();', '            ArrayList<ArrayList<Integer>> neigh = new ArrayList<ArrayList<Integer>>();', '            for (int i = 0; i < n; i++)', '                neigh.add(new ArrayList<Integer>());', '            for (int i = 0; i < m; i++) {', '                int u = sc.nextInt()-1;', '                int v = sc.nextInt()-1;', '                neigh.get(u).add(v);', '                neigh.get(v).add(u);', '            }', '            long[] adds = new long[n+1];', '            for (int i = 2; i <= n; i++) {', '                adds[i] = adds[i-1] + ((long)i)*(i-1);', '            }', '            ArrayList<Integer> cycles = new ArrayList<Integer>();', '            boolean[] vis = new boolean[n];', '            for (int i = 0; i < n; i++) {', '                if (!vis[i]) {', '                    int clen = 1;', '                    vis[i] = true;', '                    ArrayDeque<Integer> qu = new ArrayDeque<Integer>();', '                    qu.add(i);', '                    while (!qu.isEmpty()) {', '                        int u = qu.removeFirst();', '                        for (int v : neigh.get(u)) {', '                            if (!vis[v]) {', '                                clen++;', '                                qu.add(v);', '                                vis[v] = true;', '                            }', '                        }', '                    }', '                    cycles.add(clen);', '                }', '            }', '            long ans = 0;', '            Collections.sort(cycles);', '            int index = 0;', '            for (int i = cycles.size()-1; i >= 0; i--) {', '                int c = cycles.get(i);', '                ans += adds[c];', '                index += c-1;', '                ans += ((long)c)*(c-1)*(m-index);', '            }', '            System.out.println(ans);', '        }', '    }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(System.in);', '        int t = sc.nextInt();', '        for (int z = 0; z < t; z++) {', '            int n = sc.nextInt();', '            int m = sc.nextInt();', '            ArrayList<ArrayList<Integer>> neigh = new ArrayList<ArrayList<Integer>>();', '            for (int i = 0; i < n; i++)', '                neigh.add(new ArrayList<Integer>());', '            for (int i = 0; i < m; i++) {', '                int u = sc.nextInt()-1;', '                int v = sc.nextInt()-1;', '                neigh.get(u).add(v);', '                neigh.get(v).add(u);', '            }', '            long[] adds = new long[n+1];', '            for (int i = 2; i <= n; i++) {', '                adds[i] = adds[i-1] + ((long)i)*(i-1);', '            }', '            ArrayList<Integer> cycles = new ArrayList<Integer>();', '            boolean[] vis = new boolean[n];', '            for (int i = 0; i < n; i++) {', '                if (!vis[i]) {', '                    int clen = 1;', '                    vis[i] = true;', '                    ArrayDeque<Integer> qu = new ArrayDeque<Integer>();', '                    qu.add(i);', '                    while (!qu.isEmpty()) {', '                        int u = qu.removeFirst();', '                        for (int v : neigh.get(u)) {', '                            if (!vis[v]) {', '                                clen++;', '                                qu.add(v);', '                                vis[v] = true;', '                            }', '                        }', '                    }', '                    cycles.add(clen);', '                }', '            }', '            long ans = 0;', '            Collections.sort(cycles);', '            int index = 0;', '            for (int i = cycles.size()-1; i >= 0; i--) {', '                int c = cycles.get(i);', '                ans += adds[c];', '                index += c-1;', '                ans += ((long)c)*(c-1)*(m-index);', '            }', '            System.out.println(ans);', '        }', '    }', '}']"
"['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    static int n, q;', '    static int[] nodes;', '    static List<Integer>[] adList;', '    static Query[] queries; ', '    static int[][] nodeFactors;', '    static int MAXN = 25005;', '    static int LN = 19;', '     ', '    static int cur;', '    static int[] LVL = new int[MAXN];', '    static int[][] DP = new int[LN][MAXN];', '    static int[] BL = new int[MAXN << 1], ID = new int[MAXN << 1];', '    static int[] l = new int[MAXN], r = new int[MAXN];', '    ', '    static boolean[] VIS = new boolean[MAXN];', '    ', '    static int pLength = 10000001;', '    static boolean[] pBoolean = new boolean[pLength];', '    static List<Integer> primes;', '', '    static {', '        primes = new ArrayList<Integer>();', '        for (int i = 2; i < pLength; i++) {', '            if (pBoolean[i]) {', '                continue;', '            }', '            primes.add(i);', '            for (long j = (long) i * i; j < pLength; j += i) {', '                pBoolean[(int) j] = true;', '            }', '        }', '    }', '    ', '    static class Query{', '        int id, l, r, lc;', '    }', '    ', '    static class Result{', '        int n, ans;', '        int[] nFactor = new int[10000001];', '        ', '        public void remove(int x) {', '            int[] fac = nodeFactors[x];', '            int len = fac[3];', '            switch (len) {', '            case 0:', '                ans -= (n-1);', '                n--;', '                break;', '            case 1:', '                ans -= (n-1) - (nFactor[fac[0]] - 1);', '                nFactor[fac[0]]--;', '                n--;', '                break;', '            case 2:', '                int nP = (nFactor[fac[0]] - 1) + (nFactor[fac[1]] - 1) - (nFactor[fac[0] * fac[1]] - 1);', '                ans -= (n-1)-nP;', '                nFactor[fac[0]]--;', '                nFactor[fac[1]]--;', '                nFactor[fac[0] * fac[1]]--;', '                n--;', '                break;', '            case 3:', '                nP = nFactor[fac[0]]-1 + nFactor[fac[1]]-1 + nFactor[fac[2]]-1 - ', '                        (nFactor[fac[0] * fac[1]]-1 +nFactor[fac[0] * fac[2]]-1 + nFactor[fac[1] * fac[2]]-1) +', '                        nFactor[fac[0] * fac[1] * fac[2]]-1;', '                ans -= (n-1)-nP;', '                nFactor[fac[0]]--;', '                nFactor[fac[1]]--;', '                nFactor[fac[2]]--;', '                nFactor[fac[0] * fac[1]]--;', '                nFactor[fac[0] * fac[2]]--;', '                nFactor[fac[1] * fac[2]]--;', '                nFactor[fac[0] * fac[1] * fac[2]]--;', '                n--;', '                break;', '            default:', '                break;', '            }            ', '        }', '', '        public void add(int x) {', '            int[] fac = nodeFactors[x];', '            int len = fac[3];', '            switch (len) {', '            case 0:', '                ans += n;', '                n++;', '                break;', '            case 1:', '                ans += n - nFactor[fac[0]];', '                nFactor[fac[0]]++;', '                n++;', '                break;', '            case 2:', '                int nP = nFactor[fac[0]] + nFactor[fac[1]] - nFactor[fac[0] * fac[1]];', '                ans += n-nP;', '                nFactor[fac[0]]++;', '                nFactor[fac[1]]++;', '                nFactor[fac[0] * fac[1]]++;', '                n++;', '                break;', '            case 3:', '                nP = nFactor[fac[0]] + nFactor[fac[1]] + nFactor[fac[2]] - ', '                        (nFactor[fac[0] * fac[1]] + nFactor[fac[0] * fac[2]] + nFactor[fac[1] * fac[2]]) +', '                        nFactor[fac[0] * fac[1] * fac[2]];', '                ans += n-nP;', '                nFactor[fac[0]]++;', '                nFactor[fac[1]]++;', '                nFactor[fac[2]]++;', '                nFactor[fac[0] * fac[1]]++;', '                nFactor[fac[0] * fac[2]]++;', '                nFactor[fac[1] * fac[2]]++;', '                nFactor[fac[0] * fac[1] * fac[2]]++;', '                n++;', '                break;', '            default:', '                break;', '            }', '        }', '    }', '    ', '    static void dfs(int u, int par){', '        l[u] = ++cur; ', '        ID[cur] = u;', '        for (int i = 1; i < LN; i++) DP[i][u] = DP[i - 1][DP[i - 1][u]];', '        List<Integer> listU = adList[u];', '        for (int i = 0; i < listU.size(); i++){', '            int v = listU.get(i);', '            if (v == par) {', '                continue;', '            }', '            LVL[v] = LVL[u] + 1;', '            DP[0][v] = u;', '            dfs(v, u);', '        }', '        r[u] = ++cur;', '        ID[cur] = u;', '    }', '     ', '    static int lca(int u, int v){', '        if (LVL[u] > LVL[v]) {', '            int temp = u;', '            u = v;', '            v = temp;', '        }', '        for (int i = LN - 1; i >= 0; i--) {', '            if (LVL[v] - (1 << i) >= LVL[u]) {', '                v = DP[i][v];', '            }', '        }', '        if (u == v) {', '            return u;', '        }', '        for (int i = LN - 1; i >= 0; i--){', '            if (DP[i][u] != DP[i][v]){', '                u = DP[i][u];', '                v = DP[i][v];', '            }', '        }', '        return DP[0][u];', '    }', '    ', '    static void check(int x, Result res){', '        if (VIS[x]) {', '            res.remove(x); ', '        } else {', '            res.add(x);', '        }', '        VIS[x] = !VIS[x];', '    }', '     ', '    private static int[] getCP() {', '        int[] ans = new int[q]; ', '        fillFactors();', '        Arrays.sort(queries, new Comparator<Query>() {', '            @Override', '            public int compare(Query q1, Query q2) {', '                return (BL[q1.l] == BL[q2.l]) ? (q1.r - q2.r) : (BL[q1.l] - BL[q2.l]);', '            }});', '        int curL = queries[0].l, curR = queries[0].l - 1;', '        Result res = new Result();', '         for (int i = 0; i < q; i++){', '             while (curL < queries[i].l) {', '                 check(ID[curL++], res);', '             }', '            while (curL > queries[i].l) {', '                check(ID[--curL], res);', '            }', '            while (curR < queries[i].r) {', '                check(ID[++curR], res);', '            }', '            while (curR > queries[i].r) {', '                check(ID[curR--], res);', '            }', '            int u = ID[curL], v = ID[curR];', '     ', '            if (queries[i].lc != u && queries[i].lc != v) {', '                check(queries[i].lc, res);', '            }', '             ans[queries[i].id] = res.ans;', '             if (queries[i].lc != u && queries[i].lc != v) {', '                 check(queries[i].lc, res);', '             }', '        }', '         return ans;', '    }', '', '    private static void fillFactors() {', '        nodeFactors = new int[n+1][4];', '        for(int i = 1;i <= n;i++) {', '            int index = 0;', '            int k = nodes[i];', '            for (int s = 0, j = 2; j <= Math.sqrt(nodes[i]); j=primes.get(++s)){', '                if(k%j==0) {', '                    nodeFactors[i][index++] = j;', '                    while (k%j == 0){ ', '                        k /= j; ', '                    }', '                }', '                if(index == 3) {', '                    break;', '                }', '            } ', '            if (k >= 2) {', '                nodeFactors[i][index++] = k;', '            }                 ', '            nodeFactors[i][3] = index;            ', '        }', '    }', '', '    public static void main(String[] args) throws IOException {', '        new Thread(null, new Problem(), ""JS"", 1 << 26).start();        ', '    }', '    ', '    static class Problem implements Runnable {', '', '        public void run() {', '            try {', '               BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 2 * 4096 * 4096);', '                String[] nq = reader.readLine().trim().split("" "");', '                n = Integer.parseInt(nq[0]);', '                q = Integer.parseInt(nq[1]);', '                nodes = new int[n+1];', '                String[] nodesItems = reader.readLine().trim().split("" "");        ', '                for (int i = 0; i < n; i++) {', '                    int nodesItem = Integer.parseInt(nodesItems[i]);', '                    nodes[i+1] = nodesItem;            ', '                }', '                adList = new ArrayList[n+1];', '                for (int i = 1; i <= n; i++) {', '                    adList[i] = new ArrayList<Integer>();', '                }       ', '                for (int treeRowItr = 0; treeRowItr < n-1; treeRowItr++) {', '                    String[] treeRowItems = reader.readLine().trim().split("" "");', '                    int u = Integer.parseInt(treeRowItems[0]);', '                    int v = Integer.parseInt(treeRowItems[1]);', '                    adList[u].add(v);', '                    adList[v].add(u);            ', '                }        ', '                DP[0][1] = 1;', '                dfs(1, -1);', '                int size = (int) Math.sqrt(cur);', '                 for (int i = 1; i <= cur; i++) {', '                     BL[i] = (i - 1) / size + 1;', '                 }', '                 queries = new Query[q];', '                for (int i = 0; i < q; i++) {', '                    String[] uv = reader.readLine().trim().split("" "");', '                    int u = Integer.parseInt(uv[0]);', '                    int v = Integer.parseInt(uv[1]);', '                    Query query = new Query();', '                    query.lc = lca(u, v);', '                    if (l[u] > l[v]) {', '                        int temp = u;', '                        u = v;', '                        v = temp;                ', '                    }', '                    if (query.lc == u) {', '                        query.l = l[u];', '                        query.r = l[v];', '                    } else {', '                        query.l = r[u];', '                        query.r = l[v];', '                    }', '                    query.id = i;', '                    queries[i] = query;', '                }', '                int[] result = getCP();', '                for (int resultItr = 0;resultItr < result.length;resultItr++) {', '                    System.out.println(result[resultItr]);                    ', '                }', '                reader.close();                ', '            } catch (Exception e) {', '            }', '        }', '    }', '}']","['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class F {', '    InputStream is;', '    PrintWriter out;', '    String INPUT = """";', '    ', '    long ret;', '    int[] freq;', '    int[] pfreq;', '    EulerTour et;', '    int[] lpf = enumLowestPrimeFactors(10000005);', '    int[] mob = enumMobiusByLPF(10000005, lpf);', '    int[] a;', '    ', '    void solve()', '    {', '        int n = ni(), Q = ni();', '        a = na(n);', '        for(int i = 0;i < n;i++){', '            int pre = -1;', '            int mul = 1;', '            for(int j = a[i];j > 1;j /= lpf[j]){', '                if(pre != lpf[j]){', '                    mul *= lpf[j];', '                    pre = lpf[j];', '                }', '            }', '            a[i] = mul;', '        }', '        ', '        int[] from = new int[n - 1];', '        int[] to = new int[n - 1];', '        for (int i = 0; i < n - 1; i++) {', '            from[i] = ni() - 1;', '            to[i] = ni() - 1;', '        }', '        int[][] g = packU(n, from, to);', '        int[][] pars = parents3(g, 0);', '        int[] par = pars[0], ord = pars[1], dep = pars[2];', '        ', '        et = nodalEulerTour(g, 0);', '        int[][] spar = logstepParents(par);', '        ', '        int[][] qs = new int[Q][];', '        int[] special = new int[Q];', '        Arrays.fill(special, -1);', '        for(int i = 0;i < Q;i++){', '            int x = ni()-1, y = ni()-1;', '            int lca = lca2(x, y, spar, dep);', '            if(lca == x){', '                qs[i] = new int[]{et.first[x], et.first[y]};', '            }else if(lca == y){', '                qs[i] = new int[]{et.first[y], et.first[x]};', '            }else if(et.first[x] < et.first[y]){', '                qs[i] = new int[]{et.last[x], et.first[y]};', '                special[i] = lca;', '            }else{', '                qs[i] = new int[]{et.last[y], et.first[x]};', '                special[i] = lca;', '            }', '        }', '        ', '        long[] pqs = sqrtSort(qs, 2*n-1);', '        ', '        int L = 0, R = -1;', '        freq = new int[n];', '        ', '        long[] ans = new long[Q];', '        pfreq = new int[10000005];', '        for(long pa : pqs){', '            int ind = (int)(pa&(1<<25)-1);', '            int ql = qs[ind][0], qr = qs[ind][1];', '            while(R < qr)change(++R, 1);', '            while(L > ql)change(--L, 1);', '            while(R > qr)change(R--, -1);', '            while(L < ql)change(L++, -1);', '            if(special[ind] != -1)change(et.first[special[ind]], 1);', '', '            ans[ind] = ret;', '            if(special[ind] != -1)change(et.first[special[ind]], -1);', '        }', '        for(long v : ans){', '            out.println(v);', '        }', '    }', '    ', '    public static void trnz(int... o)', '    {', '        for(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+"":""+o[i]+"" "");', '        System.out.println();', '    }', '', '    ', '    public static int[] enumMobiusByLPF(int n, int[] lpf)', '    {', '        int[] mob = new int[n+1];', '        mob[1] = 1;', '        for(int i = 2;i <= n;i++){', '            int j = i/lpf[i];', '            if(lpf[j] == lpf[i]){', '//                mob[i] = 0;', '            }else{', '                mob[i] = -mob[j];', '            }', '        }', '        return mob;', '    }', '    ', '    void dfs(int cur, int n, int d)', '    {', '        if(n == 1){', '            if(d > 0)ret += mob[cur] * pfreq[cur];', '            pfreq[cur] += d;', '            if(d < 0)ret -= mob[cur] * pfreq[cur];', '            return;', '        }', '        ', '        dfs(cur, n/lpf[n], d);', '        dfs(cur/lpf[n], n/lpf[n], d);', '    }', '    ', '    void change(int x, int d)', '    {', '        int ind = et.vs[x];', '        if(freq[ind] == 1){', '            dfs(a[ind], a[ind], -1);', '        }', '        freq[ind] += d;', '        if(freq[ind] == 1){', '            dfs(a[ind], a[ind], 1);', '        }', '    }', '    ', '    public static long[] sqrtSort(int[][] qs, int n)', '    {', '        int m = qs.length;', '        long[] pack = new long[m];', '        int S = (int)Math.sqrt(n);', '        for(int i = 0;i < m;i++){', '            pack[i] = (long)qs[i][0]/S<<50|(long)((qs[i][0]/S&1)==0?qs[i][1]:(1<<25)-1-qs[i][1])<<25|i;', '        }', '        Arrays.sort(pack);', '        return pack;', '    }', '    ', '    ', '    public static int lca2(int a, int b, int[][] spar, int[] depth) {', '        if (depth[a] < depth[b]) {', '            b = ancestor(b, depth[b] - depth[a], spar);', '        } else if (depth[a] > depth[b]) {', '            a = ancestor(a, depth[a] - depth[b], spar);', '        }', '', '        if (a == b)', '            return a;', '        int sa = a, sb = b;', '        for (int low = 0, high = depth[a], t = Integer.highestOneBit(high), k = Integer', '                .numberOfTrailingZeros(t); t > 0; t >>>= 1, k--) {', '            if ((low ^ high) >= t) {', '                if (spar[k][sa] != spar[k][sb]) {', '                    low |= t;', '                    sa = spar[k][sa];', '                    sb = spar[k][sb];', '                } else {', '                    high = low | t - 1;', '                }', '            }', '        }', '        return spar[0][sa];', '    }', '', '    protected static int ancestor(int a, int m, int[][] spar) {', '        for (int i = 0; m > 0 && a != -1; m >>>= 1, i++) {', '            if ((m & 1) == 1)', '                a = spar[i][a];', '        }', '        return a;', '    }', '', '    public static int[][] logstepParents(int[] par) {', '        int n = par.length;', '        int m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1;', '        int[][] pars = new int[m][n];', '        pars[0] = par;', '        for (int j = 1; j < m; j++) {', '            for (int i = 0; i < n; i++) {', '                pars[j][i] = pars[j - 1][i] == -1 ? -1 : pars[j - 1][pars[j - 1][i]];', '            }', '        }', '        return pars;', '    }', '', '', '    ', '    public static class EulerTour', '    {', '        public int[] vs; ', '        public int[] first;', '        public int[] last; ', '        ', '        public EulerTour(int[] vs, int[] f, int[] l) {', '            this.vs = vs;', '            this.first = f;', '            this.last = l;', '        }', '    }', '    ', '    public static EulerTour nodalEulerTour(int[][] g, int root)', '    {', '        int n = g.length;', '        int[] vs = new int[2*n];', '        int[] f = new int[n];', '        int[] l = new int[n];', '        int p = 0;', '        Arrays.fill(f, -1);', '        ', '        int[] stack = new int[n];', '        int[] inds = new int[n];', '        int sp = 0;', '        stack[sp++] = root;', '        outer:', '        while(sp > 0){', '            int cur = stack[sp-1], ind = inds[sp-1];', '            if(ind == 0){', '                vs[p] = cur;', '                f[cur] = p;', '                p++;', '            }', '            while(ind < g[cur].length){', '                int nex = g[cur][ind++];', '                if(f[nex] == -1){ ', '                    inds[sp-1] = ind;', '                    stack[sp] = nex;', '                    inds[sp] = 0;', '                    sp++;', '                    continue outer;', '                }', '            }', '            inds[sp-1] = ind;', '            if(ind == g[cur].length){', '                vs[p] = cur;', '                l[cur] = p;', '                p++;', '                sp--;', '            }', '        }', '        ', '        return new EulerTour(vs, f, l);', '    }', '', '', '    public static int[][] parents3(int[][] g, int root) {', '        int n = g.length;', '        int[] par = new int[n];', '        Arrays.fill(par, -1);', '', '        int[] depth = new int[n];', '        depth[0] = 0;', '', '        int[] q = new int[n];', '        q[0] = root;', '        for (int p = 0, r = 1; p < r; p++) {', '            int cur = q[p];', '            for (int nex : g[cur]) {', '                if (par[cur] != nex) {', '                    q[r++] = nex;', '                    par[nex] = cur;', '                    depth[nex] = depth[cur] + 1;', '                }', '            }', '        }', '        return new int[][] { par, q, depth };', '    }', '', '    static int[][] packU(int n, int[] from, int[] to) {', '        int[][] g = new int[n][];', '        int[] p = new int[n];', '        for (int f : from)', '            p[f]++;', '        for (int t : to)', '            p[t]++;', '        for (int i = 0; i < n; i++)', '            g[i] = new int[p[i]];', '        for (int i = 0; i < from.length; i++) {', '            g[from[i]][--p[from[i]]] = to[i];', '            g[to[i]][--p[to[i]]] = from[i];', '        }', '        return g;', '    }', '', '    ', '    public static int[] enumLowestPrimeFactors(int n) {', '        int tot = 0;', '        int[] lpf = new int[n + 1];', '        int u = n + 32;', '        double lu = Math.log(u);', '        int[] primes = new int[(int) (u / lu + u / lu / lu * 1.5)];', '        for (int i = 2; i <= n; i++)', '            lpf[i] = i;', '        for (int p = 2; p <= n; p++) {', '            if (lpf[p] == p)', '                primes[tot++] = p;', '            int tmp;', '            for (int i = 0; i < tot && primes[i] <= lpf[p] && (tmp = primes[i] * p) <= n; i++) {', '                lpf[tmp] = primes[i];', '            }', '        }', '        return lpf;', '    }', '', '    ', '    void run() throws Exception', '    {', '        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        long s = System.currentTimeMillis();', '        solve();', '        out.flush();', '        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', '    }', '    ', '    public static void main(String[] args) throws Exception { new F().run(); }', '    ', '    private byte[] inbuf = new byte[1024];', '    public int lenbuf = 0, ptrbuf = 0;', '    ', '    private int readByte()', '    {', '        if(lenbuf == -1)throw new InputMismatchException();', '        if(ptrbuf >= lenbuf){', '            ptrbuf = 0;', '            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '            if(lenbuf <= 0)return -1;', '        }', '        return inbuf[ptrbuf++];', '    }', '    ', '    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', '    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', '    ', '    private double nd() { return Double.parseDouble(ns()); }', '    private char nc() { return (char)skip(); }', '    ', '    private String ns()', '    {', '        int b = skip();', '        StringBuilder sb = new StringBuilder();', '        while(!(isSpaceChar(b))){ ', '            sb.appendCodePoint(b);', '            b = readByte();', '        }', '        return sb.toString();', '    }', '    ', '    private char[] ns(int n)', '    {', '        char[] buf = new char[n];', '        int b = skip(), p = 0;', '        while(p < n && !(isSpaceChar(b))){', '            buf[p++] = (char)b;', '            b = readByte();', '        }', '        return n == p ? buf : Arrays.copyOf(buf, p);', '    }', '    ', '    private char[][] nm(int n, int m)', '    {', '        char[][] map = new char[n][];', '        for(int i = 0;i < n;i++)map[i] = ns(m);', '        return map;', '    }', '    ', '    private int[] na(int n)', '    {', '        int[] a = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        return a;', '    }', '    ', '    private int ni()', '    {', '        int num = 0, b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private long nl()', '    {', '        long num = 0;', '        int b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int g = in.nextInt();', '        for(int a0 = 0; a0 < g; a0++){', '            long n = in.nextLong();', '            long m = in.nextLong();', '            long s = in.nextLong();', '            if (m <= (n-2)*(n-3)/2+n-1) {', '                System.out.println(s+m-n+1);', '            } else {', '                long ans = s+m-n+1+(m-(n-2)*(n-3)/2-n+1)*(s-n+1);', '                long x = s/(n-1);', '                if (x*(n-1)==s) {', '                    ans = Math.min(ans, m*x);', '                } else {', '                    long mod = n-1-s%(n-1);', '                    ans = Math.min(ans, m*(x+1)-mod*(mod+1)/2);', '                    ans = Math.min(ans, s+(m-n+1)*x+(m-(n-2)*(n-3)/2-n+1)*(s-x*(n-1)));', '                }', '                System.out.println(ans);', '            }', '        }', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    private static long minimumWeight(long n, long m, long s) {', '        if (m <= (n - 1)*(n - 2)/2 + 1) {', '            return m + s - n + 1;', '        } else {', '            long core = (n - 1)*(n - 2)/2;', '            long unbalanced = core + (s - n + 2)*(m - core);', '            ', '            long base = s/(n - 1);', '            long larger = s - base*(n - 1);', '            long smaller = n - 1 - larger;', '', '            long midbalanced = base*core + (base + larger)*(m - core);', '            ', '            long balanced;', '            if (larger > 0) {', '                core = smaller*(smaller + 1)/2;', '                balanced = base*core + (base + 1)*(m - core);', '            } else {', '                balanced = base*m;', '            }', '            ', '            return Math.min(Math.min(unbalanced, balanced), midbalanced);', '        }', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) {', '        int g = scanner.nextInt();', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])?"");', '', '        for (int gItr = 0; gItr < g; gItr++) {', '            String[] nms = scanner.nextLine().split("" "");', '', '            int n = Integer.parseInt(nms[0]);', '', '            long m = Long.parseLong(nms[1]);', '', '            long s = Long.parseLong(nms[2]);', '', '            System.out.println(String.format(""%d"", minimumWeight(n, m, s)));', '        }', '', '        scanner.close();', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.ArrayList;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', 'import java.util.List;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void dfs(int n, int rd, int res, int[] dim, List<int[]> dims, int num)', ' {', '  if(res == 0){', '   dim[n] = num;', '   if(rd == 0)dims.add(Arrays.copyOf(dim, dim.length));', '  }else{', '   for(int i = 1;i <= rd;i++){', '    dim[n-res] = i;', '    dfs(n, rd-i, res-1, dim, dims, num);', '    num /= i;', '   }', '  }', ' }', ' ', ' static void solve()', ' {', '  List<List<int[]>> dist = new ArrayList<List<int[]>>();', '  dist.add(null);', '  dist.add(null);', '  for(int i = 2;i <= 10;i++){', '   int f = 1;', '   for(int j = 1;j <= i-2;j++){', '    f *= j;', '   }', '   List<int[]> dims = new ArrayList<int[]>();', '   dfs(i, 2*(i-1), i, new int[i+1], dims, f);', '   dist.add(dims);', '  }', '  ', '  int mod = 1000000007;', '  for(int T = ni();T >= 1;T--){', '   int n = ni();', '   int[] b = na(n);', '   long ret = 1;', '   if(n > 1){', '    for(int i = 0;i < n;i++){', '     ret = ret * pow(b[i], b[i]-2, mod) % mod;', '    }', '    ', '    long lsum = 0;', '    for(int[] dim : dist.get(n)){', '     long lmul = 1;', '     for(int i = 0;i < n;i++){', '      lmul = lmul * pow(b[i], dim[i], mod) % mod;', '     }', '     lsum += lmul * dim[n] % mod;', '    }', '    lsum %= mod;', '    ret = ret * lsum % mod;', '   }else{', '    ret = pow(b[0], b[0]-2, mod);', '   }', '   out.println(ret);', '  }', ' }', ' ', ' public static long invl(long a, long mod)', ' {', '  long b = mod;', '  long p = 1, q = 0;', '  while(b > 0){', '   long c = a / b;', '   long d;', '   d = a; a = b; b = d % b;', '   d = p; p = q; q = d - c * q;', '  }', '  return p < 0 ? p + mod : p;', ' }', ' ', ' public static long pow(long a, long n, long mod)', ' {', '  long ret = 1;', '  int x = 63-Long.numberOfLeadingZeros(n);', '  for(;x >= 0;x--){', '   ret = ret * ret % mod;', '   if(n<<63-x<0)ret = ret * a % mod;', '  }', '  return ret;', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.math.BigInteger;', 'import java.util.Scanner;', '', 'public class BeadOrnament {', '', '    public static void main(String[] args) {', '        // TODO code application logic here', '        Scanner stdin = new Scanner(System.in);', '', '        int T, N;', '', '        T = stdin.nextInt();', '', '        while (T-- > 0) {', '', '            N = stdin.nextInt();', '', '            int[] colors = new int[N];', '            BigInteger[] trees = new BigInteger[N];', '', '            BigInteger ornaments;', '', '            for (int i = 0; i < N; i++) {', '                colors[i] = stdin.nextInt();', '            }', '', '            BigInteger t = BigInteger.valueOf(1);', '            for (int i = 0; i < N; i++) {', '                trees[i] = numberOfTrees(colors[i]);', '                t = t.multiply(trees[i]);', '            }', '', '            BigInteger sp = BigInteger.valueOf(1);', '            BigInteger ss = BigInteger.valueOf(0);', '            BigInteger tot = BigInteger.valueOf(0);', '', '            for (int i = 0; i < N; i++) {', '                sp = sp.multiply(BigInteger.valueOf(colors[i]));', '                ss = ss.add(BigInteger.valueOf(colors[i]));', '            }', '', '            if (N > 2) {', '                ss = ss.pow(colors.length - 2);', '                ss = ss.multiply(sp);', '                tot = ss;', '                ornaments = tot.multiply(t);', '            } else if (N == 2) {', '                tot = sp;', '                ornaments = tot.multiply(t);', '            } else {', '                ornaments = t;', '            }', '', '            System.out.println(ornaments.mod(BigInteger.valueOf(1000000007)));', '        }', '    }', '', '    public static BigInteger numberOfTrees(int beadCount) {', '        if (beadCount <= 2) {', '            return BigInteger.ONE;', '        }', '        return BigInteger.valueOf(beadCount).pow(beadCount - 2);', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner stdIn = new Scanner(System.in);', '        String ve = stdIn.nextLine();', '        String[] tmp = ve.split("" "");', '        int V = Integer.parseInt(tmp[0]);', '        int E = Integer.parseInt(tmp[1]);', '        int[][] graph = new int[V+1][V+1];', '        ', '        for(int i=1;i<=V;i++){', '            for(int j=1;j<=V;j++){', '                if(i==j){', '                    graph[i][j] = 0;', '                }', '                else{', '                    graph[i][j] = 140000; ', '                }', '            }', '        }', '        ', '        for(int i=0;i<E;i++){', '            String inp_edge = stdIn.nextLine();', '            String[] temp = inp_edge.split("" "");', '            int v1 = Integer.parseInt(temp[0]);', '            int v2 = Integer.parseInt(temp[1]);', '            int w = Integer.parseInt(temp[2]);', '            ', '            graph[v1][v2] = w;', '        }', '        ', '        for(int k=1;k<=V;k++){', '            for(int i=1;i<=V;i++){', '                for(int j=1;j<=V;j++){', '                    graph[i][j] = Math.min(graph[i][k]+graph[k][j],graph[i][j]);', '                }', '            }', '        }', '        int Q = stdIn.nextInt();', '        String buffer = stdIn.nextLine();', '        for(int i=0;i<Q;i++){', '            String inp_edge = stdIn.nextLine();', '            String[] temp = inp_edge.split("" "");', '            int v1 = Integer.parseInt(temp[0]);', '            int v2 = Integer.parseInt(temp[1]);', '            if(graph[v1][v2]>130000)', '                System.out.println(""-1"");', '            else', '                System.out.println(graph[v1][v2]);', '        }', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', '', '', 'public class Solution {', '', '    public static void main(String[] args) throws IOException {', '        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));', '        PrintWriter out = new PrintWriter(System.out);', '        // StringTokenizer tok = new StringTokenizer(in.readLine());', '        int t = 1;', '        for (int i = 0; i < t; i++) {', '            oneTest(in);', '        }', '', '    }', '', '    private static void oneTest(BufferedReader in) throws IOException {', '        StringTokenizer tok = new StringTokenizer(in.readLine());', '        int n = Integer.parseInt(tok.nextToken());', '        int m = Integer.parseInt(tok.nextToken());', '', '        int[][] graph = readGraph(in, n, m);', '        for (int k = 0; k < n; k++) {', '            for (int i = 0; i < n; i++) {', '                for (int j = 0; j < n; j++) {', '                    if (graph[i][k] == -1 || graph[k][j] == -1)', '                        continue;', '                    if (graph[i][j] == -1', '                            || graph[i][j] > graph[i][k] + graph[k][j]) {', '                        graph[i][j] = graph[i][k] + graph[k][j];', '                    }', '                }', '            }', '        }', '', '        int q = Integer.parseInt(in.readLine());', '        for (int i = 0; i < q; i++) {', '            tok = new StringTokenizer(in.readLine());', '            int a = Integer.parseInt(tok.nextToken()) - 1;', '            int b = Integer.parseInt(tok.nextToken()) - 1;', '            System.out.println(graph[a][b]);', '        }', '    }', '', '    private static int[][] readGraph(BufferedReader in, int n, int m)', '            throws IOException {', '        int[][] res = new int[n][n];', '        for (int i = 0; i < n; i++) {', '            Arrays.fill(res[i], -1);', '            res[i][i] = 0;', '        }', '        for (int i = 0; i < m; i++) {', '            StringTokenizer tok = new StringTokenizer(in.readLine());', '', '            int a = Integer.parseInt(tok.nextToken()) - 1;', '            int b = Integer.parseInt(tok.nextToken()) - 1;', '            int w = Integer.parseInt(tok.nextToken());', '', '            res[a][b] = w;', '', '        }', '        return res;', '    }', '', '}']"
"['import java.awt.Point;', 'import java.io.*;', 'import java.math.BigInteger;', 'import java.util.*;', 'import static java.lang.Math.*;', '', 'public class Solution {', '    BufferedReader in;', '    PrintWriter out;', '    StringTokenizer tok = new StringTokenizer("""");', '', '    public static void main(String[] args) {', '        new Solution().run();', '    }', '', '    public void run() {', '        try {', '            long t1 = System.currentTimeMillis();', '                in = new BufferedReader(new InputStreamReader(System.in));', '                out = new PrintWriter(System.out);', '            ', '            Locale.setDefault(Locale.US);', '            solve();', '            in.close();', '            out.close();', '            long t2 = System.currentTimeMillis();', '            System.err.println(""Time = "" + (t2 - t1));', '        } catch (Throwable t) {', '            t.printStackTrace(System.err);', '            System.exit(-1);', '        }', '    }', '', '    String readString() throws IOException {', '        while (!tok.hasMoreTokens()) {', '            tok = new StringTokenizer(in.readLine());', '        }', '        return tok.nextToken();', '    }', '', '    int readInt() throws IOException {', '        return Integer.parseInt(readString());', '    }', '', '    long readLong() throws IOException {', '        return Long.parseLong(readString());', '    }', '', '    double readDouble() throws IOException {', '        return Double.parseDouble(readString());', '    }', '', '    // solution', '    void invertEdges() {', '        ArrayList<Edge> edgesContainer = new ArrayList<Edge>(m);', '        for (int i = 0; i < n; i++) {', '            for (Edge edge = first[i]; edge != null; edge = edge.next) {', '                edgesContainer.add(edge);', '            }', '        }', '        Arrays.fill(first, null);', '        for (int i = 0; i < edgesContainer.size(); i++) {', '            Edge edge = new Edge(edgesContainer.get(i).b, edgesContainer.get(i).a, first);', '        }', '    }', '    int n;', '    int m;', '    Edge[] first;', '', '    void dfs(int source, boolean[] visited) {', '        if (visited[source]) {', '            return;', '        }', '        visited[source] = true;', '    //    out.println(""visiting "" + source);', '        for (Edge edge = first[source]; edge != null; edge = edge.next) {', '            dfs(edge.b, visited);', '        }', '    }', '    long modulo = 1000000000L;', '', '    void solve() throws IOException {', '        n = readInt();', '        m = readInt();', '        first = new Edge[n];', '        for (int i = 0; i < m; i++) {', '            int a = readInt() - 1;', '            int b = readInt() - 1;', '            Edge edge = new Edge(a, b, first);', '        }', '', '        boolean[] visitedA = new boolean[n];', '        boolean[] visitedB = new boolean[n];', '        boolean[] importantNode = new boolean[n];', '        dfs(0, visitedA);', '        invertEdges();', '      //  out.println(""----"");', '        dfs(n - 1, visitedB);', '        invertEdges();', '', '        for (int i = 0; i < n; i++) {', '            importantNode[i] = visitedA[i] && visitedB[i];', '        }', '', '        int[] counter = new int[n];', '        long[] f = new long[n];', '        for (int i = 0; i < n; i++) {', '            if (importantNode[i]) {', '                for (Edge edge = first[i]; edge != null; edge = edge.next) {', '                    if (importantNode[edge.b]) {', '                        counter[edge.b]++;', '                    }', '                }', '            }', '        }', '        f[0] = 1;', '        counter[0] = 1;', '        calculateNumberOfPaths(0, n - 1, counter, f);', '        if (importantNode[n - 1] //if there is a path from 0 to n - 1', '                && counter[n - 1] != 0)//then there is a cycle, probably', '        {', '            out.println(""INFINITE PATHS"");', '        } else {', '            out.println(f[n - 1]);', '        }', '    }', '', '    private void calculateNumberOfPaths(int source, int target, int[] counter, long[] f) {', '        counter[source]--;', '        if (counter[source] == 0) {', '            for (Edge edge = first[source]; edge != null; edge = edge.next) {', '                f[edge.b] = (f[edge.b] + f[edge.a]) % modulo;', '                calculateNumberOfPaths(edge.b, target, counter, f);', '            }', '        }', '    }', '}', '', 'class Edge {', '', '    int a;', '    int b;', '    Edge next;', '', '    Edge(int a, int b, Edge[] edgeTable) {', '        this.a = a;', '        this.b = b;', '        next = edgeTable[a];', '        edgeTable[a] = this;', '    }', '}']","['import java.io.*;', 'import java.util.*;', 'public class Solution {', '    static HashMap<Integer, Integer>[] con;', '    static HashSet<Integer>[] coned;', '    static boolean[] pending;', '    static long[] cnt;', '    static boolean[] connected;', '    static int cities;', '    static int paths;', '    static long result;', '    static final long mod = 1000000000;', '    static boolean ended; ', '    public static void main(String[] arg) throws FileNotFoundException{    ', '        /*int ii = Integer.MAX_VALUE;', '        long jj = Integer.MAX_VALUE;', '        System.out.println((ii*jj)%100);*/', '        // Scanner sc = new Scanner(new FileInputStream(new File(""input"")));', '        Scanner sc = new Scanner(System.in);', '        cities = sc.nextInt();', '        paths = sc.nextInt();', '        cnt = new long[cities+1];', '        pending = new boolean[cities+1];', '        connected = new boolean[cities+1];', '        for(int i=0;i<=cities;i++)', '            cnt[i] = -1;', '        con = new HashMap[cities+1];', '        coned = new HashSet[cities+1];', '        for(int i=0; i<paths;i++){', '            int from = sc.nextInt();', '            int to =sc.nextInt();', '            if(coned[to] == null)', '                coned[to] = new HashSet<Integer>();', '            coned[to].add(from);', '            ', '            if(con[from] == null)', '                con[from] = new HashMap<Integer, Integer>();', '            if(con[from].containsKey(to))', '                con[from].put(to, con[from].get(to)+1);', '            else', '                con[from].put(to, 1);', '        }', '        setCon(cities);', '        result = getSum(1);', '        if(ended == true){', '            System.out.println(""INFINITE PATHS"");', '        }', '        else', '            System.out.println(result);', '    }', '    public static void setCon(int i){', '        if(coned[i] == null)', '            return;', '        for(int c: coned[i]){', '            if(connected[c] == false){', '                connected[c] = true;', '                setCon(c);', '            }', '        }        ', '    }', '    public static long getSum(int city){', '        if(ended == true)', '            return 0;', '        if(cnt[city] >= 0)', '            return cnt[city];', '        else if(pending[city] == true){', '            if(connected[city] == true)', '                ended = true;', '            return 0;', '        }', '        else{', '            long tmp = 0;', '            if(con[city] == null){', '                cnt[city] = 0;', '                return 0;', '            }', '            pending[city] = true;', '            Iterator iter = con[city].entrySet().iterator(); ', '            while(iter.hasNext()){', '                Map.Entry<Integer, Integer> entry = (Map.Entry<Integer, Integer>) iter.next(); ', '                int c = entry.getKey(); ', '                int ways = entry.getValue();             ', '                // System.out.println(""checking ""+city+"" to ""+c);', '                if(c == cities)', '                    tmp = (tmp+ways)%mod;', '                else', '                    tmp = (tmp + (getSum(c)*ways)%mod)%mod;                ', '            }', '            // System.out.println(""city ""+city+"" has ""+tmp);', '            cnt[city] = tmp;', '            return tmp;', '        }            ', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '    private static int[][] ps, qs;', '', '    static int gcd(int a, int b) {', '        if (b == 0) {', '            return a;', '        }', '        return gcd(b, a % b);', '    }', '', '    static HashMap<Integer, Integer> pIds = new HashMap<Integer, Integer>();', '', '    static int pId(int p) {', '        if (!pIds.containsKey(p)) {', '            pIds.put(p, pIds.size());', '        }', '        return pIds.get(p);', '    }', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        Random rnd = new Random(42);', '        int n = in.nextInt();', '        int[] a = new int[n];', '        int[] b = new int[n];', '        for (int i = 0; i < n; ++i) {', '            a[i] = in.nextInt();', '        }', '        for (int i = 0; i < n; ++i) {', '            b[i] = in.nextInt();', '        }/**/', '        /*for (int i = 0; i < n; ++i) {', '            a[i] = rnd.nextInt(1000000000) + 2;', '        }', '        for (int i = 0; i < n; ++i) {', '            b[i] = rnd.nextInt(1000000000) + 2;', '        }/**/', '        long time0 = System.currentTimeMillis();', '        boolean[] isPrime = new boolean[31624];', '        Arrays.fill(isPrime, true);', '        int primesCount = 0;', '        for (int i = 2; i < isPrime.length; ++i) {', '            if (isPrime[i]) {', '                primesCount++;', '                for (int j = i * i; j < isPrime.length; j += i) {', '                    isPrime[j] = false;', '                }', '            }', '        }', '        int[] primes = new int[primesCount];', '        primesCount = 0;', '        for (int i = 2; i < isPrime.length; ++i) {', '            if (isPrime[i]) {', '                primes[primesCount++] = i;', '            }', '        }', '        ps = new int[n][];', '        for (int it = 0; it < n; ++it) {', '            int x = a[it];', '            ArrayList<Integer> psList = new ArrayList<Integer>();', '            for (int i = 0; i < primes.length && primes[i] * primes[i] <= x; ++i) {', '                if (x % primes[i] == 0) {', '                    psList.add(primes[i]);', '                }', '                while (x % primes[i] == 0) {', '                    x /= primes[i];', '                }', '            }', '            if (x > 1) {', '                psList.add(x);', '            }', '            ps[it] = new int[psList.size()];', '            for (int i = 0; i < psList.size(); ++i) {', '                ps[it][ps[it].length - i - 1] = pId(psList.get(i));', '            }', '        }', '        List<Integer>[] qsList = new List[pIds.size()];', '        for (int i = 0; i < pIds.size(); ++i) {', '            qsList[i] = new ArrayList<Integer>();', '        }', '        for (int it = 0; it < n; ++it) {', '            int x = b[it];', '            for (int i = 0; i < primes.length && primes[i] * primes[i] <= x; ++i) {', '                if (x % primes[i] == 0 && pIds.containsKey(primes[i])) {', '                    qsList[pIds.get(primes[i])].add(it);', '                }', '                while (x % primes[i] == 0) {', '                    x /= primes[i];', '                }', '            }', '            if (x > 1 && pIds.containsKey(x)) {', '                qsList[pIds.get(x)].add(it);', '            }', '        }', '        qs = new int[qsList.length][];', '        for (int i = 0; i < qsList.length; ++i) {', '            qs[i] = new int[qsList[i].size()];', '            for (int j = 0; j < qs[i].length; ++j) {', '                qs[i][j] = qsList[i].get(j);', '            }', '        }', '        int[] dx = new int[n];', '        int[] dy = new int[n];', '        Arrays.fill(dx, -1);', '        Arrays.fill(dy, -1);', '        int ans = 0;', '        int[] col = new int[n];', '        int[] col2 = new int[pIds.size()];', '        int cc = 1;', '        for (int i = 0; i < n; ++i) {', '            if (dfs(i, a, b, dx, dy, col, col2, cc)) {', '                ans++;', '                cc++;', '            }', '//            System.out.println(i);', '        }', '        out.println(ans);', '        System.err.println(System.currentTimeMillis() - time0);', '    }', '', '    private static boolean dfs(int i, int[] a, int[] b, int[] dx, int[] dy, int[] col, int[] col2, int cc) {', '        if (col[i] == cc) {', '            return false;', '        }', '        col[i] = cc;', '        for (int p : ps[i]) {', '            if (col2[p] == cc) {', '                continue;', '            }', '            for (int j : qs[p]) {', '                if (dy[j] == -1) {', '                    dx[i] = j;', '                    dy[j] = i;', '                    return true;', '                }', '            }', '        }', '        for (int p : ps[i]) {', '            if (col2[p] == cc) {', '                continue;', '            }', '            col2[p] = cc;', '            for (int j : qs[p]) {', '                if (dx[i] != j && dfs(dy[j], a, b, dx, dy, col, col2, cc)) {', '                    dx[i] = j;', '                    dy[j] = i;', '                    return true;', '                }', '            }', '        }', '        return false;', '    }', '', '    public static void main(String[] args) throws IOException {', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '    private static int[][] ps, qs;', '', '    static int gcd(int a, int b) {', '        if (b == 0) {', '            return a;', '        }', '        return gcd(b, a % b);', '    }', '', '    static HashMap<Integer, Integer> pIds = new HashMap<Integer, Integer>();', '', '    static int pId(int p) {', '        if (!pIds.containsKey(p)) {', '            pIds.put(p, pIds.size());', '        }', '        return pIds.get(p);', '    }', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        Random rnd = new Random(42);', '        int n = in.nextInt();', '        int[] a = new int[n];', '        int[] b = new int[n];', '        for (int i = 0; i < n; ++i) {', '            a[i] = in.nextInt();', '        }', '        for (int i = 0; i < n; ++i) {', '            b[i] = in.nextInt();', '        }/**/', '        /*for (int i = 0; i < n; ++i) {', '            a[i] = rnd.nextInt(1000000000) + 2;', '        }', '        for (int i = 0; i < n; ++i) {', '            b[i] = rnd.nextInt(1000000000) + 2;', '        }/**/', '        long time0 = System.currentTimeMillis();', '        boolean[] isPrime = new boolean[31624];', '        Arrays.fill(isPrime, true);', '        int primesCount = 0;', '        for (int i = 2; i < isPrime.length; ++i) {', '            if (isPrime[i]) {', '                primesCount++;', '                for (int j = i * i; j < isPrime.length; j += i) {', '                    isPrime[j] = false;', '                }', '            }', '        }', '        int[] primes = new int[primesCount];', '        primesCount = 0;', '        for (int i = 2; i < isPrime.length; ++i) {', '            if (isPrime[i]) {', '                primes[primesCount++] = i;', '            }', '        }', '        ps = new int[n][];', '        for (int it = 0; it < n; ++it) {', '            int x = a[it];', '            ArrayList<Integer> psList = new ArrayList<Integer>();', '            for (int i = 0; i < primes.length && primes[i] * primes[i] <= x; ++i) {', '                if (x % primes[i] == 0) {', '                    psList.add(primes[i]);', '                }', '                while (x % primes[i] == 0) {', '                    x /= primes[i];', '                }', '            }', '            if (x > 1) {', '                psList.add(x);', '            }', '            ps[it] = new int[psList.size()];', '            for (int i = 0; i < psList.size(); ++i) {', '                ps[it][ps[it].length - i - 1] = pId(psList.get(i));', '            }', '        }', '        List<Integer>[] qsList = new List[pIds.size()];', '        for (int i = 0; i < pIds.size(); ++i) {', '            qsList[i] = new ArrayList<Integer>();', '        }', '        for (int it = 0; it < n; ++it) {', '            int x = b[it];', '            for (int i = 0; i < primes.length && primes[i] * primes[i] <= x; ++i) {', '                if (x % primes[i] == 0 && pIds.containsKey(primes[i])) {', '                    qsList[pIds.get(primes[i])].add(it);', '                }', '                while (x % primes[i] == 0) {', '                    x /= primes[i];', '                }', '            }', '            if (x > 1 && pIds.containsKey(x)) {', '                qsList[pIds.get(x)].add(it);', '            }', '        }', '        qs = new int[qsList.length][];', '        for (int i = 0; i < qsList.length; ++i) {', '            qs[i] = new int[qsList[i].size()];', '            for (int j = 0; j < qs[i].length; ++j) {', '                qs[i][j] = qsList[i].get(j);', '            }', '        }', '        int[] dx = new int[n];', '        int[] dy = new int[n];', '        Arrays.fill(dx, -1);', '        Arrays.fill(dy, -1);', '        int ans = 0;', '        int[] col = new int[n];', '        int[] col2 = new int[pIds.size()];', '        int cc = 1;', '        for (int i = 0; i < n; ++i) {', '            if (dfs(i, a, b, dx, dy, col, col2, cc)) {', '                ans++;', '                cc++;', '            }', '//            System.out.println(i);', '        }', '        out.println(ans);', '        System.err.println(System.currentTimeMillis() - time0);', '    }', '', '    private static boolean dfs(int i, int[] a, int[] b, int[] dx, int[] dy, int[] col, int[] col2, int cc) {', '        if (col[i] == cc) {', '            return false;', '        }', '        col[i] = cc;', '        for (int p : ps[i]) {', '            if (col2[p] == cc) {', '                continue;', '            }', '            for (int j : qs[p]) {', '                if (dy[j] == -1) {', '                    dx[i] = j;', '                    dy[j] = i;', '                    return true;', '                }', '            }', '        }', '        for (int p : ps[i]) {', '            if (col2[p] == cc) {', '                continue;', '            }', '            col2[p] = cc;', '            for (int j : qs[p]) {', '                if (dx[i] != j && dfs(dy[j], a, b, dx, dy, col, col2, cc)) {', '                    dx[i] = j;', '                    dy[j] = i;', '                    return true;', '                }', '            }', '        }', '        return false;', '    }', '', '    public static void main(String[] args) throws IOException {', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', ' private void solution() throws IOException {', '  int ts = in.nextInt();', '  while (ts-- > 0) {', '   int n = in.nextInt();', '   int k = in.nextInt();', '   int[] a = new int[n];', '   for (int i = 0; i < n; ++i) {', '    a[i] = in.nextInt();', '   }', '', '   int size = 2 * n + 2;', '   int[][] cap = new int[size][size];', '   int[][] flow = new int[size][size];', '', '   for (int i = 0; i < n; ++i) {', '    for (int j = i + 1; j < n; ++j) {', '     if (Math.abs(a[i] - a[j]) >= k) {', '      cap[i][n + j] = 1;', '     }', '    }', '   }', '', '   int s = size - 2;', '   int t = size - 1;', '', '   for (int i = 0; i < n; ++i) {', '    cap[s][i] = 1;', '    cap[n + i][t] = 1;', '   }', '', '   boolean[] used = new boolean[size];', '   int res = 0;', '   while (dfs(s, t, cap, flow, used)) {', '    ++res;', '    Arrays.fill(used, false);', '   }', '   out.println(n - res);', '  }', ' }', '', ' private boolean dfs(int at, int t, int[][] cap, int[][] flow, boolean[] used) {', '  if (used[at]) {', '   return false;', '  }', '  if (at == t) {', '   return true;', '  }', '  used[at] = true;', '', '  for (int next = 0; next < cap.length; ++next) {', '   if (!used[next] && cap[at][next] > flow[at][next]) {', '    if (dfs(next, t, cap, flow, used)) {', '     ++flow[at][next];', '     --flow[next][at];', '     return true;', '    }', '   }', '  }', '  return false;', ' }', '', ' public void run() {', '  try {', '   solution();', '   in.reader.close();', '   out.close();', '  } catch (Exception e) {', '   e.printStackTrace();', '   System.exit(1);', '  }', ' }', '', ' private class Scanner {', '  StringTokenizer tokenizer;', '', '  BufferedReader reader;', '', '  public Scanner(Reader reader) {', '   this.reader = new BufferedReader(reader);', '   this.tokenizer = new StringTokenizer("""");', '  }', '', '  public boolean hasNext() throws IOException {', '   while (!tokenizer.hasMoreTokens()) {', '    String line = reader.readLine();', '    if (line == null) {', '     return false;', '    }', '    tokenizer = new StringTokenizer(line);', '   }', '   return true;', '  }', '', '  public String next() throws IOException {', '   hasNext();', '   return tokenizer.nextToken();', '  }', '', '  public int nextInt() throws IOException {', '   return Integer.parseInt(next());', '  }', ' }', '', ' public static void main(String[] args) throws IOException {', '  new Solution().run();', ' }', '', ' Scanner in = new Scanner(new InputStreamReader(System.in));', ' PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));', '}']","['import java.io.*;', 'import java.math.BigInteger;', 'import java.util.Arrays;', 'import java.util.StringTokenizer;', '', 'public class Solution implements Runnable {', '', '    // leave empty to read from stdin/stdout', '    private static final String TASK_NAME_FOR_IO = """";', '', '    // file names', '    private static final String FILE_IN = TASK_NAME_FOR_IO + "".in"";', '    private static final String FILE_OUT = TASK_NAME_FOR_IO + "".out"";', '', '    BufferedReader in;', '    PrintWriter out;', '    StringTokenizer tokenizer = new StringTokenizer("""");', '', '    public static void main(String[] args) {', '        new Solution().run();', '    }', '', '    int n;', '    boolean[][] a;', '', '    private void solve() throws IOException {', '        int tc = nextInt();', '        for (int tcIdx = 0; tcIdx < tc; tcIdx++) {', '            n = nextInt();', '            int k = nextInt();', '            int[] v = new int[n];', '            for (int i = 0; i < n; i++) {', '                v[i] = nextInt();', '            }', '', '            a = new boolean[n][n];', '            for (int i = 0; i < n; i++)', '                for (int j = i + 1; j < n; j++) {', '                    a[i][j] = Math.abs(v[i] - v[j]) >= k;', '                }', '', '            int answer = maxMatching();', '            out.println(n - answer);', '        }', '    }', '', '    boolean[] used, used1;', '    int[] mt;', '', '    private int maxMatching() {', '        used1 = new boolean[n];', '        mt = new int[n];', '        Arrays.fill(mt, -1);', '        for (int i = 0; i < n; i++)', '            for (int j = i + 1; j < n; j++)', '                if (a[i][j] && mt[j] == -1) {', '                    mt[j] = i;', '                    used1[i] = true;', '                    break;', '                }', '', '        used = new boolean[n];', '        for (int i = 0; i < n; i++)', '            if (!used1[i]) {', '                Arrays.fill(used, false);', '                tryKuhn(i);', '            }', '', '        int answer = 0;', '        for (int j = 0; j < n; j++)', '            if (mt[j] != -1) {', '                answer++;', '            }', '', '        return answer;', '    }', '', '    boolean tryKuhn(int i) {', '        if (used[i]) return false;', '        used[i] = true;', '        for (int j = i + 1; j < n; j++) {', '            if (a[i][j] && (mt[j] == -1 || tryKuhn(mt[j]))) {', '                mt[j] = i;', '                return true;', '            }', '        }', '        return false;', '    }', '', '    public void run() {', '        long timeStart = System.currentTimeMillis();', '', '        boolean fileIO = TASK_NAME_FOR_IO.length() > 0;', '        try {', '', '            if (fileIO) {', '                in = new BufferedReader(new FileReader(FILE_IN));', '                out = new PrintWriter(new FileWriter(FILE_OUT));', '            } else {', '                in = new BufferedReader(new InputStreamReader(System.in));', '                out = new PrintWriter(new OutputStreamWriter(System.out));', '            }', '', '            solve();', '', '            in.close();', '            out.close();', '        } catch (IOException e) {', '            throw new IllegalStateException(e);', '        }', '        long timeEnd = System.currentTimeMillis();', '', '        if (fileIO) {', '            System.out.println(""Time spent: "" + (timeEnd - timeStart) + "" ms"");', '        }', '    }', '', '    private String nextToken() throws IOException {', '        while (!tokenizer.hasMoreTokens()) {', '            String line = in.readLine();', '            if (line == null) {', '                return null;', '            }', '            tokenizer = new StringTokenizer(line);', '        }', '        return tokenizer.nextToken();', '    }', '', '    private int nextInt() throws IOException {', '        return Integer.parseInt(nextToken());', '    }', '', '    private BigInteger nextBigInt() throws IOException {', '        return new BigInteger(nextToken());', '    }', '', '    private long nextLong() throws IOException {', '        return Long.parseLong(nextToken());', '    }', '', '    private double nextDouble() throws IOException {', '        return Double.parseDouble(nextToken());', '    }', '', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class C {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  int n = ni(), m = ni();', '  int[] from = new int[n-1];', '  int[] to = new int[n-1];', '  for(int i = 0;i < n-1;i++){', '   from[i] = ni()-1;', '   to[i] = ni()-1;', '  }', '  int[][] g = packU(n, from, to);', '  int[][] pars = parents3(g, 0);', '  int[] ord = pars[1], par = pars[0];', '  int[] ds1 = new int[n];', '  int[] ds2 = new int[n];', '  Arrays.fill(ds1, -1);', '  Arrays.fill(ds2, -1);', '  for(int i = n-1;i >= 0;i--){', '   int cur = ord[i];', '   for(int e : g[cur]){', '    if(ds1[cur] <= ds1[e] + 1){', '     ds2[cur] = ds1[cur];', '     ds1[cur] = ds1[e] + 1;', '    }else if(ds2[cur] <= ds1[e] + 1){', '     ds2[cur] = ds1[e] + 1;', '    }', '   }', '  }', '  for(int i = 1;i < n;i++){', '   int cur = ord[i];', '   int pa = par[cur];', '   int x = -1;', '   if(ds1[pa] == ds1[cur] + 1){', '    x = ds2[pa] + 1;', '   }else{', '    x = ds1[pa] + 1;', '   }', '   if(ds1[cur] <= x){', '    ds2[cur] = ds1[cur];', '    ds1[cur] = x;', '   }else if(ds2[cur] <= x){', '    ds2[cur] = x;', '   }', '  }', '  int diam = 0;', '  for(int i = 0;i < n;i++){', '   diam = Math.max(diam, ds1[i]);', '  }', '  tr(ds1);', '  tr(ds2);', '  ', '  for(int u = 0;u < m;u++){', '   int v = ni()-1, K = ni();', '   out.println(ds1[v] + (long)diam * (K-1));', '  }', ' }', ' ', ' public static int[][] parents3(int[][] g, int root) {', '  int n = g.length;', '  int[] par = new int[n];', '  Arrays.fill(par, -1);', '', '  int[] depth = new int[n];', '  depth[0] = 0;', '', '  int[] q = new int[n];', '  q[0] = root;', '  for (int p = 0, r = 1; p < r; p++) {', '   int cur = q[p];', '   for (int nex : g[cur]) {', '    if (par[cur] != nex) {', '     q[r++] = nex;', '     par[nex] = cur;', '     depth[nex] = depth[cur] + 1;', '    }', '   }', '  }', '  return new int[][] { par, q, depth };', ' }', ' ', ' static int[][] packU(int n, int[] from, int[] to) {', '  int[][] g = new int[n][];', '  int[] p = new int[n];', '  for (int f : from)', '   p[f]++;', '  for (int t : to)', '   p[t]++;', '  for (int i = 0; i < n; i++)', '   g[i] = new int[p[i]];', '  for (int i = 0; i < from.length; i++) {', '   g[from[i]][--p[from[i]]] = to[i];', '   g[to[i]][--p[to[i]]] = from[i];', '  }', '  return g;', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.util.ArrayList;', 'import java.util.Arrays;', '', 'public class HR_journey_scheduling {', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        int n = in.nextInt();', '        int qs = in.nextInt();', '        ArrayList<Integer>[] edges = new ArrayList[n];', '        for (int i = 0; i < n; ++i) {', '            edges[i] = new ArrayList<Integer>();', '        }', '        for (int i = 0; i < n - 1; ++i) {', '            int x = in.nextInt() - 1;', '            int y = in.nextInt() - 1;', '            edges[x].add(y);', '            edges[y].add(x);', '        }', '        int[] d0 = distDfs(0, edges);', '        int u = 0;', '        for (int i = 0; i < n; ++i) {', '            if (d0[i] > d0[u]) {', '                u = i;', '            }', '        }', '        int[] du = distDfs(u, edges);', '        int v = 0;', '        for (int i = 0; i < n; ++i) {', '            if (du[i] > du[v]) {', '                v = i;', '            }', '        }', '        int[] dv = distDfs(v, edges);', '        int d = du[v];', '        if (d % 2 == 0) {', '            int mid = -1;', '            for (int i = 0; i < n; ++i) {', '                if (du[i] == d / 2 && dv[i] == d / 2) {', '                    mid = i;', '                }', '            }', '//            System.err.println(d + "" "" + mid);', '            int[] dmid = distDfs(mid, edges);', '            for (int it = 0; it < qs; ++it) {', '                int i = in.nextInt() - 1;', '                long k = in.nextInt();', '                out.println(dmid[i] + d / 2 + (k - 1) * d);', '            }', '        } else {', '            int mid1 = -1, mid2 = -1;', '            for (int i = 0; i < n; ++i) {', '                if (du[i] == d / 2 && dv[i] == (d + 1) / 2) {', '                    mid1 = i;', '                }', '                if (du[i] == (d + 1) / 2 && dv[i] == d / 2) {', '                    mid2 = i;', '                }', '            }', '//            System.err.println(d + "" "" + mid1 + "" "" + mid2);', '            int[] dmid1 = distDfs(mid1, edges);', '            int[] dmid2 = distDfs(mid2, edges);', '            for (int it = 0; it < qs; ++it) {', '                int i = in.nextInt() - 1;', '                long k = in.nextInt();', '                out.println(Math.min(dmid1[i], dmid2[i]) + (d + 1) / 2 + (k - 1) * d);', '            }', '        }', '    }', '', '    static int[] distDfs(int i, ArrayList<Integer>[] edges) {', '        int[] r = new int[edges.length];', '        Arrays.fill(r, -1);', '        dfs(i, -1, 0, edges, r);', '        return r;', '    }', '', '    static void dfs(int i, int p, int d, ArrayList<Integer>[] edges, int[] ds) {', '        ds[i] = d;', '        for (int j : edges[i]) {', '            if (j != p) {', '                dfs(j, i, d + 1, edges, ds);', '            }', '        }', '    }', '', '    public static void main(String[] args) throws IOException {', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']"
"['import java.util.*;', 'import java.io.*;', 'import static java.lang.Math.*;', '', 'public class Solution {', ' static class Foo51 {', '  static class Node {', '   boolean hasMachine;', '   int weightOfParent;', '   ArrayList<Integer> child = new ArrayList<Integer>();', '   ArrayList<Integer> weight = new ArrayList<Integer>();', '  }', '  Node[] nodes;', '  int N;', '  void main() {', '   BufferedReader br = null;', '   try {', '    br = new BufferedReader(new InputStreamReader(System.in));', '    String[] s = br.readLine().trim().split("" "");', '    N = Integer.parseInt(s[0].trim());', '    int K = Integer.parseInt(s[1].trim());', '    nodes = new Node[N];', '    for (int i = 0; i < N; i++) nodes[i] = new Node();', '    for (int i = 0; i < N-1; i++) {', '     s = br.readLine().trim().split("" "");', '     int a = Integer.parseInt(s[0].trim());', '     int b = Integer.parseInt(s[1].trim());', '     int weight = Integer.parseInt(s[2].trim());', '     nodes[a].child.add(b);', '     nodes[a].weight.add(weight);', '     nodes[b].child.add(a);', '     nodes[b].weight.add(weight);', '    }', '    for (int i = 0; i < K; i++) {', '     int a = Integer.parseInt(br.readLine().trim());', '     nodes[a].hasMachine = true;', '    }', '    long res = foo();', '    System.out.println(res);', '   } catch (Exception e) {', '    e.printStackTrace();', '   } finally {', '    if (br != null) {', '     try { br.close(); } catch (Exception e) { e.printStackTrace(); }', '    }', '   }', '  }', '  long foo() {', '   return doit(0, -1)[1];', '  }', '  ', '  long[] doit(int current, int parent) {', '   long[] res = new long[2];', '   Node curr = nodes[current];', '   if (current != 0 && nodes[current].child.size() == 1) {', '    // leaf', '    if (curr.hasMachine)', '     res[0] = nodes[current].weight.get(0);', '    return res;', '   }', '   int childNum = curr.child.size()-1;', '   if (current == 0)', '    childNum++;', '   long[][] child = new long[childNum][];', '   int index = 0;', '   for (int i = 0; i < curr.child.size(); i++) {', '    int childId = curr.child.get(i);', '    if (parent != childId) {', '     nodes[childId].weightOfParent = curr.weight.get(i); ', '     child[index++] = doit(childId, current);', '    }', '   }', '   if (curr.hasMachine) {', '    for (int i = 0; i < childNum; i++) {', '     res[1] += child[i][0];', '    }', '    res[0] = res[1] + curr.weightOfParent;', '   } else {', '    long maxDiff = 0;', '    for (int i = 0; i < childNum; i++)', '     maxDiff = max(maxDiff, child[i][0]-child[i][1]);', '    long cost = 0;', '    for (int i = 0; i < childNum; i++)', '     cost += child[i][0];', '    res[0] = min(cost, cost-maxDiff+curr.weightOfParent);', '    res[1] = cost-maxDiff;', '   }', '   return res;', '  }', ' }', ' public static void main(String[] args) {', '  Foo51 foo = new Foo51();  ', '  foo.main();', ' }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '    // leave empty to read from stdin/stdout', '    private static final String TASK_NAME_FOR_IO = """";', '', '    // file names', '    private static final String FILE_IN = TASK_NAME_FOR_IO + "".in"";', '    private static final String FILE_OUT = TASK_NAME_FOR_IO + "".out"";', '', '    BufferedReader in;', '    PrintWriter out;', '    StringTokenizer tokenizer = new StringTokenizer("""");', '', '    public static void main(String[] args) {', '        new Solution().run();', '    }', '', '    int n;', '    EdgeList[] e;', '    boolean[] isBomb;', '    long[] answer;', '    long[] uAns, uMin;', '', '    class Edge {', '        int u, v;', '        long cost;', '        int idx;', '', '        Edge(int u, int v, long cost, int idx) {', '            this.u = u;', '            this.v = v;', '            this.cost = cost;', '            this.idx = idx;', '        }', '    }', '', '    class EdgeList {', '        List<Edge> list = new ArrayList<Edge>();', '    }', '', '    private void solve() throws IOException {', '        // stress();', '        // timing();', '', '        n = nextInt();', '        int k = nextInt();', '        e = new EdgeList[n];', '        for (int i = 0; i < n; i++) {', '            e[i] = new EdgeList();', '        }', '        for (int i = 0; i < n - 1; i++) {', '            int u = nextInt();', '            int v = nextInt();', '            long cost = nextLong();', '            e[u].list.add(new Edge(u, v, cost, i));', '            e[v].list.add(new Edge(v, u, cost, i));', '        }', '        isBomb = new boolean[n];', '        for (int i = 0; i < k; i++) {', '            int u = nextInt();', '            isBomb[u] = true;', '        }', '', '        out.println(solveFast());', '    }', '', '    private void stress() {', '        Random r = new Random(123456789L);', '', '        int tcNum = 100000;', '        for (int tcIdx = 0; tcIdx < tcNum; tcIdx ++) {', '            n = 2 + r.nextInt(10);', '            genTestCase(r);', '', '            long ans1 = solveNaive();', '            long ans2 = solveFast();', '            if (ans1 != ans2) {', '                throw new IllegalStateException(""Mismatch: "" + ans2 + "" vs "" + ans1);', '            }', '', '            System.out.println(""OK: "" + ans1 + "" ("" + tcIdx + "" / "" + tcNum + "")"");', '        }', '    }', '', '    private void timing() {', '        Random r = new Random(123456789L);', '        n = 100000;', '        genTestCase(r);', '        System.out.println(solveFast());', '    }', '', '    private void genTestCase(Random r) {', '        e = new EdgeList[n];', '        for (int i = 0; i < n; i++) {', '            e[i] = new EdgeList();', '        }', '', '        LinkedList<Integer> dst = new LinkedList<Integer>();', '        for (int i = 0; i < n; i++) {', '            dst.add(i);', '        }', '        Collections.shuffle(dst, r);', '', '        ArrayList<Integer> src = new ArrayList<Integer>();', '        src.add(dst.removeFirst());', '', '        int idx = 0;', '        while (!dst.isEmpty()) {', '            int u = src.get( r.nextInt(src.size()) );', '            int v = dst.removeFirst();', '            long cost = r.nextInt(100);', '', '            e[u].list.add(new Edge(u, v, cost, idx));', '            e[v].list.add(new Edge(v, u, cost, idx));', '            idx++;', '', '            src.add(v);', '        }', '', '        isBomb = new boolean[n];', '        for (int i = 0; i < n; i++)', '            if (r.nextInt(2) > 0) {', '                isBomb[i] = true;', '            }', '    }', '', '    private long solveFast() {', '        answer = new long[n];', '        uAns = new long[n];', '        uMin = new long[n];', '        Arrays.fill(uMin, Long.MAX_VALUE);', '        recFast(0, -1);', '        return uAns[0];', '    }', '', '    private void recFast(int u, int prevU) {', '        int bombEdgeCount = 0;', '        long bombEdgeSum = 0;', '        long bombEdgeMaxLen = 0;', '        for (Edge edge : e[u].list)', '            if (edge.v != prevU) {', '                recFast(edge.v, u);', '', '                // count weight for all outgoing bombs', '                if (isBomb[edge.v]) {', '                    long edgeLen = Math.min(uMin[edge.v], edge.cost);', '                    bombEdgeMaxLen = Math.max(bombEdgeMaxLen, edgeLen);', '                    bombEdgeSum += edgeLen;', '                    bombEdgeCount++;', '                    uAns[u] += uAns[edge.v];', '                }', '            }', '', '        if (isBomb[u]) {', '            // nuke all edges that lead to a bomb', '            // and this vertex stays marked as a bomb', '            uAns[u] += bombEdgeSum;', '            uMin[u] = Long.MAX_VALUE;', '        } else {', '', '            if (bombEdgeCount > 0) {', '                // nuke all edges that lead to a bomb, except one', '                // and this vertex stays marked as a bomb', '                uAns[u] += bombEdgeSum - bombEdgeMaxLen;', '                uMin[u] = bombEdgeMaxLen;', '                isBomb[u] = true;', '            }', '', '        }', '    }', '', '    @SuppressWarnings({""ConstantConditions""})', '    private long solveNaive() {', '        int m2 = 1 << (n - 1);', '        long result = Long.MAX_VALUE;', '        for (int mask = 0; mask < m2; mask++) {', '            boolean disconnected = true;', '            for (int i = 0; disconnected && i < n; i++)', '                if (isBomb[i]) {', '                    disconnected &= recNaive(i, -1, mask);', '                }', '            if (disconnected) {', '                long cost = 0;', '                for (int i = 0; i < n; i++)', '                    for (Edge edge : e[i].list)', '                        if ((mask & (1 << edge.idx)) != 0) {', '                            cost += edge.cost;', '                        }', '                result = Math.min(result, cost / 2);', '            }', '        }', '        return result;', '    }', '', '    private boolean recNaive(int u, int prevU, int mask) {', '        for (Edge edge : e[u].list)', '            if (((mask & (1 << edge.idx)) == 0) && edge.v != prevU) {', '                if (isBomb[edge.v]) {', '                    return false;', '                }', '                if (!recNaive(edge.v, u, mask)) {', '                    return false;', '                }', '            }', '        return true;', '    }', '', '    public void run() {', '        long timeStart = System.currentTimeMillis();', '', '        boolean fileIO = TASK_NAME_FOR_IO.length() > 0;', '        try {', '', '            if (fileIO) {', '                in = new BufferedReader(new FileReader(FILE_IN));', '                out = new PrintWriter(new FileWriter(FILE_OUT));', '            } else {', '                in = new BufferedReader(new InputStreamReader(System.in));', '                out = new PrintWriter(new OutputStreamWriter(System.out));', '            }', '', '            solve();', '', '            in.close();', '            out.close();', '        } catch (IOException e) {', '            throw new IllegalStateException(e);', '        }', '        long timeEnd = System.currentTimeMillis();', '', '        if (fileIO) {', '            System.out.println(""Time spent: "" + (timeEnd - timeStart) + "" ms"");', '        }', '    }', '', '    private String nextToken() throws IOException {', '        while (!tokenizer.hasMoreTokens()) {', '            String line = in.readLine();', '            if (line == null) {', '                return null;', '            }', '            tokenizer = new StringTokenizer(line);', '        }', '        return tokenizer.nextToken();', '    }', '', '    private int nextInt() throws IOException {', '        return Integer.parseInt(nextToken());', '    }', '', '    private long nextLong() throws IOException {', '        return Long.parseLong(nextToken());', '    }', '', '}']"
 , 
"['import java.io.ByteArrayInputStream;', 'import java.io.FileInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', '', ' static void solve()', ' {', '  for(int T = ni();T >= 1;T--){', '   int n = ni();', '   int[] from = new int[n-1];', '   int[] to = new int[n-1];', '   for(int i = 0;i < n-1;i++){', '    from[i] = ni();', '    to[i] = ni();', '   }', '   int[][] g = packU(n, from, to);', '   int[][] pars = parents(g, 0);', '   int[] par = pars[0];', '   int[] ord = pars[1];', '   ', '   int[] des = new int[n];', '   for(int i = n-1;i >= 0;i--){', '    int cur = ord[i];', '    int d = 0;', '    for(int e : g[cur]){', '     if(par[cur] != e)d = Math.max(d, des[e]);', '    }', '    des[cur] = d + 1;', '   }', '   ', '   int[][] dp = new int[n][2]; // not extended, extended', '   boolean[] ex = new boolean[n];', '   for(int i = n-1;i >= 0;i--){', '    int cur = ord[i];', '    int ct = 0;', '    int sdp = 0;', '    int sh = 0;', '    boolean onch = false;', '    for(int e : g[cur]){', '     if(par[cur] != e){', '//      if(cur == 11)tr(e, des[e], dp[e], ex[e]);', '      if(des[e] >= 2){', '       if(ex[e]){', '        ct++;', '        sdp += dp[e][1]-1;', '       }else{', '        sdp += dp[e][1];', '       }', '       sh++;', '      }else{', '       sdp += dp[e][0];', '       onch = true;', '      }', '     }', '    }', '//    if(cur == 11){', '//     tr(sdp, sh, onch);', '//    }', '    // 0 1 ex', '    // 1 1 ex', '    // 2 1 noex', '    // 3 2 ex', '    if(ct > 0){', '     dp[cur][0] = dp[cur][1] = sdp + (ct+1)/2;', '     if(ct%2 == 1)ex[cur] = true;', '    }else{', '     dp[cur][0] = sdp + (onch ? 1 : 0);', '     dp[cur][1] = sdp + 1;', '     ex[cur] = true;', '     if(!onch)des[cur] = 1;', '    }', '//    tr(cur, sdp, ct, sh, dp[cur], ex[cur]);', '   }', '//   tr(dp);', '//   tr(ex);', '   out.println(dp[0][0]);', '  }', ' }', ' ', ' public static int[][] parents(int[][] g, int root) {', '  int n = g.length;', '  int[] par = new int[n];', '  Arrays.fill(par, -1);', '', '  int[] q = new int[n];', '  q[0] = root;', '  for(int p = 0, r = 1;p < r;p++){', '   int cur = q[p];', '   for(int nex : g[cur]){', '    if(par[cur] != nex){', '     q[r++] = nex;', '     par[nex] = cur;', '    }', '   }', '  }', '  return new int[][] { par, q };', ' }', ' ', ' static int[][] packU(int n, int[] from, int[] to) {', '  int[][] g = new int[n][];', '  int[] p = new int[n];', '  for(int f : from)', '   p[f]++;', '  for(int t : to)', '   p[t]++;', '  for(int i = 0;i < n;i++)', '   g[i] = new int[p[i]];', '  for(int i = 0;i < from.length;i++){', '   g[from[i]][--p[from[i]]] = to[i];', '   g[to[i]][--p[to[i]]] = from[i];', '  }', '  return g;', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' static boolean eof()', ' {', '  try {', '   is.mark(1000);', '   int b;', '   while((b = is.read()) != -1 && !(b >= 33 && b <= 126));', '   is.reset();', '   return b == -1;', '  } catch (IOException e) {', '   return true;', '  }', ' }', '  ', ' static int ni()', ' {', '  try {', '   int num = 0;', '   boolean minus = false;', ""   while((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));"", ""   if(num == '-'){"", '    num = 0;', '    minus = true;', '   }else{', ""    num -= '0';"", '   }', '   ', '   while(true){', '    int b = is.read();', ""    if(b >= '0' && b <= '9'){"", ""     num = num * 10 + (b - '0');"", '    }else{', '     return minus ? -num : num;', '    }', '   }', '  } catch (IOException e) {', '  }', '  return -1;', ' }', ' ', ' static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', 'private Map<Integer, List<Integer>> roads = new HashMap<>();', '    /*', '     * Complete the repairRoads function below.', '     */', '    static int repairRoads(int n, int[][] roads) {', '        /*', '         * Write your code here.', '         */', '', '', '    ', '    Solution solution = new Solution();', '        for(int i=0;i<n-1;i++)', '        {', '            System.out.println(roads[i][0] + ""-"" + roads[i][1]);', '            solution.addRoad(roads[i][0],roads[i][1]);', '        }', '        return solution.solve();', '    }', '', '    ', '  ', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int t = Integer.parseInt(scanner.nextLine().trim());', '', '        for (int tItr = 0; tItr < t; tItr++) {', '            int n = Integer.parseInt(scanner.nextLine().trim());', '', '            int[][] roads = new int[n-1][2];', '', '            for (int roadsRowItr = 0; roadsRowItr < n-1; roadsRowItr++) {', '                String[] roadsRowItems = scanner.nextLine().split("" "");', '', '                for (int roadsColumnItr = 0; roadsColumnItr < 2; roadsColumnItr++) {', '                    int roadsItem = Integer.parseInt(roadsRowItems[roadsColumnItr].trim());', '                    roads[roadsRowItr][roadsColumnItr] = roadsItem;', '                }', '            }', '', '            int result = repairRoads(n, roads);', '', '            bufferedWriter.write(String.valueOf(result));', '            bufferedWriter.newLine();', '        }', '', '        bufferedWriter.close();', '    }', '', 'private void addToTree(RoadTree roadTree, int level, Integer city, Integer parent) {', '    List<Integer> roadsFromCity = roads.get(city);', '    if (parent != null) {', '      roadsFromCity.remove(parent);', '    }', '    roadTree.add(city, roadsFromCity, level + 1);', '    for (Integer c : roadsFromCity) {', '      addToTree(roadTree, level + 1, c, city);', '    }', '  }', '', '', '    public int solve() {', '    int result = 0;', '    int level = 0;', '    RoadTree roadTree = new RoadTree(roads.size());', '    Integer root = roads.keySet().iterator().next();', '    addToTree(roadTree, level, root, null);', '    for (int i = roadTree.levels.lastKey() - 1; i > 0; i--) {', '      List<Integer> cities = roadTree.levels.get(i);', '      for (Integer city : cities) {', '        List<Integer> leaves = roadTree.roads.get(city);', '        if (leaves != null && leaves.isEmpty() == false) {', '          for (Integer integer : leaves) {', '            roadTree.points[city] += roadTree.points[integer];', '          }', '          if (roadTree.points[city] == 0) {', '            roadTree.points[city]++;', '          } else if (roadTree.points[city] % 2 == 0) {', '            result += roadTree.points[city] / 2;', '            roadTree.points[city] = 0;', '          }', '          for (Integer integer : leaves) {', '            roadTree.roads.remove(integer);', '          }', '          if (roadTree.points[city] == 0) {', '            roadTree.remove(city);', '          }', '       }', '      }', '    }', '    return result + (roadTree.points[root] + 1) / 2;', '  }', '', '', '  public static class RoadTree {', '    private int[] parents;', '    private Map<Integer, List<Integer>> roads = new HashMap<>();', '    private TreeMap<Integer, List<Integer>> levels = new TreeMap<>();', '    private int[] points;', '', '    public RoadTree(int numberOfCities) {', '      points = new int[numberOfCities];', '      parents = new int[numberOfCities];', '    }', '', '    public void add(Integer city, List<Integer> roads, Integer level) {', '      if (levels.containsKey(level) == false) {', '        levels.put(level, new ArrayList<Integer>());', '      }', '      this.roads.put(city, roads);', '      levels.get(level).add(city);', '      for (Integer integer : roads) {', '        parents[integer] = city;', '      }', '    }', '', '    public void remove(Integer city) {', '      roads.get(parents[city]).remove(city);', '      roads.remove(city);', '    }', '', '  }', '    public void addRoad(int city1, int city2) {', '        addConnection(city1, city2);', '        addConnection(city2, city1);', '    }', '', '    private void addConnection(int city1, int city2) {', '        if (roads.containsKey(city1)) {', '        roads.get(city1).add(city2);', '        } else {', '        List<Integer> cities = new ArrayList<>();', '        cities.add(city2);', '        roads.put(city1, cities);', '        }', '    }', '', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'public class Solution{  ', '  ', '  private BufferedReader in; ', '  private StringTokenizer st;', '  private PrintWriter out;', '  ', '  int[][]parent ;', '  ', '  void process(){', '   ', '   for (int j = 1; j < 17; j++) {', '    for (int i = 1; i < parent.length; i++) {', '     parent[i][j] = parent[parent[i][j-1]][j-1];', '    }', '   }', '  }', '  void ancestor(int x, int k){', '   ', '   int node = x;', '   for(int j = 16;j>=0;j--){', '    if( (k&(1<<j)) != 0){', '     node = parent[node][j];', '     if(node == 0) break;', '    }', '   }', '   ', '   out.println(node);', '  }', '  ', '  void solve() throws IOException{', '   ', '  ', '   ', '   int t = nextInt();', '   while(t-->0){', '    parent = new int[100000+1][17];', '    int p = nextInt();', '    while(p-->0){', '     parent[nextInt()][0] = nextInt();', '    }', '    int q = nextInt();', '    process();', '    ', '    while(q-->0){', '     int type = nextInt();', '     if(type == 0){      ', '      int nodep = nextInt();', '      int node = nextInt();', '      parent[node][0] = nodep;', '      for (int j = 1; j < 17; j++) {', '       parent[node][j] = parent[parent[node][j-1]][j-1];', '      }', '      ', '     }', '     else if(type == 1){', '      int node = nextInt();', '      for (int j = 0; j < 17; j++) {', '       parent[node][j] = 0;', '      }', '      ', '     }', '     else if(type == 2){', '      int node = nextInt();', '      int k = nextInt();', '      ancestor(node,k);', '      ', '     }', '     ', '    }', '   }', '     ', '  }', '   ', '', '  Solution() throws IOException {', '   in = new BufferedReader(new InputStreamReader(System.in)); ', '   out = new PrintWriter(System.out);', '   eat("""");', '   solve(); ', '   out.close();', '  }', '', '  private void eat(String str) {', '   st = new StringTokenizer(str);', '  }', '', '  String next() throws IOException {', '   while (!st.hasMoreTokens()) {', '    String line = in.readLine();    ', '    if (line == null) {     ', '     return null;', '    }', '    eat(line);', '   }', '   return st.nextToken();', '  }', '', '  int nextInt() throws IOException {', '   return Integer.parseInt(next());', '  }', '', '  long nextLong() throws IOException {', '   return Long.parseLong(next());', '  }', '', '  double nextDouble() throws IOException {', '   return Double.parseDouble(next());', '  }', '', '  public static void main(String[] args) throws IOException {', '   new Solution();', '  }', '', '  int gcd(int a,int b){', '   if(b>a) return gcd(b,a);', '   if(b==0) return a;', '   return gcd(b,a%b);', '  }', '', '}']","['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class Solution {', '    static InputStream is;', '    static PrintWriter out;', '    static String INPUT = """";', '    ', '    static void solve()', '    {', '        for(int T = ni(); T >= 1;T--){', '            int n = 100001;', '            int m = ni();', '            int[] from = new int[m];', '            int[] to = new int[m];', '            for(int i = 0;i < m;i++){', '                from[i] = ni();', '                to[i] = ni();', '            }', '            int[][] g = packU(n, from, to);', '            int[] par = parents(g, 0);', '            ', '            int[][] spar = new int[17][n];', '            for(int i = 0;i < n;i++){', '                spar[0][i] = par[i];', '            }', '            for(int d = 1;d < 17;d++){', '                for(int i = 0;i < n;i++){', '                    spar[d][i] = spar[d-1][i] == -1 ? -1 : spar[d-1][spar[d-1][i]];', '                }', '            }', '            int Q = ni();', '            for(int z = 0;z < Q;z++){', '                int type = ni();', '                if(type == 0){', '                    // insert', '                    int y = ni(), x = ni();', '                    spar[0][x] = y;', '                    for(int d = 1;d < 17;d++){', '                        spar[d][x] = spar[d-1][x] == -1 ? -1 : spar[d-1][spar[d-1][x]];', '                    }', '                }else if(type == 1){', '                    // remove', '                    int y = ni();', '                    for(int d = 0;d < 17;d++){', '                        spar[d][y] = -1;', '                    }', '                }else if(type == 2){', '                    // kth', '                    int y = ni(), K = ni();', '                    for(int d = 0;d < 17;d++){', '                        if(K<<31-d<0){', '                            y = spar[d][y];', '                            if(y == -1)break;', '                        }', '                    }', '                    if(y == -1)y = 0;', '                    out.println(y);', '                }', '            }', '        }', '    }', '    ', '    static int[][] packU(int n, int[] from, int[] to) {', '        int[][] g = new int[n][];', '        int[] p = new int[n];', '        for(int f : from)', '            p[f]++;', '        for(int t : to)', '            p[t]++;', '        for(int i = 0;i < n;i++)', '            g[i] = new int[p[i]];', '        for(int i = 0;i < from.length;i++){', '            g[from[i]][--p[from[i]]] = to[i];', '            g[to[i]][--p[to[i]]] = from[i];', '        }', '        return g;', '    }', '    ', '    public static int[] parents(int[][] g, int root)', '    {', '        int n = g.length;', '        int[] par = new int[n];', '        Arrays.fill(par, -1);', '        ', '        int[] q = new int[n];', '        q[0] = root;', '        for(int p = 0, r = 1;p < r;p++) {', '            int cur = q[p];', '            for(int nex : g[cur]){', '                if(par[cur] != nex){', '                    q[r++] = nex;', '                    par[nex] = cur;', '                }', '            }', '        }', '        return par;', '    }', '    ', '    public static void main(String[] args) throws Exception', '    {', '        long S = System.currentTimeMillis();', '        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        solve();', '        out.flush();', '        long G = System.currentTimeMillis();', '        tr(G-S+""ms"");', '    }', '    ', '    private static boolean eof()', '    {', '        if(lenbuf == -1)return true;', '        int lptr = ptrbuf;', '        while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '        ', '        try {', '            is.mark(1000);', '            while(true){', '                int b = is.read();', '                if(b == -1){', '                    is.reset();', '                    return true;', '                }else if(!isSpaceChar(b)){', '                    is.reset();', '                    return false;', '                }', '            }', '        } catch (IOException e) {', '            return true;', '        }', '    }', '    ', '    private static byte[] inbuf = new byte[1024];', '    static int lenbuf = 0, ptrbuf = 0;', '    ', '    private static int readByte()', '    {', '        if(lenbuf == -1)throw new InputMismatchException();', '        if(ptrbuf >= lenbuf){', '            ptrbuf = 0;', '            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '            if(lenbuf <= 0)return -1;', '        }', '        return inbuf[ptrbuf++];', '    }', '    ', '    private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', '    private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', '    ', '    private static double nd() { return Double.parseDouble(ns()); }', '    private static char nc() { return (char)skip(); }', '    ', '    private static String ns()', '    {', '        int b = skip();', '        StringBuilder sb = new StringBuilder();', ""        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '            sb.appendCodePoint(b);', '            b = readByte();', '        }', '        return sb.toString();', '    }', '    ', '    private static char[] ns(int n)', '    {', '        char[] buf = new char[n];', '        int b = skip(), p = 0;', '        while(p < n && !(isSpaceChar(b))){', '            buf[p++] = (char)b;', '            b = readByte();', '        }', '        return n == p ? buf : Arrays.copyOf(buf, p);', '    }', '    ', '    private static char[][] nm(int n, int m)', '    {', '        char[][] map = new char[n][];', '        for(int i = 0;i < n;i++)map[i] = ns(m);', '        return map;', '    }', '    ', '    private static int[] na(int n)', '    {', '        int[] a = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        return a;', '    }', '    ', '    private static int ni()', '    {', '        int num = 0, b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static long nl()', '    {', '        long num = 0;', '        int b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static long[] F = new long[10001];', ' ', ' static void solve()', ' {', '  F[0] = 1;', '  for(int i = 1;i <= 10000;i++){', '   F[i] = F[i-1] * i % mod;', '  }', '  ', '  for(int T = ni();T >= 1;T--){', '   int n = ni();', '   int[] f = new int[n-1];', '   int[] t = new int[n-1];', '   for(int i = 0;i < n-1;i++){', '    f[i] = ni();', '    t[i] = ni();', '   }', '   if(n == 2){', '    out.println(0);', '    continue;', '   }', '   if(n == 1){', '    out.println(1);', '    continue;', '   }', '   ', '   int[][] g = packU(n, f, t);', '   int[][] pars = parents(g, 0);', '   int[] par = pars[0];', '   int[] ord = pars[1];', '   int[] des = new int[n];', '   for(int i = n-1;i >= 0;i--){', '    int cur = ord[i];', '    int max = 0;', '    for(int e : g[cur]){', '     if(par[cur] != e){', '      max = Math.max(max, des[e]+1);', '     }', '    }', '    des[cur] = max;', '   }', '   ', '   int root = 0;', '   if(g[0].length == 1 && g[g[0][0]].length >= 2){', '    root = g[0][0];', '   }', '   ', '   int over = 0;', '   for(int e : g[root]){', '    if(par[root] != e && des[e] > 0)over++;', '   }', '   long r;', '   if(over >= 3){', '    r = 0;', '   }else if(over == 0){', '    r = F[g[root].length];', '   }else{', '    r = 2*F[g[root].length-over];', '    for(int e : g[root]){', '     if(par[root] != e){', '      r = r * rec(e, g, par, des) % mod;', '     }', '    }', '   }', '   out.println(r);', '  }', ' }', ' static long mod = 1000000007;', ' ', ' static long rec(int cur, int[][] g, int[] par, int[] des)', ' {', '  int oo = -1;', '  int one = 0;', '  for(int e : g[cur]){', '   if(par[cur] != e){', '    if(des[e] > 0){', '     if(oo != -1)return 0;', '     oo = e;', '    }else{', '     one++;', '    }', '   }', '  }', '  if(oo != -1){', '   return rec(oo, g, par, des) * F[one] % mod;', '  }else{', '   return F[one];', '  }', ' }', ' ', ' public static int[][] parents(int[][] g, int root)', ' {', '  int n = g.length;', '  int[] par = new int[n];', '  Arrays.fill(par, -1);', '  ', '  int[] q = new int[n];', '  q[0] = root;', '  for(int p = 0, r = 1;p < r;p++) {', '   int cur = q[p];', '   for(int nex : g[cur]){', '    if(par[cur] != nex){', '     q[r++] = nex;', '     par[nex] = cur;', '    }', '   }', '  }', '  return new int[][] {par, q};', ' }', ' ', ' public static int[][] packU(int n, int[] from, int[] to)', ' {', '  int[][] g = new int[n][];', '  int[] p = new int[n];', '  for(int f : from)p[f]++;', '  for(int t : to)p[t]++;', '  for(int i = 0;i < n;i++)g[i] = new int[p[i]];', '  for(int i = 0;i < from.length;i++){', '   g[from[i]][--p[from[i]]] = to[i];', '   g[to[i]][--p[to[i]]] = from[i];', '  }', '  return g;', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' static boolean eof()', ' {', '  try {', '   is.mark(1000);', '   int b;', '   while((b = is.read()) != -1 && !(b >= 33 && b <= 126));', '   is.reset();', '   return b == -1;', '  } catch (IOException e) {', '   return true;', '  }', ' }', '  ', ' static int ni()', ' {', '  try {', '   int num = 0;', '   boolean minus = false;', ""   while((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));"", ""   if(num == '-'){"", '    num = 0;', '    minus = true;', '   }else{', ""    num -= '0';"", '   }', '   ', '   while(true){', '    int b = is.read();', ""    if(b >= '0' && b <= '9'){"", ""     num = num * 10 + (b - '0');"", '    }else{', '     return minus ? -num : num;', '    }', '   }', '  } catch (IOException e) {', '  }', '  return -1;', ' }', ' ', ' static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    private static final int MODULUS = 1000000007;', '', '    private static class Node {', '        Set<Node> neighbors = new HashSet<>();', '    }', '', '    /*', '     * Complete the bytelandianTours function below.', '     */', '    static int bytelandianTours(int n, int[][] roads) {', '        Node[] nodes = new Node[n];', '        for (int i = 0; i < n; i++) {', '            nodes[i] = new Node();', '        }', '        for (int[] road : roads) {', '            nodes[road[0]].neighbors.add(nodes[road[1]]);', '            nodes[road[1]].neighbors.add(nodes[road[0]]);', '        }', '', '        long result = 1;', '        int nonLeaves = 0;', '        for (Node node : nodes) {', '            if (node.neighbors.size() > 1) {', '                nonLeaves++;', '                int leaves = leafNeighbors(node);', '                if (leaves + 2 < node.neighbors.size()) {', '                    return 0;', '                } else {', '//                    System.out.println(String.format(""Multiplying by %d!"", node.neighbors.size() - 2));', '                    for (int i = 2; i <= leaves; i++) {', '                        result = (result*i) % MODULUS;', '                    }', '                }', '            }', '        }', '        if (nonLeaves > 1) {', '            result = (result*2) % MODULUS;', '        }', '        return (int) result;', '    }', '', '    private static int leafNeighbors(Node n) {', '        int leaves = 0;', '        for (Node other : n.neighbors) {', '            if (other.neighbors.size() == 1) {', '                leaves++;', '            }', '        }', '        return leaves;', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int t = scanner.nextInt();', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '        for (int tItr = 0; tItr < t; tItr++) {', '            int n = scanner.nextInt();', '            scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '            int[][] roads = new int[n-1][2];', '', '            for (int roadsRowItr = 0; roadsRowItr < n-1; roadsRowItr++) {', '                String[] roadsRowItems = scanner.nextLine().split("" "");', '                scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '                for (int roadsColumnItr = 0; roadsColumnItr < 2; roadsColumnItr++) {', '                    int roadsItem = Integer.parseInt(roadsRowItems[roadsColumnItr]);', '                    roads[roadsRowItr][roadsColumnItr] = roadsItem;', '                }', '            }', '', '            int result = bytelandianTours(n, roads);', '', '            bufferedWriter.write(String.valueOf(result));', '            bufferedWriter.newLine();', '        }', '', '        bufferedWriter.close();', '', '        scanner.close();', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class FindThePath {', ' InputStream is;', ' PrintWriter out;', ' String INPUT = """";', '', ' void solve() {', '  int n = ni(), m = ni();', '  int[][] a = new int[m][n];', '  for (int i = 0; i < n; i++) {', '   for (int j = 0; j < m; j++) {', '    a[j][i] = ni();', '   }', '  }', '  d = new long[m][n][][];', '', '  build(0, m, a);', '', '  int Q = ni();', '  for (int q = 0; q < Q; q++) {', '   int sc = ni(), sr = ni();', '   int tc = ni(), tr = ni();', '   if (sr > tr) {', '    {', '     int du = tr;', '     tr = sr;', '     sr = du;', '    }', '    {', '     int du = tc;', '     tc = sc;', '     sc = du;', '    }', '   }', '   out.println(go(0, m, sr, sc, tr, tc, a));', '  }', '', ' }', '', ' static long go(int L, int R, int sr, int sc, int tr, int tc, int[][] a) {', '  int M = L + R >>> 1;', '  int m = a[0].length;', '  long ret = Long.MAX_VALUE;', '  for (int i = 0; i < m; i++) {', '   ret = Math.min(ret, d[M][i][sr - L][sc] + d[M][i][tr - L][tc] - a[M][i]);', '  }', '  if (sr <= M && M <= tr) {', '   return ret;', '  }', '  if (R - L <= 1)', '   return ret;', '  if (tr < M) {', '   return Math.min(ret, go(L, M, sr, sc, tr, tc, a));', '  } else {', '   return Math.min(ret, go(M, R, sr, sc, tr, tc, a));', '  }', ' }', '', ' static long[][][][] d;', '', ' static void build(int L, int R, int[][] a) {', '  int m = a[0].length;', '  int M = L + R >>> 1;', '  if (d[M][0] != null)', '   return;', '  for (int i = 0; i < m; i++) {', '   d[M][i] = dijk(a, M, i, L, R);', '  }', '  if (R - L <= 1)', '   return;', '  build(L, M, a);', '  build(M, R, a);', ' }', '', ' public static long[][] dijk(int[][] a, int sr, int sc, int L, int R) {', '  int m = a[0].length;', '  long[][] td = new long[R - L][m];', '  for (int i = 0; i < R - L; i++) {', '   Arrays.fill(td[i], Long.MAX_VALUE / 3);', '  }', '  td[sr - L][sc] = 0;', '  MinHeapL q = new MinHeapL((R - L) * m);', '  q.add((sr - L) * m + sc, 0L);', '  td[sr - L][sc] = a[sr][sc];', '', '  int[] dr = { 1, 0, -1, 0 };', '  int[] dc = { 0, 1, 0, -1 };', '', '  while (q.size() > 0) {', '   int cur = q.argmin();', '   q.remove(cur);', '', '   int r = cur / m, c = cur % m;', '   for (int k = 0; k < 4; k++) {', '    int nr = r + dr[k], nc = c + dc[k];', '    if (nr >= L - L && nr < R - L && nc >= 0 && nc < m) {', '     long nd = td[r][c] + a[nr + L][nc];', '     if (nd < td[nr][nc]) {', '      td[nr][nc] = nd;', '      q.update(nr * m + nc, nd);', '     }', '    }', '   }', '  }', '', '  return td;', ' }', '', ' public static class MinHeapL {', '  public long[] a;', '  public int[] map;', '  public int[] imap;', '  public int n;', '  public int pos;', '  public static long INF = Long.MAX_VALUE;', '', '  public MinHeapL(int m) {', '   n = Integer.highestOneBit((m + 1) << 1);', '   a = new long[n];', '   map = new int[n];', '   imap = new int[n];', '   Arrays.fill(a, INF);', '   Arrays.fill(map, -1);', '   Arrays.fill(imap, -1);', '   pos = 1;', '  }', '', '  public long add(int ind, long x) {', '   int ret = imap[ind];', '   if (imap[ind] < 0) {', '    a[pos] = x;', '    map[pos] = ind;', '    imap[ind] = pos;', '    pos++;', '    up(pos - 1);', '   }', '   return ret != -1 ? a[ret] : x;', '  }', '', '  public long update(int ind, long x) {', '   int ret = imap[ind];', '   if (imap[ind] < 0) {', '    a[pos] = x;', '    map[pos] = ind;', '    imap[ind] = pos;', '    pos++;', '    up(pos - 1);', '   } else {', '    a[ret] = x;', '    up(ret);', '    down(ret);', '   }', '   return x;', '  }', '', '  public long remove(int ind) {', '   if (pos == 1)', '    return INF;', '   if (imap[ind] == -1)', '    return INF;', '', '   pos--;', '   int rem = imap[ind];', '   long ret = a[rem];', '   map[rem] = map[pos];', '   imap[map[pos]] = rem;', '   imap[ind] = -1;', '   a[rem] = a[pos];', '   a[pos] = INF;', '   map[pos] = -1;', '', '   up(rem);', '   down(rem);', '   return ret;', '  }', '', '  public long min() {', '   return a[1];', '  }', '', '  public int argmin() {', '   return map[1];', '  }', '', '  public int size() {', '   return pos - 1;', '  }', '', '  private void up(int cur) {', '   for (int c = cur, p = c >>> 1; p >= 1 && a[p] > a[c]; c >>>= 1, p >>>= 1) {', '    long d = a[p];', '    a[p] = a[c];', '    a[c] = d;', '    int e = imap[map[p]];', '    imap[map[p]] = imap[map[c]];', '    imap[map[c]] = e;', '    e = map[p];', '    map[p] = map[c];', '    map[c] = e;', '   }', '  }', '', '  private void down(int cur) {', '   for (int c = cur; 2 * c < pos;) {', '    int b = a[2 * c] < a[2 * c + 1] ? 2 * c : 2 * c + 1;', '    if (a[b] < a[c]) {', '     long d = a[c];', '     a[c] = a[b];', '     a[b] = d;', '     int e = imap[map[c]];', '     imap[map[c]] = imap[map[b]];', '     imap[map[b]] = e;', '     e = map[c];', '     map[c] = map[b];', '     map[b] = e;', '     c = b;', '    } else {', '     break;', '    }', '   }', '  }', ' }', '', ' void run() throws Exception {', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '', '  long s = System.currentTimeMillis();', '  solve();', '  out.flush();', '  if (!INPUT.isEmpty())', '   tr(System.currentTimeMillis() - s + ""ms"");', ' }', '', ' public static void main(String[] args) throws Exception {', '  new FindThePath().run();', ' }', '', ' private byte[] inbuf = new byte[1024];', ' private int lenbuf = 0, ptrbuf = 0;', '', ' private int readByte() {', '  if (lenbuf == -1)', '   throw new InputMismatchException();', '  if (ptrbuf >= lenbuf) {', '   ptrbuf = 0;', '   try {', '    lenbuf = is.read(inbuf);', '   } catch (IOException e) {', '    throw new InputMismatchException();', '   }', '   if (lenbuf <= 0)', '    return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', '', ' private boolean isSpaceChar(int c) {', '  return !(c >= 33 && c <= 126);', ' }', '', ' private int skip() {', '  int b;', '  while ((b = readByte()) != -1 && isSpaceChar(b))', '   ;', '  return b;', ' }', '', ' private double nd() {', '  return Double.parseDouble(ns());', ' }', '', ' private char nc() {', '  return (char) skip();', ' }', '', ' private String ns() {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', '', ' private char[] ns(int n) {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while (p < n && !(isSpaceChar(b))) {', '   buf[p++] = (char) b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', '', ' private char[][] nm(int n, int m) {', '  char[][] map = new char[n][];', '  for (int i = 0; i < n; i++)', '   map[i] = ns(m);', '  return map;', ' }', '', ' private int[] na(int n) {', '  int[] a = new int[n];', '  for (int i = 0; i < n; i++)', '   a[i] = ni();', '  return a;', ' }', '', ' private int ni() {', '  int num = 0, b;', '  boolean minus = false;', ""  while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))"", '   ;', ""  if (b == '-') {"", '   minus = true;', '   b = readByte();', '  }', '', '  while (true) {', ""   if (b >= '0' && b <= '9') {"", ""    num = num * 10 + (b - '0');"", '   } else {', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', '', ' private long nl() {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))"", '   ;', ""  if (b == '-') {"", '   minus = true;', '   b = readByte();', '  }', '', '  while (true) {', ""   if (b >= '0' && b <= '9') {"", ""    num = num * 10 + (b - '0');"", '   } else {', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', '', ' private static void tr(Object... o) {', '  System.out.println(Arrays.deepToString(o));', ' }', '}']","['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class C {', '    InputStream is;', '    PrintWriter out;', '    String INPUT = """";', '    ', '    void solve()', '    {', '        int n = ni(), m = ni();', '        int[][] a = new int[m][n];', '        for(int i = 0;i < n;i++){', '            for(int j = 0;j < m;j++){', '                a[j][i] = ni();', '            }', '        }', '        d = new long[m][n][][];', '        ', '        build(0, m, a);', '        ', '        int Q = ni();', '        for(int q = 0;q < Q;q++){', '            int sc = ni(), sr = ni();', '            int tc = ni(), tr = ni();', '            if(sr > tr){', '                {int du = tr; tr = sr; sr = du;}', '                {int du = tc; tc = sc; sc = du;}', '            }', '            out.println(go(0, m, sr, sc, tr, tc, a));', '        }', '        ', '    }', '    ', '    static long go(int L, int R, int sr, int sc, int tr, int tc, int[][] a)', '    {', '        int M = L+R>>>1;', '        int m = a[0].length;', '        long ret = Long.MAX_VALUE;', '        for(int i = 0;i < m;i++){', '            ret = Math.min(ret, d[M][i][sr-L][sc] + d[M][i][tr-L][tc] - a[M][i]);', '        }', '        if(sr <= M && M <= tr){', '            return ret;', '        }', '        if(R-L <= 1)return ret;', '        if(tr < M){', '            return Math.min(ret, go(L, M, sr, sc, tr, tc, a));', '        }else{', '            return Math.min(ret, go(M, R, sr, sc, tr, tc, a));', '        }', '    }', '    ', '    static long[][][][] d;', '    ', '    static void build(int L, int R, int[][] a)', '    {', '        int m = a[0].length;', '        int M = L+R>>>1;', '        if(d[M][0] != null)return;', '        for(int i = 0;i < m;i++){', '            d[M][i] = dijk(a, M, i, L, R);', '        }', '        if(R-L <= 1)return;', '        build(L, M, a);', '        build(M, R, a);', '    }', '    ', '    public static long[][] dijk(int[][]  a, int sr, int sc, int L, int R)', '    {', '        int m = a[0].length;', '        long[][] td = new long[R-L][m];', '        for(int i = 0;i < R-L;i++){', '            Arrays.fill(td[i], Long.MAX_VALUE / 3);', '        }', '        td[sr-L][sc] = 0;', '        MinHeapL q = new MinHeapL((R-L)*m);', '        q.add((sr-L)*m+sc, 0L);', '        td[sr-L][sc] = a[sr][sc];', '        ', '        int[] dr = { 1, 0, -1, 0 };', '        int[] dc = { 0, 1, 0, -1 };', '        ', '        while(q.size() > 0){', '            int cur = q.argmin();', '            q.remove(cur);', '            ', '            int r = cur / m, c = cur % m;', '            for(int k = 0;k < 4;k++){', '                int nr = r + dr[k], nc = c + dc[k];', '                if(nr >= L-L && nr < R-L && nc >= 0 && nc < m){', '                    long nd = td[r][c] + a[nr+L][nc];', '                    if(nd < td[nr][nc]){', '                        td[nr][nc] = nd;', '                        q.update(nr*m+nc, nd);', '                    }', '                }', '            }', '        }', '        ', '        return td;', '    }', '    ', '    public static class MinHeapL {', '        public long[] a;', '        public int[] map;', '        public int[] imap;', '        public int n;', '        public int pos;', '        public static long INF = Long.MAX_VALUE;', '        ', '        public MinHeapL(int m)', '        {', '            n = Integer.highestOneBit((m+1)<<1);', '            a = new long[n];', '            map = new int[n];', '            imap = new int[n];', '            Arrays.fill(a, INF);', '            Arrays.fill(map, -1);', '            Arrays.fill(imap, -1);', '            pos = 1;', '        }', '        ', '        public long add(int ind, long x)', '        {', '            int ret = imap[ind];', '            if(imap[ind] < 0){', '                a[pos] = x; map[pos] = ind; imap[ind] = pos;', '                pos++;', '                up(pos-1);', '            }', '            return ret != -1 ? a[ret] : x;', '        }', '        ', '        public long update(int ind, long x)', '        {', '            int ret = imap[ind];', '            if(imap[ind] < 0){', '                a[pos] = x; map[pos] = ind; imap[ind] = pos;', '                pos++;', '                up(pos-1);', '            }else{', '                a[ret] = x;', '                up(ret);', '                down(ret);', '            }', '            return x;', '        }', '        ', '        public long remove(int ind)', '        {', '            if(pos == 1)return INF;', '            if(imap[ind] == -1)return INF;', '            ', '            pos--;', '            int rem = imap[ind];', '            long ret = a[rem];', '            map[rem] = map[pos];', '            imap[map[pos]] = rem;', '            imap[ind] = -1;', '            a[rem] = a[pos];', '            a[pos] = INF;', '            map[pos] = -1;', '            ', '            up(rem);', '            down(rem);', '            return ret;', '        }', '        ', '        public long min() { return a[1]; }', '        public int argmin() { return map[1]; }', '        public int size() {    return pos-1; }', '        ', '        private void up(int cur)', '        {', '            for(int c = cur, p = c>>>1;p >= 1 && a[p] > a[c];c>>>=1, p>>>=1){', '                long d = a[p]; a[p] = a[c]; a[c] = d;', '                int e = imap[map[p]]; imap[map[p]] = imap[map[c]]; imap[map[c]] = e;', '                e = map[p]; map[p] = map[c]; map[c] = e;', '            }', '        }', '        ', '        private void down(int cur)', '        {', '            for(int c = cur;2*c < pos;){', '                int b = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;', '                if(a[b] < a[c]){', '                    long d = a[c]; a[c] = a[b]; a[b] = d;', '                    int e = imap[map[c]]; imap[map[c]] = imap[map[b]]; imap[map[b]] = e;', '                    e = map[c]; map[c] = map[b]; map[b] = e;', '                    c = b;', '                }else{', '                    break;', '                }', '            }', '        }', '    }    ', '    ', '    void run() throws Exception', '    {', '        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        long s = System.currentTimeMillis();', '        solve();', '        out.flush();', '        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', '    }', '    ', '    public static void main(String[] args) throws Exception { new C().run(); }', '    ', '    private byte[] inbuf = new byte[1024];', '    private int lenbuf = 0, ptrbuf = 0;', '    ', '    private int readByte()', '    {', '        if(lenbuf == -1)throw new InputMismatchException();', '        if(ptrbuf >= lenbuf){', '            ptrbuf = 0;', '            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '            if(lenbuf <= 0)return -1;', '        }', '        return inbuf[ptrbuf++];', '    }', '    ', '    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', '    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', '    ', '    private double nd() { return Double.parseDouble(ns()); }', '    private char nc() { return (char)skip(); }', '    ', '    private String ns()', '    {', '        int b = skip();', '        StringBuilder sb = new StringBuilder();', ""        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '            sb.appendCodePoint(b);', '            b = readByte();', '        }', '        return sb.toString();', '    }', '    ', '    private char[] ns(int n)', '    {', '        char[] buf = new char[n];', '        int b = skip(), p = 0;', '        while(p < n && !(isSpaceChar(b))){', '            buf[p++] = (char)b;', '            b = readByte();', '        }', '        return n == p ? buf : Arrays.copyOf(buf, p);', '    }', '    ', '    private char[][] nm(int n, int m)', '    {', '        char[][] map = new char[n][];', '        for(int i = 0;i < n;i++)map[i] = ns(m);', '        return map;', '    }', '    ', '    private int[] na(int n)', '    {', '        int[] a = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        return a;', '    }', '    ', '    private int ni()', '    {', '        int num = 0, b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private long nl()', '    {', '        long num = 0;', '        int b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '    static final long INF = 1000000000000000000L;', '', '    static class Edge {', '        int o;', '        long len;', '', '        public Edge(int o, long len) {', '            this.o = o;', '            this.len = len;', '        }', '    }', '', '    static class Point implements Comparable<Point> {', '        long x, y;', '', '        public Point(long x, long y) {', '            this.x = x;', '            this.y = y;', '        }', '', '        @Override', '        public int compareTo(Point o) {', '            if (x == o.x) {', '                return Long.compare(o.y, y);', '            }', '            return Long.compare(x, o.x);', '        }', '    }', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        int tests = in.nextInt();', '        for (int test = 0; test < tests; ++test) {', '            int n = in.nextInt();', '            int m = in.nextInt();', '            int k = in.nextInt() - 1;', '            ArrayList<Edge>[] edges = new ArrayList[n];', '            for (int i = 0; i < n; ++i) {', '                edges[i] = new ArrayList<Edge>();', '            }', '            int a0 = -1, b0 = -1;', '            long c0 = -1;', '            for (int i = 0; i < m; ++i) {', '                int a = in.nextInt() - 1;', '                int b = in.nextInt() - 1;', '                long c = in.nextLong();', '                if (i == k) {', '                    a0 = a;', '                    b0 = b;', '                    c0 = c;', '                } else {', '                    edges[a].add(new Edge(b, c));', '                    edges[b].add(new Edge(a, c));', '                }', '            }', '            long[] da = dists(a0, edges);', '            long[] db = dists(b0, edges);', '            Point[] points = new Point[n];', '            for (int i = 0; i < n; ++i) {', '                if (da[i] == INF && db[i] == INF) {', '                    throw new AssertionError();', '                }', '                if (da[i] + c0 < db[i]) {', '                    points[i] = new Point(-da[i], da[i] + 2 * c0);', '                } else if (db[i] + c0 < da[i]) {', '                    points[i] = new Point(-db[i] - c0, db[i] + c0);', '                } else {', '                    points[i] = new Point(-da[i], db[i] + c0);', '                }', '            }', '            Arrays.sort(points);', '            Point last = null, ans = null;', '            for (Point p : points) {', '                Point cur;', '                if (last == null) {', '                    cur = new Point(0, -2 * p.x);', '                } else if (last.y < p.y) {', '                    cur = new Point(p.x + last.y, last.y - p.x);', '                } else {', '                    continue;', '                }', '                last = p;', '                if (ans == null || ans.y > cur.y || ans.y == cur.y && ans.x > cur.x) {', '                    ans = cur;', '                }', '            }', '            if (last == null) {', '                throw new AssertionError();', '            }', '            {', '                Point cur = new Point(2 * c0, 2 * (last.y - c0));', '                if (ans == null || ans.y > cur.y || ans.y == cur.y && ans.x > cur.x) {', '                    ans = cur;', '                }', '            }', '            out.printf(""%.5f %.5f%n"", ans.x / 2.0, ans.y / 2.0);', '        }', '    }', '', '    static class Node implements Comparable<Node> {', '        int i;', '        long dist;', '', '        public Node(int i, long dist) {', '            this.i = i;', '            this.dist = dist;', '        }', '', '        @Override', '        public int compareTo(Node o) {', '            return Long.compare(dist, o.dist);', '        }', '    }', '', '    private static long[] dists(int v0, ArrayList<Edge>[] edges) {', '        long[] d = new long[edges.length];', '        Arrays.fill(d, INF);', '        PriorityQueue<Node> pq = new PriorityQueue<Node>();', '        d[v0] = 0;', '        pq.add(new Node(v0, 0));', '        while (!pq.isEmpty()) {', '            Node n = pq.poll();', '            if (d[n.i] != n.dist) {', '                continue;', '            }', '            for (Edge e : edges[n.i]) {', '                if (d[e.o] > n.dist + e.len) {', '                    d[e.o] = n.dist + e.len;', '                    pq.add(new Node(e.o, d[e.o]));', '                }', '            }', '        }', '        return d;', '    }', '', '    public static void main(String[] args) throws IOException {', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']","['import java.io.*;', 'import java.text.DecimalFormat;', 'import java.text.NumberFormat;', 'import java.util.*;', '', 'public class Solution {', '', '  static class Node {', '    int src;', '    int weight;', '', '    public Node(int src, int weight) {', '      this.src = src;', '      this.weight = weight;', '    }', '  }', '', '  static class Pll implements Comparable<Pll>  {', '    long dis0;', '    long dis1;', '', '    public Pll(long dis0, long dis1) {', '      this.dis0 = dis0;', '      this.dis1 = dis1;', '    }', '', '    @Override', '    public int compareTo(Pll o) {', '      if (dis0 != o.dis0) {', '        return  dis0 > o.dis0? 1 : -1;', '        ', '      } else {', '        if (dis1 == o.dis1) return 0;', '        return  dis1 > o.dis1 ? 1 : -1;', '      }', '    }', '  }', '', '  static class NodeQ implements Comparable<NodeQ> {', '    long dis;', '    int se;', '', '    public NodeQ(long fi, int se) {', '      this.dis = fi;', '      this.se = se;', '    }', '', '    @Override', '    public int compareTo(NodeQ o) {', '      if (dis == o.dis) return 0;', '      return dis > o.dis ? 1 : -1;', '    }', '  }', '  ', '  static final int N = 100000;', '  static final NumberFormat FORMATTER = new DecimalFormat(""#0.00000"");', '  static boolean[] vis = new boolean[N];', '  static long[] d0 = new long[N];', '  static long[] d1 = new long[N];', '  static List<Node>[] nodes = new List[N];', '', '  static void dijkstra(int n, int src, long d[]) {', '    for (int i=0; i <n; i++) {', '      vis[i] = false;', '      d[i] = Long.MAX_VALUE/3;', '    }', '    d[src] = 0;', '    PriorityQueue<NodeQ> queue = new PriorityQueue<>();', '    queue.add(new NodeQ(0, src));', '    while (!queue.isEmpty()) {', '      NodeQ x = queue.poll();', '      if (vis[x.se]) {', '        continue;', '      }', '      vis[x.se] = true;', '      for (Node e: nodes[x.se]) {', '        if (x.dis+e.weight < d[e.src]) {', '          queue.add(new NodeQ(d[e.src] = x.dis+e.weight, e.src));', '        }', '      }', '    }', '  }', '  ', '  static double[] solve(int n, int k, int x, int y, int z) {', '    dijkstra(n, x, d0);', '    dijkstra(n, y, d1);', '    Pll[] a = new Pll[n];', '    for (int i = 0; i < n; i++) {', '      a[i] = new Pll(d0[i], d1[i]);', '    }', '    Arrays.sort(a);', '    long result0 = 0;', '    long result1 = 2*a[n-1].dis0;', '    int p = n-1;', '    for (int i = n-1; --i >= 0; )', '      if (a[i].dis1 > a[p].dis1) {', '        long t = a[i].dis0+a[p].dis1+z;', '        if (t < result1) {', '          result0 = a[p].dis1+z-a[i].dis0;', '          result1 = t;', '        }', '        p = i;', '      }', '    long t = 2*a[p].dis1;', '    if (t < result1) {', '      result1 = t;', '      result0 = 2*z;', '    }', '    return new double[] { result0*.5, result1*.5};', '  }', '  ', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int t = Integer.parseInt(st.nextToken());', '', '    for (int tItr = 0; tItr < t; tItr++) {', '      st = new StringTokenizer(br.readLine());', '      int n = Integer.parseInt(st.nextToken());', '      int m = Integer.parseInt(st.nextToken());', '      int k = Integer.parseInt(st.nextToken())-1;', '', '      for (int i=0; i< n; i++) {', '        if (nodes[i] == null) {', '          nodes[i] = new LinkedList<>();', '        } else {', '          nodes[i].clear();', '        }', '      }', '      ', '      int x = 0;', '      int y = 0;', '      int z = 0;', '      for (int i = 0; i < m; i++) {', '        st = new StringTokenizer(br.readLine());', '        int u = Integer.parseInt(st.nextToken())-1;', '        int v = Integer.parseInt(st.nextToken())-1;', '        int w = Integer.parseInt(st.nextToken());', '        if (i == k) {', '          x = u;', '          y = v;', '          z = w;', '        }', '        nodes[u].add(new Node(v, w));', '        nodes[v].add(new Node(u, w));', '', '      }', '', '      double[] result = solve(n, k, x, y, z);', '      bw.write(FORMATTER.format(result[0]));', '      bw.write("" "");', '      bw.write(FORMATTER.format(result[1]));', '', '      bw.newLine();', '    }', '', '    bw.close();', '    br.close();', '  }', '}']"
"['import java.util.*;', 'import java.io.*;', 'import static java.lang.Math.*;', '', 'public class Solution {', ' /*', '  * difference constraints', '  * add new constraint d[N]-d[0] = k and check if k is feasible', '  */', ' static class Foo51 {', '  int N;', '  int[][] edges;', '  void main() {', '   BufferedReader br = null;', '   try {', '    br = new BufferedReader(new InputStreamReader(System.in));', '    String[] s = br.readLine().trim().split("" "");', '    N = Integer.parseInt(s[0].trim());', '    int M = Integer.parseInt(s[1].trim());', '    edges = new int[2*M+2*N+2][3];', '    for (int i = 0; i < M; i++) {', '     s = br.readLine().trim().split("" "");', '     int u = Integer.parseInt(s[0].trim());', '     int v = Integer.parseInt(s[1].trim());', '     int weight = Integer.parseInt(s[2].trim());', '     edges[2*i] = new int[] {u-1, v, weight};', '     edges[2*i+1] = new int[] {v, u-1, -weight};', '    }', '    for (int i = 0; i < N; i++) {', '     edges[2*i+2*M] = new int[] {i+1, i, 0};', '     edges[2*i+2*M+1] = new int[] {i, i+1, 1};', '    }', '    edges[2*M+2*N][0] = edges[2*M+2*N+1][1] = 0;', '    edges[2*M+2*N+1][0] = edges[2*M+2*N][1] = N;', '    int[] res = foo();', '    System.out.println(res[0] + "" "" + res[1]);', '   } catch (Exception e) {', '    e.printStackTrace();', '   } finally {', '    if (br != null) {', '     try { br.close(); } catch (Exception e) { e.printStackTrace(); }', '    }', '   }', '  }', '  int[] foo() {', '   // binary search is better, but since the constraint is low, just linear traverse', '   int[] res = {N, 0};', '   for (int k = 0; k <= N; k++) {', '    if (ok(k)) {', '     res[0] = min(res[0], k);', '     res[1] = max(res[1], k);', '    }', '   }', '   return res;', '  }', '  boolean ok(int K) {', '   int m = edges.length;', '   edges[m-2][2] = K;', '   edges[m-1][2] = -K;', '   int[] d = new int[N+1];', '   for (int i = 0; i < N+1; i++) {', '    for (int j = 0; j < m; j++) {', '     int u = edges[j][0];', '     int v = edges[j][1];', '     d[v] = min(d[v], d[u]+edges[j][2]);', '    }', '   }', '   for (int j = 0; j < m; j++) {', '    int u = edges[j][0];', '    int v = edges[j][1];', '    if (d[v] > d[u] + edges[j][2])', '     return false;', '   }', '   return true;', '  }', ' }', ' ', ' public static void main(String[] args) {', '  Foo51 foo = new Foo51();', '  foo.main();', ' }', '}']","['import java.io.BufferedWriter;', 'import java.io.FileWriter;', 'import java.io.IOException;', 'import java.util.AbstractMap;', 'import java.util.Arrays;', 'import java.util.Comparator;', 'import java.util.HashMap;', 'import java.util.LinkedList;', 'import java.util.Map;', 'import java.util.PriorityQueue;', 'import java.util.Queue;', 'import java.util.Scanner;', '', 'public class Solution {', '', '    static int findMax(int n, int[][] sets, boolean opposite) {', '        final Map<Integer, Integer>[] ws = new Map[n + 1];', '        for (int i = 0; i <= n; i++) {', '            ws[i] = new HashMap<>(n);', '        }', '        for (int i = 0; i < n; i++) {', '            ws[i].put(i + 1, 1);', '            ws[i + 1].put(i, 0);', '        }', '        if (opposite) {', '            for (int[] s : sets) {', '                int w = s[1] - s[0] - s[2] + 1;', '                ws[s[0] - 1].put(s[1], w);', '                ws[s[1]].put(s[0] - 1, -w);', '            }', '        } else {', '            for (int[] s : sets) {', '                ws[s[0] - 1].put(s[1], s[2]);', '                ws[s[1]].put(s[0] - 1, -s[2]);', '            }', '        }', '', '        return minPath(ws);', '    }', '', '    static int minPath(Map<Integer,Integer>[] ws){', '        int n = ws.length;', '        int[] d = new int[n];', '        Arrays.fill(d, Short.MAX_VALUE);', '        d[0] = 0;', '', '        boolean[] state = new boolean[n];', '', '        Queue<Integer> q = new LinkedList<>();', '        q.add(0);', '        while (!q.isEmpty()){', '            int v = q.poll();', '            state[v] = false;', '            for(AbstractMap.Entry<Integer, Integer> jw: ws[v].entrySet()){', '                int j = jw.getKey();', '                int w = d[v]+jw.getValue();', '                if(w < d[j]){', '                    d[j] = w;', '                    if (!state[j]){', '                        state[j] = true;', '                        q.add(j);', '                    }', '                }', '            }', '        }', '        return d[n-1];', '    }', '', '    /*', '     * Complete the liars function below.', '     */', '    static int[] liars(int n, int[][] sets) {', '        int min = n - findMax(n, sets, true);', '        int max = findMax(n, sets, false);', '', '        return new int[]{min, max};', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        String[] nm = scanner.nextLine().split("" "");', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '        int n = Integer.parseInt(nm[0]);', '', '        int m = Integer.parseInt(nm[1]);', '', '        int[][] sets = new int[m][3];', '', '        for (int setsRowItr = 0; setsRowItr < m; setsRowItr++) {', '            String[] setsRowItems = scanner.nextLine().split("" "");', '            scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '            for (int setsColumnItr = 0; setsColumnItr < 3; setsColumnItr++) {', '                int setsItem = Integer.parseInt(setsRowItems[setsColumnItr]);', '                sets[setsRowItr][setsColumnItr] = setsItem;', '            }', '        }', '', '        int[] result = liars(n, sets);', '', '        for (int resultItr = 0; resultItr < result.length; resultItr++) {', '            bufferedWriter.write(String.valueOf(result[resultItr]));', '', '            if (resultItr != result.length - 1) {', '                bufferedWriter.write("" "");', '            }', '        }', '', '        bufferedWriter.newLine();', '', '        bufferedWriter.close();', '', '        scanner.close();', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.ArrayList;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', 'import java.util.List;', '', 'public class C {', ' InputStream is;', ' PrintWriter out;', ' String INPUT = """";', ' ', ' void solve()', ' {', '  int n = ni(), K = ni();', '  char[][] map = nm(n,n);', '  int[][] ud = new int[n][n];', '  int[][] lr = new int[n][n];', '  int pud = 0, plr = 0;', '  {', '   int id = -1;', '   for(int i = 0;i < n;i++){', '    char pre = 0;', '    for(int j = 0;j < n;j++){', ""     if(map[j][i] == '.'){"", ""      if(pre != '.')id++; "", '      ud[j][i] = id;', '     }', '     pre = map[j][i];', '    }', '   }', '   pud = id + 1;', '  }', '  {', '   int id = -1;', '   for(int i = 0;i < n;i++){', '    char pre = 0;', '    for(int j = 0;j < n;j++){', ""     if(map[i][j] == '.'){"", ""      if(pre != '.')id++; "", '      lr[i][j] = id;', '     }', '     pre = map[i][j];', '    }', '   }', '   plr = id + 1;', '  }', '  List<Edge> es = new ArrayList<>();', '  for(int i = 0;i < n;i++){', '   for(int j = 0;j < n;j++){', ""    if(map[i][j] == '.'){"", '     es.add(new Edge(ud[i][j], lr[i][j]+pud, 1, 0));', '    }', '   }', '  }', '  int src = pud + plr, sink = src + 1;', '  for(int i = 0;i < pud;i++){', '   for(int j = 0;j <= n;j++){', '    es.add(new Edge(src, i, 1, j));', '   }', '  }', '  for(int i = 0;i < plr;i++){', '   for(int j = 0;j <= n;j++){', '    es.add(new Edge(i+pud, sink, 1, j));', '   }', '  }', '  out.println(solveMinCostFlow(compileWD(sink+1, es), src, sink, K));', ' }', ' ', ' public static class Edge', ' {', '  public int from, to;', '  public int capacity;', '  public int cost;', '  public int flow;', '  public Edge complement;', '  // public int iniflow;', '  ', '  public Edge(int from, int to, int capacity, int cost) {', '   this.from = from;', '   this.to = to;', '   this.capacity = capacity;', '   this.cost = cost;', '  }', ' }', ' ', ' public static Edge[][] compileWD(int n, List<Edge> edges)', ' {', '  Edge[][] g = new Edge[n][];', '  // cloning', '  for(int i = edges.size()-1;i >= 0;i--){', '   Edge origin = edges.get(i);', '   Edge clone = new Edge(origin.to, origin.from, origin.capacity, -origin.cost);', '   clone.flow = origin.capacity;', '   clone.complement = origin;', '   origin.complement = clone;', '   edges.add(clone);', '  }', '  ', '  int[] p = new int[n];', '  for(Edge e : edges)p[e.from]++;', '  for(int i = 0;i < n;i++)g[i] = new Edge[p[i]];', '  for(Edge e : edges)g[e.from][--p[e.from]] = e;', '  return g;', ' }', '', ' // NOT VERIFIED', ' public static Edge[][] compileWU(int n, List<Edge> edges)', ' {', '  Edge[][] g = new Edge[n][];', '  // cloning', '  for(int i = edges.size()-1;i >= 0;i--){', '   Edge origin = edges.get(i);', '   Edge back = new Edge(origin.to, origin.from, origin.capacity, origin.cost);', '   edges.add(back);', '  }', '  for(int i = edges.size()-1;i >= 0;i--){', '   Edge origin = edges.get(i);', '   Edge clone = new Edge(origin.to, origin.from, origin.capacity, -origin.cost);', '   clone.flow = origin.capacity;', '   clone.complement = origin;', '   origin.complement = clone;', '   edges.add(clone);', '  }', '  ', '  int[] p = new int[n];', '  for(Edge e : edges)p[e.from]++;', '  for(int i = 0;i < n;i++)g[i] = new Edge[p[i]];', '  for(Edge e : edges)g[e.from][--p[e.from]] = e;', '  return g;', ' } ', '', ' ', ' public static long solveMinCostFlow(Edge[][] g, int source, int sink, long all)', ' {', '  int n = g.length;', '  long mincost = 0;', '  int[] potential = new int[n];', '  ', '  final int[] d = new int[n];', '  MinHeap q = new MinHeap(n);', '  while(all > 0){', '   // shortest path src->sink', '   Edge[] inedge = new Edge[n];', '   Arrays.fill(d, Integer.MAX_VALUE / 2);', '   d[source] = 0;', '   q.add(source, 0);', '   while(q.size() > 0){', '    int cur = q.argmin();', '    q.remove(cur);', '    for(Edge ne : g[cur]){', '     if(ne.capacity - ne.flow > 0){', '      int nd = d[cur] + ne.cost + potential[cur] - potential[ne.to];', '      if(d[ne.to] > nd){', '       inedge[ne.to] = ne;', '       d[ne.to] = nd;', '       q.update(ne.to, nd);', '      }', '     }', '    }', '   }', '   ', '   if(inedge[sink] == null)break;', '   ', '   long minflow = all;', '   long sumcost = 0;', '   for(Edge e = inedge[sink];e != null;e = inedge[e.from]){', '    if(e.capacity - e.flow < minflow)minflow = e.capacity - e.flow;', '    sumcost += e.cost;', '   }', '   mincost += minflow * sumcost;', '   for(Edge e = inedge[sink];e != null;e = inedge[e.from]){', '    e.flow += minflow;', '    e.complement.flow -= minflow;', '   }', '   ', '   all -= minflow;', '   for(int i = 0;i < n;i++){', '    potential[i] += d[i];', '   }', '  }', '  return mincost;', ' }', ' ', '', ' public static class MinHeap {', '  public int[] a;', '  public int[] map;', '  public int[] imap;', '  public int n;', '  public int pos;', '  public static int INF = Integer.MAX_VALUE;', '  ', '  public MinHeap(int m)', '  {', '   n = m+2;', '   a = new int[n];', '   map = new int[n];', '   imap = new int[n];', '   Arrays.fill(a, INF);', '   Arrays.fill(map, -1);', '   Arrays.fill(imap, -1);', '   pos = 1;', '  }', '  ', '  public int add(int ind, int x)', '  {', '   int ret = imap[ind];', '   if(imap[ind] < 0){', '    a[pos] = x; map[pos] = ind; imap[ind] = pos;', '    pos++;', '    up(pos-1);', '   }', '   return ret != -1 ? a[ret] : x;', '  }', '  ', '  public int update(int ind, int x)', '  {', '   int ret = imap[ind];', '   if(imap[ind] < 0){', '    a[pos] = x; map[pos] = ind; imap[ind] = pos;', '    pos++;', '    up(pos-1);', '   }else{', '    int o = a[ret];', '    a[ret] = x;', '    up(ret);', '    down(ret);', '//    if(a[ret] > o){', '//     up(ret);', '//    }else{', '//     down(ret);', '//    }', '   }', '   return x;', '  }', '  ', '  public int remove(int ind)', '  {', '   if(pos == 1)return INF;', '   if(imap[ind] == -1)return INF;', '   ', '   pos--;', '   int rem = imap[ind];', '   int ret = a[rem];', '   map[rem] = map[pos];', '   imap[map[pos]] = rem;', '   imap[ind] = -1;', '   a[rem] = a[pos];', '   a[pos] = INF;', '   map[pos] = -1;', '   ', '   up(rem);', '   down(rem);', '   return ret;', '  }', '  ', '  public int min() { return a[1]; }', '  public int argmin() { return map[1]; }', '  public int size() { return pos-1; }', '  ', '  private void up(int cur)', '  {', '   for(int c = cur, p = c>>>1;p >= 1 && a[p] > a[c];c>>>=1, p>>>=1){', '    int d = a[p]; a[p] = a[c]; a[c] = d;', '    int e = imap[map[p]]; imap[map[p]] = imap[map[c]]; imap[map[c]] = e;', '    e = map[p]; map[p] = map[c]; map[c] = e;', '   }', '  }', '  ', '  private void down(int cur)', '  {', '   for(int c = cur;2*c < pos;){', '    int b = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;', '    if(a[b] < a[c]){', '     int d = a[c]; a[c] = a[b]; a[b] = d;', '     int e = imap[map[c]]; imap[map[c]] = imap[map[b]]; imap[map[b]] = e;', '     e = map[c]; map[c] = map[b]; map[b] = e;', '     c = b;', '    }else{', '     break;', '    }', '   }', '  }', ' }', '', ' ', ' void run() throws Exception', ' {', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  long s = System.currentTimeMillis();', '  solve();', '  out.flush();', '  if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', ' }', ' ', ' public static void main(String[] args) throws Exception { new C().run(); }', ' ', ' private byte[] inbuf = new byte[1024];', ' private int lenbuf = 0, ptrbuf = 0;', ' ', ' private int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private double nd() { return Double.parseDouble(ns()); }', ' private char nc() { return (char)skip(); }', ' ', ' private String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.ArrayList;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', 'import java.util.List;', '', 'public class C {', '    InputStream is;', '    PrintWriter out;', '    String INPUT = """";', '    ', '    void solve()', '    {', '        int n = ni(), K = ni();', '        char[][] map = nm(n,n);', '        int[][] ud = new int[n][n];', '        int[][] lr = new int[n][n];', '        int pud = 0, plr = 0;', '        {', '            int id = -1;', '            for(int i = 0;i < n;i++){', '                char pre = 0;', '                for(int j = 0;j < n;j++){', ""                    if(map[j][i] == '.'){"", ""                        if(pre != '.')id++; "", '                        ud[j][i] = id;', '                    }', '                    pre = map[j][i];', '                }', '            }', '            pud = id + 1;', '        }', '        {', '            int id = -1;', '            for(int i = 0;i < n;i++){', '                char pre = 0;', '                for(int j = 0;j < n;j++){', ""                    if(map[i][j] == '.'){"", ""                        if(pre != '.')id++; "", '                        lr[i][j] = id;', '                    }', '                    pre = map[i][j];', '                }', '            }', '            plr = id + 1;', '        }', '        List<Edge> es = new ArrayList<>();', '        for(int i = 0;i < n;i++){', '            for(int j = 0;j < n;j++){', ""                if(map[i][j] == '.'){"", '                    es.add(new Edge(ud[i][j], lr[i][j]+pud, 1, 0));', '                }', '            }', '        }', '        int src = pud + plr, sink = src + 1;', '        for(int i = 0;i < pud;i++){', '            for(int j = 0;j <= n;j++){', '                es.add(new Edge(src, i, 1, j));', '            }', '        }', '        for(int i = 0;i < plr;i++){', '            for(int j = 0;j <= n;j++){', '                es.add(new Edge(i+pud, sink, 1, j));', '            }', '        }', '        out.println(solveMinCostFlow(compileWD(sink+1, es), src, sink, K));', '    }', '    ', '    public static class Edge', '    {', '        public int from, to;', '        public int capacity;', '        public int cost;', '        public int flow;', '        public Edge complement;', '        // public int iniflow;', '        ', '        public Edge(int from, int to, int capacity, int cost) {', '            this.from = from;', '            this.to = to;', '            this.capacity = capacity;', '            this.cost = cost;', '        }', '    }', '    ', '    public static Edge[][] compileWD(int n, List<Edge> edges)', '    {', '        Edge[][] g = new Edge[n][];', '        // cloning', '        for(int i = edges.size()-1;i >= 0;i--){', '            Edge origin = edges.get(i);', '            Edge clone = new Edge(origin.to, origin.from, origin.capacity, -origin.cost);', '            clone.flow = origin.capacity;', '            clone.complement = origin;', '            origin.complement = clone;', '            edges.add(clone);', '        }', '        ', '        int[] p = new int[n];', '        for(Edge e : edges)p[e.from]++;', '        for(int i = 0;i < n;i++)g[i] = new Edge[p[i]];', '        for(Edge e : edges)g[e.from][--p[e.from]] = e;', '        return g;', '    }', '', '    // NOT VERIFIED', '    public static Edge[][] compileWU(int n, List<Edge> edges)', '    {', '        Edge[][] g = new Edge[n][];', '        // cloning', '        for(int i = edges.size()-1;i >= 0;i--){', '            Edge origin = edges.get(i);', '            Edge back = new Edge(origin.to, origin.from, origin.capacity, origin.cost);', '            edges.add(back);', '        }', '        for(int i = edges.size()-1;i >= 0;i--){', '            Edge origin = edges.get(i);', '            Edge clone = new Edge(origin.to, origin.from, origin.capacity, -origin.cost);', '            clone.flow = origin.capacity;', '            clone.complement = origin;', '            origin.complement = clone;', '            edges.add(clone);', '        }', '        ', '        int[] p = new int[n];', '        for(Edge e : edges)p[e.from]++;', '        for(int i = 0;i < n;i++)g[i] = new Edge[p[i]];', '        for(Edge e : edges)g[e.from][--p[e.from]] = e;', '        return g;', '    }    ', '', '    ', '    public static long solveMinCostFlow(Edge[][] g, int source, int sink, long all)', '    {', '        int n = g.length;', '        long mincost = 0;', '        int[] potential = new int[n];', '        ', '        final int[] d = new int[n];', '        MinHeap q = new MinHeap(n);', '        while(all > 0){', '            // shortest path src->sink', '            Edge[] inedge = new Edge[n];', '            Arrays.fill(d, Integer.MAX_VALUE / 2);', '            d[source] = 0;', '            q.add(source, 0);', '            while(q.size() > 0){', '                int cur = q.argmin();', '                q.remove(cur);', '                for(Edge ne : g[cur]){', '                    if(ne.capacity - ne.flow > 0){', '                        int nd = d[cur] + ne.cost + potential[cur] - potential[ne.to];', '                        if(d[ne.to] > nd){', '                            inedge[ne.to] = ne;', '                            d[ne.to] = nd;', '                            q.update(ne.to, nd);', '                        }', '                    }', '                }', '            }', '            ', '            if(inedge[sink] == null)break;', '            ', '            long minflow = all;', '            long sumcost = 0;', '            for(Edge e = inedge[sink];e != null;e = inedge[e.from]){', '                if(e.capacity - e.flow < minflow)minflow = e.capacity - e.flow;', '                sumcost += e.cost;', '            }', '            mincost += minflow * sumcost;', '            for(Edge e = inedge[sink];e != null;e = inedge[e.from]){', '                e.flow += minflow;', '                e.complement.flow -= minflow;', '            }', '            ', '            all -= minflow;', '            for(int i = 0;i < n;i++){', '                potential[i] += d[i];', '            }', '        }', '        return mincost;', '    }', '    ', '', '    public static class MinHeap {', '        public int[] a;', '        public int[] map;', '        public int[] imap;', '        public int n;', '        public int pos;', '        public static int INF = Integer.MAX_VALUE;', '        ', '        public MinHeap(int m)', '        {', '            n = m+2;', '            a = new int[n];', '            map = new int[n];', '            imap = new int[n];', '            Arrays.fill(a, INF);', '            Arrays.fill(map, -1);', '            Arrays.fill(imap, -1);', '            pos = 1;', '        }', '        ', '        public int add(int ind, int x)', '        {', '            int ret = imap[ind];', '            if(imap[ind] < 0){', '                a[pos] = x; map[pos] = ind; imap[ind] = pos;', '                pos++;', '                up(pos-1);', '            }', '            return ret != -1 ? a[ret] : x;', '        }', '        ', '        public int update(int ind, int x)', '        {', '            int ret = imap[ind];', '            if(imap[ind] < 0){', '                a[pos] = x; map[pos] = ind; imap[ind] = pos;', '                pos++;', '                up(pos-1);', '            }else{', '                int o = a[ret];', '                a[ret] = x;', '                up(ret);', '                down(ret);', '//                if(a[ret] > o){', '//                    up(ret);', '//                }else{', '//                    down(ret);', '//                }', '            }', '            return x;', '        }', '        ', '        public int remove(int ind)', '        {', '            if(pos == 1)return INF;', '            if(imap[ind] == -1)return INF;', '            ', '            pos--;', '            int rem = imap[ind];', '            int ret = a[rem];', '            map[rem] = map[pos];', '            imap[map[pos]] = rem;', '            imap[ind] = -1;', '            a[rem] = a[pos];', '            a[pos] = INF;', '            map[pos] = -1;', '            ', '            up(rem);', '            down(rem);', '            return ret;', '        }', '        ', '        public int min() { return a[1]; }', '        public int argmin() { return map[1]; }', '        public int size() {    return pos-1; }', '        ', '        private void up(int cur)', '        {', '            for(int c = cur, p = c>>>1;p >= 1 && a[p] > a[c];c>>>=1, p>>>=1){', '                int d = a[p]; a[p] = a[c]; a[c] = d;', '                int e = imap[map[p]]; imap[map[p]] = imap[map[c]]; imap[map[c]] = e;', '                e = map[p]; map[p] = map[c]; map[c] = e;', '            }', '        }', '        ', '        private void down(int cur)', '        {', '            for(int c = cur;2*c < pos;){', '                int b = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;', '                if(a[b] < a[c]){', '                    int d = a[c]; a[c] = a[b]; a[b] = d;', '                    int e = imap[map[c]]; imap[map[c]] = imap[map[b]]; imap[map[b]] = e;', '                    e = map[c]; map[c] = map[b]; map[b] = e;', '                    c = b;', '                }else{', '                    break;', '                }', '            }', '        }', '    }', '', '    ', '    void run() throws Exception', '    {', '        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        long s = System.currentTimeMillis();', '        solve();', '        out.flush();', '        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', '    }', '    ', '    public static void main(String[] args) throws Exception { new C().run(); }', '    ', '    private byte[] inbuf = new byte[1024];', '    private int lenbuf = 0, ptrbuf = 0;', '    ', '    private int readByte()', '    {', '        if(lenbuf == -1)throw new InputMismatchException();', '        if(ptrbuf >= lenbuf){', '            ptrbuf = 0;', '            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '            if(lenbuf <= 0)return -1;', '        }', '        return inbuf[ptrbuf++];', '    }', '    ', '    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', '    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', '    ', '    private double nd() { return Double.parseDouble(ns()); }', '    private char nc() { return (char)skip(); }', '    ', '    private String ns()', '    {', '        int b = skip();', '        StringBuilder sb = new StringBuilder();', ""        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '            sb.appendCodePoint(b);', '            b = readByte();', '        }', '        return sb.toString();', '    }', '    ', '    private char[] ns(int n)', '    {', '        char[] buf = new char[n];', '        int b = skip(), p = 0;', '        while(p < n && !(isSpaceChar(b))){', '            buf[p++] = (char)b;', '            b = readByte();', '        }', '        return n == p ? buf : Arrays.copyOf(buf, p);', '    }', '    ', '    private char[][] nm(int n, int m)', '    {', '        char[][] map = new char[n][];', '        for(int i = 0;i < n;i++)map[i] = ns(m);', '        return map;', '    }', '    ', '    private int[] na(int n)', '    {', '        int[] a = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        return a;', '    }', '    ', '    private int ni()', '    {', '        int num = 0, b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private long nl()', '    {', '        long num = 0;', '        int b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']"
"['import java.io.BufferedReader;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.util.HashMap;', 'import java.util.HashSet;', 'import java.util.StringTokenizer;', '', 'public class Solution {', '', ' public static void main(String[] args) {', '  FastReader fr = new FastReader();', '  int n = fr.nextInt();', '  ', '  HashMap<String, HashSet<String>> neighbors1 = new HashMap<>();', '  ', '  fillGraph(fr, neighbors1);', '  ', '  HashMap<String, HashSet<String>> neighbors2 = new HashMap<>();', '  fillGraph(fr, neighbors2);', '  ', '  int count = 0;', '  ', '  int m = fr.nextInt();', '  for (int i = 0; i < m; i++) {', '   String u = fr.next();', '   String v = fr.next();', '   count += count(neighbors1.get(v), neighbors2.get(u)) + count(neighbors1.get(u), neighbors2.get(v));', '  }', '  ', '//  HashMap<String, HashSet<String>> neighbors3 = new HashMap<>();', '//  fillGraph(fr, neighbors3);', '  ', '//  for (int a = 1; a < n + 1; a++) {', '//   String u = """" + a;', '//   if (neighbors3.containsKey(u)) {', '//    for (String v : neighbors3.get(u)) {', '//     if (neighbors2.containsKey(u) && neighbors1.containsKey(v)) {', '//      HashSet<String> neighbors_u = new HashSet<>(neighbors2.get(u));', '//      neighbors_u.remove(v);', '//      HashSet<String> neighbors_v = new HashSet<>(neighbors1.get(v));', '//      neighbors_v.remove(u);', '//      ', '//      neighbors_v.retainAll(neighbors_u);', '//      ', '//      count += neighbors_v.size();', '//     }', '//    }', '//   }', '//  }', '  ', '//  for (int a = 1; a < n + 1; a++) {', '//   String u = """" + a;', '//   if (neighbors3.containsKey(u) && neighbors1.containsKey(u)) {', '//    HashSet<String> neighborsFrom1 = neighbors1.get(u);', '//    HashSet<String> neighborsFrom3 = neighbors3.get(u);', '//    HashSet<String> allFrom1 = new HashSet<>();', '//    for (String v : neighborsFrom1) {', '//     if (neighbors2.containsKey(v)) {', '//      allFrom1.addAll(neighbors2.get(v));', '//     }', '//    }    ', '//    allFrom1.retainAll(neighborsFrom3);', '//    count += allFrom1.size();', '//   }', '//  }', '  ', '  System.out.println(count);', '', ' }', ' ', ' private static int count(HashSet<String> neighborsA, HashSet<String> neighborsB) {', '  if (neighborsA != null && neighborsB != null) {', '//   HashSet<String> first = new HashSet<>(neighborsA.size() < neighborsB.size() ? neighborsA : neighborsB);', '//   HashSet<String> second = neighborsA.size() < neighborsB.size() ? neighborsB : neighborsA;', '//   first.retainAll(second);', '//   return first.size();', '   int cnt = 0;', '   HashSet<String> first = neighborsA.size() < neighborsB.size() ? neighborsA : neighborsB;', '   HashSet<String> second = neighborsA.size() < neighborsB.size() ? neighborsB : neighborsA;', '   for (String string : first) {', '    if (second.contains(string))', '     cnt++;', '   }', '   return cnt;', '  }', '  return 0;', ' }', ' ', ' private static void fillGraph(FastReader fr, HashMap<String, HashSet<String>> neighbors1) {', '  int m = fr.nextInt();', '  for (int i = 0; i < m; i++) {', '   String u = fr.next();', '   String v = fr.next();', '   ', '   if (!neighbors1.containsKey(u)) {', '    neighbors1.put(u, new HashSet<String>());', '   }', '   neighbors1.get(u).add(v);', '   ', '   if (!neighbors1.containsKey(v)) {', '    neighbors1.put(v, new HashSet<String>());', '   }', '   neighbors1.get(v).add(u);', '   ', '  }', ' }', ' ', ' static class FastReader {', '        BufferedReader br;', '        StringTokenizer st;', ' ', '        public FastReader() {', '            br = new BufferedReader(new InputStreamReader(System.in));', '        }', ' ', '        String next() {', '            while (st == null || !st.hasMoreElements()) {', '                try {', '                    st = new StringTokenizer(br.readLine());', '                } catch (IOException  e) {', '                    e.printStackTrace();', '                }', '            }', '            return st.nextToken();', '        }', ' ', '        int nextInt() {', '            return Integer.parseInt(next());', '        }', ' ', '        long nextLong() {', '            return Long.parseLong(next());', '        }', ' ', '        String nextLine() {', '            String str = """";', '            try {', '                str = br.readLine();', '            } catch (IOException e) {', '                e.printStackTrace();', '            }', '            return str;', '        }', '    }', '', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner scanner = new Scanner(System.in);', '', '        scanner.nextInt(); // number of graphs - it will be always 3', '', '        Map<Integer, Set<Integer>> graph1 = new HashMap<>();', '', '        int edgesCount = scanner.nextInt();', '', '        for (int e = 0; e < edgesCount; e++) {', '            int edge1 = scanner.nextInt();', '            int edge2 = scanner.nextInt();', '', '            Set<Integer> set1 = graph1.get(edge1);', '            if (set1 == null) {', '                set1 = new HashSet<>();', '                graph1.put(edge1, set1);', '            }', '            set1.add(edge2);', '', '            Set<Integer> set2 = graph1.get(edge2);', '            if (set2 == null) {', '                set2 = new HashSet<>();', '                graph1.put(edge2, set2);', '            }', '            set2.add(edge1);', '        }', '', '        Map<Integer, Set<Integer>> graph2 = new HashMap<>();', '', '        edgesCount = scanner.nextInt();', '', '        for (int e = 0; e < edgesCount; e++) {', '            int edge1 = scanner.nextInt();', '            int edge2 = scanner.nextInt();', '', '            Set<Integer> set1 = graph2.get(edge1);', '            if (set1 == null) {', '                set1 = new HashSet<>();', '                graph2.put(edge1, set1);', '            }', '            set1.add(edge2);', '', '            Set<Integer> set2 = graph2.get(edge2);', '            if (set2 == null) {', '                set2 = new HashSet<>();', '                graph2.put(edge2, set2);', '            }', '            set2.add(edge1);', '        }', '', '        edgesCount = scanner.nextInt();', '', '        int tripartites = 0;', '', '        for (int e = 0; e < edgesCount; e++) {', '            int edge1 = scanner.nextInt();', '            int edge2 = scanner.nextInt();', '', '            Set<Integer> set1 = graph1.get(edge1);', '            Set<Integer> set2 = graph2.get(edge2);', '', '            if (set1 != null && set2 != null) {', '                for (Integer edge : set1) {', '                    if (set2.contains(edge)) tripartites++;', '                }', '            }', '', '            set1 = graph1.get(edge2);', '            set2 = graph2.get(edge1);', '', '            if (set1 != null && set2 != null) {', '                for (Integer edge : set1) {', '                    if (set2.contains(edge)) tripartites++;', '                }', '            }', '        }', '        System.out.println(tripartites);', '    }', '}']"
"['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '  static class Edge {', '        public int from, to;', '        public long weight, acc;', '', '        public Edge(int from, int to, long weight) {', '            this.from = from;', '            this.to = to;', '            this.weight = weight;', '        }', '    }', '', '    static HashMap<Integer, List<Edge>> connections = new HashMap<Integer, List<Edge>>(500000);', '    static int nodes;', '', '    static long bfs(int node) {', '        long b = System.currentTimeMillis();', '        long totalACCValue = 0;', '        LinkedList<Edge> queue = new LinkedList<Edge>();', '        List<Edge> list = connections.get(node);', '        for (int i = 0,count = list.size();i < count;i++) {', '            Edge edge = list.get(i);', '            edge.acc = edge.weight;', '            queue.addLast(edge);', '        }', '        while (!queue.isEmpty()) {', '            Edge current = queue.removeFirst();', '            long cACC = current.acc;', '            totalACCValue += cACC;', '            for (Edge edge : connections.get(current.to)) {', '                if (current.from == edge.to)', '                    continue;', '                queue.add(edge);', '                edge.acc = edge.weight + cACC;', '            }', '        }', '        System.out.println(System.currentTimeMillis() - b);', '        return totalACCValue;', '    }', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in),  2*4096*4096);', '        nodes = Integer.parseInt(reader.readLine());', '        for(int i = 1;i <= nodes;i++) {', '            connections.put(i, new ArrayList<Edge>());', '        }', '        for (int treeRowItr = 0; treeRowItr < nodes - 1; treeRowItr++) {', '            String[] tokens = reader.readLine().split("" "");', '            int from = Integer.parseInt(tokens[0]);', '            int to = Integer.parseInt(tokens[1]);', '            int weight = Integer.parseInt(tokens[2]);', '            connections.get(from).add(new Edge(from, to, weight));', '            connections.get(to).add(new Edge(to, from, weight));', '        }', '        long result = Math.min(bfs(1), bfs(nodes));', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '        reader.close();', '        bufferedWriter.close();', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'public class Solution {', '  private static InputReader in;', '  private static PrintWriter out;', '  ', '  static class Edge {', '    public int to;', '    public long weight;', '    public Edge(int to, int weight) {', '      this.to = to;', '      this.weight = weight;', '    }', '  }', '  ', '  ', '  public static void dfs(int node, int par, long cdist) {', '    dist[node] = cdist;', '    for (Edge e : graph[node]) {', '      if (e.to == par) continue;', '      dfs(e.to, node, cdist+e.weight);', '    }', '  }', '  ', '  public static void bfs(int node) {', '    int front = 0, back = 0;', '    Arrays.fill(vis, false);', '    queue[back++] = node;', '    dist[node] = 0;', '    vis[node] = true;', '    while (front < back) {', '      int cur = queue[front++];', '      for (Edge e : graph[cur]) {', '        if (vis[e.to]) continue;', '        vis[e.to] = true;', '        dist[e.to] = dist[cur] + e.weight;', '        queue[back++] = e.to;', '      }', '    }', '  }', '  ', '  public static ArrayList<Edge>[] graph;', '  public static long[] dist;', '  public static int[] queue;', '  public static boolean[] vis;', '  public static void main(String[] args) throws IOException {', '    in = new InputReader(System.in);', '    out = new PrintWriter(System.out, true);', '', '    int n = in.nextInt();', '    graph = new ArrayList[n];', '    queue = new int[graph.length];', '    vis = new boolean[graph.length];', '    for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();', '    for (int i = 0; i < n-1; i++) {', '      int a = in.nextInt()-1, b = in.nextInt()-1, c = in.nextInt();', '      graph[a].add(new Edge(b,c));', '      graph[b].add(new Edge(a,c));', '    }', '    ', '    dist = new long[n];', '    bfs(0);', '    long ans1 = 0;', '    for (int i = 0; i < n; i++) ans1 += dist[i];', '    bfs(n-1);', '    long ans2 = 0;', '    for (int i = 0; i < n; i++) ans2 += dist[i];', '    out.println(Math.min(ans1, ans2));', '    out.close();', '    System.exit(0);', '  }', '', '  static class InputReader {', '    public BufferedReader reader;', '    public StringTokenizer tokenizer;', '', '    public InputReader(InputStream stream) {', '      reader = new BufferedReader(new InputStreamReader(stream), 32768);', '      tokenizer = null;', '    }', '', '    public String next() {', '      while (tokenizer == null || !tokenizer.hasMoreTokens()) {', '        try {', '          tokenizer = new StringTokenizer(reader.readLine());', '        } catch (IOException e) {', '          throw new RuntimeException(e);', '        }', '      }', '      return tokenizer.nextToken();', '    }', '', '    public int nextInt() {', '      return Integer.parseInt(next());', '    }', '  }', '', '', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '  static class MyBitSet {', '    private final static int ADDRESS_BITS_PER_WORD = 6;', '    private long[] words;', '    private transient int wordsInUse = 0;', '', '    private static int wordIndex(int bitIndex) {', '      return bitIndex >> ADDRESS_BITS_PER_WORD;', '    }', '', '    public MyBitSet(int nbits) {', '      words = new long[wordIndex(nbits - 1) + 1];', '    }', '', '    public void clear() {', '      while (wordsInUse > 0)', '        words[--wordsInUse] = 0;', '    }', '', '    public void set(int bitIndex) {', '      int wordIndex = wordIndex(bitIndex);', '      expandTo(wordIndex);', '      words[wordIndex] |= (1L << bitIndex);', '    }', '', '    private void expandTo(int wordIndex) {', '      int wordsRequired = wordIndex + 1;', '      if (wordsInUse < wordsRequired) {', '        wordsInUse = wordsRequired;', '      }', '    }', '', '', '    public void or(MyBitSet set) {', '      int wordsInCommon = Math.min(wordsInUse, set.wordsInUse);', '', '      if (wordsInUse < set.wordsInUse) {', '        wordsInUse = set.wordsInUse;', '      }', '', '      for (int i = 0; i < wordsInCommon; i++) {', '        words[i] |= set.words[i];', '      }', '', '      if (wordsInCommon < set.wordsInUse) {', '        System.arraycopy(set.words, wordsInCommon, words, wordsInCommon,', '            wordsInUse - wordsInCommon);', '      }', '    }', '', '    public boolean get(int bitIndex) {', '      int wordIndex = wordIndex(bitIndex);', '      return (wordIndex < wordsInUse) && ((words[wordIndex] & (1L << bitIndex)) != 0);', '    }', '  }', '', '  static class PS {', '    int opt;', '    int u;', '    int x;', '    int i;', '  }', '', '  static class QS {', '    int u;', '    int i;', '', '    public QS(int u, int i) {', '      this.u = u;', '      this.i = i;', '    }', '  }', '', '  static Set<Integer>[] graph;', '  static int[] indeg;', '  static int[] topo;', '  static int ttot = 1;', '', '  static void topo_dfs(int node) {', '    topo[ttot++] = node;', '    for (int i = ptr[node]; i > 0; i = nxt[i]) {', '      if (--indeg[succ[i]] == 0) {', '        topo_dfs(succ[i]);', '      }', '    }', '  }', '', '  static int[] nxt;', '  static int[] succ;', '  static int[] ptr;', '  static int index = 1;', '', '  static void addedge(int u, int v) {', '    nxt[index] = ptr[u];', '    ptr[u] = index;', '    succ[index++] = v;', '  }', '', '', '  static final int B = 316;', '', '  static int[] solve2(int[][] queries, int n, int nQue) {', '    int q = queries[0].length - 1;', '    int[] ans = new int[q + 1];', '', '    QS[] que = new QS[nQue + 1];', '    PS[] perform = new PS[q + 1];', '    int ptot = 0;', '    int qtot = 0;', '', '    for (int i = 1; i <= q; i++) {', '      perform[ptot] = new PS();', '      perform[ptot].opt = queries[0][i];', '      if (perform[ptot].opt <= 2) {', '        perform[ptot].u = queries[1][i];', '        perform[ptot].x = queries[2][i];', '        perform[ptot++].i = i;', '      } else {', '        que[qtot++] = new QS(queries[1][i], i);', '      }', '      ans[i] = Integer.MAX_VALUE;', '    }', '', '    MyBitSet[] b = new MyBitSet[n + 1];', '    for (int i = n; i > 0; i--) {', '      b[i] = new MyBitSet(320);', '    }', '', '    boolean[] cover = new boolean[n + 1];', '    int[] minVal = new int[n + 1];', '', '    for (int l = (ptot - 1) - (ptot - 1) % B, r = ptot - 1; l >= 0; r = l - 1, l -= B) {', '      for (int i = n; i > 0; i--) {', '        b[i].clear();', '      }', '', '      for (int i = l; i <= r; ++i) {', '        b[perform[i].u].set(i - l);', '      }', '', '      for (int i = 1; i <= n; i++) {', '        for (int j = ptr[topo[i]]; j > 0; j = nxt[j]) {', '          b[succ[j]].or(b[topo[i]]);', '        }', '      }', '', '      Arrays.fill(cover, false);', '', '      for (int i = l; i <= r; i++) {', '        if (perform[i].opt == 1) {', '          cover[perform[i].u] = true;', '        }', '      }', '', '      for (int i = 1; i <= n; i++) {', '        if (cover[topo[i]]) {', '          for (int j = ptr[topo[i]]; j > 0; j = nxt[j]) {', '            cover[succ[j]] = true;', '          }', '        }', '      }', '', '      Arrays.fill(minVal, Integer.MAX_VALUE);', '', '      for (int i = l; i <= r; i++) {', '        if (perform[i].opt == 2) {', '          minVal[perform[i].u] = Math.min(minVal[perform[i].u], perform[i].x);', '        }', '      }', '', '      for (int i = 1; i <= n; ++i) {', '        for (int j = ptr[topo[i]]; j > 0; j = nxt[j]) {', '          minVal[succ[j]] = Math.min(minVal[succ[j]], minVal[topo[i]]);', '        }', '      }', '', '', '      int i = qtot;', '      while (i > 0 && que[i - 1].i > perform[l].i) {', '        i--;', '      }', '      while (i < qtot) {', '        if (que[i].i < perform[r].i) {', '          int j = r;', '          while (perform[j].i > que[i].i) {', '            --j;', '          }', '          for (; j >= l; j--)', '            if (b[que[i].u].get(j - l)) {', '              ans[que[i].i] = Math.min(ans[que[i].i], perform[j].x);', '              if (perform[j].opt == 1) {', '                --qtot;', '                QS temp = que[i];', '                que[i] = que[qtot];', '                que[qtot] = temp;', '                break;', '              }', '            }', '          i += j < l ? 1 : 0;', '        } else if (cover[que[i].u]) {', '          int j = r;', '          for (; perform[j].opt == 2 || !b[que[i].u].get(j - l); j--) {', '            if (perform[j].opt == 2 && b[que[i].u].get(j - l)) {', '              ans[que[i].i] = Math.min(ans[que[i].i], perform[j].x);', '            }', '          }', '          ans[que[i].i] = Math.min(ans[que[i].i], perform[j].x);', '', '          --qtot;', '          QS temp = que[i];', '          que[i] = que[qtot];', '          que[qtot] = temp;', '', '        } else {', '          ans[que[i].i] = Math.min(ans[que[i].i], minVal[que[i].u]);', '          i++;', '        }', '', '      }', '    }', '    while (qtot-- > 0) {', '      ans[que[qtot].i] = 0;', '    }', '    return ans;', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '', '    int n = Integer.parseInt(st.nextToken());', '    int m = Integer.parseInt(st.nextToken());', '    int q = Integer.parseInt(st.nextToken());', '', '    graph = new Set[n + 1];', '    Set<Integer>[] parent = new Set[n + 1];', '', '    for (int i = 1; i <= n; i++) {', '      graph[i] = new HashSet<>();', '      parent[i] = new HashSet<>();', '    }', '', '    for (int i = 0; i < m; i++) {', '      st = new StringTokenizer(br.readLine());', '      int u = Integer.parseInt(st.nextToken());', '      int v = Integer.parseInt(st.nextToken());', '      graph[u].add(v);', '      parent[v].add(u);', '    }', '', '    int[][] queries = new int[3][q + 1];', '    int[] convert = new int[n + 1];', '    int nodes = 0;', '    int op3 = 0;', '', '    for (int i = 1; i <= q; i++) {', '      st = new StringTokenizer(br.readLine());', '      queries[0][i] = Integer.parseInt(st.nextToken());', '      int u = Integer.parseInt(st.nextToken());', '', '      if (convert[u] == 0) {', '        nodes++;', '        convert[u] = nodes;', '      }', '', '      queries[1][i] = convert[u];', '      if (queries[0][i] <= 2) {', '        int x = Integer.parseInt(st.nextToken());', '        queries[2][i] = x;', '      } else {', '        op3++;', '      }', '    }', '', '    for (int u = 1; u <= n; u++) {', '      if (convert[u] == 0) {', '        for (int v : parent[u]) {', '          graph[v].remove(u);', '          graph[v].addAll(graph[u]);', '        }', '        for (int v : graph[u]) {', '          parent[v].remove(u);', '          parent[v].addAll(parent[u]);', '        }', '        ', '        parent[u] = null;', '        graph[u] = null;', '      }', '    }', '', '    indeg = new int[nodes + 1];', '    boolean[] existDeg = new boolean[nodes + 1];', '', '    nxt = new int[m + 1];', '    ptr = new int[nodes + 1];', '    succ = new int[m + 1];', '', '    for (int u1 = 1; u1 <= n; u1++) {', '      int u = convert[u1];', '      if (u > 0) {', '        for (int v1 : graph[u1]) {', '          int v = convert[v1];', '          indeg[v]++;', '          existDeg[v] = true;', '          addedge(u, v);', '        }', '      }', '    }', '', '    topo = new int[nodes + 1];', '    for (int i = nodes; i > 0; i--) {', '      if (!existDeg[i]) {', '        topo_dfs(i);', '      }', '    }', '', '    int[] ans = solve2(queries, nodes, op3);', '', '    for (int i = 1; i <= q; i++) {', '      if (ans[i] < Integer.MAX_VALUE) {', '        bw.write(ans[i] + ""\\n"");', '      }', '    }', '', '    bw.close();', '    br.close();', '  }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '  static class MyBitSet {', '    private final static int ADDRESS_BITS_PER_WORD = 6;', '    private long[] words;', '    private transient int wordsInUse = 0;', '', '    private static int wordIndex(int bitIndex) {', '      return bitIndex >> ADDRESS_BITS_PER_WORD;', '    }', '', '    public MyBitSet(int nbits) {', '      words = new long[wordIndex(nbits - 1) + 1];', '    }', '', '    public void clear() {', '      while (wordsInUse > 0)', '        words[--wordsInUse] = 0;', '    }', '', '    public void set(int bitIndex) {', '      int wordIndex = wordIndex(bitIndex);', '      expandTo(wordIndex);', '      words[wordIndex] |= (1L << bitIndex);', '    }', '', '    private void expandTo(int wordIndex) {', '      int wordsRequired = wordIndex + 1;', '      if (wordsInUse < wordsRequired) {', '        wordsInUse = wordsRequired;', '      }', '    }', '', '', '    public void or(MyBitSet set) {', '      int wordsInCommon = Math.min(wordsInUse, set.wordsInUse);', '', '      if (wordsInUse < set.wordsInUse) {', '        wordsInUse = set.wordsInUse;', '      }', '', '      for (int i = 0; i < wordsInCommon; i++) {', '        words[i] |= set.words[i];', '      }', '', '      if (wordsInCommon < set.wordsInUse) {', '        System.arraycopy(set.words, wordsInCommon, words, wordsInCommon,', '            wordsInUse - wordsInCommon);', '      }', '    }', '', '    public boolean get(int bitIndex) {', '      int wordIndex = wordIndex(bitIndex);', '      return (wordIndex < wordsInUse) && ((words[wordIndex] & (1L << bitIndex)) != 0);', '    }', '  }', '', '  static class PS {', '    int opt;', '    int u;', '    int x;', '    int i;', '  }', '', '  static class QS {', '    int u;', '    int i;', '', '    public QS(int u, int i) {', '      this.u = u;', '      this.i = i;', '    }', '  }', '', '  static Set<Integer>[] graph;', '  static int[] indeg;', '  static int[] topo;', '  static int ttot = 1;', '', '  static void topo_dfs(int node) {', '    topo[ttot++] = node;', '    for (int i = ptr[node]; i > 0; i = nxt[i]) {', '      if (--indeg[succ[i]] == 0) {', '        topo_dfs(succ[i]);', '      }', '    }', '  }', '', '  static int[] nxt;', '  static int[] succ;', '  static int[] ptr;', '  static int index = 1;', '', '  static void addedge(int u, int v) {', '    nxt[index] = ptr[u];', '    ptr[u] = index;', '    succ[index++] = v;', '  }', '', '', '  static final int B = 316;', '', '  static int[] solve2(int[][] queries, int n, int nQue) {', '    int q = queries[0].length - 1;', '    int[] ans = new int[q + 1];', '', '    QS[] que = new QS[nQue + 1];', '    PS[] perform = new PS[q + 1];', '    int ptot = 0;', '    int qtot = 0;', '', '    for (int i = 1; i <= q; i++) {', '      perform[ptot] = new PS();', '      perform[ptot].opt = queries[0][i];', '      if (perform[ptot].opt <= 2) {', '        perform[ptot].u = queries[1][i];', '        perform[ptot].x = queries[2][i];', '        perform[ptot++].i = i;', '      } else {', '        que[qtot++] = new QS(queries[1][i], i);', '      }', '      ans[i] = Integer.MAX_VALUE;', '    }', '', '    MyBitSet[] b = new MyBitSet[n + 1];', '    for (int i = n; i > 0; i--) {', '      b[i] = new MyBitSet(320);', '    }', '', '    boolean[] cover = new boolean[n + 1];', '    int[] minVal = new int[n + 1];', '', '    for (int l = (ptot - 1) - (ptot - 1) % B, r = ptot - 1; l >= 0; r = l - 1, l -= B) {', '      for (int i = n; i > 0; i--) {', '        b[i].clear();', '      }', '', '      for (int i = l; i <= r; ++i) {', '        b[perform[i].u].set(i - l);', '      }', '', '      for (int i = 1; i <= n; i++) {', '        for (int j = ptr[topo[i]]; j > 0; j = nxt[j]) {', '          b[succ[j]].or(b[topo[i]]);', '        }', '      }', '', '      Arrays.fill(cover, false);', '', '      for (int i = l; i <= r; i++) {', '        if (perform[i].opt == 1) {', '          cover[perform[i].u] = true;', '        }', '      }', '', '      for (int i = 1; i <= n; i++) {', '        if (cover[topo[i]]) {', '          for (int j = ptr[topo[i]]; j > 0; j = nxt[j]) {', '            cover[succ[j]] = true;', '          }', '        }', '      }', '', '      Arrays.fill(minVal, Integer.MAX_VALUE);', '', '      for (int i = l; i <= r; i++) {', '        if (perform[i].opt == 2) {', '          minVal[perform[i].u] = Math.min(minVal[perform[i].u], perform[i].x);', '        }', '      }', '', '      for (int i = 1; i <= n; ++i) {', '        for (int j = ptr[topo[i]]; j > 0; j = nxt[j]) {', '          minVal[succ[j]] = Math.min(minVal[succ[j]], minVal[topo[i]]);', '        }', '      }', '', '', '      int i = qtot;', '      while (i > 0 && que[i - 1].i > perform[l].i) {', '        i--;', '      }', '      while (i < qtot) {', '        if (que[i].i < perform[r].i) {', '          int j = r;', '          while (perform[j].i > que[i].i) {', '            --j;', '          }', '          for (; j >= l; j--)', '            if (b[que[i].u].get(j - l)) {', '              ans[que[i].i] = Math.min(ans[que[i].i], perform[j].x);', '              if (perform[j].opt == 1) {', '                --qtot;', '                QS temp = que[i];', '                que[i] = que[qtot];', '                que[qtot] = temp;', '                break;', '              }', '            }', '          i += j < l ? 1 : 0;', '        } else if (cover[que[i].u]) {', '          int j = r;', '          for (; perform[j].opt == 2 || !b[que[i].u].get(j - l); j--) {', '            if (perform[j].opt == 2 && b[que[i].u].get(j - l)) {', '              ans[que[i].i] = Math.min(ans[que[i].i], perform[j].x);', '            }', '          }', '          ans[que[i].i] = Math.min(ans[que[i].i], perform[j].x);', '', '          --qtot;', '          QS temp = que[i];', '          que[i] = que[qtot];', '          que[qtot] = temp;', '', '        } else {', '          ans[que[i].i] = Math.min(ans[que[i].i], minVal[que[i].u]);', '          i++;', '        }', '', '      }', '    }', '    while (qtot-- > 0) {', '      ans[que[qtot].i] = 0;', '    }', '    return ans;', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '', '    int n = Integer.parseInt(st.nextToken());', '    int m = Integer.parseInt(st.nextToken());', '    int q = Integer.parseInt(st.nextToken());', '', '    graph = new Set[n + 1];', '    Set<Integer>[] parent = new Set[n + 1];', '', '    for (int i = 1; i <= n; i++) {', '      graph[i] = new HashSet<>();', '      parent[i] = new HashSet<>();', '    }', '', '    for (int i = 0; i < m; i++) {', '      st = new StringTokenizer(br.readLine());', '      int u = Integer.parseInt(st.nextToken());', '      int v = Integer.parseInt(st.nextToken());', '      graph[u].add(v);', '      parent[v].add(u);', '    }', '', '    int[][] queries = new int[3][q + 1];', '    int[] convert = new int[n + 1];', '    int nodes = 0;', '    int op3 = 0;', '', '    for (int i = 1; i <= q; i++) {', '      st = new StringTokenizer(br.readLine());', '      queries[0][i] = Integer.parseInt(st.nextToken());', '      int u = Integer.parseInt(st.nextToken());', '', '      if (convert[u] == 0) {', '        nodes++;', '        convert[u] = nodes;', '      }', '', '      queries[1][i] = convert[u];', '      if (queries[0][i] <= 2) {', '        int x = Integer.parseInt(st.nextToken());', '        queries[2][i] = x;', '      } else {', '        op3++;', '      }', '    }', '', '    for (int u = 1; u <= n; u++) {', '      if (convert[u] == 0) {', '        for (int v : parent[u]) {', '          graph[v].remove(u);', '          graph[v].addAll(graph[u]);', '        }', '        for (int v : graph[u]) {', '          parent[v].remove(u);', '          parent[v].addAll(parent[u]);', '        }', '        ', '        parent[u] = null;', '        graph[u] = null;', '      }', '    }', '', '    indeg = new int[nodes + 1];', '    boolean[] existDeg = new boolean[nodes + 1];', '', '    nxt = new int[m + 1];', '    ptr = new int[nodes + 1];', '    succ = new int[m + 1];', '', '    for (int u1 = 1; u1 <= n; u1++) {', '      int u = convert[u1];', '      if (u > 0) {', '        for (int v1 : graph[u1]) {', '          int v = convert[v1];', '          indeg[v]++;', '          existDeg[v] = true;', '          addedge(u, v);', '        }', '      }', '    }', '', '    topo = new int[nodes + 1];', '    for (int i = nodes; i > 0; i--) {', '      if (!existDeg[i]) {', '        topo_dfs(i);', '      }', '    }', '', '    int[] ans = solve2(queries, nodes, op3);', '', '    for (int i = 1; i <= q; i++) {', '      if (ans[i] < Integer.MAX_VALUE) {', '        bw.write(ans[i] + ""\\n"");', '      }', '    }', '', '    bw.close();', '    br.close();', '  }', '}']"
 , 
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'class Node {', '    public int id;', '    public ArrayList<Integer> edges;', '    public boolean active;', '    ', '    Node (int nid) {', '        id = nid;', '        edges = new ArrayList<Integer>();', '        active = true; ', '    }', '}', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        ', '        /* Custom Input */', '        /*', '        StringBuilder custom = new StringBuilder();', '        ', '        int edges = 0; ', '        int nnn = 50000; //447;', '        for (int i = 1; i <= nnn; i++) {', '            for (int j = i+1; j <= Math.min(nnn,i+1+450) ; j++) {', '               if (edges < 100000)', '                    edges++;', '            }', '        }', '        ', '        custom.append(nnn);', '        custom.append("" "");', '        custom.append(edges);', '        custom.append(""\\n"");', '        ', '        edges = 0;', '        for (int i = 1; i <= nnn; i++) {', '            for (int j = i+1; j <= Math.min(nnn,i+1+450); j++) {', '                if (edges < 100000) { ', '                    edges++;', '                    custom.append(i);', '                    custom.append("" "");', '                    custom.append(j);', '                    custom.append(""\\n"");', '                } else {', '                    break;', '                }', '            }', '            if (edges >= 100000) break;', '        }', '        ', '        System.out.printf(""%d %d\\n"", nnn, edges);', '        Scanner sc = new Scanner(custom.toString());', '        */', '        ', '        Scanner sc = new Scanner(System.in);', '        ', '        int N = sc.nextInt();', '        int M = sc.nextInt();', '        ', '        Node [] nodes = new Node[N+1];', '        for (int i = 1; i <= N; i++)', '            nodes[i] = new Node(i);', '        ', '        for (int i =0 ; i < M; i++) {', '            int a = sc.nextInt();', '            int b = sc.nextInt();', '            ', '            nodes[a].edges.add(b);', '            nodes[b].edges.add(a);', '        }', '        ', '        long sum = 0;', '        ', '        for (int o = 1; o <= N; o++) {', '            nodes[o].active = false;', '            ', '            HashMap<Integer, Integer> paths_to = new HashMap<>();', '            ', '            for (int e : nodes[o].edges) {', '                if (nodes[e].active) { ', '                    for (int ee : nodes[e].edges) { ', '                        if (nodes[ee].active) { ', '                            paths_to.put(ee, (paths_to.containsKey(ee) ? paths_to.get(ee)+1 : 1));', '                        }', '                    }', '                }', '            }', '            ', '            for (int c : paths_to.keySet()) { ', '                long cc = paths_to.get(c);', '                if (cc >= 2) {', '                    sum += (cc*(cc-1L)/2L);', '                }', '            }', '        }', '        ', '        //sum = 3;', '        System.out.printf(""%d\\n"", sum);', '    }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'class Node {', '    public int id;', '    public ArrayList<Integer> edges;', '    public boolean active;', '    ', '    Node (int nid) {', '        id = nid;', '        edges = new ArrayList<Integer>();', '        active = true; ', '    }', '}', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        ', '        /* Custom Input */', '        /*', '        StringBuilder custom = new StringBuilder();', '        ', '        int edges = 0; ', '        int nnn = 50000; //447;', '        for (int i = 1; i <= nnn; i++) {', '            for (int j = i+1; j <= Math.min(nnn,i+1+450) ; j++) {', '               if (edges < 100000)', '                    edges++;', '            }', '        }', '        ', '        custom.append(nnn);', '        custom.append("" "");', '        custom.append(edges);', '        custom.append(""\\n"");', '        ', '        edges = 0;', '        for (int i = 1; i <= nnn; i++) {', '            for (int j = i+1; j <= Math.min(nnn,i+1+450); j++) {', '                if (edges < 100000) { ', '                    edges++;', '                    custom.append(i);', '                    custom.append("" "");', '                    custom.append(j);', '                    custom.append(""\\n"");', '                } else {', '                    break;', '                }', '            }', '            if (edges >= 100000) break;', '        }', '        ', '        System.out.printf(""%d %d\\n"", nnn, edges);', '        Scanner sc = new Scanner(custom.toString());', '        */', '        ', '        Scanner sc = new Scanner(System.in);', '        ', '        int N = sc.nextInt();', '        int M = sc.nextInt();', '        ', '        Node [] nodes = new Node[N+1];', '        for (int i = 1; i <= N; i++)', '            nodes[i] = new Node(i);', '        ', '        for (int i =0 ; i < M; i++) {', '            int a = sc.nextInt();', '            int b = sc.nextInt();', '            ', '            nodes[a].edges.add(b);', '            nodes[b].edges.add(a);', '        }', '        ', '        long sum = 0;', '        ', '        for (int o = 1; o <= N; o++) {', '            nodes[o].active = false;', '            ', '            HashMap<Integer, Integer> paths_to = new HashMap<>();', '            ', '            for (int e : nodes[o].edges) {', '                if (nodes[e].active) { ', '                    for (int ee : nodes[e].edges) { ', '                        if (nodes[ee].active) { ', '                            paths_to.put(ee, (paths_to.containsKey(ee) ? paths_to.get(ee)+1 : 1));', '                        }', '                    }', '                }', '            }', '            ', '            for (int c : paths_to.keySet()) { ', '                long cc = paths_to.get(c);', '                if (cc >= 2) {', '                    sum += (cc*(cc-1L)/2L);', '                }', '            }', '        }', '        ', '        //sum = 3;', '        System.out.printf(""%d\\n"", sum);', '    }', '}']"
"['/* Enter your code here. Read input from STDIN. Print output to STDOUT */', '', '', 'import java.io.BufferedReader;', 'import java.io.InputStreamReader;', 'import java.util.ArrayList;', 'import java.util.Arrays;', '', 'public class Solution {', ' private static final int[] BC = new int[1<<16];', ' public static void main(String[] argv) throws Exception {', '  prep();', '  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '  String line1 = br.readLine();', '  int N = Integer.parseInt(line1);', '  ArrayList<String> dump = new ArrayList<String>(100000);', '  int[] x = new int[N/32+1];', '  int[] y = new int[N/32+1];', '  long rs = System.currentTimeMillis();', '  for(int i=0;i<N;i++){', '   String line2 = br.readLine();', '   String[] tmp2 = line2.split("" "");', ""   if(tmp2[0].charAt(0) != '-') x[i/32] |= 1<< i%32;"", ""   if(tmp2[1].charAt(0) != '-') y[i/32] |= 1<< i%32;"", '  }', '  long re = System.currentTimeMillis();', '  String line3 = br.readLine();', '  int Q = Integer.parseInt(line3);', '  boolean wasC = false;', '  int[] tmp1 = new int[N/32+1];', '  int[] tmp24= new int[N/32+1];', '  int[] tmp2 = new int[N/32+1];', '  int[] cnt1 = new int[N/32+1];', '  int[] cnt24= new int[N/32+1];', '  int[] cnt2 = new int[N/32+1];', '  long ws = System.currentTimeMillis();', '  for(int i=0;i<Q;i++){', '   String line4 = br.readLine();', '   String[] tmp4 = line4.split("" "");', '   int sindex = Integer.parseInt(tmp4[1]);', '   int eindex = Integer.parseInt(tmp4[2]);', '   int sm = (sindex-1)%32;', '   int sn = (sindex-1)/32;', '   int em = eindex%32;', '   int en = eindex/32;', '   int es = eindex-sindex+1;', '   if(tmp4[0].equals(""X"")) {', '    if(sn == en){', '     int mask = ((1<<(es))-1)<<(sm);', '     y[en] ^= mask;', '    }else{', '     int mask = -1;', '     int fmask = mask<<(sm);', '     int emask = (1<<(em))-1;', '     y[sn] ^= fmask;', '     for(int j=sn+1;j<en;j++) y[j] ^= mask;', '     y[en] ^= emask;', '    }', '    wasC = false;', '   }else if(tmp4[0].equals(""Y"")) {', '    if(sn == en){', '     int mask = ((1<<(es))-1)<<(sm);', '     x[en] ^= mask;', '    }else{', '     int mask = -1;', '     int fmask = mask<<(sm);', '     int emask = (1<<(em))-1;', '     x[sn] ^= fmask;', '     for(int j=sn+1;j<en;j++) x[j] ^= mask;', '     x[en] ^= emask;', '    }', '    wasC = false;', '   }else{', '    /*', '    if(!wasC || wasC){', '     for(int j=0;j<x.length;j++) {', '      tmp1[j]  = x[j] & y[j];', '      tmp24[j] = x[j] ^ y[j];', '      tmp2[j]  = tmp24[j] & y[j];', '      cnt1[j] = bitCount(tmp1[j]);', '      cnt24[j]= bitCount(tmp24[j]);', '      cnt2[j] = bitCount(tmp2[j]);', '     }', '    }', '    */', '    int maskes = ((1<<(es))-1)<<(sm);', '    int maskall = -1;', '    int fmask = maskall<<(sm);', '    int emask = (1<<(em))-1;', '    // 1st quadrant x bit: 1, y bit: 1 (x & y)', '    int c1 = 0;', '    if(sn == en){', '     c1 += bitCount(x[en] & y[en] & maskes);', '    }else{', '     c1 += bitCount(x[sn] & y[sn] & fmask);', '     for(int j=sn+1;j<en;j++) c1 += bitCount(x[j] & y[j]);', '     c1 += bitCount(x[en] & y[en] & emask);', '    }', '    // 2nd quadrant x bit: 0, y bit: 1', '    // 4th quadrant x bit: 1, y bit: 0', '    // x xor y = c2 + c4', '    // (x xor y) & y = c2', '    int c24 = 0;', '    int c2 = 0;', '    if(sn == en){', '     int t2 = (x[en] ^ y[en]) & maskes;', '     c24 += bitCount(t2);', '     c2 += bitCount(t2 & y[en]);', '    }else{', '     int t2 = (x[sn] ^ y[sn]) & fmask;', '     c24 += bitCount(t2);', '     c2 += bitCount(t2 & y[sn]);', '     for(int j=sn+1;j<en;j++) {', '      t2 = x[j] ^ y[j];', '      c24 += bitCount(t2);', '      c2 += bitCount(t2 & y[j]);', '     }', '     t2 = (x[en] ^ y[en]) & emask;', '     c24 += bitCount(t2);', '     c2 += bitCount(t2 & y[en]);', '    }', '    int c4 = c24 - c2;', '    // 3rd quadrant x bit: 0, y bit: 0 (total - c1 - c2 - c4)', '    int c3 = eindex - sindex + 1 - c1 - c2 - c4;', '    dump.add(c1+"" ""+c2+"" ""+c3+"" ""+c4);', '    //System.out.println(c1+"" ""+c2+"" ""+c3+"" ""+c4);', '    wasC = true;', '   }', '  }', '  long we = System.currentTimeMillis();', '  for(int i=0;i<dump.size();i++) System.out.println(dump.get(i));', '  br.close();', '  //System.out.println(""R:""+(re-rs));', '  //System.out.println(""W:""+(we-ws));', ' }', ' private static void prep() {', '  int max = 1<<16;', '  int step1 = 1<<8;', '  for(int i=0;i<step1;i++) BC[i] = Integer.bitCount(i);', '  for(int i=step1;i<max;i++){', '   BC[i] = BC[i&0xFF] + BC[(i>>8)&0xFF];', '  }', ' }', ' ', ' private static int bitCount(int i){', '  return BC[i&0xFFFF] + BC[(i>>16)&0xFFFF];', ' }', '}']","['import java.util.*;', 'import java.io.*;', '', 'class SegmentTree {', '    private int min, max, center;', '    private SegmentTree left, right;', '    private int count;', '    private boolean leaf;', '', '    public SegmentTree(int min, int max) {', '    this.min = min;', '    this.max = max;', '    left = null;', '    right = null;', '    count = 0;', '    center = (min + max) / 2;', '    leaf = (min == max);', '    }', '', '    public void add(int n) {', '    count++;', '    if (leaf) {', '        return;', '    } else if (n <= center) {', '        if (left == null)', '        left = new SegmentTree(min, center);', '        left.add(n);', '    } else {', '        if (right == null)', '        right = new SegmentTree(center + 1, max);', '        right.add(n);', '    }', '    }', '    ', '    public int countInRange(int m, int n) {', '    if (min >= m && max <= n) {', '        return count;', '    }', '', '    int sum = 0;', '    if (left != null && m <= center) {', '        sum += left.countInRange(m, n);', '    }', '    if (right != null && n > center) {', '        sum += right.countInRange(m, n);', '    }', '    return sum;', '    }', '', '    public boolean deleteRange(ArrayList<SegmentTree> results, int m, int n) {', '    if (min >= m && max <= n) {', '        results.add(this);', '        return true;', '    }', '', '    int origSize = results.size();', '', '    if (left != null && m <= center) {', '        if (left.deleteRange(results, m, n) || left.count == 0) {', '        left = null;', '        }', '    }', '    if (right != null && n > center) {', '        if (right.deleteRange(results, m, n) || right.count == 0) {', '        right = null;', '        }', '    }', '', '    if (results.size() > origSize) {', '        recalculateCount();', '    }', '    return false;', '    }', '', '    public void merge(SegmentTree s) {', '    if (s.min == min && s.max == max) {', '        if (left != null && s.left != null) {', '        left.merge(s.left);', '        } else {', '        left = s.left;', '        }', '        if (right != null && s.right != null) {', '        right.merge(s.right);', '        } else {', '        right = s.right;', '        }', '    } else if (s.min == min && s.max == center && left == null) {', '        left = s;', '    } else if (s.min == center + 1 && s.max == max) {', '        right = s;', '    } else if (s.center <= center) {', '        if (left == null) {', '        left = new SegmentTree(min, center);', '        }', '        left.merge(s);', '    } else {', '        if (right == null) {', '        right = new SegmentTree(center + 1, max);', '        }', '        right.merge(s);', '    }', '    count += s.count;', '    }', '', '    private void recalculateCount() {', '    if (leaf) {', '        count = 1;', '    } else {', '        count = (left != null ? left.count : 0) + (right != null ? right.count : 0);', '    }', '    }', '}', '', 'class Quadrants {', '    private SegmentTree[] quadrants;', '    private ArrayList<SegmentTree> tmp1, tmp2;', '    private PrintStream out;', '', '    public Quadrants(int nPoints) {', '    quadrants = new SegmentTree[4];', '    for (int i = 0; i < 4; i++) {', '        quadrants[i] = new SegmentTree(1, nPoints);', '    }', '    tmp1 = new ArrayList<SegmentTree>(20);', '    tmp2 = new ArrayList<SegmentTree>(20);', '    out = new PrintStream(new BufferedOutputStream(System.out, 8192));', '    }', '', '    public void add(int x, int y, int i) {', '    int q;', '    if (x >= 0 && y >= 0)', '        q = 0;', '    else if (x <= 0 && y >= 0)', '        q = 1;', '    else if (x <= 0 && y <= 0)', '        q = 2;', '    else', '        q = 3;', '    quadrants[q].add(i);', '    }', '', '    public void swapPointsInRange(int q1, int q2, int m, int n) {', '    tmp1.clear();', '    quadrants[q1].deleteRange(tmp1, m, n);', '    tmp2.clear();', '    quadrants[q2].deleteRange(tmp2, m, n);', '    if (!tmp2.isEmpty()) {', '        Iterator<SegmentTree> iter = tmp2.iterator();', '        while (iter.hasNext()) {', '        quadrants[q1].merge(iter.next());', '        }', '    }', '    if (!tmp1.isEmpty()) {', '        Iterator<SegmentTree> iter = tmp1.iterator();', '        while (iter.hasNext()) {', '        quadrants[q2].merge(iter.next());', '        }', '    }', '    }', '    ', '    public void mirrorX(int m, int n) {', '    swapPointsInRange(0, 3, m, n);', '    swapPointsInRange(1, 2, m, n);', '    }', '', '    public void mirrorY(int m, int n) {', '    swapPointsInRange(0, 1, m, n);', '    swapPointsInRange(2, 3, m, n);', '    }', '', '    public void flush() {', '    out.flush();', '    }', '', '    public void count(int m, int n) {', '    out.println(quadrants[0].countInRange(m, n) + "" "" +', '            quadrants[1].countInRange(m, n) + "" "" +', '            quadrants[2].countInRange(m, n) + "" "" +', '            quadrants[3].countInRange(m, n) );', '    }', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));', '    int nPoints = Integer.parseInt(in.readLine());', '', '    Quadrants quadrants = new Quadrants(nPoints);', '', '    for (int i = 1; i <= nPoints; i++) {', '        String line = in.readLine();', ""        int spc = line.indexOf(' ');"", ""        int x = line.charAt(0) == '-' ? -1 : 1;"", ""        int y = line.charAt(spc + 1) == '-' ? -1 : 1;"", '        quadrants.add(x, y, i);', '    }', '', '    int nQueries = Integer.parseInt(in.readLine());', '    for (int i = 0; i < nQueries; i++) {', '        String line = in.readLine();', '        char cmd = line.charAt(0);', ""        int spc = line.indexOf(' ', 2);"", '        int m = Integer.parseInt(line.substring(2, spc));', '        int n = Integer.parseInt(line.substring(spc + 1));', '        switch (cmd) {', ""        case 'X':"", '        quadrants.mirrorX(m, n);', '        break;', ""        case 'Y':"", '        quadrants.mirrorY(m, n);', '        break;', ""        case 'C':"", '        quadrants.count(m, n);', '        break;', '        }', '    }', '    quadrants.flush();', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  int n = ni();', '  int[][] a = new int[n][n];', '  for(int i = 0;i < n;i++){', '   for(int j = 0;j < n;j++){', '    a[i][j] = ni();', '   }', '  }', '  long[] ret = minavg(a);', '  out.println(ret[0] + ""/"" + ret[1]);', ' }', ' ', ' static long[] minavg(int[][] g)', ' {', '  int n = g.length;', '  int[][] dp = new int[n+1][n];', '  int I = 400000;', '  for(int k = 0;k < n;k++){', '   Arrays.fill(dp[k+1], I);', '   for(int i = 0;i < n;i++){', '    for(int j = 0;j < n;j++){', '     if(i != j && dp[k][i] < I){', '      dp[k+1][j] = Math.min(dp[k+1][j], dp[k][i] + g[i][j]);', '     }', '    }', '   }', '  }', '  long[] ret = {1L, 0L};', '  for(int i = 0;i < n;i++){', '   long[] lret = {0L, 1L};', '   for(int k = 0;k < n;k++){', '    if(dp[n][i] < I && dp[k][i] < I){', '     long num = dp[n][i]-dp[k][i];', '     long den = n-k;', '     if(lret[0] * den < lret[1] * num){', '      lret[0] = num; lret[1] = den;', '     }', '    }', '   }', '   if(lret[0] > 0){', '    if(ret[0] * lret[1] > ret[1] * lret[0]){', '     ret = lret;', '    }', '   }', '  }', '  long gcd = gcd(ret[0], ret[1]);', '  ret[0] /= gcd;', '  ret[1] /= gcd;', '  return ret;', ' }', ' ', ' public static long gcd(long a, long b) {', '  if(a == 0)return b;', '  if(b == 0)return a;', '  while (b > 0){', '   long c = a;', '   a = b;', '   b = c % b;', '  }', '  return a;', ' }', ' ', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) throws IOException {', '        // Read the number of cities', '        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '        String line = br.readLine();', '        int N = Integer.parseInt(line);', '        ', '        // Read the cost matrix', '        PriorityQueue<Path> pq = new PriorityQueue<Path>();', '        int[][] costs = new int[N][N];', '        double[][] bestPathCosts = new double[N][N];', '        for (int i = 0; i < N; i++) {', '            line = br.readLine();', '            String[] lineSplit = line.split("" "");', '            for (int j = 0; j < N; j++) {', '                int c = Integer.parseInt(lineSplit[j]);', '                costs[i][j] = c;', '                bestPathCosts[i][j] = (double) c;', '                if (i != j) {', '                    pq.add(new Path(c, 1, i, j));', '                }', '            }', '            bestPathCosts[i][i] = Double.POSITIVE_INFINITY;', '        }', '        ', '        // Find the min avg cost path', '        Path p;', '        while ((p = pq.poll()) != null) {', '            if (p.start == p.curr) {', '                break;', '            }', '            ', '            if (p.avgCost() > bestPathCosts[p.start][p.curr]) {', '                continue;', '            }', '            ', '            int length_ = p.length + 1;', '            for (int j = 0; j < N; j++) {', '                int cost_ = p.cost + costs[p.curr][j];', '                double avgCost = ((double) cost_) / ((double) length_);', '                if (p.curr != j && avgCost < bestPathCosts[p.start][j]) {', '                    pq.add(new Path(cost_, length_, p.start, j));', '                    bestPathCosts[p.start][j] = avgCost;', '                }', '            }', '        }', '        ', '        // Print out result', '        System.out.println(p);', '    }', '}', '', 'class Path implements Comparable<Path> {', '    public int cost, length, start, curr;', '    ', '    public Path(int cost, int length, int start, int curr) {', '        this.cost = cost;', '        this.length = length;', '        this.start = start;', '        this.curr = curr;', '    }', '    ', '    public double avgCost() {', '        return ((double) cost) / ((double) length);', '    }', '    ', '    public int compareTo(Path p) {', '        return (int) Math.signum(this.avgCost() - p.avgCost());', '    }', '    ', '    public static int gcd(int x, int y) {', '        return (y == 0) ? x : gcd(y, x%y);', '    }', '    ', '    public String toString() {', '        int div = gcd(cost, length);', '        return (cost/div) + ""/"" + (length/div);', '    }', '}']"
"['import java.io.*;', 'import java.util.Arrays;', '', 'public class Solution {', '', '    static class Point implements Comparable<Point> {', '        int x, y;', '', '        Point(int x, int y) {', '            this.x = x;', '            this.y = y;', '        }', '', '        @Override', '        public int compareTo(Point o) {', '            if (x == o.x) {', '                return y - o.y;', '            }', '            return x - o.x;', '        }', '    }', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        int n = in.nextInt();', '        Point[] ps = new Point[n];', '        for (int i = 0; i < n; ++i) {', '            int t = in.nextInt();', '            int f = in.nextInt();', '            ps[i] = new Point(t - f, t + f);', '        }', '        Arrays.sort(ps);', '        int[] max = new int[n + 1];', '        Arrays.fill(max, Integer.MIN_VALUE);', '        max[0] = Integer.MAX_VALUE;', '        for (Point p : ps) {', '//            System.err.println(p.y);', '            int l = 0, r = n;', '            while (l < r - 1) {', '                int mid = (l + r) / 2;', '                if (max[mid] > p.y) {', '                    l = mid;', '                } else {', '                    r = mid;', '                }', '            }', '            max[l + 1] = p.y;', '        }', '//        System.err.println(Arrays.toString(max));', '        int ans = 0;', '        while (ans < n && max[ans + 1] > Integer.MIN_VALUE) {', '            ++ans;', '        }', '        out.println(ans);', '    }', '', '    public static void main(String[] args) throws IOException {', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']","['import java.io.*;', 'import java.util.Arrays;', '', 'public class Solution {', '', '    static class Point implements Comparable<Point> {', '        int x, y;', '', '        Point(int x, int y) {', '            this.x = x;', '            this.y = y;', '        }', '', '        @Override', '        public int compareTo(Point o) {', '            if (x == o.x) {', '                return y - o.y;', '            }', '            return x - o.x;', '        }', '    }', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        int n = in.nextInt();', '        Point[] ps = new Point[n];', '        for (int i = 0; i < n; ++i) {', '            int t = in.nextInt();', '            int f = in.nextInt();', '            ps[i] = new Point(t - f, t + f);', '        }', '        Arrays.sort(ps);', '        int[] max = new int[n + 1];', '        Arrays.fill(max, Integer.MIN_VALUE);', '        max[0] = Integer.MAX_VALUE;', '        for (Point p : ps) {', '//            System.err.println(p.y);', '            int l = 0, r = n;', '            while (l < r - 1) {', '                int mid = (l + r) / 2;', '                if (max[mid] > p.y) {', '                    l = mid;', '                } else {', '                    r = mid;', '                }', '            }', '            max[l + 1] = p.y;', '        }', '//        System.err.println(Arrays.toString(max));', '        int ans = 0;', '        while (ans < n && max[ans + 1] > Integer.MIN_VALUE) {', '            ++ans;', '        }', '        out.println(ans);', '    }', '', '    public static void main(String[] args) throws IOException {', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']"
 , 
 , 
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class E {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  int n = ni(), m = ni(), Q = ni();', '  int[] a = na(n);', '  int[][] gg = makeBuckets(a, m+1);', '  int s = (int)Math.sqrt(n);', '  ', '  int[][] qs = new int[Q][];', '  for(int i = 0;i < Q;i++){', '   qs[i] = new int[]{ni()-1, ni()-1};', '  }', '  ', '  int[] ret = new int[m+1];', '  Arrays.fill(ret, -1);', '  for(int i = 1;i <= m;i++){', '   if(gg[i].length == 1){', '    ret[i] = 0;', '   }', '  }', '  ', '  DJSet ds = new DJSet(n);', '  ', '  for(int i = 0;i < Q;i+=s){', '   DJSet xds = new DJSet(ds);', '   ', '   for(int j = i;j < i+s && j < Q;j++){', '    ds.union(qs[j][0], qs[j][1]);', '   }', '   ', '   int[] id = new int[m+1];', '   Arrays.fill(id, -1);', '   for(int j = 0;j < n;j++){', '    int v = a[j];', '    if(id[v] == -1){', '     id[v] = ds.root(j);', '    }else if(id[v] >= 0){', '     if(id[v] != ds.root(j)){', '      id[v] = -2;', '     }', '    }', '   }', '   ', '   int[] an = new int[m];', '   int p = 0;', '   for(int j = 1;j <= m;j++){', '    if(id[j] >= 0 && ret[j] == -1){', '     an[p++] = j;', '    }', '   }', '   ', '   for(int j = i;j < i+s && j < Q;j++){', '    xds.union(qs[j][0], qs[j][1]);', '    inner:', '    for(int k = 0;k < p;k++){', '     if(ret[an[k]] == -1){', '      for(int u : gg[an[k]]){', '       if(!xds.equiv(u, gg[an[k]][0]))continue inner;', '      }', '      ret[an[k]] = j+1;', '     }', '    }', '   }', '  }', '  ', '  for(int i = 1;i <= m;i++){', '   out.println(ret[i]);', '  }', ' }', ' ', ' public static int[][] makeBuckets(int[] a, int sup)', ' {', '  int n = a.length;', '  int[][] bucket = new int[sup+1][];', '  int[] bp = new int[sup+1];', '  for(int i = 0;i < n;i++)bp[a[i]]++;', '  for(int i = 0;i <= sup;i++)bucket[i] = new int[bp[i]];', '  for(int i = n-1;i >= 0;i--)bucket[a[i]][--bp[a[i]]] = i;', '  return bucket;', ' }', ' ', ' public static class DJSet {', '  public int[] upper;', '', '  public DJSet(int n) {', '   upper = new int[n];', '   Arrays.fill(upper, -1);', '  }', '', '  public DJSet(DJSet ds) {', '   upper = Arrays.copyOf(ds.upper, ds.upper.length);', '  }', '', '  public int root(int x) {', '   return upper[x] < 0 ? x : (upper[x] = root(upper[x]));', '  }', '', '  public boolean equiv(int x, int y) {', '   return root(x) == root(y);', '  }', '', '  public boolean union(int x, int y) {', '   x = root(x);', '   y = root(y);', '   if (x != y) {', '    if (upper[y] < upper[x]) {', '     int d = x;', '     x = y;', '     y = d;', '    }', '    upper[x] += upper[y];', '    upper[y] = x;', '   }', '   return x == y;', '  }', '', '  public int count() {', '   int ct = 0;', '   for (int u : upper)', '    if (u < 0)', '     ct++;', '   return ct;', '  }', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.IOException;', 'import java.io.PrintWriter;', 'import java.io.Writer;', 'import java.util.HashSet;', 'import java.util.Scanner;', 'import java.util.Set;', '', 'public class Solution {', '    public static void main(String[] args) {', '        Writer writer = new PrintWriter(System.out);', '        compute(new Scanner(System.in), writer);', '        try {', '            writer.flush();', '        } catch (IOException e) {', '            throw new RuntimeException(e);', '        }', '    }', '    ', '    public static void compute(Scanner in, Writer out) {', '        new Solution().computeImpl(in, out);', '    }', '    ', '    private Solution() {}', '    ', '    private int numNodes;', '    private int numLabels;', '    private int numEdges;', '    private Node[] nodes;', '    private int[] labelComponentCounts;', '    private int[] labelFinishTimes;', '    private int now;', '    ', '    private void computeImpl(Scanner in, Writer out) {', '        numNodes = in.nextInt();', '        numLabels = in.nextInt();', '        numEdges = in.nextInt();', '        ', '        nodes = new Node[numNodes+1];', '        labelComponentCounts = new int[numLabels+1];', '        for (int i=1; i<=numNodes; i++) {', '            int label = in.nextInt();', '            nodes[i] = new Node(this, label);', '            labelComponentCounts[label]++;', '        }', '        labelFinishTimes = new int[numLabels+1];', '        for (int label=1; label<=numLabels; label++) {', '            if (labelComponentCounts[label]<=0) {', '                throw new AssertionError(', '                        ""Label ""+label+"" was used "" +', '                        labelComponentCounts[label] + "" times; "" +', '                        ""expected a positive number of occurences"");', '            } else if (labelComponentCounts[label]==1) {', '                labelFinishTimes[label] = 0;', '            } else {', '                labelFinishTimes[label] = -1;', '            }', '        }', '        ', '        for (int t=1; t<=numEdges; t++) {', '            now = t;', '            int v1 = in.nextInt();', '            int v2 = in.nextInt();', '            combine(nodes[v1].getComponentRef(), nodes[v2].getComponentRef());', '        }', '        ', '        for (int k=1; k<=numLabels; k++) {', '            try {', '                out.write(labelFinishTimes[k] + ""\\n"");', '            } catch (IOException e) {', '                throw new RuntimeException(e);', '            }', '        }', '    }', '    ', '    private void combine(ComponentRef ref1, ComponentRef ref2) {', '        if (ref1.getComponent().getNumNodes() <', '                ref2.getComponent().getNumNodes()) {', '            combine(ref2, ref1);', '        }', '        ref2.combineInto(ref1);', '    }', '    ', '    private static class Node {', '        private ComponentRef componentRef;', '        public ComponentRef getComponentRef() {return componentRef;}', '        ', '        public Node(Solution outer, int label) {', '            componentRef =', '                    ComponentRef.createSingleNodeComponentRef(outer, label);', '        }', '    }', '    ', '    private static class ComponentRef {', '        private ComponentRef next;', '        private Component component;', '', '        public boolean isTerminal() {', '            return next==null;', '        }', '', '        public Component getComponent() {', '            if (isTerminal()) {', '                return component;', '            } else {', '                return getTerminal().getComponent();', '            }', '        }', '', '        public ComponentRef getTerminal() {', '            if (isTerminal()) {', '                return this;', '            } else {', '                // Performs path compression', '                next = next.getTerminal();', '                return next;', '            }', '        }', '        ', '        public void combineInto(ComponentRef other) {', '            if (this.getTerminal()==other.getTerminal()) {', '                return;', '            }', '            if (isTerminal()) {', '                other.getComponent().absorb(this.getComponent());', '                this.next = other.getTerminal();', '                this.component = null;', '            } else {', '                this.getTerminal().combineInto(other);', '            }', '        }', '        ', '        public static ComponentRef createSingleNodeComponentRef(', '                Solution outer, int label) {', '            Component c = Component.createSingleNodeComponent(outer, label);', '            return new ComponentRef(null, c);', '        }', '        ', '        private ComponentRef(ComponentRef next, Component component) {', '            this.next = next;', '            this.component = component;', '        }', '    }', '    ', '    private static class Component {', '        private Solution outer;', '        private int numNodes;', '        public int getNumNodes() {return numNodes;}', '        private Set<Integer> labels;', '        public Set<Integer> getLabels() {return labels;}', '        ', '        public static Component createSingleNodeComponent(', '                Solution outer, int label) {', '            Set<Integer> labels = new HashSet<>();', '            labels.add(label);', '            return new Component(outer, 1, labels);', '        }', '        ', '        private Component(', '                Solution outer,', '                int numNodes,', '                Set<Integer> labels) {', '            this.outer = outer;', '            this.numNodes = numNodes;', '            this.labels = labels;', '        }', '        ', '        public void absorb(Component other) {', '            this.numNodes += other.getNumNodes();', '            for (int label : other.getLabels()) {', '                if (this.labels.contains(label)) {', '                    outer.labelComponentCounts[label]--;', '                    if (outer.labelComponentCounts[label]==1) {', '                        outer.labelFinishTimes[label] = outer.now;', '                    }', '                } else {', '                    this.labels.add(label);', '                }', '            }', '        }', '    }', '}']"
"['//package codesprint;', '', 'import java.io.*;', 'import java.util.*;', '', '', 'public class travelinhacker {', '', ' static int N = 100005;', ' static int ans[] = new int[N];', ' static PrintWriter pw;', ' public static void main(String[] args) throws Exception {', '  ', '  InputReader in=new InputReader(System.in);', '  pw=new PrintWriter(System.out);', '', ' int  n = in.nextInt();', ' int  m = in.nextInt();', ' int  q = in.nextInt();', '  ArrayList<Integer>[] search = new ArrayList[N + 1];', '  int owner[] = new int[N];', '  ', '  ', ' ', '', '  for (int i = 0; i < m; i++)', '  {', '   search[i] = new ArrayList<Integer>();', '  }', '   int lis[] = new int[N];', '   int my[] = new int[N];', '   int ris[] = new int[N];', '  for (int i = 0; i < n; i++)', '  {', '   owner[i] = in.nextInt();', '  }', '  int dis[] = new int[N];', '   int a[] = new int[N];', '  rekha rr[] = new rekha[m];', '  for (int i = 0; i < m; i++) {', '   int ff = in.nextInt() - 1;', '   int bb = in.nextInt() - 1;', '   int mm = in.nextInt();', '   rr[i] = new rekha(ff, bb, mm);', '  }', '', '  Arrays.sort(rr);', '', '  for (int i = 0; i < q; i++) {', '   my[i] = in.nextInt() - 1;', '   a[i] = in.nextInt() - 1;', '   dis[i] = in.nextInt();', '  }', '', '  for (int i = 0; i < q; i++) {', '   lis[i] = 0;', '   ris[i] = m - 1;', '   ans[i] = -1;', '   if (my[i] == a[i] && dis[i] == 1)', '   {', '    ans[i] = 0;', '   }', '   else', '   {', '    search[(lis[i] + ris[i]) >>1].add(i);', '   }', '  }', '', '  boolean updated = true;', '', '  while (updated==true) {', '   updated = false;', '  disjointsetunion ds = new disjointsetunion(n, owner);', '   for (int i = 0; i < m; i++) {', '    ds.jointkaro(rr[i].a, rr[i].b);', '    for (int temp = 0; temp < search[i].size(); temp++) {', '     int doubt = search[i].get(temp);', '     if (ds.alagche(my[doubt], a[doubt]) >= dis[doubt]) {', '      ans[doubt] = rr[i].c;', '      ris[doubt] = i - 1;', '      } ', '     else', '      {', '      lis[doubt] = i + 1;', '      }', '     ', '     if (lis[doubt] <= ris[doubt]) {', '      updated = true;', '      search[(lis[doubt] + ris[doubt]) >>1].add(doubt);', '     }', '     ', '     ', '    }', '        search[i].clear();', '   }', '  }', '', '  output(q);', '  ', '', '  pw.close();', ' }', ' public static void output(int q)', ' {', '  for (int i = 0; i < q; i++)', '  {', '   pw.println(ans[i]);', '  }', ' }', ' public static long gcd(long a,long b)', ' {', '  while(a>0 && b>0)', '  {', '   if(a>b)', '   {', '    a%=b;', '   }', '   else', '   {', '    b%=a;', '   }', '   ', '  }', '  return a+b;', '', ' }', ' ', '  static class InputReader {', '', '   private InputStream stream;', '   private byte[] buf = new byte[8192];', '   private int curChar;', '   private int snumChars;', '   private SpaceCharFilter filter;', '', '   public InputReader(InputStream stream) {', '    this.stream = stream;', '   }', '', '   public int snext() {', '    if (snumChars == -1)', '     throw new InputMismatchException();', '    if (curChar >= snumChars) {', '     curChar = 0;', '     try {', '      snumChars = stream.read(buf);', '     } catch (IOException e) {', '      throw new InputMismatchException();', '     }', '     if (snumChars <= 0)', '      return -1;', '    }', '    return buf[curChar++];', '   }', '', '   public int nextInt() {', '    int c = snext();', '    while (isSpaceChar(c))', '     c = snext();', '    int sgn = 1;', ""    if (c == '-') {"", '     sgn = -1;', '     c = snext();', '    }', '', '    int res = 0;', '', '    do {', ""     if (c < '0' || c > '9')"", '      throw new InputMismatchException();', '     res *= 10;', ""     res += c - '0';"", '     c = snext();', '    } while (!isSpaceChar(c));', '', '    return res * sgn;', '   }', '   ', '   public long nextLong() {', '    int c = snext();', '    while (isSpaceChar(c))', '     c = snext();', '    int sgn = 1;', ""    if (c == '-') {"", '     sgn = -1;', '     c = snext();', '    }', '', '    long res = 0;', '', '    do {', ""     if (c < '0' || c > '9')"", '      throw new InputMismatchException();', '     res *= 10;', ""     res += c - '0';"", '     c = snext();', '    } while (!isSpaceChar(c));', '', '    return res * sgn;', '   }', '   ', '   public String readString() {', '    int c = snext();', '    while (isSpaceChar(c))', '     c = snext();', '    StringBuilder res = new StringBuilder();', '    do {', '     res.appendCodePoint(c);', '     c = snext();', '    } while (!isSpaceChar(c));', '    return res.toString();', '   }', '', '   public boolean isSpaceChar(int c) {', '    if (filter != null)', '     return filter.isSpaceChar(c);', ""    return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;"", '   }', '', '   public interface SpaceCharFilter {', '    public boolean isSpaceChar(int ch);', '   }', '  }', '', ' ', ' ', '', '', '', '', ' static class rekha implements Comparable<rekha> {', '  int a, b, c;', '', '  rekha(int x, int y, int z) {', '   this.a = x;', '   this.b = y;', '   this.c = z;', '  }', '', '  public int compareTo(rekha r1) {', '   return Integer.compare(c, r1.c);', '  }', ' }', '', ' static public class disjointsetunion {', '', '  public int parent[];', '  public int n;', '  public TreeSet<Integer> children[];', '  public int[] size;', '', '  public disjointsetunion(int n, int t[]) {', '   this.n = n;', '   parent = new int[n];', '   size = new int[n];', '   for(int i = 0; i < n; i++)', '   {', '    parent[i] = i;', '   }', '   children = new TreeSet[n];', '   for (int i = 0; i < n; i++) {', '    children[i] = new TreeSet<Integer>();', '    children[i].add(t[i]);', '   }', '   size = new int[n];', '   Arrays.fill(size, 1);', '  }', '', '  public int find(int x) {', '   if (parent[x] != x)', '    parent[x] = find(parent[x]);', '   return parent[x];', '  }', '  public int alagche(int a, int b) {', '    if (this.find(a) == this.find(b))', '     return this.children[this.find(a)].size();', '    return 0;', '   }', '', '  public void jointkaro(int x, int y) {', '   int xx = find(x);', '   int yy = find(y);', '', '   if (xx == yy)', '    return;', '', '   if (size[xx] < size[yy]) {', '    parent[xx] = yy;', '    for(int c : children[xx])', '     children[yy].add(c);', '   } else {', '    parent[yy] = xx;', '    for(int c : children[yy])', '     children[xx].add(c);', '   }', '', '   size[xx] = size[yy] = size[xx] + size[yy];', '  }', '  ', '', ' }', '', '', '}']","['//package codesprint;', '', 'import java.io.*;', 'import java.util.*;', '', '', 'public class travelinhacker {', '', '    static int N = 100005;', '    static int ans[] = new int[N];', '    static PrintWriter pw;', '    public static void main(String[] args) throws Exception {', '        ', '        InputReader in=new InputReader(System.in);', '        pw=new PrintWriter(System.out);', '', '    int  n = in.nextInt();', '    int  m = in.nextInt();', '    int  q = in.nextInt();', '     ArrayList<Integer>[] search = new ArrayList[N + 1];', '     int owner[] = new int[N];', '     ', '     ', '    ', '', '        for (int i = 0; i < m; i++)', '        {', '            search[i] = new ArrayList<Integer>();', '        }', '         int lis[] = new int[N];', '         int my[] = new int[N];', '         int ris[] = new int[N];', '        for (int i = 0; i < n; i++)', '        {', '            owner[i] = in.nextInt();', '        }', '        int dis[] = new int[N];', '         int a[] = new int[N];', '        rekha rr[] = new rekha[m];', '        for (int i = 0; i < m; i++) {', '            int ff = in.nextInt() - 1;', '            int bb = in.nextInt() - 1;', '            int mm = in.nextInt();', '            rr[i] = new rekha(ff, bb, mm);', '        }', '', '        Arrays.sort(rr);', '', '        for (int i = 0; i < q; i++) {', '            my[i] = in.nextInt() - 1;', '            a[i] = in.nextInt() - 1;', '            dis[i] = in.nextInt();', '        }', '', '        for (int i = 0; i < q; i++) {', '            lis[i] = 0;', '            ris[i] = m - 1;', '            ans[i] = -1;', '            if (my[i] == a[i] && dis[i] == 1)', '            {', '                ans[i] = 0;', '            }', '            else', '            {', '                search[(lis[i] + ris[i]) >>1].add(i);', '            }', '        }', '', '        boolean updated = true;', '', '        while (updated==true) {', '            updated = false;', '        disjointsetunion    ds = new disjointsetunion(n, owner);', '            for (int i = 0; i < m; i++) {', '                ds.jointkaro(rr[i].a, rr[i].b);', '                for (int temp = 0; temp < search[i].size(); temp++) {', '                    int doubt = search[i].get(temp);', '                    if (ds.alagche(my[doubt], a[doubt]) >= dis[doubt]) {', '                        ans[doubt] = rr[i].c;', '                        ris[doubt] = i - 1;', '                        } ', '                    else', '                        {', '                        lis[doubt] = i + 1;', '                        }', '                    ', '                    if (lis[doubt] <= ris[doubt]) {', '                        updated = true;', '                        search[(lis[doubt] + ris[doubt]) >>1].add(doubt);', '                    }', '                    ', '                    ', '                }', '                                search[i].clear();', '            }', '        }', '', '        output(q);', '        ', '', '        pw.close();', '    }', '    public static void output(int q)', '    {', '        for (int i = 0; i < q; i++)', '        {', '            pw.println(ans[i]);', '        }', '    }', '    public static long gcd(long a,long b)', '    {', '        while(a>0 && b>0)', '        {', '            if(a>b)', '            {', '                a%=b;', '            }', '            else', '            {', '                b%=a;', '            }', '            ', '        }', '        return a+b;', '', '    }', '    ', '     static class InputReader {', '', '            private InputStream stream;', '            private byte[] buf = new byte[8192];', '            private int curChar;', '            private int snumChars;', '            private SpaceCharFilter filter;', '', '            public InputReader(InputStream stream) {', '                this.stream = stream;', '            }', '', '            public int snext() {', '                if (snumChars == -1)', '                    throw new InputMismatchException();', '                if (curChar >= snumChars) {', '                    curChar = 0;', '                    try {', '                        snumChars = stream.read(buf);', '                    } catch (IOException e) {', '                        throw new InputMismatchException();', '                    }', '                    if (snumChars <= 0)', '                        return -1;', '                }', '                return buf[curChar++];', '            }', '', '            public int nextInt() {', '                int c = snext();', '                while (isSpaceChar(c))', '                    c = snext();', '                int sgn = 1;', ""                if (c == '-') {"", '                    sgn = -1;', '                    c = snext();', '                }', '', '                int res = 0;', '', '                do {', ""                    if (c < '0' || c > '9')"", '                        throw new InputMismatchException();', '                    res *= 10;', ""                    res += c - '0';"", '                    c = snext();', '                } while (!isSpaceChar(c));', '', '                return res * sgn;', '            }', '            ', '            public long nextLong() {', '                int c = snext();', '                while (isSpaceChar(c))', '                    c = snext();', '                int sgn = 1;', ""                if (c == '-') {"", '                    sgn = -1;', '                    c = snext();', '                }', '', '                long res = 0;', '', '                do {', ""                    if (c < '0' || c > '9')"", '                        throw new InputMismatchException();', '                    res *= 10;', ""                    res += c - '0';"", '                    c = snext();', '                } while (!isSpaceChar(c));', '', '                return res * sgn;', '            }', '            ', '            public String readString() {', '                int c = snext();', '                while (isSpaceChar(c))', '                    c = snext();', '                StringBuilder res = new StringBuilder();', '                do {', '                    res.appendCodePoint(c);', '                    c = snext();', '                } while (!isSpaceChar(c));', '                return res.toString();', '            }', '', '            public boolean isSpaceChar(int c) {', '                if (filter != null)', '                    return filter.isSpaceChar(c);', ""                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;"", '            }', '', '            public interface SpaceCharFilter {', '                public boolean isSpaceChar(int ch);', '            }', '        }', '', '    ', '    ', '', '', '', '', '    static class rekha implements Comparable<rekha> {', '        int a, b, c;', '', '        rekha(int x, int y, int z) {', '            this.a = x;', '            this.b = y;', '            this.c = z;', '        }', '', '        public int compareTo(rekha r1) {', '            return Integer.compare(c, r1.c);', '        }', '    }', '', '    static public class disjointsetunion {', '', '        public int parent[];', '        public int n;', '        public TreeSet<Integer> children[];', '        public int[] size;', '', '        public disjointsetunion(int n, int t[]) {', '            this.n = n;', '            parent = new int[n];', '            size = new int[n];', '            for(int i = 0; i < n; i++)', '            {', '                parent[i] = i;', '            }', '            children = new TreeSet[n];', '            for (int i = 0; i < n; i++) {', '                children[i] = new TreeSet<Integer>();', '                children[i].add(t[i]);', '            }', '            size = new int[n];', '            Arrays.fill(size, 1);', '        }', '', '        public int find(int x) {', '            if (parent[x] != x)', '                parent[x] = find(parent[x]);', '            return parent[x];', '        }', '        public int alagche(int a, int b) {', '                if (this.find(a) == this.find(b))', '                    return this.children[this.find(a)].size();', '                return 0;', '            }', '', '        public void jointkaro(int x, int y) {', '            int xx = find(x);', '            int yy = find(y);', '', '            if (xx == yy)', '                return;', '', '            if (size[xx] < size[yy]) {', '                parent[xx] = yy;', '                for(int c : children[xx])', '                    children[yy].add(c);', '            } else {', '                parent[yy] = xx;', '                for(int c : children[yy])', '                    children[xx].add(c);', '            }', '', '            size[xx] = size[yy] = size[xx] + size[yy];', '        }', '        ', '', '    }', '', '', '}']"
 , 
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args)', '    {', '        new Solution().solve();', '    }', '    ', '    private void solve()', '    {', '        Scanner in = new Scanner(System.in);', '        int t = in.nextInt();', '        ', '', '        for (int i = 0; i < t; i++)', '        {', '            int n = in.nextInt();', '            int m = in.nextInt();', '            ', '            WeightedGraph graph = new WeightedGraph(n, n - 1);', '            ', '            for (int j = 0; j < n - 1; j++)', '            {', '                graph.addEdge(in.nextInt() - 1, in.nextInt() - 1, in.nextInt());', '            }', '            ', '            graph.buildIncidence();', '            ', '            CreateRootedTreeAlgo algo = new CreateRootedTreeAlgo(graph);', '            algo.run(0);', '            ', '            List<Path> paths = new ArrayList<>(m);', '            List<Path>[] outPaths = new List[n];', '            List<Path>[] inPaths = new List[n];', '            ', '            for (int j = 0; j < n; j++)', '            {', '                outPaths[j] = new ArrayList<Path>(1);', '                inPaths[j] = new ArrayList<Path>(1);', '            }', '             ', '            this.distance = new long[n];', '            this.inq = new int[n];', '            this.queue = new int[n];', '            fq = new int[n];', '            lastPath = new Path[n];', '            lastEdge = new WeightedGraph.Edge[n];', '            ', '            for (int j = 0; j < m; j++)', '            {', '                Path path = new Path(in.nextInt() - 1, in.nextInt() - 1, in.nextInt());', '                paths.add(path);', '            }', '            ', '            Collections.sort(paths,', '                            new Comparator<Path>()', '                             {', '                                public int compare(Path p1, Path p2)', '                                {', '                                    return p2.from - p1.from;', '                                }', '                             });', '                        ', '            for (int j = 0; j < m; j++)', '            {', '                Path path = paths.get(j);', '                ', '                if (this.checkSimple(path.from, path.to, graph))', '                {', '                    this.reversePath(path.from, path.to);', '                    path.reverse = false;', '                }', '                else', '                {', '                    this.shortestPath(path.from, path.to, graph, outPaths, inPaths, j * 2 + 1);', '', '                    if (distance[path.to] < path.value)', '                    {', '                        this.reversePath(path.from, path.to);', '                        path.reverse = false;', '                    }', '                    else', '                    {', '                        path.reverse = true;', '                    }', '                }', '                ', '                outPaths[path.from].add(path);', '                inPaths[path.to].add(path);', '            }', '            ', '            long total = 0;', '            ', '            for (Path path : paths)', '            {', '                if (!path.reverse)', '                {', '                    total += path.value;', '                }', '            }', '            ', '            System.out.println(total);', '        }', '    }', '    ', '    private boolean checkSimple(int from, int to, WeightedGraph graph)', '    {', '        while (to != from)', '        {', '            Graph.Node node = graph.nodes.get(to);', '            WeightedGraph.Edge edge = (WeightedGraph.Edge) node.inEdges.get(0);', '            ', '            if (edge.reverse < edge.weight)', '            {', '                lastEdge[to] = edge;', '                lastPath[to] = null;', '                to = edge.source.index;', '            }', '            else', '            {', '                return false;', '            }', '        }', '        ', '        return true;', '    }', '    ', '    private void reversePath(int from, int to)', '    {', '        while (to != from)', '        {', '            if (lastEdge[to] != null)', '            {', '                if (lastEdge[to].target.index == to)', '                {', '                    lastEdge[to].reverse++;', '                    to = lastEdge[to].source.index;', '                }', '                else', '                {', '                    lastEdge[to].reverse--;', '                    to = lastEdge[to].target.index;', '                }', '            }', '            else', '            {', '                lastPath[to].reverse = !lastPath[to].reverse;', '                ', '                if (lastPath[to].from == to)', '                {', '                    to = lastPath[to].to;', '                }', '                else', '                {', '                    to = lastPath[to].from;', '                }', '            }', '        }', '    }', '    ', '    long distance[];', '    Path lastPath[];', '    WeightedGraph.Edge lastEdge[];', '    int inq[];', '    int[] queue;', '    int[] fq;', '    ', ' private void fill(int source, WeightedGraph graph, int mark)', ' {', '  Graph.Node node = graph.nodes.get(source);', '  int previous = -1;', '', '  for (;;)', '  {', '   int s = 1;', '   fq[0] = node.index;', '   Graph.Node snode = node;', '', '   for (int i = 0; i < s; i++)', '   {', '    int ni = fq[i];', '    node = graph.nodes.get(ni);', '', '    for (Graph.Edge e : node.outEdges)', '    {', '     WeightedGraph.Edge edge = (WeightedGraph.Edge) e;', '', '     if (edge.target.index != previous &&', '      edge.reverse < edge.weight)', '     {', '      distance[edge.target.index] = distance[source];', '      lastEdge[edge.target.index] = edge;', '      lastPath[edge.target.index] = null;', '', '      if (inq[edge.target.index] <= mark)', '      {', '       inq[edge.target.index] = mark + 1;', '       queue[this.size] = edge.target.index;', '       this.size++;', '      }', '', '      fq[s] = edge.target.index;', '      s++;', '     }', '    }', '   }', '', '   if (snode.inEdges.isEmpty())', '   {', '    break;', '   }', '', '   WeightedGraph.Edge edge = (WeightedGraph.Edge) snode.inEdges.get(0);', '', '   if (edge.reverse > 0 && edge.reverse < edge.weight)', '   {', '    previous = snode.index;', '    node = edge.source;', '    distance[node.index] = distance[source];', '    lastEdge[node.index] = edge;', '    lastPath[node.index] = null;', '', '    if (inq[node.index] <= mark)', '    {', '     inq[node.index] = mark + 1;', '     queue[this.size] = node.index;', '     this.size++;', '    }', '   }', '   else', '   {', '    break;', '   }', '  }', ' }', '    ', '    int size;', '    ', '    private void shortestPath(int source, int target, WeightedGraph graph, List<Path>[] outPaths, List<Path>[] inPaths,', '                             int mark)', '    {', '        this.size = 1;', '        inq[source] = mark + 1;', '        queue[0] = source;', '        distance[source] = 0;', '        lastPath[source] = null;', '        lastEdge[source] = null;', '        //this.fill(source, graph, mark);', '        ', '        if (inq[target] >= mark)', '        {', '            return;', '        }', '        ', '        while (size > 0)', '        {', '            size--;', '            int ni = queue[size];', '            inq[ni] = mark;', '            Graph.Node node = graph.nodes.get(ni);', '            ', '            if (node.inEdges.size() > 0)', '            {', '                WeightedGraph.Edge edge = (WeightedGraph.Edge) node.inEdges.get(0);', '                ', '                if (edge.reverse > 0)', '                {', '                    if (inq[edge.source.index] < mark || distance[edge.source.index] > distance[ni])', '                    {', '                        distance[edge.source.index] = distance[ni];', '                        lastEdge[edge.source.index] = edge;', '                        lastPath[edge.source.index] = null;', '                        ', '                        if (inq[edge.source.index] <= mark)', '                        {', '                            inq[edge.source.index] = mark + 1;', '                            queue[size] = edge.source.index;', '                            size++;', '                        }', '                        ', '                        //this.fill(edge.source.index, graph, mark);', '                    }', '                }', '            }', '            ', '            for (Graph.Edge e : node.outEdges)', '            {', '                WeightedGraph.Edge edge = (WeightedGraph.Edge) e;', '                ', '                if (edge.reverse < edge.weight)', '                {', '                    if (inq[edge.target.index] < mark || distance[edge.target.index] > distance[ni])', '                    {', '                        distance[edge.target.index] = distance[ni];', '                        lastEdge[edge.target.index] = edge;', '                        lastPath[edge.target.index] = null;', '                        ', '                        if (inq[edge.target.index] <= mark)', '                        {', '                            inq[edge.target.index] = mark + 1;', '                            queue[size] = edge.target.index;', '                            size++;', '                        }', '                        ', '                        //this.fill(edge.target.index, graph, mark);', '                    }', '                }', '            }', '            ', '            for (Path path : outPaths[ni])', '            {', '                if (!path.reverse)', '                {', '                    if (inq[path.to] < mark || distance[path.to] > distance[ni] + path.value)', '                    {', '                        distance[path.to] = distance[ni] + path.value;', '                        lastEdge[path.to] = null;', '                        lastPath[path.to] = path;', '                        ', '                        if (inq[path.to] <= mark)', '                        {', '                            inq[path.to] = mark + 1;', '                            queue[size] = path.to;', '                            size++;', '                        }', '                        ', '                        //this.fill(path.to, graph, mark);', '                    }', '                }', '            }', '            ', '            for (Path path : inPaths[ni])', '            {', '                if (path.reverse)', '                {', '                    if (inq[path.from] < mark || distance[path.from] > distance[ni] - path.value)', '                    {', '                        distance[path.from] = distance[ni] - path.value;', '                        lastEdge[path.from] = null;', '                        lastPath[path.from] = path;', '                        ', '                        if (inq[path.from] <= mark)', '                        {', '                            inq[path.from] = mark + 1;', '                            queue[size] = path.from;', '                            size++;', '                        }', '                        ', '                        //this.fill(path.from, graph, mark);', '                    }', '                }', '            }', '        }', '    }', '    ', '    static class Path', '    {', '        Path(int from, int to, int value)', '        {', '            this.from = from;', '            this.to = to;', '            this.value = value;', '        }', '        ', '        int from;', '        int to;', '        int value;', '        boolean reverse;', '    }', '   ', 'static class BreadthFirstSearchAlgo', '{', ' public BreadthFirstSearchAlgo(Graph graph)', ' {', '  this.graph = graph;', ' }', '', '', ' public void run(int startNode)', ' {', '  List<Graph.Node> queue = new ArrayList<>(this.graph.n);', '  queue.add(this.graph.nodes.get(startNode));', '  this.distance = new int[this.graph.n];', '', '  for (int i = 0; i < this.graph.n; i++)', '  {', '   this.distance[i] = Integer.MAX_VALUE;', '  }', '', '  this.distance[startNode] = 0;', '', '  for (int i = 0; i < queue.size(); i++)', '  {', '   Graph.Node node = queue.get(i);', '', '   for (Graph.Edge edge : node.outEdges)', '   {', '    if (this.distance[edge.target.index] == Integer.MAX_VALUE)', '    {', '     this.distance[edge.target.index] = this.distance[node.index] + 1;', '     queue.add(edge.target);', '    }', '   }', '', '   for (Graph.Edge edge : node.inEdges)', '   {', '    if (this.distance[edge.source.index] == Integer.MAX_VALUE)', '    {', '     this.distance[edge.source.index] = this.distance[node.index] + 1;', '     queue.add(edge.source);', '    }', '   }', '  }', ' }', '', '', ' public int[] distance;', ' private Graph graph;', '}', '    ', 'static class CreateRootedTreeAlgo', '{', ' public CreateRootedTreeAlgo(Graph graph)', ' {', '  this.graph = graph;', ' }', '', '', ' public void run(int rootIndex)', ' {', '  BreadthFirstSearchAlgo bfs = new BreadthFirstSearchAlgo(this.graph);', '  bfs.run(rootIndex);', '', '  for (Graph.Edge edge : this.graph.edges)', '  {', '   if (bfs.distance[edge.source.index] > bfs.distance[edge.target.index])', '   {', '    Graph.Node temp = edge.source;', '    edge.source = edge.target;', '    edge.target = temp;', '   }', '  }', '', '  this.graph.buildIncidence();', ' }', '', '', ' private Graph graph;', '}', '', 'static class Graph', '{', ' public Graph(int n, int maxM)', ' {', '  this.n = n;', '  this.nodes = new ArrayList<>(this.n);', '', '  for (int i = 0; i < this.n; i++)', '  {', '   this.nodes.add(new Node(i));', '  }', '', '  this.edges = new ArrayList<>(maxM);', ' }', '', ' public void addEdge(int s, int t)', ' {', '  this.edges.add(new Edge(this.nodes.get(s), this.nodes.get(t)));', ' }', '', ' public void buildIncidence()', ' {', '  int out[] = new int[this.n];', '  int in[] = new int[this.n];', '', '  for (Edge edge : this.edges)', '  {', '   out[edge.source.index]++;', '   in[edge.target.index]++;', '  }', '', '  for (int i = 0; i < this.n; i++)', '  {', '   Node node = this.nodes.get(i);', '   node.outEdges = new ArrayList<>(out[i]);', '   node.inEdges = new ArrayList<>(in[i]);', '  }', '', '  for (Edge edge : this.edges)', '  {', '   edge.source.outEdges.add(edge);', '   edge.target.inEdges.add(edge);', '  }', ' }', '', ' public int n;', ' public List<Node> nodes;', ' public List<Edge> edges;', '', '', ' public static class Node', ' {', '  public Node(int index)', '  {', '   this.index = index;', '  }', '', '  public int degree()', '  {', '   return this.inDegree() + this.outDegree();', '  }', '', '  public int inDegree()', '  {', '   return this.inEdges.size();', '  }', '', '  public int outDegree()', '  {', '   return this.outEdges.size();', '  }', '', '  public int index;', '  public List<Edge> outEdges;', '  public List<Edge> inEdges;', ' }', '', ' public static class Edge', ' {', '  public Edge(Node source, Node target)', '  {', '   this.source = source;', '   this.target = target;', '  }', '', '  public int weight()', '  {', '   return 1;', '  }', '', '  public Node source;', '  public Node target;', ' }', '}', '    ', 'static class WeightedGraph extends Graph', '{', ' public WeightedGraph(int n, int maxM)', ' {', '  super(n, maxM);', ' }', '', ' public void addEdge(int s, int t, int weight)', ' {', '  this.edges.add(new Edge(this.nodes.get(s), this.nodes.get(t), weight));', ' }', '', ' public static class Edge extends Graph.Edge', ' {', '  public Edge(Node source, Node target, int weight)', '  {', '   super(source, target);', '   this.weight = weight;', '  }', '', '', '  @Override', '  public int weight()', '  {', '   return this.weight;', '  }', '        ', '        public int weight;', '        public int reverse = 0;', ' }', '}', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args)', '    {', '        new Solution().solve();', '    }', '    ', '    private void solve()', '    {', '        Scanner in = new Scanner(System.in);', '        int t = in.nextInt();', '        ', '', '        for (int i = 0; i < t; i++)', '        {', '            int n = in.nextInt();', '            int m = in.nextInt();', '            ', '            WeightedGraph graph = new WeightedGraph(n, n - 1);', '            ', '            for (int j = 0; j < n - 1; j++)', '            {', '                graph.addEdge(in.nextInt() - 1, in.nextInt() - 1, in.nextInt());', '            }', '            ', '            graph.buildIncidence();', '            ', '            CreateRootedTreeAlgo algo = new CreateRootedTreeAlgo(graph);', '            algo.run(0);', '            ', '            List<Path> paths = new ArrayList<>(m);', '            List<Path>[] outPaths = new List[n];', '            List<Path>[] inPaths = new List[n];', '            ', '            for (int j = 0; j < n; j++)', '            {', '                outPaths[j] = new ArrayList<Path>(1);', '                inPaths[j] = new ArrayList<Path>(1);', '            }', '             ', '            this.distance = new long[n];', '            this.inq = new int[n];', '            this.queue = new int[n];', '            fq = new int[n];', '            lastPath = new Path[n];', '            lastEdge = new WeightedGraph.Edge[n];', '            ', '            for (int j = 0; j < m; j++)', '            {', '                Path path = new Path(in.nextInt() - 1, in.nextInt() - 1, in.nextInt());', '                paths.add(path);', '            }', '            ', '            Collections.sort(paths,', '                            new Comparator<Path>()', '                             {', '                                public int compare(Path p1, Path p2)', '                                {', '                                    return p2.from - p1.from;', '                                }', '                             });', '                        ', '            for (int j = 0; j < m; j++)', '            {', '                Path path = paths.get(j);', '                ', '                if (this.checkSimple(path.from, path.to, graph))', '                {', '                    this.reversePath(path.from, path.to);', '                    path.reverse = false;', '                }', '                else', '                {', '                    this.shortestPath(path.from, path.to, graph, outPaths, inPaths, j * 2 + 1);', '', '                    if (distance[path.to] < path.value)', '                    {', '                        this.reversePath(path.from, path.to);', '                        path.reverse = false;', '                    }', '                    else', '                    {', '                        path.reverse = true;', '                    }', '                }', '                ', '                outPaths[path.from].add(path);', '                inPaths[path.to].add(path);', '            }', '            ', '            long total = 0;', '            ', '            for (Path path : paths)', '            {', '                if (!path.reverse)', '                {', '                    total += path.value;', '                }', '            }', '            ', '            System.out.println(total);', '        }', '    }', '    ', '    private boolean checkSimple(int from, int to, WeightedGraph graph)', '    {', '        while (to != from)', '        {', '            Graph.Node node = graph.nodes.get(to);', '            WeightedGraph.Edge edge = (WeightedGraph.Edge) node.inEdges.get(0);', '            ', '            if (edge.reverse < edge.weight)', '            {', '                lastEdge[to] = edge;', '                lastPath[to] = null;', '                to = edge.source.index;', '            }', '            else', '            {', '                return false;', '            }', '        }', '        ', '        return true;', '    }', '    ', '    private void reversePath(int from, int to)', '    {', '        while (to != from)', '        {', '            if (lastEdge[to] != null)', '            {', '                if (lastEdge[to].target.index == to)', '                {', '                    lastEdge[to].reverse++;', '                    to = lastEdge[to].source.index;', '                }', '                else', '                {', '                    lastEdge[to].reverse--;', '                    to = lastEdge[to].target.index;', '                }', '            }', '            else', '            {', '                lastPath[to].reverse = !lastPath[to].reverse;', '                ', '                if (lastPath[to].from == to)', '                {', '                    to = lastPath[to].to;', '                }', '                else', '                {', '                    to = lastPath[to].from;', '                }', '            }', '        }', '    }', '    ', '    long distance[];', '    Path lastPath[];', '    WeightedGraph.Edge lastEdge[];', '    int inq[];', '    int[] queue;', '    int[] fq;', '    ', '    private void fill(int source, WeightedGraph graph, int mark)', '    {', '        Graph.Node node = graph.nodes.get(source);', '        int previous = -1;', '', '        for (;;)', '        {', '            int s = 1;', '            fq[0] = node.index;', '            Graph.Node snode = node;', '', '            for (int i = 0; i < s; i++)', '            {', '                int ni = fq[i];', '                node = graph.nodes.get(ni);', '', '                for (Graph.Edge e : node.outEdges)', '                {', '                    WeightedGraph.Edge edge = (WeightedGraph.Edge) e;', '', '                    if (edge.target.index != previous &&', '                        edge.reverse < edge.weight)', '                    {', '                        distance[edge.target.index] = distance[source];', '                        lastEdge[edge.target.index] = edge;', '                        lastPath[edge.target.index] = null;', '', '                        if (inq[edge.target.index] <= mark)', '                        {', '                            inq[edge.target.index] = mark + 1;', '                            queue[this.size] = edge.target.index;', '                            this.size++;', '                        }', '', '                        fq[s] = edge.target.index;', '                        s++;', '                    }', '                }', '            }', '', '            if (snode.inEdges.isEmpty())', '            {', '                break;', '            }', '', '            WeightedGraph.Edge edge = (WeightedGraph.Edge) snode.inEdges.get(0);', '', '            if (edge.reverse > 0 && edge.reverse < edge.weight)', '            {', '                previous = snode.index;', '                node = edge.source;', '                distance[node.index] = distance[source];', '                lastEdge[node.index] = edge;', '                lastPath[node.index] = null;', '', '                if (inq[node.index] <= mark)', '                {', '                    inq[node.index] = mark + 1;', '                    queue[this.size] = node.index;', '                    this.size++;', '                }', '            }', '            else', '            {', '                break;', '            }', '        }', '    }', '    ', '    int size;', '    ', '    private void shortestPath(int source, int target, WeightedGraph graph, List<Path>[] outPaths, List<Path>[] inPaths,', '                             int mark)', '    {', '        this.size = 1;', '        inq[source] = mark + 1;', '        queue[0] = source;', '        distance[source] = 0;', '        lastPath[source] = null;', '        lastEdge[source] = null;', '        //this.fill(source, graph, mark);', '        ', '        if (inq[target] >= mark)', '        {', '            return;', '        }', '        ', '        while (size > 0)', '        {', '            size--;', '            int ni = queue[size];', '            inq[ni] = mark;', '            Graph.Node node = graph.nodes.get(ni);', '            ', '            if (node.inEdges.size() > 0)', '            {', '                WeightedGraph.Edge edge = (WeightedGraph.Edge) node.inEdges.get(0);', '                ', '                if (edge.reverse > 0)', '                {', '                    if (inq[edge.source.index] < mark || distance[edge.source.index] > distance[ni])', '                    {', '                        distance[edge.source.index] = distance[ni];', '                        lastEdge[edge.source.index] = edge;', '                        lastPath[edge.source.index] = null;', '                        ', '                        if (inq[edge.source.index] <= mark)', '                        {', '                            inq[edge.source.index] = mark + 1;', '                            queue[size] = edge.source.index;', '                            size++;', '                        }', '                        ', '                        //this.fill(edge.source.index, graph, mark);', '                    }', '                }', '            }', '            ', '            for (Graph.Edge e : node.outEdges)', '            {', '                WeightedGraph.Edge edge = (WeightedGraph.Edge) e;', '                ', '                if (edge.reverse < edge.weight)', '                {', '                    if (inq[edge.target.index] < mark || distance[edge.target.index] > distance[ni])', '                    {', '                        distance[edge.target.index] = distance[ni];', '                        lastEdge[edge.target.index] = edge;', '                        lastPath[edge.target.index] = null;', '                        ', '                        if (inq[edge.target.index] <= mark)', '                        {', '                            inq[edge.target.index] = mark + 1;', '                            queue[size] = edge.target.index;', '                            size++;', '                        }', '                        ', '                        //this.fill(edge.target.index, graph, mark);', '                    }', '                }', '            }', '            ', '            for (Path path : outPaths[ni])', '            {', '                if (!path.reverse)', '                {', '                    if (inq[path.to] < mark || distance[path.to] > distance[ni] + path.value)', '                    {', '                        distance[path.to] = distance[ni] + path.value;', '                        lastEdge[path.to] = null;', '                        lastPath[path.to] = path;', '                        ', '                        if (inq[path.to] <= mark)', '                        {', '                            inq[path.to] = mark + 1;', '                            queue[size] = path.to;', '                            size++;', '                        }', '                        ', '                        //this.fill(path.to, graph, mark);', '                    }', '                }', '            }', '            ', '            for (Path path : inPaths[ni])', '            {', '                if (path.reverse)', '                {', '                    if (inq[path.from] < mark || distance[path.from] > distance[ni] - path.value)', '                    {', '                        distance[path.from] = distance[ni] - path.value;', '                        lastEdge[path.from] = null;', '                        lastPath[path.from] = path;', '                        ', '                        if (inq[path.from] <= mark)', '                        {', '                            inq[path.from] = mark + 1;', '                            queue[size] = path.from;', '                            size++;', '                        }', '                        ', '                        //this.fill(path.from, graph, mark);', '                    }', '                }', '            }', '        }', '    }', '    ', '    static class Path', '    {', '        Path(int from, int to, int value)', '        {', '            this.from = from;', '            this.to = to;', '            this.value = value;', '        }', '        ', '        int from;', '        int to;', '        int value;', '        boolean reverse;', '    }', '   ', 'static class BreadthFirstSearchAlgo', '{', '    public BreadthFirstSearchAlgo(Graph graph)', '    {', '        this.graph = graph;', '    }', '', '', '    public void run(int startNode)', '    {', '        List<Graph.Node> queue = new ArrayList<>(this.graph.n);', '        queue.add(this.graph.nodes.get(startNode));', '        this.distance = new int[this.graph.n];', '', '        for (int i = 0; i < this.graph.n; i++)', '        {', '            this.distance[i] = Integer.MAX_VALUE;', '        }', '', '        this.distance[startNode] = 0;', '', '        for (int i = 0; i < queue.size(); i++)', '        {', '            Graph.Node node = queue.get(i);', '', '            for (Graph.Edge edge : node.outEdges)', '            {', '                if (this.distance[edge.target.index] == Integer.MAX_VALUE)', '                {', '                    this.distance[edge.target.index] = this.distance[node.index] + 1;', '                    queue.add(edge.target);', '                }', '            }', '', '            for (Graph.Edge edge : node.inEdges)', '            {', '                if (this.distance[edge.source.index] == Integer.MAX_VALUE)', '                {', '                    this.distance[edge.source.index] = this.distance[node.index] + 1;', '                    queue.add(edge.source);', '                }', '            }', '        }', '    }', '', '', '    public int[] distance;', '    private Graph graph;', '}', '    ', 'static class CreateRootedTreeAlgo', '{', '    public CreateRootedTreeAlgo(Graph graph)', '    {', '        this.graph = graph;', '    }', '', '', '    public void run(int rootIndex)', '    {', '        BreadthFirstSearchAlgo bfs = new BreadthFirstSearchAlgo(this.graph);', '        bfs.run(rootIndex);', '', '        for (Graph.Edge edge : this.graph.edges)', '        {', '            if (bfs.distance[edge.source.index] > bfs.distance[edge.target.index])', '            {', '                Graph.Node temp = edge.source;', '                edge.source = edge.target;', '                edge.target = temp;', '            }', '        }', '', '        this.graph.buildIncidence();', '    }', '', '', '    private Graph graph;', '}', '', 'static class Graph', '{', '    public Graph(int n, int maxM)', '    {', '        this.n = n;', '        this.nodes = new ArrayList<>(this.n);', '', '        for (int i = 0; i < this.n; i++)', '        {', '            this.nodes.add(new Node(i));', '        }', '', '        this.edges = new ArrayList<>(maxM);', '    }', '', '    public void addEdge(int s, int t)', '    {', '        this.edges.add(new Edge(this.nodes.get(s), this.nodes.get(t)));', '    }', '', '    public void buildIncidence()', '    {', '        int out[] = new int[this.n];', '        int in[] = new int[this.n];', '', '        for (Edge edge : this.edges)', '        {', '            out[edge.source.index]++;', '            in[edge.target.index]++;', '        }', '', '        for (int i = 0; i < this.n; i++)', '        {', '            Node node = this.nodes.get(i);', '            node.outEdges = new ArrayList<>(out[i]);', '            node.inEdges = new ArrayList<>(in[i]);', '        }', '', '        for (Edge edge : this.edges)', '        {', '            edge.source.outEdges.add(edge);', '            edge.target.inEdges.add(edge);', '        }', '    }', '', '    public int n;', '    public List<Node> nodes;', '    public List<Edge> edges;', '', '', '    public static class Node', '    {', '        public Node(int index)', '        {', '            this.index = index;', '        }', '', '        public int degree()', '        {', '            return this.inDegree() + this.outDegree();', '        }', '', '        public int inDegree()', '        {', '            return this.inEdges.size();', '        }', '', '        public int outDegree()', '        {', '            return this.outEdges.size();', '        }', '', '        public int index;', '        public List<Edge> outEdges;', '        public List<Edge> inEdges;', '    }', '', '    public static class Edge', '    {', '        public Edge(Node source, Node target)', '        {', '            this.source = source;', '            this.target = target;', '        }', '', '        public int weight()', '        {', '            return 1;', '        }', '', '        public Node source;', '        public Node target;', '    }', '}', '    ', 'static class WeightedGraph extends Graph', '{', '    public WeightedGraph(int n, int maxM)', '    {', '        super(n, maxM);', '    }', '', '    public void addEdge(int s, int t, int weight)', '    {', '        this.edges.add(new Edge(this.nodes.get(s), this.nodes.get(t), weight));', '    }', '', '    public static class Edge extends Graph.Edge', '    {', '        public Edge(Node source, Node target, int weight)', '        {', '            super(source, target);', '            this.weight = weight;', '        }', '', '', '        @Override', '        public int weight()', '        {', '            return this.weight;', '        }', '        ', '        public int weight;', '        public int reverse = 0;', '    }', '}', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args)  {', '        Scanner scan = new Scanner(System.in);', '        //try{scan = new Scanner(new File(""input00.txt""));}catch(Exception e){}', '        ', '        step[] steps = new step[scan.nextInt()];', '        passenger[] passengers = new passenger[scan.nextInt()];', '        int nitro = scan.nextInt();', '        ', '        loadStuff(scan,steps,passengers);', '        addPassengers(steps,passengers);', '        calcDepartures(steps);', '        //printStations(steps);', '        //System.out.println(passengerTime(steps,passengers));', '        ', '        Queue<run> runs = new PriorityQueue();', '        findruns(runs,steps);', '        //printruns(runs);', '        //System.out.println(totalDistance(steps));', '        saveNitro(steps,runs,nitro);', '        calcDepartures(steps);', '        System.out.println(passengerTime(steps,passengers));', '        ', '    }', '    ', '    static void saveNitro(step[] steps,Queue<run> runs,int nitroLimit){', '        long targetSaving = totalDistance(steps) - nitroLimit;', '        run r;', '        int s;', '        int x;', '        ', '        while(0<targetSaving){', '            r = runs.poll();', '            s = r.station;', '            x = steps[s].distance - steps[s].travelTime;', '            if(x>r.deadline){x=r.deadline;}', '            if(x>targetSaving){x=(int)targetSaving;}', '            ', '            //System.out.println(""Station ""+String.valueOf(s)+"", saved ""+String.valueOf(x));', '            steps[s].travelTime += x;', '            r.deadline -= x;', '            targetSaving -= x;', '            if ((0<s) && (0 < r.deadline)){', '                r.carrying += steps[s].dropped;', '                r.station--;', '                runs.add(r);', '            }', '        }', '    }', '    ', '    static long totalDistance(step[] steps){', '        long distance=0;', '        for(step s : steps){', '            distance += s.distance;', '        }', '        return distance;', '    }', '    ', '    static void printruns(Queue<run> runs){', '        for(run r : runs){', '            System.out.println(""~~~~~~~~"");', '            System.out.println(""station : ""+String.valueOf(r.station));', '            System.out.println(""deadline : ""+String.valueOf(r.deadline));', '            System.out.println(""tocarry : ""+String.valueOf(r.carrying));', '        }', '    }', '    ', '    static void findruns(Queue<run> runs,step[] steps){', '        // timeTaken should be 0 for all stations', '        steps[steps.length-1].departure = 2000000000;', '        for(int i=0;i<steps.length-1;i++){', '            if(steps[i].departure < steps[i+1].departure){', '                run r = new run();', '                r.station = i;', '                r.deadline = steps[i+1].departure - steps[i].departure;', '                r.carrying = steps[i+1].dropped;', '                runs.add(r);', '            }', '        }', '    }', '    ', '    static long passengerTime(step[] steps,passenger[] passengers){', '        long total = 0;', '        for(passenger p : passengers){', '            total += steps[p.dest-1].departure + steps[p.dest-1].travelTime - p.arrival;', '        }', '        return total;', '    }', '    ', '    ', '    static void calcDepartures(step[] steps){', '        int t = 0;', '        for (step s : steps){', '            if(s.departure < t){', '                s.departure = t;', '            }else{', '                t = s.departure;', '            }', '            t+=s.travelTime;', '        }', '    }', '    ', '    static void addPassengers(step[] steps, passenger[] passengers){', '        for (passenger p : passengers) {', '            if(steps[p.start].departure < p.arrival){', '                steps[p.start].departure = p.arrival;', '            }', '            steps[p.start].pickedUp++;', '            steps[p.dest].dropped++;', '        }', '        ', '        int load=0;', '        for (step s : steps){', '            load += s.pickedUp - s.dropped;', '            s.carried = load;', '        }', '    }', '    ', '    static void loadStuff(Scanner scan,step[] steps, passenger[] passengers){', '        for(int i=0;i<steps.length-1;i++){', '            steps[i] = new step();', '            steps[i].distance = scan.nextInt();', '            steps[i].departure = 0;', '            steps[i].travelTime = 0;', '            steps[i].carried = 0;', '            steps[i].pickedUp = 0;', '            steps[i].dropped = 0;', '            ', '        }', '        steps[steps.length-1] = new step();', '        ', '        for(int i=0;i<passengers.length;i++){', '            passengers[i] = new passenger();', '            passengers[i].arrival = scan.nextInt();', '            passengers[i].start = scan.nextInt()-1;', '            passengers[i].dest = scan.nextInt()-1;', '        }', '    }', '    ', '    static void printStations(step[] steps){', '        for(step s : steps){', '            //System.out.println("" : ""+String.valueOf(s));', '            System.out.println(""-------"");', '            System.out.println(""departure : ""+String.valueOf(s.departure));', '            System.out.println(""distance : ""+String.valueOf(s.distance));', '            System.out.println(""travel time : ""+String.valueOf(s.travelTime));', '            System.out.println(""picked up : ""+String.valueOf(s.pickedUp));', '            System.out.println(""dropped : ""+String.valueOf(s.dropped));', '            System.out.println(""carried : ""+String.valueOf(s.carried));', '        }', '    }', '}', '', 'class passenger{', '    public', '    int arrival;', '    int start;', '    int dest;', '}', '', 'class step{', 'public', '    int departure;', '    int distance;', '    int carried;', '    int pickedUp;', '    int dropped;', '    int travelTime;', '}', '', 'class run implements Comparable<run>{', 'public', '    int station;', '    int deadline;', '    int carrying;', '    ', '    @Override public int compareTo(run r2){', '        return (this.carrying - r2.carrying);', '    }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args)  {', '        Scanner scan = new Scanner(System.in);', '        //try{scan = new Scanner(new File(""input00.txt""));}catch(Exception e){}', '        ', '        step[] steps = new step[scan.nextInt()];', '        passenger[] passengers = new passenger[scan.nextInt()];', '        int nitro = scan.nextInt();', '        ', '        loadStuff(scan,steps,passengers);', '        addPassengers(steps,passengers);', '        calcDepartures(steps);', '        //printStations(steps);', '        //System.out.println(passengerTime(steps,passengers));', '        ', '        Queue<run> runs = new PriorityQueue();', '        findruns(runs,steps);', '        //printruns(runs);', '        //System.out.println(totalDistance(steps));', '        saveNitro(steps,runs,nitro);', '        calcDepartures(steps);', '        System.out.println(passengerTime(steps,passengers));', '        ', '    }', '    ', '    static void saveNitro(step[] steps,Queue<run> runs,int nitroLimit){', '        long targetSaving = totalDistance(steps) - nitroLimit;', '        run r;', '        int s;', '        int x;', '        ', '        while(0<targetSaving){', '            r = runs.poll();', '            s = r.station;', '            x = steps[s].distance - steps[s].travelTime;', '            if(x>r.deadline){x=r.deadline;}', '            if(x>targetSaving){x=(int)targetSaving;}', '            ', '            //System.out.println(""Station ""+String.valueOf(s)+"", saved ""+String.valueOf(x));', '            steps[s].travelTime += x;', '            r.deadline -= x;', '            targetSaving -= x;', '            if ((0<s) && (0 < r.deadline)){', '                r.carrying += steps[s].dropped;', '                r.station--;', '                runs.add(r);', '            }', '        }', '    }', '    ', '    static long totalDistance(step[] steps){', '        long distance=0;', '        for(step s : steps){', '            distance += s.distance;', '        }', '        return distance;', '    }', '    ', '    static void printruns(Queue<run> runs){', '        for(run r : runs){', '            System.out.println(""~~~~~~~~"");', '            System.out.println(""station : ""+String.valueOf(r.station));', '            System.out.println(""deadline : ""+String.valueOf(r.deadline));', '            System.out.println(""tocarry : ""+String.valueOf(r.carrying));', '        }', '    }', '    ', '    static void findruns(Queue<run> runs,step[] steps){', '        // timeTaken should be 0 for all stations', '        steps[steps.length-1].departure = 2000000000;', '        for(int i=0;i<steps.length-1;i++){', '            if(steps[i].departure < steps[i+1].departure){', '                run r = new run();', '                r.station = i;', '                r.deadline = steps[i+1].departure - steps[i].departure;', '                r.carrying = steps[i+1].dropped;', '                runs.add(r);', '            }', '        }', '    }', '    ', '    static long passengerTime(step[] steps,passenger[] passengers){', '        long total = 0;', '        for(passenger p : passengers){', '            total += steps[p.dest-1].departure + steps[p.dest-1].travelTime - p.arrival;', '        }', '        return total;', '    }', '    ', '    ', '    static void calcDepartures(step[] steps){', '        int t = 0;', '        for (step s : steps){', '            if(s.departure < t){', '                s.departure = t;', '            }else{', '                t = s.departure;', '            }', '            t+=s.travelTime;', '        }', '    }', '    ', '    static void addPassengers(step[] steps, passenger[] passengers){', '        for (passenger p : passengers) {', '            if(steps[p.start].departure < p.arrival){', '                steps[p.start].departure = p.arrival;', '            }', '            steps[p.start].pickedUp++;', '            steps[p.dest].dropped++;', '        }', '        ', '        int load=0;', '        for (step s : steps){', '            load += s.pickedUp - s.dropped;', '            s.carried = load;', '        }', '    }', '    ', '    static void loadStuff(Scanner scan,step[] steps, passenger[] passengers){', '        for(int i=0;i<steps.length-1;i++){', '            steps[i] = new step();', '            steps[i].distance = scan.nextInt();', '            steps[i].departure = 0;', '            steps[i].travelTime = 0;', '            steps[i].carried = 0;', '            steps[i].pickedUp = 0;', '            steps[i].dropped = 0;', '            ', '        }', '        steps[steps.length-1] = new step();', '        ', '        for(int i=0;i<passengers.length;i++){', '            passengers[i] = new passenger();', '            passengers[i].arrival = scan.nextInt();', '            passengers[i].start = scan.nextInt()-1;', '            passengers[i].dest = scan.nextInt()-1;', '        }', '    }', '    ', '    static void printStations(step[] steps){', '        for(step s : steps){', '            //System.out.println("" : ""+String.valueOf(s));', '            System.out.println(""-------"");', '            System.out.println(""departure : ""+String.valueOf(s.departure));', '            System.out.println(""distance : ""+String.valueOf(s.distance));', '            System.out.println(""travel time : ""+String.valueOf(s.travelTime));', '            System.out.println(""picked up : ""+String.valueOf(s.pickedUp));', '            System.out.println(""dropped : ""+String.valueOf(s.dropped));', '            System.out.println(""carried : ""+String.valueOf(s.carried));', '        }', '    }', '}', '', 'class passenger{', '    public', '    int arrival;', '    int start;', '    int dest;', '}', '', 'class step{', 'public', '    int departure;', '    int distance;', '    int carried;', '    int pickedUp;', '    int dropped;', '    int travelTime;', '}', '', 'class run implements Comparable<run>{', 'public', '    int station;', '    int deadline;', '    int carrying;', '    ', '    @Override public int compareTo(run r2){', '        return (this.carrying - r2.carrying);', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.ArrayList;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', 'import java.util.List;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  int m = ni(), n = ni();', '  int[][] g = new int[2*m+1][2*n+1];', '  for(int i = 0;i < 2*m+1;i++){', '   Arrays.fill(g[i], -1);', '  }', '  for(int i = 0;i < m;i++){', '   for(int j = 0;j < n-1;j++){', '    g[2*i][2*j+1] = ni();', '   }', '  }', '  for(int j = 0;j < m-1;j++){', '   for(int i = 0;i < n;i++){', '    g[2*j+1][2*i] = ni();', '   }', '  }', '  if(m == 1 || n == 1 || (m%2==1 && n%2==1)){', '   out.println(0);', '   return;', '  }', '  ', '  HMG<State> dp = new HMG<State>();', '  State ini = new State((1L<<4*n)-1, 0, 0);', '  add(ini, dp);', '  for(int i = 0;i < m;i++){', '   for(int j = 0;j < n;j++){', '    HMG<State> ndp = new HMG<State>();', '    for(HMG.Entry<State> e : dp.table){', '     for(;e != null;e = e.next){', '      State s = e.value;', '       int fig0 = s.fig&7;', '       int figlast = s.fig>>>3*(n-1)&7;', '       boolean fromup = i > 0 && (fig0 == 1 || fig0 == 3 || fig0 == 5);', '       boolean fromleft = j > 0 && (figlast == 0 || figlast == 3 || figlast == 4);', '       if(fromup){', '        if(fromleft){', '         if((i == m-1 && j == n-1) || (s.clus&15) != (s.clus>>>4*(n-1)&15)) {', '          // 2', '          long xclus = s.clus>>>4|(s.clus&15)<<4*(n-1);', '          int xfig = s.fig>>>3|2<<3*(n-1);', '          int oclus = (int)(s.clus>>>4*(n-1)&15);', '          for(int l = 0;l < n;l++){', '           if((xclus>>>4*l&15) == oclus){', '            xclus &= ~(15L<<4*l);', '            xclus |= (s.clus&15)<<4*l;', '           }', '          }', '          int val = s.val + g[i*2-1][j*2] + g[i*2][j*2-1];', '          add(new State(relocate(xclus, n), xfig, val), ndp);', '         }', '        }else{', '         if(j < n-1){', '          // 0', '          long xclus = s.clus>>>4|(s.clus&15)<<4*(n-1);', '          int xfig = s.fig>>>3|0<<3*(n-1);', '          int val = s.val + g[i*2-1][j*2];', '          add(new State(relocate(xclus, n), xfig, val), ndp);', '         }', '         if(i < m-1){', '          // 1', '          long xclus = s.clus>>>4|(s.clus&15)<<4*(n-1);', '          int xfig = s.fig>>>3|1<<3*(n-1);', '          int val = s.val + g[i*2-1][j*2];', '          add(new State(relocate(xclus, n), xfig, val), ndp);', '         }', '        }', '       }else{', '        if(hasHidden(s.clus, n))continue;', '        if(fromleft){', '         if(j < n-1){', '          // 4', '          long xclus = s.clus>>>4|(s.clus>>>4*(n-1)&15)<<4*(n-1);', '          int xfig = s.fig>>>3|4<<3*(n-1);', '          int val = s.val + g[i*2][j*2-1];', '          add(new State(relocate(xclus, n), xfig, val), ndp);', '         }', '         if(i < m-1){', '          // 5', '          long xclus = s.clus>>>4|(s.clus>>>4*(n-1)&15)<<4*(n-1);', '          int xfig = s.fig>>>3|5<<3*(n-1);', '          int val = s.val + g[i*2][j*2-1];', '          add(new State(relocate(xclus, n), xfig, val), ndp);', '         }', '        }else{', '         if(i < m-1 && j < n-1){', '          // 3', '          long xclus = s.clus>>>4|11L<<4*(n-1);', '          int xfig = s.fig>>>3|3<<3*(n-1);', '          int val = s.val;', '          add(new State(relocate(xclus, n), xfig, val), ndp);', '         }', '        }', '       }', '      }', '    }', '//    tr(i, j, ndp.size());', '//    tr(ndp.values());', '    dp = ndp;', '   }', '  }', '  int min = Integer.MAX_VALUE;', '  for(HMG.Entry<State> e : dp.table){', '   for(;e != null;e = e.next){', '    State s = e.value;', '    if(s.clus == 0L){', '     min = Math.min(min, s.val);', '    }', '   }', '  }', '  out.println(min);', ' }', ' ', ' public static class State', ' {', '  final long clus;', '  final int fig;', '  // UR:0', '  // UD:1', '  // UL:2', '  // RD:3', '  // RL:4', '  // DL:5', '  int val;', '  ', '  public State(long clus, int fig, int val) {', '   this.clus = clus;', '   this.val = val;', '   this.fig = fig;', '  }', '  ', '  public long h()', '  {', '   long h = 1;', '   h = h * 1000000009 + clus;', '   h = h * 1000000009 + fig;', '   return h;', '  }', '', '  @Override', '  public String toString() {', '   StringBuilder builder = new StringBuilder();', '   builder.append(""State [clus="");', '   builder.append(Long.toBinaryString(clus));', '   builder.append("", fig="");', '   builder.append(Integer.toBinaryString(fig));', '   builder.append("", val="");', '   builder.append(val);', '   builder.append(""]"");', '   return builder.toString();', '  }', ' }', ' ', ' public static boolean hasHidden(long a, int n)', ' {', '  if((a&15) != 15){', '   for(int i = 1;i < n;i++){', '    if((a>>>4*i&15) == 0)return false;', '   }', '   return true;', '  }else{', '   return false;', '  }', ' }', ' ', ' public static boolean hasHidden(int[] a)', ' {', '  if(a[0] != -1){', '   for(int i = 1;i < a.length;i++){', '    if(a[i] == 0)return false;', '   }', '   return true;', '  }else{', '   return false;', '  }', ' }', ' ', ' public static int has(int[] a)', ' {', '  for(int v : a){', '   if(v != -1)return 1;', '  }', '  return 0;', ' }', ' ', ' public static int num(int[] a)', ' {', '  int num = -1;', '  for(int v : a){', '   if(v > num)num = v;', '  }', '  return num+1;', ' }', ' ', ' public static long relocate(long a, int n)', ' {', '  long map = -1L;', '  int p = 0;', '  long b = 0;', '  for(int i = 0;i < n;i++){', '   int cl = (int)(a>>>4*i&15);', '   if(cl == 15){', '    b |= 15L<<4*i;', '   }else{', '    if((map>>>4*cl&15) == 15){', '     map ^= (15L^p++)<<4*cl;', '    }', '    b |= (map>>>4*cl&15)<<4*i;', '   }', '  }', '  return b;', ' }', ' ', ' public static class HMG<T> {', '  public int size;', '  ', '  private List<Entry<T>> table;', '  private int threshold;', '  ', '     static final int DEFAULT_INITIAL_CAPACITY = 4;', '     ', '     public HMG() {', '      this(DEFAULT_INITIAL_CAPACITY);', '     }', '     ', '     public HMG(int ice)', '     {', '      int capacity = 1<<ice;', '      threshold = capacity * 3 / 4;', '      table = new ArrayList<Entry<T>>();', '      for(int i = 0;i < capacity;i++)table.add(null);', '     }', '     ', '  final int hash(long n)', '  {', '   n ^= (n>>>20)^(n>>>12);', '   return (int)(n^(n>>>7)^(n>>>4));', '  }', '  ', '  int indexFor(int h, int length){', '   return h&length-1;', '  }', '  ', '  Entry<T> getEntry(long k)', '  {', '   for(Entry<T> e = table.get(indexFor(hash(k), table.size())); e != null; e = e.next)if(e.key == k)return e;', '   return null;', '  }', '  ', '  T get(long k)', '  {', '   for(Entry<T> e = table.get(indexFor(hash(k), table.size())); e != null; e = e.next)if(e.key == k)return e.value;', '   return null;', '  }', '  ', '  boolean containsKey(long k)', '  {', '   for(Entry<T> e = table.get(indexFor(hash(k), table.size())); e != null; e = e.next)if(e.key == k)return true;', '   return false;', '  }', '  ', '  T put(long k, T v)', '  {', '   int h = hash(k);', '   int i = indexFor(h, table.size());', '   for(Entry<T> e = table.get(i); e != null; e = e.next){', '    if(e.key == k){', '     T oldValue = e.value;', '     e.value = v;', '     return oldValue;', '    }', '   }', '   ', '   addEntry(h, k, v, i);', '   return null;', '  }', '  ', '  void addEntry(int h, long k, T v, int bucketIndex)', '  {', '   if(size >= threshold && null != table.get(bucketIndex)){', '    resize(2*table.size());', '    bucketIndex = indexFor(h, table.size());', '   }', '   createEntry(k, v, bucketIndex);', '  }', '  ', '  void resize(int nc)', '  {', '   List<Entry<T>> newTable = new ArrayList<Entry<T>>();', '   for(int i = 0;i < nc;i++)newTable.add(null);', '   transfer(newTable);', '   table = newTable;', '   threshold = nc*3/4;', '  }', '  ', '  void transfer(List<Entry<T>> newTable)', '  {', '   int nc = newTable.size();', '   for(Entry<T> e : table){', '    while(e != null){', '     Entry<T> next = e.next;', '     int i = indexFor(hash(e.key), nc);', '     e.next = newTable.get(i);', '     newTable.set(i, e);', '     e = next;', '    }', '   }', '  }', '  ', '  void createEntry(long k, T v, int bucketIndex)', '  {', '   Entry<T> e = table.get(bucketIndex);', '   table.set(bucketIndex, new Entry<T>(k, v, e));', '   size++;', '  }', '  ', '  // not verified', '  final Entry<T> remove(int k)', '  {', '   int h = hash(k);', '   int i = indexFor(h, table.size());', '   Entry<T> prev = table.get(i), e = prev;', '   while(e != null){', '    Entry<T> next = e.next;', '    if(e.key == k){', '     size--;', '     if(prev == e){', '      table.set(i, next);', '     }else{', '      prev.next = next;', '     }', '     return e;', '    }', '    prev = e;', '    e = next;', '   }', '   return e;', '  }', '  ', '  static class Entry<T>', '  {', '   public long key;', '   public T value;', '   public Entry<T> next;', '   ', '   public Entry(long key, T value, Entry<T> next) {', '    this.key = key;', '    this.value = value;', '    this.next = next;', '   }', '  }', ' }', ' ', ' public static HMG<State> add(State s, HMG<State> map)', ' {', '  long h = s.h();', '  if(map.containsKey(h)){', '   map.get(h).val = Math.min(map.get(h).val, s.val);', '  }else{', '   map.put(h, s);', '  }', '  return map;', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.BufferedReader;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.StringTokenizer;', '', 'public class Solution {', '    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));', '    PrintWriter writer = new PrintWriter(System.out);', '    StringTokenizer stringTokenizer;', '', '    String next() throws IOException {', '        while (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {', '            stringTokenizer = new StringTokenizer(reader.readLine());', '        }', '        return stringTokenizer.nextToken();', '    }', '', '    int nextInt() throws IOException {', '        return Integer.parseInt(next());', '    }', '', '    long nextLong() throws IOException {', '        return Long.parseLong(next());', '    }', '', '    final int MOD = 1000 * 1000 * 1000 + 7;', '', '    int sum(int a, int b) {', '        a += b;', '        return a >= MOD ? a - MOD : a;', '    }', '    int product(int a, int b) {', '        return (int)(1L * a * b % MOD);', '    }', '    int pow(int x, int k) {', '        int result = 1;', '        while(k > 0) {', '            if(k % 2 == 1) {', '                result = product(result, x);', '            }', '            x = product(x, x);', '            k /= 2;', '        }', '        return result;', '    }', '    int inv(int x) {', '        return pow(x, MOD - 2);', '    }', '', '    int encode(int[] decoded) {', '        int result = 0;', '        for(int i = 0; i < decoded.length; i++) {', '            result *= 3;', '            result += decoded[decoded.length - 1 - i];', '        }', '        return result;', '    }', '', '    void solveTest() throws IOException {', '        final int rows = nextInt(), cols = nextInt();', '        final int[][] rowConnectors = new int[rows][cols];', '        final int[][] colConnectors = new int[cols][rows];', '        for(int i = 0; i < rows; i++) {', '            for(int j = 0; j < cols - 1; j++) {', '                rowConnectors[i][j] = nextInt();', '            }', '        }', '        for(int i = 0; i < rows - 1; i++) {', '            for(int j = 0; j < cols; j++) {', '                colConnectors[j][i] = nextInt();', '            }', '        }', '        int maxMask = 1;', '        for(int i = 0; i < cols + 1; i++) {', '            maxMask *= 3;', '        }', '        final int[][][] dp = new int[rows + 1][cols + 1][maxMask];', '        for(int i = 0; i < rows + 1; i++) {', '            for(int j = 0; j < cols + 1; j++) {', '                Arrays.fill(dp[i][j], Integer.MAX_VALUE);', '            }', '        }', '        dp[0][0][0] = 0;', '        int[] stack = new int[cols + 1];', '        int stackTop = 0;', '        int[] decoded = new int[cols + 1];', '        int[] copy = new int[cols + 1];', '        int[] correspondent = new int[cols + 1];', '        for(int r = 0; r < rows; r++) {', '            for(int c = 0; c <= cols; c++) {', '                for(int mask = 0; mask < maxMask; mask++) {', '                    if(dp[r][c][mask] == Integer.MAX_VALUE) continue;', '                    if(c == cols) {', '                        if(mask < maxMask / 3) {', '                            dp[r + 1][0][mask * 3] = Math.min(dp[r + 1][0][mask * 3], dp[r][c][mask]);', '                        }', '                        continue;', '                    }', '                    int maskCopy = mask;', '//                    Arrays.fill(correspondent, 0);', '                    for(int i = 0; i <= cols; i++) {', '                        decoded[i] = maskCopy % 3;', '                        maskCopy /= 3;', '                        if(decoded[i] == 1) {', '                            stack[stackTop++] = i;', '                        }', '                        if(decoded[i] == 2) {', '                            int pop = stack[--stackTop];', '                            correspondent[i] = pop;', '                            correspondent[pop] = i;', '                        }', '                    }', '                    if(decoded[c] == 0 && decoded[c + 1] == 0) {', '                        decoded[c] = 1;', '                        decoded[c + 1] = 2;', '                        int encoded = encode(decoded);', '                        dp[r][c + 1][encoded] = Math.min(dp[r][c + 1][encoded], dp[r][c][mask] + rowConnectors[r][c] + colConnectors[c][r]);', '                    }', '                    else if(decoded[c] == 0 || decoded[c + 1] == 0) {', '                        System.arraycopy(decoded, 0, copy, 0, decoded.length);', '                        copy[c] = decoded[c] + decoded[c + 1];', '                        copy[c + 1] = 0;', '                        int encoded = encode(copy);', '                        dp[r][c + 1][encoded] = Math.min(dp[r][c + 1][encoded], dp[r][c][mask] + colConnectors[c][r]);', '                        copy[c + 1] = decoded[c] + decoded[c + 1];', '                        copy[c] = 0;', '                        encoded = encode(copy);', '                        dp[r][c + 1][encoded] = Math.min(dp[r][c + 1][encoded], dp[r][c][mask] + rowConnectors[r][c]);', '                    }', '                    else {', '                        boolean connect = (r == rows - 1 && c == cols - 1) || correspondent[c] != c + 1;', '                        if(connect) {', '                            int c1 = correspondent[c];', '                            int c2 = correspondent[c + 1];', '                            decoded[c1] = c1 < c2 ? 1 : 2;', '                            decoded[c2] = c2 < c1 ? 1 : 2;', '                            decoded[c] = decoded[c + 1] = 0;', '                            int encoded = encode(decoded);', '                            dp[r][c + 1][encoded] = Math.min(dp[r][c + 1][encoded], dp[r][c][mask]);', '                        }', '                    }', '                }', '            }', '        }', '        int ans = dp[rows][0][0];', '        if(ans == Integer.MAX_VALUE) ans = 0;', '        writer.println(ans);', '        writer.close();', '    }', '', '    void solve() throws IOException {', '        for(int i = nextInt(); i >= 1; i--) {', '            solveTest();', '        }', '        writer.close();', '    }', '', '    public static void main(String[] args) throws IOException {', '        new Solution().solveTest();', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' public static int[][][] packWU(int n, int[] from, int[] to, int[] w) {', '  int[][][] g = new int[n][][];', '  int[] p = new int[n];', '  for(int f : from)', '   p[f]++;', '  for(int t : to)', '   p[t]++;', '  for(int i = 0;i < n;i++)', '   g[i] = new int[p[i]][2];', '  for(int i = 0;i < from.length;i++){', '   --p[from[i]];', '   g[from[i]][p[from[i]]][0] = to[i];', '   g[from[i]][p[from[i]]][1] = w[i];', '   --p[to[i]];', '   g[to[i]][p[to[i]]][0] = from[i];', '   g[to[i]][p[to[i]]][1] = w[i];', '  }', '  return g;', ' }', ' ', ' static void solve()', ' {', '  int n = ni(), m = ni();', '  int[] from = new int[m];', '  int[] to = new int[m];', '  int[] w = new int[m];', '  for(int i = 0;i < m;i++){', '   from[i] = ni()-1;', '   to[i] = ni()-1;', '   w[i] = ni();', '  }', '  int[][][] g = packWU(n, from, to, w);', '  int[][] ans = buildGomoryHuTree(g);', '  int mod = 1000000007;', '  long ret = 1;', '  for(int i = 0;i < n;i++){', '   for(int j = i+1;j < n;j++){', '    ret = ret * ans[i][j] % mod;', '   }', '  }', '  out.println(ret);', ' }', ' ', ' public static int[][] buildGomoryHuTree(int[][][] g)', ' {', '  int n = g.length;', '  int[] par = new int[n];', '  int[][] ans = new int[n][n];', '  int I = 99999999;', '  for(int i = 0;i < n;i++){', '   Arrays.fill(ans[i], I);', '  }', '  int[][][] pre = prepare(g);', '  int[][] ig = pre[0];', '  int[][] gind = pre[1];', '  int[][] igind = pre[2];', '  int[] d = new int[n];', '  int[] fq = new int[n];', '  ', '  for(int i = 1;i < n;i++){', '   Flow flow = maximumFlowDinicRecycling(g, i, par[i], ig, gind, igind, d, fq);', '   int[] mincut = mincut(flow, i, g);', '   for(int j : mincut){', '    if(j > i && par[j] == par[i])par[j] = i;', '   }', '   ans[i][par[i]] = ans[par[i]][i] = (int)flow.maximum;', '   for(int j = 0;j < i;j++){', '    ans[i][j] = ans[j][i] = Math.min((int)flow.maximum, ans[par[i]][j]);', '   }', '  }', '  return ans;', ' }', ' ', ' public static int[][][] prepare(int[][][] g){', '  int n = g.length;', '  // unweighted invgraph', '  int[] p = new int[n];', '  for(int i = 0;i < n;i++){', '   for(int j = 0;j < g[i].length;j++)p[g[i][j][0]]++;', '  }', '  int[][] ig = new int[n][];', '  for(int i = 0;i < n;i++)ig[i] = new int[p[i]];', '  for(int i = n-1;i >= 0;i--){', '   for(int j = 0;j < g[i].length;j++){', '    ig[g[i][j][0]][--p[g[i][j][0]]] = i;', '   }', '  }', '  ', '  int[][] gind = new int[n][];', '  for(int i = 0;i < n;i++)gind[i] = new int[g[i].length];', '  int[] gp = new int[n];', '  for(int i = 0;i < n;i++){', '   for(int j = 0;j < g[i].length;j++)gind[i][j] = gp[g[i][j][0]]++;', '  }', '  ', '  int[][] igind = new int[n][];', '  for(int i = 0;i < n;i++)igind[i] = new int[ig[i].length];', '  int[] igp = new int[n];', '  for(int i = 0;i < n;i++){', '   for(int j = 0;j < ig[i].length;j++)igind[i][j] = igp[ig[i][j]]++;', '  }', '  ', '  return new int[][][]{ig, gind, igind};', ' }', ' ', ' static int[] mincut(Flow flow, int src, int[][][] g)', ' {', '  int n = g.length;', '  int[] q = new int[n];', '  boolean[] ved = new boolean[n];', '  int p = 0;', '  q[p++] = src;', '  ved[src] = true;', '  for(int r = 0;r < p;r++){', '   int cur = q[r];', '   for(int i = 0;i < flow.F[cur].length;i++){', '    if(flow.F[cur][i] < g[cur][i][1] && !ved[g[cur][i][0]]){', '     ved[g[cur][i][0]] = true;', '     q[p++] = g[cur][i][0];', '    }', '   }', '  }', '  return Arrays.copyOf(q, p);', ' }', ' ', ' public static class Flow', ' {', '  long maximum;', '  int[][] F;', '  ', '  public Flow(long maximum, int[][] f) {', '   this.maximum = maximum;', '   F = f;', '  }', ' }', ' ', ' public static Flow maximumFlowDinicRecycling(int[][][] g, int source, int sink, int[][] ig, int[][] gind, int[][] igind, int[] d, int[] q)', ' {', '  int n = g.length;', '  ', '  int[][] F = new int[n][];', '  for(int i = 0;i < n;i++)F[i] = new int[g[i].length];', '  ', '  int[][] iF = new int[n][];', '  for(int i = 0;i < n;i++)iF[i] = new int[ig[i].length];', '  ', '  long ret = 0;', '  while(true){', '   Arrays.fill(d, -1);', '   q[0] = source;', '   int r = 1;', '   d[source] = 0;', '   ', '   for(int v = 0;v < r;v++){', '    int cur = q[v];', '    // plus flow', '    for(int i = 0;i < g[cur].length;i++){', '     int[] ne = g[cur][i];', '     int nex = ne[0], w = ne[1];', '     if(d[nex] == -1 && w - F[cur][i] > 0) {', '      q[r++] = nex;', '      d[nex] = d[cur] + 1;', '     }', '    }', '    // minus flow', '    for(int i = 0;i < ig[cur].length;i++){', '     int nex = ig[cur][i];', '     if(d[nex] == -1 && -iF[cur][i] > 0) {', '      q[r++] = nex;', '      d[nex] = d[cur] + 1;', '     }', '    }', '   }', '   if(d[sink] == -1)break;', '   int[] sp = new int[n];', '   int[] isp = new int[n];', '   for(int i = 0;i < n;i++)sp[i] = g[i].length - 1;', '   for(int i = 0;i < n;i++)isp[i] = ig[i].length - 1;', '   int delta;', '   while((delta = dfsDinic(d, g, ig, sp, isp, F, iF, gind, igind, source, sink, Integer.MAX_VALUE)) > 0){', '    ret += delta;', '   }', '  }', '  ', '  return new Flow(ret, F);', ' }', ' ', ' private static int dfsDinic(int[] d, int[][][] g, int[][] ig, int[] sp, int[] isp, int[][] F, int[][] iF, int[][] gind, int[][] igind, int cur, int sink, int min)', ' {', '  if(cur == sink){', '   return min;', '  }else{', '   int left = min;', '   for(int i = sp[cur];i >= 0;i--){', '    int[] ne = g[cur][i];', '    int nex = ne[0], w = ne[1];', '    if(d[nex] == d[cur]+1 && w-F[cur][i] > 0){', '     int fl = dfsDinic(d, g, ig, sp, isp, F, iF, gind, igind, nex, sink, Math.min(left, w-F[cur][i]));', '     if(fl > 0){', '      left -= fl;', '      F[cur][i] += fl;', '      iF[nex][gind[cur][i]] -= fl;', '      if(left == 0){', '       sp[cur] = i;', '       return min;', '      }', '     }', '    }', '   }', '   sp[cur] = -1;', '   for(int i = isp[cur];i >= 0;i--){', '    int nex = ig[cur][i];', '    if(d[nex] == d[cur]+1 && -iF[cur][i] > 0){', '     int fl = dfsDinic(d, g, ig, sp, isp, F, iF, gind, igind, nex, sink, Math.min(left, -iF[cur][i]));', '     if(fl > 0){', '      iF[cur][i] += fl;', '      F[nex][igind[cur][i]] -= fl;', '      left -= fl;', '      if(left == 0){', '       isp[cur] = i;', '       return min;', '      }', '     }', '    }', '   }', '   isp[cur] = -1;', '   return min-left;', '  }', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '    BufferedReader br;', '    PrintWriter out;', '    StringTokenizer st;', '    boolean eof;', '', '    static final int INF = Integer.MAX_VALUE / 3;', '', '    static class FlowGraph {', '        int N, S, T;', '', '        List<FlowEdge>[] g;', '', '        int[] dist;', '        private Deque<Integer> q;', '        private int[] ptr;', '', '        public FlowGraph(int n, int s, int t) {', '            N = n;', '            S = s;', '            T = t;', '            g = new List[N];', '            for (int i = 0; i < N; i++) {', '                g[i] = new ArrayList<>();', '            }', '            dist = new int[N];', '            q = new ArrayDeque<>();', '            ptr = new int[N];', '        }', '', '        public void addDirectedEdge(int v1, int v2, int cap) {', '            FlowEdge e1 = new FlowEdge(v2, cap);', '            FlowEdge e2 = new FlowEdge(v1, 0);', '            e1.rev = e2;', '            e2.rev = e1;', '            g[v1].add(e1);', '            g[v2].add(e2);', '        }', '', '        public void addUndirectedEdge(int v1, int v2, int cap) {', '            FlowEdge e1 = new FlowEdge(v2, cap);', '            FlowEdge e2 = new FlowEdge(v1, cap);', '            e1.rev = e2;', '            e2.rev = e1;', '            g[v1].add(e1);', '            g[v2].add(e2);', '        }', '', '        private boolean bfs() {', '            Arrays.fill(dist, INF);', '            dist[S] = 0;', '            q.clear();', '            q.add(S);', '', '            while (!q.isEmpty()) {', '                int v = q.poll();', '                List<FlowEdge> adj = g[v];', '                for (int i = 0; i < adj.size(); i++) {', '                    FlowEdge e = adj.get(i);', '                    if (e.flow < e.cap && dist[e.to] > dist[v] + 1) {', '                        dist[e.to] = dist[v] + 1;', '                        q.add(e.to);', '                    }', '                }', '            }', '            return dist[T] != INF;', '        }', '', '        private int dfs(int v, int curFlow) {', '            if (v == T)', '                return curFlow;', '            List<FlowEdge> adj = g[v];', '            while (ptr[v] < adj.size()) {', '                FlowEdge e = adj.get(ptr[v]);', '                if (dist[e.to] == dist[v] + 1 && e.flow != e.cap) {', '                    int go = dfs(e.to, Math.min(curFlow, e.cap - e.flow));', '                    if (go != 0) {', '                        e.flow += go;', '                        e.rev.flow -= go;', '                        return go;', '                    }', '                }', '                ptr[v]++;', '            }', '            return 0;', '        }', '', '        public int maxFlow(int S, int T) {', '            clear();', '            this.S = S;', '            this.T = T;', '            int flow = 0;', '', '            while (bfs()) {', '                Arrays.fill(ptr, 0);', '                int addFlow;', '                do {', '                    addFlow = dfs(S, INF);', '                    flow += addFlow;', '                } while (addFlow > 0);', '            }', '', '            return flow;', '        }', '', '        public void clear() {', '            for (int i = 0; i < N; i++) {', '                for (int j = 0; j < g[i].size(); j++) {', '                    g[i].get(j).flow = 0;', '                }', '            }', '        }', '', '        public boolean[] getCut() {', '            /**', '             * only call after maxFlow invocation!', '             * using dist array from the last ', '             * bfs() call', '             */', '            boolean[] ret = new boolean[N];', '            for (int i = 0; i < N; i++) {', '                ret[i] = dist[i] != INF;', '            }', '            return ret;', '        }', '', '    }', '', '    static class FlowEdge {', '        int to;', '        int flow, cap;', '', '        FlowEdge rev;', '', '        public FlowEdge(int to, int cap) {', '            this.to = to;', '            this.cap = cap;', '        }', '    }', '', '    void solve() throws IOException {', '        int n = nextInt();', '        int m = nextInt();', '        FlowGraph g = new FlowGraph(n, -1, -1);', '        for (int i = 0; i < m; i++) {', '            int v1 = nextInt() - 1;', '            int v2 = nextInt() - 1;', '            int cap = nextInt();', '            if (v1 == v2) {', '                throw new AssertionError(""Or should I?"");', '            }', '            g.addUndirectedEdge(v1, v2, cap);', '        }', '', '        int ans = 1;', '', '        int[] p = new int[n];', '        Arrays.fill(p, 0);', '', '        int[][] flowVal = new int[n][n];', '        for (int i = 0; i < n; i++) {', '            Arrays.fill(flowVal[i], INF);', '        }', '', '        for (int i = 1; i < n; i++) {', '            int val = g.maxFlow(i, p[i]);', '            boolean[] cut = g.getCut();', '            for (int j = i + 1; j < n; j++) {', '                if (cut[j] && p[j] == p[i]) {', '                    p[j] = i;', '                }', '            }', '            flowVal[i][p[i]] = flowVal[p[i]][i] = val;', '            for (int j = 0; j < i; j++) {', '                if (j != p[i]) {', '                    flowVal[i][j] = flowVal[j][i] = Math.min(val, flowVal[p[i]][j]);', '                }', '            }', '        }', '        ', '        for (int i = 0; i < n; i++)', '            for (int j = 0; j < i; j++) {', '                ans = mul(ans, flowVal[i][j]);', '            }', '        ', '        out.println(ans);', '    }', '', '    int mul(int a, int b) {', '        return (int) ((long) a * b % MOD);', '    }', '', '    static final int MOD = 1_000_000_007;', '', '    void inp() throws IOException {', '        br = new BufferedReader(new InputStreamReader(System.in));', '        out = new PrintWriter(System.out);', '        solve();', '        out.close();', '    }', '', '    public static void main(String[] args) throws IOException {', '        new Solution().inp();', '    }', '', '    String nextToken() {', '        while (st == null || !st.hasMoreTokens()) {', '            try {', '                st = new StringTokenizer(br.readLine());', '            } catch (Exception e) {', '                eof = true;', '                return null;', '            }', '        }', '        return st.nextToken();', '    }', '', '    String nextString() {', '        try {', '            return br.readLine();', '        } catch (IOException e) {', '            eof = true;', '            return null;', '        }', '    }', '', '    int nextInt() throws IOException {', '        return Integer.parseInt(nextToken());', '    }', '', '    long nextLong() throws IOException {', '        return Long.parseLong(nextToken());', '    }', '', '    double nextDouble() throws IOException {', '        return Double.parseDouble(nextToken());', '    }', '}']"
 , 
 , 
"['/* HackerRank Template */', '', 'import java.io.*;', 'import java.util.*;', '', 'import static java.lang.Math.*;', 'import static java.util.Arrays.fill;', 'import static java.util.Arrays.binarySearch;', 'import static java.util.Arrays.sort;', '', 'public class Solution {', ' ', ' static long initTime;', ' static final Random rnd = new Random(7777L);', ' static boolean writeLog = false;', ' ', ' public static void main(String[] args) throws IOException {', '//  initTime = System.currentTimeMillis();', '//  try {', '//   writeLog = ""true"".equals(System.getProperty(""LOCAL_RUN_7777""));', '//  } catch (SecurityException e) {}', '//  new Thread(null, new Runnable() {', '//   public void run() {', '//    try {', '//     try {', '//      if (new File(""input.txt"").exists())', '//       System.setIn(new FileInputStream(""input.txt""));', '//     } catch (SecurityException e) {}', '//     long prevTime = System.currentTimeMillis();', '//     new Solution().run();', '//     writeLog(""Total time: "" + (System.currentTimeMillis() - prevTime) + "" ms"");', '//     writeLog(""Memory status: "" + memoryStatus());', '//    } catch (IOException e) {', '//     e.printStackTrace();', '//    }', '//   }', '//  }, ""1"", 1L << 24).start();', '  new Solution().run();', ' }', '', ' void run() throws IOException {', '  in = new BufferedReader(new InputStreamReader(System.in));', '  out = new PrintWriter(System.out);', '  solve();', '  out.close();', '  in.close();', ' }', ' ', ' /*************************************************************** ', '  * Solution: min-cost-flow on multi-list', '  **************************************************************/', '', ' final int INF = Integer.MAX_VALUE >> 1;', ' final Map<String, Integer> indexes = new HashMap<String, Integer>(120);', ' final int costOffset = 10000;', ' final int edgesCap = 30;', ' ', ' void solve() throws IOException  {', '  ', '  int n = nextInt();', '  int m = nextInt();', '  int k = nextInt();', '  ', '  int[] prices = new int [k];', '  int[] destionations = new int [n];', '  ', '  for (int i = 0; i < k; i++) {', '   prices[indexOf(nextToken())] = 5 * nextInt();', '  }', '  ', '  for (int i = 0; i < n; i++) {', '   destionations[i] = indexOf(nextToken());', '  }', '  ', '  ', '  ', '  int S = n + n;', '  int T = S + 1;', '  Net net = new Net(T + 1, n + n * (n - 1) / 2 + n);', '  ', '  for (int i = 0; i < n; i++) {', '   net.addDirectedEdge(S, i, 1, 0);', '  }', '  ', '  for (int i = 0; i < n; i++) {', '   boolean first = true;', '   int edges = 0;', '   for (int j = i + 1; j < n; j++) {', '    int discount = getDiscount(prices, destionations, i, j);', '    if (discount == 0) {', '     if (++edges <= edgesCap) {', '      net.addDirectedEdge(i, n + j, 1, costOffset);', '     }', '    } else if (first) {', '     first = false;', '     net.addDirectedEdge(i, n + j, 1, costOffset - discount);', '    }', '   }', '  }', '  ', '  for (int i = 0; i < n; i++) {', '   net.addDirectedEdge(n + i, T, 1, 0);', '  }', '  ', '  MinCostFlowAlgorithm minCostFlowAlgorithm = new MinCostFlowAlgorithm(net, S, T);', '  ', '  int totalCost = minCostFlowAlgorithm.run(n - m);', '  ', '  for (int i = 0; i < n; i++) {', '   totalCost += prices[destionations[i]];', '  }', '  ', '  out.println(0.2 * totalCost);', '  ', '  int[] pathIndexes = getPathIndexes(n, net);', '  ', '  for (int pathIndex : pathIndexes) {', '   out.println(pathIndex);', '  }', ' }', ' ', ' int[] getPathIndexes(int n, Net net) {', '  int[] pathIndexes = new int [n];', '  ', '  int curIndex = 1;', '  ', '  for (int i = 0; i < n; i++) {', '   if (pathIndexes[i] == 0) {', '    dfs(net, n, i, curIndex++, pathIndexes);', '   }', '  }', '  ', '  return pathIndexes;', ' }', '', ' void dfs(Net net, int n, int v, int pathIndex, int[] pathIndexes) {', '  pathIndexes[v] = pathIndex;', '  ', '  for (int i = net.head[v]; i != 0; i = net.next[i]) {', '   NetEdge edge = net.edges[i];', '   if (edge.flow == 1) {', '    dfs(net, n, edge.to - n, pathIndex, pathIndexes);', '   }', '  }', '  ', ' }', '', ' int getDiscount(int[] prices, int[] destionations, int i, int j) {', '  if (destionations[i] == destionations[j]) {', '   return prices[destionations[i]] / 5;', '  }', '  return 0;', ' }', '', ' int indexOf(String key) {', '  Integer index = indexes.get(key);', '  if (index == null) indexes.put(key, index = indexes.size());', '  return index;', ' }', ' ', ' class MinCostFlowAlgorithm {', '  Net net;', '  int[] dist;', '  int[] used;', '  int[] phi;', '  NetEdge[] prev;', '  int tick = 1;', '  ', '  int S, T;', '  int cost;', '  int flow;', '  ', '  MinCostFlowAlgorithm(Net net, int S, int T) {', '   this.net = net;', '   dist = new int [net.vNum];', '   used = new int [net.vNum];', '   phi = new int [net.vNum];', '   prev = new NetEdge [net.vNum];', '   this.S = S;', '   this.T = T;', '  }', '  ', '  int run(int minFlow) {', '   ', '   cost = flow = 0;', '   ', '   for (;;) {', '    ', '    int pathCost = dijkstra();', '    ', '//    if (pathCost == INF && flow < minFlow) {', '//     throw new RuntimeException(""Something wrong"");', '//    }', '    ', '    if (pathCost >= 0 && flow >= minFlow) {', '     break;', '    }', '    ', '    updateFlow();', '   }', '   ', '   return cost - flow * costOffset;', '  }', '  ', '  int dijkstra() {', '   fill(dist, INF);', '   tick++;', '   dist[S] = 0;', '   ', '   for (;;) {', '    int v = -1;', '    for (int i = 0; i < net.vNum; i++)', '     if (used[i] != tick && dist[i] != INF && (v == -1 || dist[v] > dist[i]))', '      v = i;', '    if (v == -1) break;', '    used[v] = tick;', '    for (int i = net.head[v]; i != 0; i = net.next[i]) {', '     NetEdge e = net.edges[i];', '     if (e.restCapacity() > 0)', '      if (dist[e.to] > dist[v] + e.cost + phi[v] - phi[e.to]) {', '       dist[e.to] = dist[v] + e.cost + phi[v] - phi[e.to];', '       prev[e.to] = e;', '      }', '    }', '   }', '   ', '   return dist[T];', '  }', '  ', '  void updateFlow() {', '   for (int v = T; v != S; v = prev[v].from)', '    cost += prev[v].inc();', '   flow++;', '   for (int v = 0; v < net.vNum; v++)', '    phi[v] += dist[v] != INF ? dist[v] : dist[T];', '  }', '  ', ' }', ' ', ' class NetEdge {', '  int from;', '  int to;', '  int capacity;', '  int flow;', '  int cost;', '  NetEdge back;', '  ', '  NetEdge(int from, int to, int capacity, int cost) {', '   this.from = from;', '   this.to = to;', '   this.capacity = capacity;', '   this.cost = cost;', '  }', '  ', '  int restCapacity() {', '   return capacity - flow;', '  }', '  ', '  void connect(NetEdge back) {', '   this.back = back;', '  }', '  ', '  int inc() {', '   flow++;', '   back.flow--;', '   return cost;', '  }', ' }', ' ', ' class Net {', '  int vNum;', '  int[] head;', '  int[] next;', '  NetEdge[] edges;', '  int cnt = 1;', '  ', '  Net(int vNum, int eNum) {', '   this.vNum = vNum;', '   head = new int [vNum];', '   next = new int [2 * eNum + 1];', '   edges = new NetEdge [2 * eNum + 1];', '  }', '  ', '  void add(int v, NetEdge e) {', '   next[cnt] = head[v];', '   edges[cnt] = e;', '   head[v] = cnt++;', '  }', '  ', '  void addDirectedEdge(int from, int to, int capacity, int cost) {', '   NetEdge forward = new NetEdge(from, to, capacity, cost);', '   NetEdge back = new NetEdge(to, from, 0, -cost);', '   forward.connect(back);', '   back.connect(forward);', '   this.add(from, forward);', '   this.add(to, back);', '  }', ' }', ' ', ' /*************************************************************** ', '  * Input ', '  **************************************************************/', ' BufferedReader in;', ' PrintWriter out;', ' StringTokenizer st = new StringTokenizer("""");', ' ', ' String nextToken() throws IOException {', '  while (!st.hasMoreTokens())', '   st = new StringTokenizer(in.readLine());', '  return st.nextToken();', ' }', ' ', ' int nextInt() throws IOException {', '  return Integer.parseInt(nextToken());', ' }', ' ', ' long nextLong() throws IOException {', '  return Long.parseLong(nextToken());', ' }', ' ', ' double nextDouble() throws IOException {', '  return Double.parseDouble(nextToken());', ' }', ' ', ' int[] nextIntArray(int size) throws IOException {', '  int[] ret = new int [size];', '  for (int i = 0; i < size; i++)', '   ret[i] = nextInt();', '  return ret;', ' }', ' ', ' long[] nextLongArray(int size) throws IOException {', '  long[] ret = new long [size];', '  for (int i = 0; i < size; i++)', '   ret[i] = nextLong();', '  return ret;', ' }', ' ', ' double[] nextDoubleArray(int size) throws IOException {', '  double[] ret = new double [size];', '  for (int i = 0; i < size; i++)', '   ret[i] = nextDouble();', '  return ret;', ' }', ' ', ' String nextLine() throws IOException {', '  st = new StringTokenizer("""");', '  return in.readLine();', ' }', ' ', ' boolean EOF() throws IOException {', '  while (!st.hasMoreTokens()) {', '   String s = in.readLine();', '   if (s == null)', '    return true;', '   st = new StringTokenizer(s);', '  }', '  return false;', ' }', ' ', ' /*************************************************************** ', '  * Output ', '  **************************************************************/', ' void printRepeat(String s, int count) {', '  for (int i = 0; i < count; i++)', '   out.print(s);', ' }', ' ', ' void printArray(int[] array) {', '  if (array == null || array.length == 0)', '   return;', '  for (int i = 0; i < array.length; i++) {', ""   if (i > 0) out.print(' ');"", '   out.print(array[i]);', '  }', '  out.println();', ' }', ' ', ' void printArray(long[] array) {', '  if (array == null || array.length == 0)', '   return;', '  for (int i = 0; i < array.length; i++) {', ""   if (i > 0) out.print(' ');"", '   out.print(array[i]);', '  }', '  out.println();', ' }', ' ', ' void printArray(double[] array) {', '  if (array == null || array.length == 0)', '   return;', '  for (int i = 0; i < array.length; i++) {', ""   if (i > 0) out.print(' ');"", '   out.print(array[i]);', '  }', '  out.println();', ' }', ' ', ' void printArray(double[] array, String spec) {', '  if (array == null || array.length == 0)', '   return;', '  for (int i = 0; i < array.length; i++) {', ""   if (i > 0) out.print(' ');"", '   out.printf(Locale.US, spec, array[i]);', '  }', '  out.println();', ' }', ' ', ' void printArray(Object[] array) {', '  if (array == null || array.length == 0)', '   return;', '  boolean blank = false;', '  for (Object x : array) {', ""   if (blank) out.print(' '); else blank = true;"", '   out.print(x);', '  }', '  out.println();', ' }', ' ', ' @SuppressWarnings(""rawtypes"")', ' void printCollection(Collection collection) {', '  if (collection == null || collection.isEmpty())', '   return;', '  boolean blank = false;', '  for (Object x : collection) {', ""   if (blank) out.print(' '); else blank = true;"", '   out.print(x);', '  }', '  out.println();', ' }', ' ', ' /*************************************************************** ', '  * Utility', '  **************************************************************/', ' static String memoryStatus() {', '  return (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() >> 20) + ""/"" + (Runtime.getRuntime().totalMemory() >> 20) + "" MB"";', ' }', ' ', ' static void checkMemory() {', '  System.err.println(memoryStatus());', ' }', ' ', ' static long prevTimeStamp = Long.MIN_VALUE;', ' ', ' static void updateTimer() {', '  prevTimeStamp = System.currentTimeMillis();', ' }', ' ', ' static long elapsedTime() {', '  return (System.currentTimeMillis() - prevTimeStamp);', ' }', ' ', ' static void checkTimer() {', '  System.err.println(elapsedTime() + "" ms"");', ' }', ' ', ' static void chk(boolean f) {', '  if (!f) throw new RuntimeException(""Assert failed"");', ' }', ' ', ' static void chk(boolean f, String format, Object ... args) {', '  if (!f) throw new RuntimeException(String.format(format, args));', ' }', ' ', ' static void writeLog(String format, Object ... args) {', '  if (writeLog) System.err.println(String.format(Locale.US, format, args));', ' }', ' ', ' static void swap(int[] a, int i, int j) {', '  int tmp = a[i];', '  a[i] = a[j];', '  a[j] = tmp;', ' }', ' ', ' static void swap(long[] a, int i, int j) {', '  long tmp = a[i];', '  a[i] = a[j];', '  a[j] = tmp;', ' }', ' ', ' static void swap(double[] a, int i, int j) {', '  double tmp = a[i];', '  a[i] = a[j];', '  a[j] = tmp;', ' }', ' ', ' static void shuffle(int[] a, int from, int to) {', '  for (int i = from; i < to; i++)', '   swap(a, i, rnd.nextInt(a.length));', ' }', ' ', ' static void shuffle(long[] a, int from, int to) {', '  for (int i = from; i < to; i++)', '   swap(a, i, rnd.nextInt(a.length));', ' }', ' ', ' static void shuffle(double[] a, int from, int to) {', '  for (int i = from; i < to; i++)', '   swap(a, i, rnd.nextInt(a.length));', ' }', ' ', ' static void shuffle(int[] a) {', '  if (a == null) return;', '  shuffle(a, 0, a.length);', ' }', ' ', ' static void shuffle(long[] a) {', '  if (a == null) return;', '  shuffle(a, 0, a.length);', ' }', ' ', ' static void shuffle(double[] a) {', '  if (a == null) return;', '  shuffle(a, 0, a.length);', ' }', ' ', ' static long[] getPartialSums(int[] a) {', '  final long[] sums = new long [a.length + 1];', '  for (int i = 0; i < a.length; i++)', '   sums[i + 1] = sums[i] + a[i];', '  return sums;', ' }', ' ', ' static long[] getPartialSums(long[] a) {', '  final long[] sums = new long [a.length + 1];', '  for (int i = 0; i < a.length; i++)', '   sums[i + 1] = sums[i] + a[i];', '  return sums;', ' }', ' ', ' static int[] getOrderedSet(int[] a) {', '  final int[] set = Arrays.copyOf(a, a.length);', '  if (a.length == 0) return set;', '  shuffle(set);', '  sort(set);', '  int k = 1;', '  int prev = set[0];', '  for (int i = 1; i < a.length; i++) {', '   if (prev != set[i]) {', '    set[k++] = prev = set[i];', '   }', '  }', '  return Arrays.copyOf(set, k);', ' }', ' ', ' static long[] getOrderedSet(long[] a) {', '  final long[] set = Arrays.copyOf(a, a.length);', '  if (a.length == 0) return set;', '  shuffle(set);', '  sort(set);', '  int k = 1;', '  long prev = set[0];', '  for (int i = 1; i < a.length; i++) {', '   if (prev != set[i]) {', '    set[k++] = prev = set[i];', '   }', '  }', '  return Arrays.copyOf(set, k);', ' }', '}']","['import java.io.*;', 'import java.text.DecimalFormat;', 'import java.util.*;', '', 'public class Solution {', '', '  static class Edge {', '    int v;', '    int c;', '    double w;', '    Edge next;', '    Edge twain;', '    public Edge(int v, int c, double w) {', '      this.v = v;', '      this.c = c;', '      this.w = w;', '    }', '  }', '  ', '  static Edge[] es;', '  static Edge[] pred;', '  static Edge[] pool;', '  static int allo = 0;', '', '  static void add(int u, int v, int c, double w) {', '    Edge e1 = new Edge(v, c, w);', '    Edge e2 = new Edge(u, 0, -w);', '    ', '    pool[allo] = e1;', '    pool[allo].next = es[u];', '    pool[allo].twain = e2;', '    ', '    pool[allo+1] = e2;', '    pool[allo+1].next = es[v];', '    pool[allo+1].twain = e1;', '', '    es[u] = pool[allo++];', '    es[v] = pool[allo++];', '  }', '', '  static final double EPS = 1e-8;', '  static boolean[] in;', '  static int[] q;', '  static double[] dist;', '  ', '  static boolean labelCorrecting(int n, int src, int sink) {', '    Arrays.fill(in, 0, n, false);', '    Arrays.fill(pred, 0, n, null);', '    Arrays.fill(dist, 0, n, Double.MAX_VALUE/2);', '    dist[src] = 0;', '    int fr = 0;', '    int re = 0;', '    q[re++] = src;', '    while (fr != re) {', '      int u = q[fr++];', '      if (fr == q.length) {', '        fr = 0;', '      }', '      in[u] = false;', '      for (Edge e = es[u]; e != null; e = e.next) {', '        if (e.c > 0) {', '          double t = dist[u]+e.w;', '          if (t + EPS < dist[e.v]) {', '            dist[e.v] = t;', '            pred[e.v] = e;', '            if (! in[e.v]) {', '              in[e.v] = true;', '              q[re++] = e.v;', '              if (re == q.length)', '                re = 0;', '            }', '          }', '        }', '      }', '    }', '    return dist[sink] < Double.MAX_VALUE;', '  }', '', '  static double minCostMaxFlow(int n, int src, int sink, int m) {', '    int flow = 0;', '    double cost = 0;', '    while (flow < m && labelCorrecting(n, src, sink) && dist[sink] < 0) {', '      int f = m-flow;', '      for (int v = sink; v != src; v = pred[v].twain.v) {', '        f = Math.min(f, pred[v].c);', '      }', '      flow += f;', '      cost += f*dist[sink];', '      for (int v = sink; v != src; v = pred[v].twain.v) {', '        pred[v].c -= f;', '        pred[v].twain.c += f;', '      }', '    }', '    return cost;', '  }', '  ', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int n = Integer.parseInt(st.nextToken());', '    int m = Integer.parseInt(st.nextToken());', '    int k = Integer.parseInt(st.nextToken());', '    Map<String, Integer> price = new HashMap<>();', '    for (int i = 0; i < k; i++) {', '      st = new StringTokenizer(br.readLine());', '      String s = st.nextToken();', '      int p = Integer.parseInt(st.nextToken());', '      price.put(s, p);', '    }', '    int src = 2*n;', '    int sink = src+1;', '    String[] dest = new String[n];', '    es = new Edge[n*2+2];', '    pred = new Edge[n*2+2];', '    pool = new Edge[n*(n-1)+3*n << 1];', '    for (int i = 0; i < n; i++) {', '      st = new StringTokenizer(br.readLine());', '      String s = st.nextToken();', '      dest[i] = s;', '      double t = price.get(s);', '      add(src, i, 1, t);', '      add(i, n+i, 1, -100*n);', '      add(n+i, sink, 1, 0);', '      for (int j = 0; j < i; j++) {', '        add(n+j, i, 1, dest[j].equals(dest[i]) ? 0.8*t : t);', '      }', '    }', '    in = new boolean[n*2+2];', '    q = new int[n*2+2];', '    dist = new double[n*2+2];', '    double res = minCostMaxFlow(sink+1, src, sink, m)+100*n*n;', '    DecimalFormat df = new DecimalFormat(""#.###"");', '    bw.write(df.format(res) + ""\\n"");', '    int id = 0;', '    int[] window = new int[n];', '    for (Edge e = es[src]; e != null; e = e.next) {', '      if (e.c == 0) {', '        window[e.v] = ++id;', '      }', '    }', '    for (int i = 0; i < n; i++) {', '      for (Edge e = es[n+i]; e != null; e = e.next) {', '        if (e.v < n && i < e.v && e.c == 0) {', '          window[e.v] = window[i];', '        }', '      }', '    }', '    for (int i = 0; i < n; i++) {', '      bw.write(window[i] + ""\\n"");', '    }', '', '    bw.newLine();', '    bw.close();', '    br.close();', '  }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int t = in.nextInt();', '        int b = in.nextInt();', '        int f = in.nextInt();', '        int c = in.nextInt();', '        // your code goes here', '        int minNodes = getMinNodes(t,b,f,c);', '        if (minNodes < 0)', '            System.out.println(minNodes);', '        else {', '            int maxNodes = (int)Math.max(minNodes, t+1);', '   TreeMap<Integer, ArrayList<Integer>> map = initializeMap(maxNodes);', '   // create edges for excess tree edges', '   createEdge(minNodes+1, maxNodes, 1, map);', '            while (minNodes > 1) {', '    //identify max possible cross / forward edges for minNodes-1 vertices', '    //thereby identifying number of cross / forward edges that needs to be', '    //created in this iteration', '    int currMaxFwdOrCrossEdges = ((minNodes-1)*(minNodes-2))/2;', '    int prevMaxFwdOrCrossEdges = ((minNodes-2)*(minNodes-3))/2;', '    int currMaxBackEdges = ((minNodes-1)*minNodes)/2;', '    int prevMaxBackEdges = currMaxFwdOrCrossEdges;', '    ', '    int maxFwdOrCrossEdges = minNodes-2;', '    int maxBackEdges = minNodes-1;', '', '    int minCreateForwardEdge = (int) Math.max(f-prevMaxFwdOrCrossEdges, 0);', '    int minCreateCrossEdge = (int)Math.min(c, maxFwdOrCrossEdges - minCreateForwardEdge);    ', '    int minCreateBackEdge = (int) Math.max(c + b - minCreateCrossEdge - prevMaxBackEdges, 0);', '    ', '    int treeEdgeNode = ', '            (int) Math.min(minNodes - minCreateCrossEdge, ', '                           (int) Math.max(minCreateBackEdge, minCreateForwardEdge+1));', '        ', '    //create the tree edge / forward edge depending ', '    //on whether a fwd edge was already created', '    createCrossEdges(minCreateCrossEdge, minNodes, treeEdgeNode, map);', '    createForwardEdges(minCreateForwardEdge, treeEdgeNode, minNodes, map);', '    createBackEdges(minCreateBackEdge, minNodes, treeEdgeNode, map);', '       createEdge(minNodes, minNodes, treeEdgeNode, map);', '', '                //update counts remaining and current node for processing', '    c -= minCreateCrossEdge;', '    b -= minCreateBackEdge;', '    f -= minCreateForwardEdge;', '    --minNodes;', '   }', '   printMap(map);', '   ', '        }', '    }', '', '    private static void createCrossEdges(int numEdges, ', '                                      int startNode, ', '           TreeMap<Integer, ArrayList<Integer>> tMap){', '  createEdge(startNode-numEdges, startNode-1, startNode, tMap);  ', ' } ', ' ', '    private static void createCrossEdges(int numEdges, ', '                                      int startNode, ', '           int treeNode,', '           TreeMap<Integer, ArrayList<Integer>> tMap){', '  createEdge(treeNode+1, treeNode+numEdges, startNode, tMap);  ', ' } ', ' ', '    private static void createBackEdges(int numEdges, ', '                                     int startNode, ', '          int treeNode,', '          TreeMap<Integer, ArrayList<Integer>> tMap){', '  createEdge(treeNode-numEdges+1, treeNode, startNode, tMap);  ', ' } ', ' ', '    private static void createForwardEdges(int numEdges, ', '             int treeNode,', '             int startNode, ', '             TreeMap<Integer, ArrayList<Integer>> tMap){', '  for (int i=treeNode-numEdges; i<=treeNode-1; i++)', '   createEdge(startNode, startNode, i, tMap);  ', ' } ', ' ', '    //creates an edge from startNode to all the nodes (both inclusive) between from and to', ' private static void createEdge(int from, ', '                                int to, ', '           int startNode, ', '           TreeMap<Integer, ArrayList<Integer>> tMap) {', '  ArrayList<Integer> edges = tMap.get(startNode);', '  for (int i=from; i<=to; i++) {', '   edges.add(i);', '  }', '  edges = null;', ' }', ' ', ' private static TreeMap<Integer, ArrayList<Integer>> initializeMap(int size){', '     TreeMap<Integer, ArrayList<Integer>> newMap = new TreeMap<Integer, ArrayList<Integer>>();', '  for (int i=1; i<=size; i++) {', '   newMap.put(i, new ArrayList<Integer>());', '  }', '  return newMap;', ' }', ' ', ' private static void printMap(TreeMap<Integer, ArrayList<Integer>> treeMap) {', '        System.out.println(treeMap.size());', '  ArrayList<Integer> edges = null;', '  for (Integer key: treeMap.keySet()) {', '   edges = treeMap.get(key);', '   Collections.sort(edges);', '   System.out.print(edges.size());', '   for (Integer edge: edges) {', '    System.out.print("" "" + edge);', '   }', '   System.out.println("""");', '  }', ' }', '    ', '    private static int getMinNodes(int te, int be, int fe, int ce) {', '        // there should be at least 1 te (2 nodes) to have 1 be and', '        // at least 2 te (3 nodes) for 1 fe and ce.', '        // Also, the maximum number of be or  fe and ce grows with every new node', '        // at this rate: n*(n-1)/2 and (n-1)*(n-2)/2  respectively', '        ', '        if (te == 0 && be == 0 && fe == 0 && ce == 0)', '            return 1;', '        ', '        //There can be utmost n*(n-1) edged in a graph of n nodes.', '        // every ce means conversion of 1 fe + 1 be to 1 ce.', ""        // since fe and ce grow at same rate, if all are ce, there won't be any fe but there still can be some be"", '        // be = (n-1)*n/2, ce and fe are (n-1)*(n-2)/2 ', '        int min_te4cefeRbe = (int)Math.max(1 + (int)Math.round(Math.sqrt(2*(ce+fe))), (int)Math.round(Math.sqrt(2*(be+ce))));        ', '        if (min_te4cefeRbe > te) return -1;', '        return 1 + min_te4cefeRbe;', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '  static List<Integer>[] g;', '', '  static boolean left(int nodes, int f, int b) {', '    for (int i = 1; i < nodes; i++) {', '      g[i].add(i + 1);', '    }', '    int f0 = f;', '    int b0 = b;', '    int start = 1;', '    while (f0 > 0 || b0 > 0) {', '      int next = start + 1;', '      if (next > nodes) {', '        return false;', '      }', '      if (b0 > 0) {', '        g[next].add(start);', '        b0--;', '      }      ', '      next++;', '      while ((f0 > 0 || b0 > 0) && next <= nodes) {', '        if (f0 > 0) {', '          g[start].add(next);', '          f0--;', '        }', '        if (b0 > 0) {', '          g[next].add(start);', '          b0--;', '        }', '        next++;', '      }', '      start++;', '    }', '    return true;', '  }', '', '  static boolean right(int start, int nodes, int c) {', '    for (int i = start; i <= nodes; i++) {', '      g[1].add(i);', '    }', '    int c0 = c;', '    for (int i = nodes; i >= start; i--) {', '      for (int j = i - 1; j > 1; j--) {', '        g[i].add(j);', '        c0--;', '        if (c0 == 0) {', '          break;', '        }', '      }', '      if (c0 == 0) {', '        break;', '      }', '    }', '    if (c0 > 0) {', '      return false;', '    }', '    return true;', '  }', '', '  static boolean complexn(int nodes, int t, int b, int f, int c) {', '    int n = 1;', '    int egges = nodes - n - 1;', '    int last = nodes - n - 1;', '    while (egges < c) {', '      n++;', '      last = egges;', '      egges += nodes - n - 1;', '    }', '    n--;', '    int left = nodes - n;', '    for (int i = 1; i < left - 1; i++) {', '      g[i].add(i + 1);', '    }', '    int crossNode = left - (c - last) - 1;', '    g[crossNode].add(left);', '    n = left - 1;', '    int f0 = f;', '    int b0 = b;', '    int start = 1;', '    while (f0 > 0 || b0 > 0) {', '      int next = start + 1;', '      if (next > n) {', '        break;', '      }', '      if (b0 > 0) {', '        g[next].add(start);', '        b0--;', '      }', '      next++;', '      while ((f0 > 0 || b0 > 0) && next <= n) {', '        if (f0 > 0) {', '          g[start].add(next);', '          f0--;', '        }', '        if (b0 > 0) {', '          g[next].add(start);', '          b0--;', '        }', '        next++;', '      }', '      start++;', '    }', '', '    if (b0 > 0) {', '      for (int i = 1; b0 > 0 && i <= crossNode; i++) {', '        g[left].add(i);', '        b0--;', '      }', '    }', '    for (int i = 0; i < (c - last); i++) {', '      g[left].add(crossNode + i + 1);', '    }', '    for (int i = 1; i < left && f0 > 0; i++) {', '      g[i].add(left);', '      f0--;', '    }', '    if (!right(left + 1, nodes, last)) {', '      return false;', '    }', '    if (b0 > 0) {', '      for (int i = left+1; b0 > 0 && i <= nodes; i++) {', '        g[i].add(1);', '        b0--;', '      }', '    }', '', '    return true;', '  }  ', '', '  static boolean complex1(int nodes, int t, int b, int f, int c) {', '    int n = nodes - 1;', '    for (int i = 1; i < n; i++) {', '      g[i].add(i + 1);', '    }', '    int crossNode = nodes - c-1;', '    g[crossNode].add(nodes);', '    int f0 = f;', '    int b0 = b;', '    int start = 1;', '    while (f0 > 0 || b0 > 0) {', '      int next = start + 1;', '      if (next > n) {', '        break;', '      }', '      if (b0 > 0) {', '        g[next].add(start);', '        b0--;', '      }', '      next++;', '      while ((f0 > 0 || b0 > 0) && next <= n) {', '        if (f0 > 0) {', '          g[start].add(next);', '          f0--;', '        }', '        if (b0 > 0) {', '          g[next].add(start);', '          b0--;', '        }', '        next++;', '      }', '      start++;', '    }', '', '    for (int i = 1; i <= b0; i++) {', '      g[nodes].add(i);', '    }', '    for (int i = 0; i < c; i++) {', '      g[nodes].add(crossNode+i+1);', '    }', '    for (int i = 1; i <= f0; i++) {', '      g[i].add(nodes);', '    }', '', '    return true;', '  }', '  ', '  @SuppressWarnings(""unchecked"")', '  static boolean solve(int t, int b, int f, int c) {', '    int nodes = t + 1;', '    int maxEdges = nodes * (nodes - 1);', '    if (t + b + f + c > maxEdges', '        || f > maxEdges/2 ', '        || b + c > maxEdges/2) {', '      return false;', '    }', '    g = new List[nodes + 1];', '    for (int i = 1; i < g.length; i++) {', '      g[i] = new ArrayList<>();', '    }', '    if (b + f + c == 0) {', '      for (int i = 1; i < nodes; i++) {', '        g[i].add(i + 1);', '      }', '      return true;', '    }', '    if (c == 0) {', '      if (!left(nodes, f, b)) {', '        return false;', '      }', '      return true;', '    }', '    if (b + f == 0) {', '      if (!right(2, nodes, c)) {', '        return false;', '      }', '      return true;', '    }', '', '    int n = 1;', '    int egges = nodes - n-1;', '    while (egges < c) {', '      n++;', '      egges += nodes - n-1;', '    }', '    int left = nodes - n;', '    int tot = ((left - 1) * (left - 2)) / 2;', '    if (b <= tot && f <= tot) {', '      if (!left(left, f, b)) {', '        return false;', '      }', '  ', '      if (!right(left + 1, nodes, c)) {', '        return false;', '      }', '      return true;', '    }', '    ', '    if (n == 1 && complex1(nodes, t, b, f, c)) {', '      return true;', '    }', '', '    if (left <= 2 && f == 0 && b < nodes) {', '      if (!right(2, nodes, c)) {', '        return false;', '      }', '      for (int i = 2; i <= b+1; i++) {', '        g[i].add(1);', '      }', '      return true;', '    }', '', '    if (complexn(nodes, t, b, f, c)) {', '      return true;', '    }', '', '    return false;', '  }', '', '  public static void main(String[] args) throws Exception {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '', '    int t = Integer.parseInt(st.nextToken());', '    int b = Integer.parseInt(st.nextToken());', '    int f = Integer.parseInt(st.nextToken());', '    int c = Integer.parseInt(st.nextToken());', '', '    if (solve(t, b, f, c)) {', '      bw.write((g.length - 1) + ""\\n"");', '      for (int i = 1; i < g.length; i++) {', '        bw.write(String.valueOf(g[i].size()));', '        for (int x : g[i]) {', '          bw.write("" "" + x);', '        }', '        bw.write(""\\n"");', '      }', '    } else {', '      bw.write(""-1"");', '    }', '', '    bw.newLine();', '', '    bw.close();', '    br.close();', '  }', '', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class DiameterMinimization {', '', ' static int[] stack = new int[1100];', ' static int[] visited = new int[1100];', ' ', ' static int diameter(int[][] g, int b) {', '  for (int i = 0; i < g.length; i++) {', '   visited[i] = -1;', '  }', '  stack[0] = b;', '  visited[b] = 0;', '  int d = 0;', '  int c = 0;', '  int v = 1;', '  while(c < v) {', '   int p = stack[c];   ', '   for (int i = 0; i < g[p].length; i++) {', '    int q = g[p][i];', '    if(visited[q] < 0) {', '     visited[q] = visited[p] + 1;', '     stack[v] = q;', '     v++;', '     if(visited[q] > d) {', '      d = visited[q];', '     }', '    }', '   }', '   c++;', '  }', '  if(v < g.length) throw new RuntimeException(""Visited "" + v + "" out of "" + g.length);', '  return d;', ' }', ' ', ' static int diameter(int[][] g) {', '  int d = 0;', '  for (int i = 0; i < g.length; i++) {', '   int di = diameter(g, i);', '   if(di > d) d = di;', '  }', '  return d;', ' }', ' ', ' static int[][] generateGraph(int n, int m) {', '  int[] b = getK(n,  m);', '  int n1 = n / m;', '  if(n < 10) n1 = n; else {', '   n1 = b[1];', '   if(seed.nextDouble() < 0.5 && n1 * m < n) n1 = n1 * m;', '  }', '  int[][] g = new int[n][m];', '  int l = 1;', '  for (int p = 0; p < n; p++) {', '   int s = 0;', '   for (int i = 0; i < m; i++) {', '    if(l < n) {', '     g[p][i] = l;', '     l++;', '    } else {', '     g[p][i] = s;', '     if(s > 0) g[p][i] = seed.nextInt(n1);', '     if(s + 1 < n) s++;', '    }', '   }', '  }  ', '  return g;', ' }', ' ', ' static int[] getK(int n, int m) {', '  int leaves = n - (n + m - 1) / m;', '  if(m > 1 && n > 10){', '   return new int[]{1, (n - leaves) };', '  }', '  int[] ps = new int[11];', '  ps[0] = 1;', '  int s = 1;', '  int l = 1;', '  int b = 0;', '  int e = 0;', '  while(true) {', '   ps[l] = ps[l-1] * m;', '   if(ps[l] * ps[l] < leaves * (m - 1)) {', '    b = s;', '    e = b + ps[l];', '   }', '   s += ps[l];', '   if(s >= n) {', '    ps[l] = ps[l] - s + n;', '    break;', '   } else {', '    l++;', '   }', '  }', '  return new int[]{b, e};', ' }', ' ', ' static int[][] generateGraph1(int n, int m, int h) {', '  if(h > n / 2) h = n / 2;', '  int[] b = getK(n,  m);', '  int[][] g = new int[n][m];', '  int l = 1;', '  int q = b[0];', '  for (int p = 0; p < n; p++) {', '   int s = 0;', '   for (int i = 0; i < m; i++) {', '    if(l < n) {', '     g[p][i] = l;', '     l++;', '    } else {', '     g[p][i] = s;', '     if(s > 0 || p % h != 0) {', '      g[p][i] = q;', '      q++;', '      if(q == b[1]) q = b[0];', '     } else {', '      if(s + 1 < n) s++;', '     }', '    }', '   }', '  }  ', '  return g;', ' }', ' ', ' static void print(int[][] g, int n, int m) {', '  int d = diameter(g);', '  System.out.println(d);', '  for (int p = 0; p < n; p++) {', '   for (int i = 0; i < m; i++) {', '    if(i > 0) System.out.print("" "");', '    System.out.print(g[p][i]);', '   }', '   System.out.println("""");', '  }  ', ' }', ' ', ' static Random seed = new Random();', ' ', ' static void run() {', '  Scanner in = new Scanner(System.in);', '  int n = in.nextInt();', '  int m = in.nextInt();', '  long t = System.currentTimeMillis();', '  int[][] g = generateGraph(n, m);', '  int d = diameter(g);', '  for (int h = 1; h < n / 3 && h < 30; h++) {', '   try {', '    int[][] gi = generateGraph1(n, m, h);', '    int di = diameter(gi);', '    if(di < d) {', '     g = gi;', '     d = di;', '    }', '    long dt = System.currentTimeMillis() - t;', '    if(dt > 700) break;', '   } catch (Exception e) {', '    break;', '   }', '  }', '  for (int i = 0; i < 5000; i++) {', '   int[][] gi = generateGraph(n, m);', '   int di = diameter(gi);', '   if(di < d) {', '    g = gi;', '    d = di;', '   }', '   long dt = System.currentTimeMillis() - t;', '   if(dt > 1000) break;', '  }', '  print(g, n, m);', ' }', '    public static void main(String[] args) {', '        run();', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '  static Deque<Integer> q = new LinkedList<>();', '', '  static int[] dis = new int[1001];', '', '  static int bfs(int n, int m, int x) {', '    Arrays.fill(dis, 1_000_000_000);', '    dis[x] = 0;', '    q.add(x);', '    int mmh = 0;', '    while (!q.isEmpty()) {', '      int k = q.removeFirst();', '      mmh = dis[k];', '      for (int i = 0; i < m; i++) {', '        int j = (k * m + i) % n;', '        if (dis[j] > mmh + 1) {', '          dis[j] = mmh + 1;', '          q.add(j);', '        }', '      }', '    }', '    return mmh;', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int n = Integer.parseInt(st.nextToken());', '    int m = Integer.parseInt(st.nextToken());', '', '    dis = new int[n];', '    ', '    int mmh = 0;', '    for (int i = 0; i < n; i++) {', '      mmh = Math.max(mmh, bfs(n, m, i));', '    }', '    bw.write(mmh + ""\\n"");', '    for (int i = 0; i < n; i++) {', '      for (int j = 0; j < m; j++) {', '        bw.write((i * m + j) % n + "" "");', '      }', '      bw.write(""\\n"");', '    }', '', '    bw.newLine();', '', '    bw.close();', '    br.close();', '  }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', 'import java.util.Random;', '', 'public class F {', ' InputStream is;', ' PrintWriter out;', ' String INPUT = """";', '// String INPUT = ""1 4 4\\r\\n"" + ', '//   ""-3 1 0 -2 "";', ' ', ' // -2 -2 -1 -1', ' ', ' void solve()', ' {', '  for(int T = ni();T > 0;T--){', '   int n = ni();', '   int d = ni();', '   if(d == 0){', '    for(int i = 0;i < n;i++){', '     ni();', '     out.print(0 + "" "");', '    }', '    out.println();', '    continue;', '   }', '   ', '   Node root = null;', '   int minx = Integer.MAX_VALUE;', '   int maxx = Integer.MIN_VALUE;', '   for(int i = 0;i < n;i++){', '    int x = ni();', '    Node my = new Node(x, 0);', '    minx = Math.min(minx, x);', '    maxx = Math.max(maxx, x);', '    root = insertb(root, my);', '    Node next = next(my);', '    if(next != null){', '     my.v = next.pos - my.pos;', '     propagate(my);', '    }', '    Node prev = prev(my);', '    if(prev != null){', '     prev.v = my.pos - prev.pos;', '     propagate(prev);', '    }', '    ', '    int r = lowerBound(root, minx + d)-1;', '    int l = lowerBound(root, maxx - d + 1)-1;', '//    tr(i);', '//    for(Node no : nodes(root))tr(no.v, no.pos);', '    // -3 -2 0 1', '//    tr(l, r);', '    int ans = Integer.MAX_VALUE;', '    // [0,l] : >=d', '    // [r,last]: >=d', '    ', '    if(r <= l || i == 0){', '     ans = 0;', '    }else{', '     {', '//      Node L = get(root, 0);', '      Node R = get(root, 1);', '      int can = Math.max(d-(R.pos-minx), 0);', '      ans = Math.min(ans, can);', '     }', '     {', '      Node L = get(root, count(root)-2);', '//      Node R = get(root, count(root)-1);', '      int can = Math.max(d-(maxx-L.pos), 0);', '      ans = Math.min(ans, can);', '     }', '     if(l >= 0 && l+1 < count(root)){', '      Node L = get(root, l);', '      Node R = get(root, l+1);', '      int can = Math.max(d-(R.pos-minx), 0) + Math.max(d-(maxx-L.pos), 0);', '      ans = Math.min(ans, can);', '     }', '     if(r >= 0 && r+1 < count(root)){', '      Node L = get(root, r);', '      Node R = get(root, r+1);', '      int can = Math.max(d-(R.pos-minx), 0) + Math.max(d-(maxx-L.pos), 0);', '      ans = Math.min(ans, can);', '     }', '     ans = Math.min(ans, 2*d-(maxx-minx)-max(root, l+1, r));', '    }', '    out.print(ans + "" "");', '   }', '   out.println();', '  }', ' }', ' ', ' public static Node next(Node x)', ' {', '  if(x == null)return null;', '  if(x.right != null){', '   x = x.right;', '   while(x.left != null)x = x.left;', '   return x;', '  }else{', '   while(true){', '    Node p = x.parent;', '    if(p == null)return null;', '    if(p.left == x)return p;', '    x = p;', '   }', '  }', ' }', ' ', ' public static Node prev(Node x)', ' {', '  if(x == null)return null;', '  if(x.left != null){', '   x = x.left;', '   while(x.right != null)x = x.right;', '   return x;', '  }else{', '   while(true){', '    Node p = x.parent;', '    if(p == null)return null;', '    if(p.right == x)return p;', '    x = p;', '   }', '  }', ' }', ' ', ' ', ' public static Random gen = new Random();', ' ', ' static public class Node', ' {', '  public int v; // value', '  public int pos;', '  public long priority;', '  public Node left, right, parent;', '  ', '  public int count;', '  ', '  public int max; ', '  ', '  public Node(int pos, int v)', '  {', '   this.pos = pos;', '   this.v = v;', '   priority = gen.nextLong();', '   update(this);', '  }', '  ', '  @Override', '  public String toString() {', '   StringBuilder builder = new StringBuilder();', '   builder.append(""Node [v="");', '   builder.append(v);', '   builder.append("", count="");', '   builder.append(count);', '   builder.append("", parent="");', '   builder.append(parent != null ? parent.v : ""null"");', '   builder.append("", max="");', '   builder.append(max);', '   builder.append(""]"");', '   return builder.toString();', '  }', ' }', '', ' public static Node update(Node a)', ' {', '  if(a == null)return null;', '  a.count = 1;', '  if(a.left != null)a.count += a.left.count;', '  if(a.right != null)a.count += a.right.count;', '  ', '  a.max = a.v;', '  if(a.left != null)a.max = Math.max(a.left.max, a.max);', '  if(a.right != null)a.max = Math.max(a.right.max, a.max);', '  return a;', ' }', ' ', ' public static Node disconnect(Node a)', ' {', '  if(a == null)return null;', '  a.left = a.right = a.parent = null;', '  return update(a);', ' }', ' ', ' public static Node root(Node x)', ' {', '  if(x == null)return null;', '  while(x.parent != null)x = x.parent;', '  return x;', ' }', ' ', ' public static int count(Node a)', ' {', '  return a == null ? 0 : a.count;', ' }', ' ', ' public static void setParent(Node a, Node par)', ' {', '  if(a != null)a.parent = par;', ' }', ' ', ' public static int max(Node a, int L, int R)', ' {', '  if(a == null || L >= R || L >= count(a) || R <= 0)return -Integer.MAX_VALUE / 3;', '  if(L <= 0 && R >= count(a)){', '   return a.max;', '  }else{', '   int lmax = max(a.left, L, R);', '   int rmax = max(a.right, L-count(a.left)-1, R-count(a.left)-1);', '   int max = Math.max(lmax, rmax);', '   if(L <= count(a.left) && count(a.left) < R)max = Math.max(max, a.v);', '   return max;', '  }', ' }', ' ', ' public static void propagate(Node a)', ' {', '  while(a != null){', '   update(a);', '   a = a.parent;', '  }', ' }', ' ', ' public static Node merge(Node a, Node b)', ' {', '  if(b == null)return a;', '  if(a == null)return b;', '  if(a.priority > b.priority){', '   setParent(a.right, null);', '   setParent(b, null);', '   a.right = merge(a.right, b);', '   setParent(a.right, a);', '   return update(a);', '  }else{', '   setParent(a, null);', '   setParent(b.left, null);', '   b.left = merge(a, b.left);', '   setParent(b.left, b);', '   return update(b);', '  }', ' }', ' ', ' // [0,K),[K,N)', ' public static Node[] split(Node a, int K)', ' {', '  if(a == null)return new Node[]{null, null};', '  if(K <= count(a.left)){', '   setParent(a.left, null);', '   Node[] s = split(a.left, K);', '   a.left = s[1];', '   setParent(a.left, a);', '   s[1] = update(a);', '   return s;', '  }else{', '   setParent(a.right, null);', '   Node[] s = split(a.right, K-count(a.left)-1);', '   a.right = s[0];', '   setParent(a.right, a);', '   s[0] = update(a);', '   return s;', '  }', ' }', ' ', ' public static Node insert(Node a, int K, Node b)', ' {', '  if(a == null)return b;', '  if(b.priority < a.priority){', '   if(K <= count(a.left)){', '    a.left = insert(a.left, K, b);', '    setParent(a.left, a);', '   }else{', '    a.right = insert(a.right, K-count(a.left)-1, b);', '    setParent(a.right, a);', '   }', '   return update(a);', '  }else{', '   Node[] ch = split(a, K);', '   b.left = ch[0]; b.right = ch[1];', '   setParent(b.left, b);', '   setParent(b.right, b);', '   return update(b);', '  }', ' }', ' ', ' // delete K-th', ' public static Node erase(Node a, int K)', ' {', '  if(a == null)return null;', '  if(K < count(a.left)){', '   a.left = erase(a.left, K);', '   setParent(a.left, a);', '   return update(a);', '  }else if(K == count(a.left)){', '   setParent(a.left, null);', '   setParent(a.right, null);', '   Node aa = merge(a.left, a.right);', '   disconnect(a);', '   return aa;', '  }else{', '   a.right = erase(a.right, K-count(a.left)-1);', '   setParent(a.right, a);', '   return update(a);', '  }', ' }', ' ', ' public static Node get(Node a, int K)', ' {', '  while(a != null){', '   if(K < count(a.left)){', '    a = a.left;', '   }else if(K == count(a.left)){', '    break;', '   }else{', '    K = K - count(a.left)-1;', '    a = a.right;', '   }', '  }', '  return a;', ' }', ' ', ' static Node[] Q = new Node[100];', ' public static Node update(Node a, int K, int v)', ' {', '  int p = 0;', '  while(a != null){', '   Q[p++] = a;', '   if(K < count(a.left)){', '    a = a.left;', '   }else if(K == count(a.left)){', '    break;', '   }else{', '    K = K - count(a.left)-1;', '    a = a.right;', '   }', '  }', '  a.v = v;', '  while(p > 0){', '   update(Q[--p]);', '  }', '  return a;', ' }', ' ', ' public static int index(Node a)', ' {', '  if(a == null)return -1;', '  int ind = count(a.left);', '  while(a != null){', '   Node par = a.parent;', '   if(par != null && par.right == a){', '    ind += count(par.left) + 1;', '   }', '   a = par;', '  }', '  return ind;', ' }', ' ', ' public static Node insertb(Node root, Node x)', ' {', '  int ind = lowerBound(root, x.pos);', '  return insert(root, ind, x);', ' }', ' ', ' public static int lowerBound(Node a, int q)', ' {', '  int lcount = 0;', '  while(a != null){', '   if(a.pos >= q){', '    a = a.left;', '   }else{', '    lcount += count(a.left) + 1;', '    a = a.right;', '   }', '  }', '  return lcount;', ' }', '', ' ', ' public static Node[] nodes(Node a) { return nodes(a, new Node[count(a)], 0, count(a)); }', ' public static Node[] nodes(Node a, Node[] ns, int L, int R)', ' {', '  if(a == null)return ns;', '  nodes(a.left, ns, L, L+count(a.left));', '  ns[L+count(a.left)] = a;', '  nodes(a.right, ns, R-count(a.right), R);', '  return ns;', ' }', ' ', ' public static String toString(Node a, String indent)', ' {', '  if(a == null)return """";', '  StringBuilder sb = new StringBuilder();', '  sb.append(toString(a.left, indent + ""  ""));', '  sb.append(indent).append(a).append(""\\n"");', '  sb.append(toString(a.right, indent + ""  ""));', '  return sb.toString();', ' }', ' ', ' void run() throws Exception', ' {', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  long s = System.currentTimeMillis();', '  solve();', '  out.flush();', '  if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', ' }', ' ', ' public static void main(String[] args) throws Exception { new F().run(); }', ' ', ' private byte[] inbuf = new byte[1024];', ' public int lenbuf = 0, ptrbuf = 0;', ' ', ' private int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private double nd() { return Double.parseDouble(ns()); }', ' private char nc() { return (char)skip(); }', ' ', ' private String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    static class Node {', '        int x, rlen;', '        boolean dup;', '        public Node(int xi, int rleni) {', '            x = xi;', '            rlen = rleni;', '            dup = false;', '        }', '    }', '    ', '    static class positionComparator implements Comparator<Node> {', '        @Override', '        public int compare(Node a, Node b) {', '             return a.x - b.x;', '        }', '    }', '    ', '    ', '    static class distanceComparator implements Comparator<Node> {', '        @Override', '        public int compare(Node a, Node b) {   ', '            if (a.rlen != b.rlen)', '                return a.rlen - b.rlen;', '            return a.x - b.x;', '        }', '    }', '    ', '    static TreeSet<Node> xset = null;', '    static TreeSet<Node> dset = null;', '    static Node lo = null, hi = null;', '    ', '    static int eval(int d) {', '        if (xset.isEmpty()) return 0;', '        ', '        int l = hi.x - lo.x;', '        int cost =  2 * d - l;', '        int maxdist = dset.last().rlen;', '        ', '        if (lo.x + d > hi.x) {', '            int dl = 0;', '            if (!lo.dup) {', '                Node rlo = xset.higher(lo);', '                if (rlo != null && rlo.x - lo.x > dl)', '                    dl = rlo.x - lo.x;', '            }', '            int dr = 0;', '            if (!hi.dup) {', '                Node lhi = xset.lower(hi);', '                if (lhi != null && hi.x - lhi.x > dr)', '                    dr = hi.x - lhi.x;', '            }', '                ', '            maxdist = Math.max(d - l + dl, maxdist);', '            maxdist = Math.max(d - l + dr, maxdist);     ', '            return cost - maxdist;', '        }', '        ', '        Node left = xset.first();', '        Node right = xset.last();', '        if (left.x - hi.x + d > maxdist)', '            maxdist = left.x - hi.x + d;', '        if (lo.x + d - right.x > maxdist)', '            maxdist = lo.x + d - right.x;', '        return cost - maxdist;', '    }', '    ', '    // the set only maintain nodes that can not be reached from either hi or lo', '    static void add(int x, int d) {', '        // add an airport located at x', '        Node xnode = new Node(x, 0);', '        if (lo == null) {', '            lo = xnode;', '            hi = xnode;', '            ', '            xset.add(xnode);', '            dset.add(xnode);', '            return;', '            //add node to sets at last --- set below', '        }else if (x == lo.x) {', '            lo.dup = true;', '            return;', '        }else if (x < lo.x) {', '            // update lo, remove nodes on the upper side that can be reached from x', '            if (x + d <= hi.x) {', '                while (!xset.isEmpty()) {', '                    Node tmp = xset.last();', '                    if (tmp.x - x >= d) {', '                        xset.remove(tmp);', '                        dset.remove(tmp);', '                    }else {', '                        dset.remove(tmp);                        ', '                        tmp.rlen = 0;', '                        dset.add(tmp);', '                        break;', '                    }', '                }', '                // since x + d <= hi.x,  x is reachable from hi, no need to add x, return here', '                lo = xnode;', '                return;', '            }', '            ', '            // even after add x, still can not reach hi, need to add x', '            xnode.rlen = lo.x - x;', '            lo = xnode;', '            xset.add(xnode);', '            dset.add(xnode);', '            ', '            return;', '        }else if (x == hi.x) {', '            hi.dup = true;', '            return;', '        }else if (x > hi.x) {', '            if (lo.x + d <= x) {', '                while (!xset.isEmpty()) {', '                    Node tmp = xset.first();', '                    if (tmp.x + d <= x) {', '                        xset.remove(tmp);', '                        dset.remove(tmp);', '                    }else {', '                        break;', '                    }', '                }', '                ', '                // no need to add x, return here', '                hi = xnode;', '                return;', '            }', '            // even after add x, still can not reach lo, need to add x', '            dset.remove(hi);', '            hi.rlen = x - hi.x;', '            dset.add(hi);', '            ', '            xnode.rlen = 0;', '            hi = xnode;', '            xset.add(xnode);', '            dset.add(xnode);', '            return;', '        }else if (lo.x + d <= x || x + d <= hi.x) {', '            // x will not update lo or hi, and x can be reached from lo or hi, so x is useless, just return', '            return;', '        }else if (xset.isEmpty()) {', '            // fall through to add xnode(x, 0, 0)', '            xset.add(xnode);', '            dset.add(xnode);', '            return;', '        }else {', '            Node floor = xset.floor(xnode);', '            if (floor != null && floor.x == x) {                 ', '                floor.dup = true;', '                return;', '            }', '            ', '            Node lower = xset.lower(xnode);', '            Node higher = xset.higher(xnode);', '            if (lower == null) {', '                // higher could not be null', '                xnode.rlen = higher.x - x;', '            }else if (higher == null) {', '                /// lower could not be null', '                dset.remove(lower);', '                lower.rlen = x - lower.x;', '                dset.add(lower);', '                xnode.rlen = 0;', '            }else {', '                xnode.rlen = higher.x - x;', '                dset.remove(lower);', '                lower.rlen = x - lower.x;', '                dset.add(lower);', '            }', '            xset.add(xnode);', '            dset.add(xnode);', '            return;', '        }', '    }', '    ', '    static int[] airports(int d, int[] x) {', '        // Complete this function', '        int n = x.length;', '        int[] ans = new int[n];', '        ', '        if (d == 0) return ans;', '        ', '        xset = new TreeSet<>(new positionComparator());', '        dset = new TreeSet<>(new distanceComparator());', '        lo = null;', '        hi = null;', '        // add the first one, and ans[0] = 0 by definition', '        add(x[0], d);', '        ', '        for (int i = 1; i < n; i++) {', '            add(x[i], d);            ', '            ans[i] = eval(d);', '        }', '        return ans;', '    }', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int q = in.nextInt();', '        for(int a0 = 0; a0 < q; a0++){', '            int n = in.nextInt();', '            int d = in.nextInt();', '            int[] x = new int[n];', '            for(int x_i = 0; x_i < n; x_i++){', '                x[x_i] = in.nextInt();', '            }', '            int[] result = airports(d, x);', '            for (int i = 0; i < result.length; i++) {', '                System.out.print(result[i] + (i != result.length - 1 ? "" "" : """"));', '            }', '            System.out.println("""");', '', '', '        }', '        in.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    static long[] pret;', '    static long[] aftt;', '    public static int x,y;', '    public static void extendgcd(int a,int b){  ', '        if(b==0){  ', '            x=1;  ', '            y=0;  ', '            return;  ', '        }  ', '        extendgcd(b,a%b);  ', '        int temp=x;  ', '        x=y;  ', '        y=temp-a/b*x;  ', '    }', '    static int M=998244353;', '    static HashSet<Integer> gnlp=new HashSet();', '    static HashSet<Integer> glp=new HashSet();', '    static HashMap<Integer,HashMap<Integer,Integer>> hm=new HashMap();', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        int m = in.nextInt();', '        int k = in.nextInt();', '        int[] f = new int[n];', '        for(int f_i=0; f_i < n; f_i++){', '            f[f_i] = in.nextInt();', '        }', '        int[] p = new int[m];', '        for(int p_i=0; p_i < m; p_i++){', '            p[p_i] = in.nextInt();', '        }', '        // your code goes here', '        extendgcd(n,M);', '        pret=new long[n];', '        x=(x+M)%M;', '        int[] vst=new int[n];', '        LinkedList<Integer> tpl=new LinkedList();', '        for(int i=0;i<n;++i) {', '            if(vst[i]==0) topo(i,vst,tpl,f);', '        }', '        vst=new int[n];', '        for(int z:tpl) {', '            if(vst[z]==0) addlist(z,vst,f);', '        }', '        for(int z:gnlp) {', '            pret[z]=x;', '        }', '        while(k-->0) mt(f,p);', '        for(int z:glp) {', '            aftt[z]+=x;', '            aftt[z]%=M;', '        }', '        for(long z:aftt) System.out.println(z);', '    }', '    static void addlist(int sp,int[] vst,int[] f) {', '            int lists=sp;', '            ', '            while(vst[sp]==0){', '                vst[sp]=1;', '                sp=f[sp]-1;', '            }', '            int loops=sp;', '            int t=lists;', '            while(t!=loops) {', '                gnlp.add(t);', '                t=f[t]-1;', '            }', '        if(glp.contains(t)) return;', '            glp.add(t);', '            t=f[t]-1;', '            while(!glp.contains(t)) {', '                glp.add(t);', '                t=f[t]-1;', '            }', '    }', '    static void topo(int cur,int[] vst,LinkedList<Integer> tpl,int[] f) {', '        vst[cur]=1;', '        int next=f[cur]-1;', '        if(vst[next]==0) topo(next,vst,tpl,f);', '        tpl.add(0,cur);', '    }', '    static void prec(int[] f,int[] p,int z){', '        int m=p.length;', '            int cur=z;', '            HashMap<Integer,Integer> mx=new HashMap();', '        hm.put(cur,mx);', '            for(int j=0;j<m;++j) {', '                int next=cur;', '                int curp=p[j];', '                if(j!=0) next=f[cur]-1;', '                if(mx.containsKey(next)) {', '                    mx.put(next,(curp+mx.get(next))%M);', '                } else mx.put(next,curp);', '                cur=next;', '            }', '        ', '    }', '    static void mt(int[] f,int[] p) {', '        aftt=new long[pret.length];', '        int len=gnlp.size();', '        HashSet<Integer> nadd=new HashSet();', '        for(int z:gnlp) {', '            if(!hm.containsKey(z)) prec(f,p,z);', '            HashMap<Integer,Integer> mx=hm.get(z);', '            long curp=pret[z];', '            for(int nz:mx.keySet()) {', '                if(!gnlp.contains(nz)){', '                    nadd.add(nz);', '                }', '                aftt[nz]+=(curp*mx.get(nz))%M;', '                aftt[nz]%=M;', '            }', '        }', '        gnlp.addAll(nadd);', '        pret=aftt;', '    }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    static long[] pret;', '    static long[] aftt;', '    public static int x,y;', '    public static void extendgcd(int a,int b){  ', '        if(b==0){  ', '            x=1;  ', '            y=0;  ', '            return;  ', '        }  ', '        extendgcd(b,a%b);  ', '        int temp=x;  ', '        x=y;  ', '        y=temp-a/b*x;  ', '    }', '    static int M=998244353;', '    static HashSet<Integer> gnlp=new HashSet();', '    static HashSet<Integer> glp=new HashSet();', '    static HashMap<Integer,HashMap<Integer,Integer>> hm=new HashMap();', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        int m = in.nextInt();', '        int k = in.nextInt();', '        int[] f = new int[n];', '        for(int f_i=0; f_i < n; f_i++){', '            f[f_i] = in.nextInt();', '        }', '        int[] p = new int[m];', '        for(int p_i=0; p_i < m; p_i++){', '            p[p_i] = in.nextInt();', '        }', '        // your code goes here', '        extendgcd(n,M);', '        pret=new long[n];', '        x=(x+M)%M;', '        int[] vst=new int[n];', '        LinkedList<Integer> tpl=new LinkedList();', '        for(int i=0;i<n;++i) {', '            if(vst[i]==0) topo(i,vst,tpl,f);', '        }', '        vst=new int[n];', '        for(int z:tpl) {', '            if(vst[z]==0) addlist(z,vst,f);', '        }', '        for(int z:gnlp) {', '            pret[z]=x;', '        }', '        while(k-->0) mt(f,p);', '        for(int z:glp) {', '            aftt[z]+=x;', '            aftt[z]%=M;', '        }', '        for(long z:aftt) System.out.println(z);', '    }', '    static void addlist(int sp,int[] vst,int[] f) {', '            int lists=sp;', '            ', '            while(vst[sp]==0){', '                vst[sp]=1;', '                sp=f[sp]-1;', '            }', '            int loops=sp;', '            int t=lists;', '            while(t!=loops) {', '                gnlp.add(t);', '                t=f[t]-1;', '            }', '        if(glp.contains(t)) return;', '            glp.add(t);', '            t=f[t]-1;', '            while(!glp.contains(t)) {', '                glp.add(t);', '                t=f[t]-1;', '            }', '    }', '    static void topo(int cur,int[] vst,LinkedList<Integer> tpl,int[] f) {', '        vst[cur]=1;', '        int next=f[cur]-1;', '        if(vst[next]==0) topo(next,vst,tpl,f);', '        tpl.add(0,cur);', '    }', '    static void prec(int[] f,int[] p,int z){', '        int m=p.length;', '            int cur=z;', '            HashMap<Integer,Integer> mx=new HashMap();', '        hm.put(cur,mx);', '            for(int j=0;j<m;++j) {', '                int next=cur;', '                int curp=p[j];', '                if(j!=0) next=f[cur]-1;', '                if(mx.containsKey(next)) {', '                    mx.put(next,(curp+mx.get(next))%M);', '                } else mx.put(next,curp);', '                cur=next;', '            }', '        ', '    }', '    static void mt(int[] f,int[] p) {', '        aftt=new long[pret.length];', '        int len=gnlp.size();', '        HashSet<Integer> nadd=new HashSet();', '        for(int z:gnlp) {', '            if(!hm.containsKey(z)) prec(f,p,z);', '            HashMap<Integer,Integer> mx=hm.get(z);', '            long curp=pret[z];', '            for(int nz:mx.keySet()) {', '                if(!gnlp.contains(nz)){', '                    nadd.add(nz);', '                }', '                aftt[nz]+=(curp*mx.get(nz))%M;', '                aftt[nz]%=M;', '            }', '        }', '        gnlp.addAll(nadd);', '        pret=aftt;', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(new BufferedInputStream(System.in));', '        int t = sc.nextInt();', '', '        for (int i = 0; i < t; i++) {', '            int m = sc.nextInt();', '            int n = sc.nextInt();', '            Integer[] yi = new Integer[m-1];', '            Integer[] xi = new Integer[n-1];', '            ', '            for(int j=0;j<m-1;j++){', '                yi[j]= sc.nextInt();', '            }', '            for(int j=0;j<n-1;j++){', '                xi[j]= sc.nextInt();', '            }', '            Arrays.sort(yi,Collections.reverseOrder());', '            Arrays.sort(xi,Collections.reverseOrder());', '            ', '            int ny=1,nx=1;', '            long c=0;', '            ', '            while(ny<m || nx<n) {', '                if(ny<m && (nx>=n || yi[ny-1]>xi[nx-1])) {', '                    c= (c + ((long)nx*(long)yi[ny-1])%1000000007)%1000000007;', '                    ny++;', '                } else if(nx<n && (ny>=m || xi[nx-1]>=yi[ny-1])) {', '                    c= (c + ((long)ny*(long)xi[nx-1])%1000000007)%1000000007;', '                    nx++;', '                }', '            }', '            ', '            System.out.println(c);', '        }', '    }', '}']","['import java.util.*;', '', 'public class Solution {', '    ', '    static int N;', '    static int[] array;', '    static long INF = Long.MAX_VALUE;', '    static long mod = 1000000007;', '    ', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int T = in.nextInt();', '        while(T-- != 0) {', '            int m = in.nextInt();', '            int n = in.nextInt();', '            int[] y = new int[m];', '            int[] x = new int[n];', '            for(int i=1; i<m; i++) y[i] = in.nextInt();', '            for(int i=1; i<n; i++) x[i] = in.nextInt();', '            Arrays.sort(y);', '            Arrays.sort(x);', '            int i = 1;', '            int j = 1;', '            long count = 0;', '            while(i < n || j < m) {', '                long valX = -1;', '                long valY = -1;', '                if(i < n) valX = x[n-i];', '                if(j < m) valY = y[m-j];', '                if(valX > valY) {', '                    count = (count + j*valX)%mod;', '                    i++;', '                } else {', '                    count = (count + i*valY)%mod;', '                    j++;', '                }', '            }', '            System.out.println(count);', '        }', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  char[] s = ns().toCharArray();', '  int n = s.length;', '  for(int p = 0, q = n-1;p < q;p++,q--){', '   char d = s[p]; s[p] = s[q]; s[q] = d;', '  }', '  ', '  int[] f = new int[26];', '  for(int i = 0;i < n;i++){', ""   f[s[i]-'a']++;"", '  }', '  for(int i = 0;i < 26;i++){', '   f[i] /= 2;', '  }', '  ', '  char[] A = new char[n/2];', '  int ap = 0;', '  ', '  int[] rev = Arrays.copyOf(f, 26);', '  boolean[] used = new boolean[n];', '  int start = 0;', '  outer:', '  while(ap < n/2){', '   inner:', '   for(int i = 0;i < 26;i++){', '    int[] h = Arrays.copyOf(f, 26);', '    for(int j = start;j < n && rev[i] > 0;j++){', '     if(used[j])continue;', ""     if(s[j] == 'a'+i){"", '      A[ap++] = s[j];', '      rev[i]--;', '      used[j] = true;', '      start = j+1;', '      f = Arrays.copyOf(h, 26);', '      continue outer;', '     }else{', ""      if(--h[s[j]-'a'] < 0){"", '       continue inner;', '      }', '     }', '    }', '   }', '  }', '  out.println(new String(A));', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '    static public class CharData {', '        int total;', '        int skipped;', '        int taken;', '        boolean hasToTake(){', '            return 2*skipped == total;', '        }', '        boolean hasToSkip(){', '            return 2*taken == total;', '        }', '        void putBack(){', '            taken--;', '            skipped++;', '        }', '    }  ', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        String s = new StringBuilder(in.nextLine()).reverse().toString();', ""        CharData cd[] = new CharData['z' - 'a' + 1];"", '        for(int i=0;i<cd.length;i++){', '            cd[i]=new CharData();', '        }', '        for (int i = 0; i < s.length(); i++) {', ""            cd[s.charAt(i)-'a'].total++;"", '        }', '        char [] r = new char[s.length()/2];', '        int ri=0;', '        for (int i = 0; i < s.length(); i++) {', '            char ch = s.charAt(i);', ""            CharData di = cd[ch-'a'];"", '            if(di.hasToSkip()){', '                di.skipped++;', '            }else {', ""                while(ri>0 && r[ri-1]>ch && !cd[r[ri-1]-'a'].hasToTake()){"", ""                    cd[r[--ri]-'a'].putBack();"", '                }', '                r[ri++]=ch;', '                di.taken++;', '            }', '        }', '        System.out.println(new String(r));', '        in.close();', '    }', '}']"
"['import java.util.Scanner;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '  Scanner in = new Scanner(System.in);', '  int n = in.nextInt();', '  String s = in.nextLine();', '  int[] heights = new int[n];', '  for(int i = 0; i < n; i++) {', '   heights[i] = in.nextInt();', '  }', '  System.out.println(calcMinEnergy(heights));', ' }', '', ' public static long calcMinEnergy(int[] heights) {', '  if(heights.length < 1) return 0;', '  long energy = 0;', '  for(int i = 0; i < heights.length; i++) {', '   long tmp = energy + heights[heights.length - 1 - i];', '   int one = (int)(tmp % 2);', '   energy = tmp / 2 + one;', '  }', '  return energy;', ' }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '    public static void main(String[] args) throws Exception {', '        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */', '        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '        String s;', '        StringTokenizer st;', '        int N=Integer.parseInt(br.readLine().trim());', '        s=br.readLine().trim();', '        st=new StringTokenizer(s);', '        int height[]=new int[N];', '        for(int i=0;i<N;i++)', '        {', '            height[i]=Integer.parseInt(st.nextToken());', '        }', '        int min=0;', '        for(int i=N-1;i>=0;i--)', '        {', '            min= (int) Math.ceil((double)(min+height[i])/2);', '            ', '        }', '        System.out.println(min);', '    }', '}']"
"['import java.util.Arrays;', 'import java.io.BufferedWriter;', 'import java.util.InputMismatchException;', 'import java.io.InputStream;', 'import java.util.NoSuchElementException;', 'import java.io.OutputStreamWriter;', 'import java.math.BigInteger;', 'import java.io.OutputStream;', 'import java.io.PrintWriter;', 'import java.io.Writer;', 'import java.io.IOException;', '', '/**', ' * Built using CHelper plug-in', ' * Actual solution is at the top', ' * @author Egor Kulikov (egor@egork.net)', ' */', 'public class Solution {', ' public static void main(String[] args) {', '  InputStream inputStream = System.in;', '  OutputStream outputStream = System.out;', '  InputReader in = new InputReader(inputStream);', '  OutputWriter out = new OutputWriter(outputStream);', '  SherlockAndMiniMax solver = new SherlockAndMiniMax();', '  solver.solve(1, in, out);', '  out.close();', ' }', '}', '', 'class SherlockAndMiniMax {', '    public void solve(int testNumber, InputReader in, OutputWriter out) {', '  int count = in.readInt();', '  int[] array = IOUtils.readIntArray(in, count);', '  int min = in.readInt();', '  int max = in.readInt();', '  int best = -1;', '  int at = -1;', '  Arrays.sort(array);', '  int candidate = Integer.MAX_VALUE;', '  for (int i : array)', '   candidate = Math.min(candidate, Math.abs(min - i));', '  if (candidate > best || candidate == best && at > min) {', '   at = min;', '   best = candidate;', '  }', '  candidate = Integer.MAX_VALUE;', '  for (int i : array)', '   candidate = Math.min(candidate, Math.abs(max - i));', '  if (candidate > best || candidate == best && at > max) {', '   at = max;', '   best = candidate;', '  }', '  for (int i = 1; i < count; i++) {', '   int current = (array[i] + array[i - 1]) / 2;', '   if (current < min || current > max) {', '    continue;', '   }', '   candidate = current - array[i - 1];', '   if (candidate > best || candidate == best && at > current) {', '    at = current;', '    best = candidate;', '   }', '  }', '  out.printLine(at);', ' }', '}', '', 'class InputReader {', '', ' private InputStream stream;', ' private byte[] buf = new byte[1024];', ' private int curChar;', ' private int numChars;', ' private SpaceCharFilter filter;', '', ' public InputReader(InputStream stream) {', '  this.stream = stream;', ' }', '', ' public int read() {', '  if (numChars == -1)', '   throw new InputMismatchException();', '  if (curChar >= numChars) {', '   curChar = 0;', '   try {', '    numChars = stream.read(buf);', '   } catch (IOException e) {', '    throw new InputMismatchException();', '   }', '   if (numChars <= 0)', '    return -1;', '  }', '  return buf[curChar++];', ' }', '', ' public int readInt() {', '  int c = read();', '  while (isSpaceChar(c))', '   c = read();', '  int sgn = 1;', ""  if (c == '-') {"", '   sgn = -1;', '   c = read();', '  }', '  int res = 0;', '  do {', ""   if (c < '0' || c > '9')"", '    throw new InputMismatchException();', '   res *= 10;', ""   res += c - '0';"", '   c = read();', '  } while (!isSpaceChar(c));', '  return res * sgn;', ' }', '', ' public boolean isSpaceChar(int c) {', '  if (filter != null)', '   return filter.isSpaceChar(c);', '  return isWhitespace(c);', ' }', '', ' public static boolean isWhitespace(int c) {', ""  return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;"", ' }', '', ' public interface SpaceCharFilter {', '  public boolean isSpaceChar(int ch);', ' }', '}', '', 'class OutputWriter {', ' private final PrintWriter writer;', '', ' public OutputWriter(OutputStream outputStream) {', '  writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));', ' }', '', ' public OutputWriter(Writer writer) {', '  this.writer = new PrintWriter(writer);', ' }', '', ' public void close() {', '  writer.close();', ' }', '', ' public void printLine(int i) {', '  writer.println(i);', ' }', '}', '', 'class IOUtils {', '', ' public static int[] readIntArray(InputReader in, int size) {', '  int[] array = new int[size];', '  for (int i = 0; i < size; i++)', '   array[i] = in.readInt();', '  return array;', ' }', '', '}']","['import java.io.*;', 'import java.util.Arrays;', '', '', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        int N;', '        long[] A;', '        long P, Q;', '        BufferedReader bi = new BufferedReader(new InputStreamReader(System.in));', '        N = Integer.parseInt(bi.readLine().trim());', '        A = new long[N];', '        String[] inStr = bi.readLine().trim().split(""\\\\s+"");', '        for(int i=0;i<N;i++) ', '            A[i] = Long.parseLong(inStr[i]);', '        inStr = bi.readLine().trim().split(""\\\\s+"");', '        P = Long.parseLong(inStr[0]);', '        Q = Long.parseLong(inStr[1]);', '        Arrays.sort(A);', '        long maxDist = 0;', '        long maxLoc = Long.MAX_VALUE;', '        if(P <= A[0]) {', '            maxDist = A[0] - P;', '            maxLoc = P;', '        }', '        if(Q >= A[N-1]){', '            if(Q - A[N-1] > maxDist) {', '                maxDist = Q - A[N-1];', '                maxLoc = Q;', '            }', '        }', '        for(int i=0;i<N-1;i++){', '            if(P >= A[i] && P <= A[i+1]) {', '                long minD = Math.min(P - A[i], A[i+1] - P);', '                if (minD > maxDist) {', '                    maxDist = minD;', '                    maxLoc = P;', '                }', '                else if(minD == maxDist)', '                    maxLoc = Math.min(maxLoc, P);', '            }', '            if(Q >= A[i] && Q <= A[i+1]) {', '                long minD = Math.min(Q - A[i], A[i+1] - Q);', '                if (minD > maxDist) {', '                    maxDist = minD;', '                    maxLoc = Q;', '                }', '                else if(minD == maxDist)', '                    maxLoc = Math.min(maxLoc, Q);', '            }', '            long midPt = (A[i+1] + A[i])/2;', '            if(Q >= midPt && P <= midPt) {', '                long minD = Math.min(midPt - A[i], A[i+1] - midPt);', '                if (minD > maxDist) {', '                    maxDist = minD;', '                    maxLoc = midPt;', '                }', '                else if(minD == maxDist)', '                    maxLoc = Math.min(maxLoc, midPt);', '            }', '            if(Q >= (midPt + 1) && P <= (midPt + 1) && (midPt + 1 <= A[i+1])) {', '                long minD = Math.min(midPt + 1 - A[i], A[i+1] - midPt - 1);', '                if (minD > maxDist) {', '                    maxDist = minD;', '                    maxLoc = midPt;', '                }', '                else if(minD == maxDist)', '                    maxLoc = Math.min(maxLoc, midPt + 1);', '            }', '        }', '', '        System.out.println(maxLoc);', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.math.*;', '', 'public class Vic {', '', '     static long Solve(int L, int A, int N, int D) {           ', '', '            if(D<2 || N>L)  // no constraint; use only element A', '              return (long)L*A;', '            else if(A<D || D>N) return -1; // no solution', '            else { ', '             // a solution is always ', '             // bestsum of the best set of L elements where each subset ', '              long bestsum = 0;', '              for(int i = (int)Math.ceil((L-N+1.0)/(A-D+1.0)); i <= (N-1)/(D-1); i++){', '             int used = N-i*(D-2)-1; // number of A; used <= L.', '             long sum = (long)used*A;', '             if(D==2 && used>i){i=used;};//since i has not occurred', '             // the next num values A-1..A-num are taken min times', '             long num = (L-used)/i; //integer division will round down', '             sum += (num*i*(2*A-1-num))/2; ', '             used += num*i;', '             // a last value keeps the rest', '             sum += (L-used)*(A-num-1);', '             if(sum>bestsum) bestsum=sum;', '              }', '              return bestsum;', '            }                                ', '        } //Solve', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int T = in.nextInt();', '        for(int a0 = 0; a0 < T; a0++){', '            int L = in.nextInt();', '            int A = in.nextInt();', '            int N = in.nextInt();', '            int D = in.nextInt();', '            long res = Solve(L,A,N,D);', '            if(res<=0)', '             System.out.println(""SAD"");', '            else', '             System.out.println(res);', '        } // for', '    } //main', '    ', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    ', '    static String acessoryCollection(long L, long A, long N, long D) {', '        long max=0;', '        if(D>N || N>L){', '            return ""SAD"";', '        }else if(D==1){', '            return String.valueOf(A*L);', '        }else{', '            long cmid=(N-1)/(D-1);', '            for(long mid=cmid;mid>=1;mid--){', '                long clarge=N+(mid-1)-((D-1)*mid);', '                long n=(L-clarge)/mid;', '                long csmall=(L-clarge)%mid;', '                if(n>A-1 || (csmall>0 && n==A-1)){', '                    break;', '                }', '', '                long sum=clarge*A+csmall*(A-n-1)+(((A-1+A-n)*(n) *mid)/2);', '                if(sum<max)break;', '                max=sum;', '', '', '            }', '        }', '        if(max==0){', '            return ""SAD"";', '        }else{', '            return String.valueOf(max);', '        }', '', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int T = Integer.parseInt(scanner.nextLine().trim());', '', '        for (int TItr = 0; TItr < T; TItr++) {', '            String[] LAND = scanner.nextLine().split("" "");', '', '            long L = Long.parseLong(LAND[0].trim());', '', '            long A = Long.parseLong(LAND[1].trim());', '', '            long N = Long.parseLong(LAND[2].trim());', '', '            long D = Long.parseLong(LAND[3].trim());', '', '            String result = acessoryCollection(L, A, N, D);', '', '            bufferedWriter.write(result);', '            bufferedWriter.newLine();', '        }', '', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.ArrayDeque;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', 'import java.util.Queue;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  for(int T = ni();T >= 1;T--){', '   int n = ni();', '   int[] a = na(n);', '   if(n == 0){', '    out.println(0);', '    continue;', '   }', '   Arrays.sort(a);', '   Queue<Integer> q = new ArrayDeque<Integer>();', '   int f = 0;', '   int prev = -1999999999;', '   int min = 1999999999;', '   for(int i = 0;i < n;){', '    int j = i;', '    for(;j < n && a[i] == a[j];j++);', '    int cf = j-i;', '    if(prev+1 < a[i]){', '     for(int k = 0;k < f;k++){', '      min = Math.min(min, prev-q.poll()+1);', '     }', '     for(int k = 0;k < cf;k++){', '      q.add(a[i]);', '     }', '    }else{', '     if(cf > f){', '      for(int k = f;k < cf;k++){', '       q.add(a[i]);', '      }', '     }else{', '      for(int k = cf;k < f;k++){', '       min = Math.min(min, a[i]-q.poll());', '      }', '     }', '    }', '    prev = a[i];', '    f = cf;', '    i = j;', '   }', '   for(int k = 0;k < f;k++){', '    min = Math.min(min, prev-q.poll()+1);', '   }', '   out.println(min);', '  }', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '    public static void main(String[] args) throws Exception {', '        Scanner in = new Scanner(System.in);', '        int queries = in.nextInt();', '        while (queries-- > 0) {', '            teams.clear();', '            int count = in.nextInt();', '            int[] arr = new int[count];', '            ArrayList<Integer> list = new ArrayList<>();', '            for (int i = 0; i < count; i++) {', '                arr[i] = in.nextInt();', '                list.add(arr[i]);', '            }', '', '            Collections.sort(list);', '            for (int i : list) {', '                addItem(i);', '            }', '', '            int min = count;', '            for (Team team : teams) {', '                if (min > team.getSize()) {', '                    min = team.getSize();', '                }', '            }', '            System.out.println(min);', '        }', '    }', '', '    static ArrayList<Team> teams = new ArrayList<>();', '', '    private static void addItem(Integer item) {', '        Team sTeam = null;', '        int index = teams.size();', '        while (--index >= 0 && teams.get(index).getHigh() > item - 2) {', '            Team team = teams.get(index);', '            if (team.getHigh() + 1 == item) {', '                if (sTeam == null || sTeam.getSize() > team.getSize()) {', '                    sTeam = team;', '                }', '            }', '        }', '        if (sTeam == null) {', '            sTeam = new Team();', '            sTeam.setLow(item);', '            teams.add(sTeam);', '        }', '        sTeam.setHigh(item);', '    }', '', '    private static class Team {', '        int low;', '        int high;', '', '        public int getLow() {', '            return low;', '        }', '', '        public void setLow(int low) {', '            this.low = low;', '        }', '', '        public int getHigh() {', '            return high;', '        }', '', '        public void setHigh(int high) {', '            this.high = high;', '        }', '', '        public int getSize() {', '            return high - low + 1;', '        }', '', '        public boolean isPresent(Integer item) {', '            if (high >= item && low <= item) {', '                return true;', '            }', '            return false;', '        }', '', '        @Override', '        public String toString() {', '            return ""["" + low + "","" + high + ""]"";', '        }', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', ' public static  long iterations = 0;', ' public static final long MASKLOW =  0x000000000003FFFFL;', ' public static final long MASKMID =  0x0000000FFFFC0000L;', ' public static final long MASKHIGH = 0x0000001000000000L;', ' ', ' public static void fillQueueFromInput(Scanner scan, ArrayDeque<Long> queue, int[] teamSizes, int N, int Q) {', ""        // Read each fighter's attributes"", '        int cmd, op1, op2, strength, team;', '        for (int n=0; n<N; n++) {', '            strength = scan.nextInt();', '            team = scan.nextInt();', '            queue.addLast(pack(strength, team));', '            teamSizes[team]++;', '        }', '', '        // Read all the queries', '        for (int q=0; q<Q; q++) {', '            cmd = scan.nextInt();', '            op1 = scan.nextInt();', '            op2 = scan.nextInt();', '', '            if (cmd == 1) {', '                // Add fighter of strength (op1) to team (op2)', '                queue.addLast(pack(op1, op2));', '                teamSizes[op2]++;', '            } else if (cmd == 2) {', '                // Print winning team; (op1 goes first, vs. op2)', '                queue.addLast(MASKHIGH + pack(op1, op2));', '            }', '        }  ', ' }', ' ', '    public static void main(String[] args) {', '        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */', '     Scanner scan = new Scanner(System.in);', '        int N = scan.nextInt(); // number of fighters', '        int K = scan.nextInt(); // number of teams', '        int Q = scan.nextInt(); // number of queries', '', '     //long startTime = System.nanoTime();', '', '        long queueItem = 0;', '        int op1, op2, strength, team;', '                ', '        // Figure out the optimal size for our data structures', '        // Holds the queries to execute', '        ArrayDeque<Long> queue = new ArrayDeque<Long>(Q+N);        ', '        int[] teamSizes = new int[K+1]; // 1-based indexing', '        int[] teamCompressedSizes = new int[K+1];  // 1-based indexing', '        ', '        fillQueueFromInput(scan, queue, teamSizes, N, Q);', '        // scan.close();', '        //System.out.println(""After Queue Filled: "" + ((System.nanoTime() - startTime) /1000000));', '', '        // Allocate sufficient space & init all teams', '        long[][] teams = new long[K+1][];   // 1-based indexing', '        long[][] teamIndex = new long[K+1][];  // 1-based indexing', '        ', '        for (int k=1; k<=K; k++) {', '            teams[k] = new long[(teamSizes[k] == 0 ? 1 : teamSizes[k])];', '            teamIndex[k] = new long[(teamSizes[k] == 0 ? 1 : teamSizes[k])];', '        }', '', '        //System.out.println(""After Teams Allocated: "" + ((System.nanoTime() - startTime) /1000000));', '', '        // Reset the team sizes to zero', '        teamSizes = new int[K+1];', '        ', '        // Process queue until first (print) is found        ', '        while (!queue.isEmpty()) {', '            queueItem = queue.removeFirst().longValue();', '            if (queueItem >= MASKHIGH) {', '                break;', '            }', '            strength = unpackhigh(queueItem);', '            team = unpacklow(queueItem);', '            teams[team][teamSizes[team]] = strength; ', '            teamSizes[team]++;', '        }', '', '        //System.out.println(""After Queue 1st Processed: "" + ((System.nanoTime() - startTime) /1000000));', '       ', '        // Sort each team by fighter strength (weak to strong)', '        // Also, convert the (teams[]) and (teamSizes[]) arrays to a compressed format after sorting.', '        for (int k=1; k<=K; k++) {', '         if (teamSizes[k] > 0) {', '             Arrays.sort(teams[k], 0, teamSizes[k]);', '             // Step thru the array and count the number of duplicate values', '             int searchPos = 1;', '             int storePos = -1;', '             int maxSearchPos = teamSizes[k];', '             int indexPos = 1;', '             int prevValue = (int) teams[k][0];', '             int repeatCount = 1;', '             teamIndex[k][0] = pack(storePos+1, repeatCount);', '             while (searchPos < maxSearchPos) {', '              if (teams[k][searchPos] == prevValue) {', '               repeatCount++;', '                  teamIndex[k][indexPos++] = pack(storePos+1, repeatCount);', '              } else {', '               // Save the compressed version', '               storePos++;', '               teams[k][storePos] = pack(prevValue, repeatCount);', '               repeatCount = 1;', '               prevValue = (int) teams[k][searchPos];', '                  teamIndex[k][indexPos++] = pack(storePos+1, repeatCount);', '              }', '              searchPos++;', '             }', '             // Save the compressed version', '       storePos++;', '             teams[k][storePos] = pack(prevValue, repeatCount);', '       // Save the compressed version of (teamSizes)', '       teamCompressedSizes[k] = storePos;', '         } else {', '          teams[k][0] = 0; // Empty team', '          teamIndex[k][0] = 0;', '         }', '        }', '', '        //System.out.println(""After Sort/Compress: "" + ((System.nanoTime() - startTime) /1000000));', '        ', '        StringBuilder sb = new StringBuilder(Q * 4);', '        ', '        // process queries (continue with previously read queueItem)', '        while (true) {            ', '            if (queueItem >= MASKHIGH) {', '                // Print winning team (op1 goes first, vs. op2)', '                queueItem -= MASKHIGH;', '                op1 = unpackhigh(queueItem);', '                op2 = unpacklow(queueItem);', '                //int expectedWinner = scan.nextInt();', '                int winner = determineWinner(teams, teamIndex, teamSizes, teamCompressedSizes, op1, op2);', '                //if (winner != expectedWinner) {', '                // System.out.println(""ERROR: "" + expectedWinner + "" should have won."");', '                //}', '', '                sb.append(winner);', '                sb.append(""\\n"");', '            } else {', '                // Add fighter of strength (op1) to team (op2)', '                // (op1) is guaranteed to be >= strongest fighter', '                strength = unpackhigh(queueItem);', '                team = unpacklow(queueItem);', '                int compSize = teamCompressedSizes[team];', '                int repValue = unpackhigh(teams[team][compSize]);', '                int repCount = unpacklow(teams[team][compSize]);', '                if (strength == repValue) {', '                 // if this value already exists, just increment its repeat count', '                 teams[team][compSize]++;', '                 teamIndex[team][teamSizes[team]++] = pack(compSize, repCount + 1);', '                } else {', ""                 // value doesn't exist. We need to store it in next location"", '                 // Handle case where no one is on this team yet. (repCount ==0 and repValue == 0)', '                 if (repValue != 0) {', '                        teamCompressedSizes[team]++;', '                        compSize++;', '                 }', '                 teams[team][compSize] = pack(strength, 1);', '                 teamIndex[team][teamSizes[team]++] = pack(compSize, 1);', '                }', '            }', '            if (queue.isEmpty()) {', '                break;', '            }', '            queueItem = queue.removeFirst().longValue();', '        }', '        System.out.println(sb);', '        //System.out.println(""End: "" + ((System.nanoTime() - startTime) /1000000));', '', '        //System.out.println(""Iterations = "" + iterations);', '    }', '    ', '    public static int determineWinner(long[][] teams, long[][] teamIndex, int[] teamSizes, int[] compressedSizes, int firstTeam, int secondTeam) {', '        // teamX always goes first', '        long[] teamX = teams[firstTeam];', '        long[] teamY = teams[secondTeam];', '        long[] teamXIndex = teamIndex[firstTeam];', '        long[] teamYIndex = teamIndex[secondTeam];', '        ', '        // Track which living fighter is strongest on each team', '        int onX = teamSizes[firstTeam] - 1; ', '        int onY = teamSizes[secondTeam] - 1;  ', '        int onXcomp = compressedSizes[firstTeam];', '        int onYcomp = compressedSizes[secondTeam];', '        ', '        int onXstrength = unpackhigh(teamX[onXcomp]);', '        int onXrepeat = unpacklow(teamX[onXcomp]);', '        int onYstrength = unpackhigh(teamY[onYcomp]);', '        int onYrepeat = unpacklow(teamY[onYcomp]);', '        ', '        // Fight', '        while (true) {', '         iterations++;', '', '         // Since the list of strengths is sorted, when we reach strengths of 1', '         // on both teams, we can just calculate the winner in some', '         // decisive cases.', '         int reductionCount = min(((onYrepeat-1) / onXstrength), ((onXrepeat-1) / onYstrength));', '         if (reductionCount > 0) {', '          onXrepeat -= (onYstrength * reductionCount);', '          onYrepeat -= (onXstrength * reductionCount);', '           onX -= (onYstrength * reductionCount);', '          onY -= (onXstrength * reductionCount);', '            }', '         ', '         ', ""         // teamX's strongest fighter kills strongest opponents"", '         onY -= onXstrength;', '         if (onY < 0) {', '          return firstTeam;', '         }', '         onYcomp = unpackhigh(teamYIndex[onY]);', '         onYrepeat = unpacklow(teamYIndex[onY]);', '         onYstrength = unpackhigh(teamY[onYcomp]);', '                        ', '         reductionCount = min(((onYrepeat-1) / onXstrength), ((onXrepeat-1) / onYstrength));', '         if (reductionCount > 0) {', '          onXrepeat -= (onYstrength * reductionCount);', '          onYrepeat -= (onXstrength * reductionCount);', '           onX -= (onYstrength * reductionCount);', '          onY -= (onXstrength * reductionCount);', '            }', '', ""         // teamY's strongest fighter kills"", '         onX -= onYstrength;', '         if (onX < 0) {', '          return secondTeam;', '         }', '         onXcomp = unpackhigh(teamXIndex[onX]);', '         onXrepeat = unpacklow(teamXIndex[onX]);', '         onXstrength = unpackhigh(teamX[onXcomp]);', '        }', '    }', '    ', '    public static final int min(int a, int b) {', '     return (a<b ? a: b);', '    }', '    public static final long pack(int a, int b) {', '     return ((long)a << 18) + (long)b;', '    }', '    public static final int unpacklow(long l) {', '     return (int)(l & MASKLOW);', '    }', '    public static final int unpackhigh(long l) {', '     return (int)(l >> 18);', '    }', '    ', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static  long iterations = 0;', '    public static final long MASKLOW =  0x000000000003FFFFL;', '    public static final long MASKMID =  0x0000000FFFFC0000L;', '    public static final long MASKHIGH = 0x0000001000000000L;', '    ', '    public static void fillQueueFromInput(Scanner scan, ArrayDeque<Long> queue, int[] teamSizes, int N, int Q) {', ""        // Read each fighter's attributes"", '        int cmd, op1, op2, strength, team;', '        for (int n=0; n<N; n++) {', '            strength = scan.nextInt();', '            team = scan.nextInt();', '            queue.addLast(pack(strength, team));', '            teamSizes[team]++;', '        }', '', '        // Read all the queries', '        for (int q=0; q<Q; q++) {', '            cmd = scan.nextInt();', '            op1 = scan.nextInt();', '            op2 = scan.nextInt();', '', '            if (cmd == 1) {', '                // Add fighter of strength (op1) to team (op2)', '                queue.addLast(pack(op1, op2));', '                teamSizes[op2]++;', '            } else if (cmd == 2) {', '                // Print winning team; (op1 goes first, vs. op2)', '                queue.addLast(MASKHIGH + pack(op1, op2));', '            }', '        }        ', '    }', '    ', '    public static void main(String[] args) {', '        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */', '        Scanner scan = new Scanner(System.in);', '        int N = scan.nextInt(); // number of fighters', '        int K = scan.nextInt(); // number of teams', '        int Q = scan.nextInt(); // number of queries', '', '        //long startTime = System.nanoTime();', '', '        long queueItem = 0;', '        int op1, op2, strength, team;', '                ', '        // Figure out the optimal size for our data structures', '        // Holds the queries to execute', '        ArrayDeque<Long> queue = new ArrayDeque<Long>(Q+N);        ', '        int[] teamSizes = new int[K+1]; // 1-based indexing', '        int[] teamCompressedSizes = new int[K+1];  // 1-based indexing', '        ', '        fillQueueFromInput(scan, queue, teamSizes, N, Q);', '        // scan.close();', '        //System.out.println(""After Queue Filled: "" + ((System.nanoTime() - startTime) /1000000));', '', '        // Allocate sufficient space & init all teams', '        long[][] teams = new long[K+1][];   // 1-based indexing', '        long[][] teamIndex = new long[K+1][];  // 1-based indexing', '        ', '        for (int k=1; k<=K; k++) {', '            teams[k] = new long[(teamSizes[k] == 0 ? 1 : teamSizes[k])];', '            teamIndex[k] = new long[(teamSizes[k] == 0 ? 1 : teamSizes[k])];', '        }', '', '        //System.out.println(""After Teams Allocated: "" + ((System.nanoTime() - startTime) /1000000));', '', '        // Reset the team sizes to zero', '        teamSizes = new int[K+1];', '        ', '        // Process queue until first (print) is found        ', '        while (!queue.isEmpty()) {', '            queueItem = queue.removeFirst().longValue();', '            if (queueItem >= MASKHIGH) {', '                break;', '            }', '            strength = unpackhigh(queueItem);', '            team = unpacklow(queueItem);', '            teams[team][teamSizes[team]] = strength; ', '            teamSizes[team]++;', '        }', '', '        //System.out.println(""After Queue 1st Processed: "" + ((System.nanoTime() - startTime) /1000000));', '       ', '        // Sort each team by fighter strength (weak to strong)', '        // Also, convert the (teams[]) and (teamSizes[]) arrays to a compressed format after sorting.', '        for (int k=1; k<=K; k++) {', '            if (teamSizes[k] > 0) {', '                Arrays.sort(teams[k], 0, teamSizes[k]);', '                // Step thru the array and count the number of duplicate values', '                int searchPos = 1;', '                int storePos = -1;', '                int maxSearchPos = teamSizes[k];', '                int indexPos = 1;', '                int prevValue = (int) teams[k][0];', '                int repeatCount = 1;', '                teamIndex[k][0] = pack(storePos+1, repeatCount);', '                while (searchPos < maxSearchPos) {', '                    if (teams[k][searchPos] == prevValue) {', '                        repeatCount++;', '                        teamIndex[k][indexPos++] = pack(storePos+1, repeatCount);', '                    } else {', '                        // Save the compressed version', '                        storePos++;', '                        teams[k][storePos] = pack(prevValue, repeatCount);', '                        repeatCount = 1;', '                        prevValue = (int) teams[k][searchPos];', '                        teamIndex[k][indexPos++] = pack(storePos+1, repeatCount);', '                    }', '                    searchPos++;', '                }', '                // Save the compressed version', '                storePos++;', '                teams[k][storePos] = pack(prevValue, repeatCount);', '                // Save the compressed version of (teamSizes)', '                teamCompressedSizes[k] = storePos;', '            } else {', '                teams[k][0] = 0;    // Empty team', '                teamIndex[k][0] = 0;', '            }', '        }', '', '        //System.out.println(""After Sort/Compress: "" + ((System.nanoTime() - startTime) /1000000));', '        ', '        StringBuilder sb = new StringBuilder(Q * 4);', '        ', '        // process queries (continue with previously read queueItem)', '        while (true) {            ', '            if (queueItem >= MASKHIGH) {', '                // Print winning team (op1 goes first, vs. op2)', '                queueItem -= MASKHIGH;', '                op1 = unpackhigh(queueItem);', '                op2 = unpacklow(queueItem);', '                //int expectedWinner = scan.nextInt();', '                int winner = determineWinner(teams, teamIndex, teamSizes, teamCompressedSizes, op1, op2);', '                //if (winner != expectedWinner) {', '                //    System.out.println(""ERROR: "" + expectedWinner + "" should have won."");', '                //}', '', '                sb.append(winner);', '                sb.append(""\\n"");', '            } else {', '                // Add fighter of strength (op1) to team (op2)', '                // (op1) is guaranteed to be >= strongest fighter', '                strength = unpackhigh(queueItem);', '                team = unpacklow(queueItem);', '                int compSize = teamCompressedSizes[team];', '                int repValue = unpackhigh(teams[team][compSize]);', '                int repCount = unpacklow(teams[team][compSize]);', '                if (strength == repValue) {', '                    // if this value already exists, just increment its repeat count', '                    teams[team][compSize]++;', '                    teamIndex[team][teamSizes[team]++] = pack(compSize, repCount + 1);', '                } else {', ""                    // value doesn't exist. We need to store it in next location"", '                    // Handle case where no one is on this team yet. (repCount ==0 and repValue == 0)', '                    if (repValue != 0) {', '                        teamCompressedSizes[team]++;', '                        compSize++;', '                    }', '                    teams[team][compSize] = pack(strength, 1);', '                    teamIndex[team][teamSizes[team]++] = pack(compSize, 1);', '                }', '            }', '            if (queue.isEmpty()) {', '                break;', '            }', '            queueItem = queue.removeFirst().longValue();', '        }', '        System.out.println(sb);', '        //System.out.println(""End: "" + ((System.nanoTime() - startTime) /1000000));', '', '        //System.out.println(""Iterations = "" + iterations);', '    }', '    ', '    public static int determineWinner(long[][] teams, long[][] teamIndex, int[] teamSizes, int[] compressedSizes, int firstTeam, int secondTeam) {', '        // teamX always goes first', '        long[] teamX = teams[firstTeam];', '        long[] teamY = teams[secondTeam];', '        long[] teamXIndex = teamIndex[firstTeam];', '        long[] teamYIndex = teamIndex[secondTeam];', '        ', '        // Track which living fighter is strongest on each team', '        int onX = teamSizes[firstTeam] - 1; ', '        int onY = teamSizes[secondTeam] - 1;  ', '        int onXcomp = compressedSizes[firstTeam];', '        int onYcomp = compressedSizes[secondTeam];', '        ', '        int onXstrength = unpackhigh(teamX[onXcomp]);', '        int onXrepeat = unpacklow(teamX[onXcomp]);', '        int onYstrength = unpackhigh(teamY[onYcomp]);', '        int onYrepeat = unpacklow(teamY[onYcomp]);', '        ', '        // Fight', '        while (true) {', '            iterations++;', '', '            // Since the list of strengths is sorted, when we reach strengths of 1', '            // on both teams, we can just calculate the winner in some', '            // decisive cases.', '            int reductionCount = min(((onYrepeat-1) / onXstrength), ((onXrepeat-1) / onYstrength));', '            if (reductionCount > 0) {', '                onXrepeat -= (onYstrength * reductionCount);', '                onYrepeat -= (onXstrength * reductionCount);', '                 onX -= (onYstrength * reductionCount);', '                onY -= (onXstrength * reductionCount);', '               }', '            ', '            ', ""            // teamX's strongest fighter kills strongest opponents"", '            onY -= onXstrength;', '            if (onY < 0) {', '                return firstTeam;', '            }', '            onYcomp = unpackhigh(teamYIndex[onY]);', '            onYrepeat = unpacklow(teamYIndex[onY]);', '            onYstrength = unpackhigh(teamY[onYcomp]);', '                        ', '            reductionCount = min(((onYrepeat-1) / onXstrength), ((onXrepeat-1) / onYstrength));', '            if (reductionCount > 0) {', '                onXrepeat -= (onYstrength * reductionCount);', '                onYrepeat -= (onXstrength * reductionCount);', '                 onX -= (onYstrength * reductionCount);', '                onY -= (onXstrength * reductionCount);', '               }', '', ""            // teamY's strongest fighter kills"", '            onX -= onYstrength;', '            if (onX < 0) {', '                return secondTeam;', '            }', '            onXcomp = unpackhigh(teamXIndex[onX]);', '            onXrepeat = unpacklow(teamXIndex[onX]);', '            onXstrength = unpackhigh(teamX[onXcomp]);', '        }', '    }', '    ', '    public static final int min(int a, int b) {', '        return (a<b ? a: b);', '    }', '    public static final long pack(int a, int b) {', '        return ((long)a << 18) + (long)b;', '    }', '    public static final int unpacklow(long l) {', '        return (int)(l & MASKLOW);', '    }', '    public static final int unpackhigh(long l) {', '        return (int)(l >> 18);', '    }', '    ', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '', '    public static int[] readIntArray3(Scanner in, int size) {', '        int[] arr = new int[size];', '        for (int i = 0; i < size; i++) {', '            arr[i] = in.nextInt();', '        }', '        return arr;', '    }', '', '', '', '    public static void main(String[] args) throws Exception {', '        Scanner in = new Scanner(System.in);', '        int cases = 1;//in.nextInt();', '        for (int testcase = 0; testcase < cases; testcase++) {', '            int[] arr = readIntArray3(in, 26);', '            kmpproblem(arr);', '        }', '    }', '', '    public static void kmpproblem(int[] arr) {', '        int least = Integer.MAX_VALUE;', '        int leastIndex = -1;', '        int smallestIndex = -1;', '        for (int i = 0; i < 26; i++) {', '            if (arr[i] < least && arr[i] > 0) {', '                least = arr[i];', '                leastIndex = i;', '            }', '            if (smallestIndex == -1 && arr[i] > 0) {', '                smallestIndex = i;', '            }', '        }', '//        System.out.println(leastIndex + "": "" + least);', '//        System.out.println(smallestIndex);', '        if (leastIndex == -1)  {', '            System.out.println("""");', '            return;', '        }', '        if (smallestIndex != leastIndex) {', ""            System.out.print((char)(leastIndex+'a'));"", '            arr[leastIndex]--;', '            for (int i = 0; i < 26; i++) {', '                for (int j = 0; j < arr[i]; j++) {', ""                    System.out.print((char)(i+'a'));"", '                }', '            }', '            return;', '        }', ""        System.out.print((char)(leastIndex+'a'));"", '        arr[leastIndex]--;', '        for (int i = leastIndex+1; i < 26; i++) {', '            for (int j = 0; j < arr[i]; j++) {', '                if (arr[leastIndex] > 0) {', ""                    System.out.print((char)(leastIndex+'a'));"", '                    arr[leastIndex]--;', '                }', ""                System.out.print((char)(i+'a'));"", '            }', '        }', '        while (arr[leastIndex] > 0) {', ""            System.out.print((char)(leastIndex+'a'));"", '            arr[leastIndex]--;', '        }', '', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', '', 'public class KMP {', '    public static void main(String[] args) {', ""        char ch='a',ch1;"", '        String s1="""";', '        int ar[]=new int [26];', '        int min=99999999,loc=0;', '        int loc2=0;', '        Scanner in=new Scanner(System.in);', '        int k=0;', '        for(int i=0;i<26;i++){', '            ar[i]=in.nextInt();', '            if(ar[i]<min && ar[i]!=0){', '               min=ar[i];loc=i;', '            }', '            if(ar[i]!=0){', '                k++;', '                if(k==2) {', '                    loc2 = i;', '                }', '            }', '        }', '        ch1=(char)(97+loc);', '        ar[loc]=ar[loc]-1;', '        s1=s1+Character.toString(ch1);', '        if(ar[loc]<ar[loc2]) {', '            ch1 = (char) (97 + loc);', '            char ch2 = (char) (97 + loc2);', '            int len1 = ar[loc];', '            if(ch1<ch2) {', '                s1 = s1 + new String(new char[len1]).replace(""\\0"", Character.toString(ch1) + Character.toString(ch2));', '                ar[loc2] = ar[loc2] - len1;', '                ar[loc] = ar[loc] - len1;', '            }', '        }', '', '        for(int i=0;i<26;i++){', '            String s=new String(new char[ar[i]]).replace(""\\0"",Character.toString(ch));', '            s1=s1+s;', '            ++ch;', '        }', '        System.out.println(s1);', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(System.in);', '        int n = sc.nextInt();', '        int max = n/3*2;', '        if (n%3==2)', '            max++;', '        int sn = n;', '        if (n%3==1)', '            sn--;', '        System.out.println(max+1);', '        int first = max;', '        for (int i = (max+1)/2; i >= 0; i--) {', '            System.out.println(first+"" ""+i+"" ""+(n-i-first));', '            first--;', '        }', '        for (int i = sn-first-1; first >= 0; i--) {', '            System.out.println(first+"" ""+i+"" ""+(n-i-first));', '            first--;', '        }', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '        Scanner sc = new Scanner(System.in);', '        int n = sc.nextInt();', '        int max = n/3*2;', '        if (n%3==2) {', '            max++;', '        }', '        bw.write(String.valueOf(max+1));', '        bw.newLine();', '        int first = max;', '        for (int i = (max+1)/2; i >= 0; i--) {', '            bw.write(String.valueOf(first+"" ""+i+"" ""+(n-i-first)));', '            bw.newLine();', '            first--;', '        }', '        int sn = n;', '        if (n%3==1) {', '            sn--;', '        }', '        for (int i = sn-first-1; first >= 0; i--) {', '            bw.write(String.valueOf(first+"" ""+i+"" ""+(n-i-first)));', '            bw.newLine();', '            first--;', '        }', '        bw.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));', '        int n = sc.nextInt();', '        int faken = 1;', '        int d = 1;', '        while (faken < n) {', '            faken <<= 1;', '            d++;', '        }', '        sc.nextLine();', '        String[] nums = sc.nextLine().split("" "");', '        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();', '        for (int i = 0; i < 2*n-1; i++) {', '            int j = Integer.parseInt(nums[i]);', '            if (!hm.containsKey(j))', '                hm.put(j, 0);', '            hm.put(j, hm.get(j)+1);', '        }', '        ArrayList<TreeSet<Integer>> tms = new ArrayList<TreeSet<Integer>>();', '        for (int i = 0; i <= d; i++)', '            tms.add(new TreeSet<Integer>());', '        for (int j : hm.keySet()) {', '            if (hm.get(j) > d) {', '                System.out.println(""NO"");', '                return;', '            }', '            tms.get(hm.get(j)).add(j);', '        }', '        int arrind = 0;', '        int[] tree = new int[2*n-1];', '        int expectation = 1;', '        for (int i = 0; i < d; i++) {', '            if (tms.get(d-i).size()!=expectation) {', '                System.out.println(""NO"");', '                return;', '            }', '            for (int j = 0; j < expectation; j++) {', '                Integer value;', '                if (i==0) {', '                    value = tms.get(d-i).first();', '                } else {', '                    value = tms.get(d-i).ceiling(tree[arrind-1]);', '                }', '                if (value == null) {', '                    System.out.println(""NO"");', '                    return;', '                }', '                tms.get(d-i).remove(value);', '                int val = value;', '                int temparrind = arrind;', '                for (int k = 0; k < d-i; k++) {', '                    tree[temparrind] = val;', '                    temparrind = temparrind*2+1;', '                }', '                arrind += 2;', '            }', '            if (i > 0)', '                expectation *= 2;', '        }', '        boolean valid = true;', '        for (int i = 0; i < n-1; i++) {', '            if (arrind<2*n-1||tree[i]!=tree[2*i+1]||tree[2*i+1]>=tree[2*i+2]) {', '                valid = false;', '                break;', '            }', '        }', '        if (valid) {', '            System.out.println(""YES"");', '            StringBuilder ans = new StringBuilder();', '            String space = """";', '            for (int i = 0; i < 2*n-1; i++) {', '                ans.append(space+tree[i]);', '                space = "" "";', '            }', '            System.out.println(ans);', '        } else {', '            System.out.println(""NO"");', '        }', '    }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));', '        int n = sc.nextInt();', '        int faken = 1;', '        int d = 1;', '        while (faken < n) {', '            faken <<= 1;', '            d++;', '        }', '        sc.nextLine();', '        String[] nums = sc.nextLine().split("" "");', '        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();', '        for (int i = 0; i < 2*n-1; i++) {', '            int j = Integer.parseInt(nums[i]);', '            if (!hm.containsKey(j))', '                hm.put(j, 0);', '            hm.put(j, hm.get(j)+1);', '        }', '        ArrayList<TreeSet<Integer>> tms = new ArrayList<TreeSet<Integer>>();', '        for (int i = 0; i <= d; i++)', '            tms.add(new TreeSet<Integer>());', '        for (int j : hm.keySet()) {', '            if (hm.get(j) > d) {', '                System.out.println(""NO"");', '                return;', '            }', '            tms.get(hm.get(j)).add(j);', '        }', '        int arrind = 0;', '        int[] tree = new int[2*n-1];', '        int expectation = 1;', '        for (int i = 0; i < d; i++) {', '            if (tms.get(d-i).size()!=expectation) {', '                System.out.println(""NO"");', '                return;', '            }', '            for (int j = 0; j < expectation; j++) {', '                Integer value;', '                if (i==0) {', '                    value = tms.get(d-i).first();', '                } else {', '                    value = tms.get(d-i).ceiling(tree[arrind-1]);', '                }', '                if (value == null) {', '                    System.out.println(""NO"");', '                    return;', '                }', '                tms.get(d-i).remove(value);', '                int val = value;', '                int temparrind = arrind;', '                for (int k = 0; k < d-i; k++) {', '                    tree[temparrind] = val;', '                    temparrind = temparrind*2+1;', '                }', '                arrind += 2;', '            }', '            if (i > 0)', '                expectation *= 2;', '        }', '        boolean valid = true;', '        for (int i = 0; i < n-1; i++) {', '            if (arrind<2*n-1||tree[i]!=tree[2*i+1]||tree[2*i+1]>=tree[2*i+2]) {', '                valid = false;', '                break;', '            }', '        }', '        if (valid) {', '            System.out.println(""YES"");', '            StringBuilder ans = new StringBuilder();', '            String space = """";', '            for (int i = 0; i < 2*n-1; i++) {', '                ans.append(space+tree[i]);', '                space = "" "";', '            }', '            System.out.println(ans);', '        } else {', '            System.out.println(""NO"");', '        }', '    }', '}']"
"['import java.io.BufferedReader;', 'import java.io.BufferedWriter;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.io.OutputStreamWriter;', 'import java.io.PrintWriter;', 'import java.util.ArrayList;', 'import java.util.Arrays;', 'import java.util.HashMap;', 'import java.util.HashSet;', 'import java.util.Iterator;', 'import java.util.List;', 'import java.util.Map;', 'import java.util.Map.Entry;', 'import java.util.Set;', 'import java.util.Stack;', 'import java.util.StringTokenizer;', 'import java.util.TreeMap;', 'import java.util.TreeSet;', 'import java.util.Vector;', 'import java.util.regex.Matcher;', 'import java.util.regex.Pattern;', '', '', '', 'public class CS9E {', '', '    static StringTokenizer st;', '    static BufferedReader br;', '    static PrintWriter pw;', '', '    static class Sort implements Comparable<Sort> {', '        int ind, a;', '', '        @Override', '        public int compareTo(Sort o) {', '            return a - o.a;', '        }', '        public Sort(int i, int an) {', '            ind = i;', '            a = an;', '        }', '    }', '', '    public static void main(String[] args) throws IOException {', '        br = new BufferedReader(new InputStreamReader(System.in));', '        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));', '        solve();', '        pw.close();', '    }', '', '    static int n;', '    static int[] a;', '    static int g = 0, m = 1, count;', '    private static void solve() throws IOException {', '        n = nextInt();', '        a = new int [n];', '        count = n;', '        for (int i = 0; i < n; ++i)', '            a[i] = nextInt();', '        if (n <= 2000) {', '            minHandle();', '            return;', '        }', '        while (n >= 1 && a[n - 1] <= 0) --n;', '        sum = new int [n + 1];', '        ms = new int [n + 1];', '        for (int i = 1; i <= n; ++i) {', '            sum[i] = sum[i - 1] + a[i - 1];', '            ms[i] = Math.min(sum[i], ms[i - 1]);', '        }', '        maxHandle();', '    }', '    static int[] sum, ms; ', '    static final int MAXA = 40;', '    private static void maxHandle() {', '        int[] maxa = new int [MAXA + 1];', '        int minsum = 0, tt = 0;', '        for (int i = 0; i < n - 1; ++i) {', '            if (a[i] > 0 && ms[i] == sum[i])', '                tt = i;', '            if (a[i] > 0 && i - tt <= MAXA + 1) {', '                int s = 0;', '                Arrays.fill(maxa, 0);', '                for (int j = i; j < n; ++j) {', '                    s += a[j];', '                    if (s <= 0)', '                        break;', '                    if (a[j] > 0 && maxa[a[j] - 1] + a[j] >= maxa[a[j]]) {', '                        maxa[a[j]] = maxa[a[j] - 1] + a[j];', '                        for (int k = a[j] + 1; k <= MAXA; ++k)', '                            if (maxa[k - 1] > maxa[k])', '                                maxa[k] = maxa[k - 1];', '                            else', '                                break;', '                    }', '                    if (s - maxa[MAXA] > g) {', '                        g = s - maxa[MAXA];', '                        count = 1;', '                        m = j - i + 1;', '                    } else if (s - maxa[MAXA] == g && g != 0) {', '                        if (m == j - i + 1) ', '                            ++count;', '                        else if (j - i + 1 < m) {', '                            count = 1;', '                            m = j - i + 1;', '                        }', '                    }', '                }', '            }', '        }', '        pw.println(g + "" "" + count);', '    }', '', '    private static void minHandle() {', '        int[] maxa = new int [MAXA + 1];', '        for (int i = 0; i < n - 1; ++i)', '            if (a[i] > 0) {', '                int sum = 0;', '                Arrays.fill(maxa, 0);', '                for (int j = i; j < n; ++j) {', '                    sum += a[j];', '                    if (a[j] > 0 && maxa[a[j] - 1] + a[j] >= maxa[a[j]]) {', '                        maxa[a[j]] = maxa[a[j] - 1] + a[j];', '                        for (int k = a[j] + 1; k <= MAXA; ++k)', '                            if (maxa[k - 1] > maxa[k])', '                                maxa[k] = maxa[k - 1];', '                            else', '                                break;', '                    }', '                    if (sum - maxa[MAXA] > g) {', '                        g = sum - maxa[MAXA];', '                        count = 1;', '                        m = j - i + 1;', '                    } else if (sum - maxa[MAXA] == g && g != 0) {', '                        if (m == j - i + 1) ', '                            ++count;', '                        else if (j - i + 1 < m) {', '                            count = 1;', '                            m = j - i + 1;', '                        }', '                    }', '                }', '            }', '        pw.println(g + "" "" + count);', '    }', '', '    private static int sumf(int[] fen, int id) {', '        int summ = 0;', '        for (; id >= 0; id = (id & (id + 1)) - 1)', '            summ += fen[id];', '        return summ;', '    }', '', '    private static void addf(int[] fen, int id) {', '        for (; id < fen.length; id |= id + 1)', '            fen[id]++;', '    }', '', '    private static int nextInt() throws IOException {', '        return Integer.parseInt(next());', '    }', '    private static long nextLong() throws IOException {', '        return Long.parseLong(next());', '    }', '    private static double nextDouble() throws IOException {', '        return Double.parseDouble(next());', '    }', '    private static String next() throws IOException {', '        while (st==null || !st.hasMoreTokens())', '            st = new StringTokenizer(br.readLine());', '        return st.nextToken();', '    }', '}']","['import java.io.BufferedOutputStream;', 'import java.io.BufferedReader;', 'import java.io.FileInputStream;', 'import java.io.FileOutputStream;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.io.PrintStream;', 'import java.util.Arrays;', 'import java.util.Locale;', 'import java.util.StringTokenizer;', '', 'public class Solution implements Runnable {', '  ', '  public static final int inf = 40 * 2 * 100000 + 1;', '  ', '  private PrintStream out;', '  private BufferedReader in;', '  private StringTokenizer st;', '  ', '  public void solve() throws IOException {', '    long time0 = System.currentTimeMillis();', '    ', '    int n = nextInt();', '    int[] a = new int[n];', '    for (int i = 0; i < n; i++) {', '      a[i] = nextInt();', '    }', '    String answer = solve(n, a);', '    out.println(answer);', '    ', '    System.err.println(""time: "" + (System.currentTimeMillis() - time0));', '  }', '  ', '  private String solve(int n, int[] a) {', '    int maxa = 0;', '    for (int i = 0; i < n; i++) {', '      maxa = Math.max(maxa, a[i]);', '    }', '    int[] s = new int[n + 1];', '    for (int i = 1; i <= n; i++) {', '      s[i] = s[i - 1] + a[i - 1];', '    }', '    SegmentTree tree = new SegmentTree(s);', '    int[][] b = new int[maxa * (maxa + 1) / 2 + 1][maxa + 1];', '    for (int[] bb : b) {', '      Arrays.fill(bb, -1);', '    }', '    int g = 0;', '    int gm = 0;', '    int gn = n;', '    for (int i = 0; i < n; i++) {', '      if (a[i] <= 0) {', '        continue;', '      }', '      b[0][a[i] - 1] = i;', '      for (int sum = a[i]; sum < b.length; sum++) {', '        b[sum][a[i]] = Math.max(b[sum][a[i]], b[sum - a[i]][a[i] - 1]);', '        for (int j = a[i] + 1; j < b[sum].length; j++) {', '          b[sum][j] = Math.max(b[sum][j], b[sum][a[i]]);', '        }', '      }', '      int rightest = -1;', '      for (int sum = b.length - 1; sum >= 1; sum--) {', '        int minret = tree.min(rightest + 1, b[sum][b[sum].length - 1]);', '        if (minret == -1) {', '          continue;', '        }', '        int mins = s[minret];', '        int pg = s[i + 1] - mins - sum;', '        int pm = i + 1 - minret;', '        if (g < pg) {', '          g = pg;', '          gm = pm;', '          gn = 1;', '        } else if (g == pg && gm > pm) {', '          gm = pm;', '          gn = 1;', '        } else if (g == pg && gm == pm) {', '          gn++;', '        }', '        rightest = Math.max(rightest, b[sum][b[sum].length - 1]);', '      }', '    }', '    if (g == 0) {', '      gn = n;', '    }', '    return g + "" "" + gn;', '  }', '  ', '  public static class SegmentTree {', '    private int[] a;', '    private int[] aret;', '    private int base;', '    public SegmentTree(int[] s) {', '      base = 1;', '      while (base < s.length) {', '        base *= 2;', '      }', '      a = new int[base + base];', '      aret = new int[a.length];', '      for (int i = 0; i < s.length; i++) {', '        a[base + i] = s[i];', '        aret[base + i] = i;', '      }', '      for (int i = s.length; i < base; i++) {', '        a[base + i] = inf;', '        aret[base + i] = -1;', '      }', '      for (int i = base - 1; i > 0; i--) {', '        if (a[2 * i + 0] < a[2 * i + 1]) {', '          a[i] = a[2 * i + 0];', '          aret[i] = aret[2 * i + 0];', '        } else {', '          a[i] = a[2 * i + 1];', '          aret[i] = aret[2 * i + 1];', '        }', '      }', '    }', '    public int min(int left, int right) {', '      if (left > right) {', '        return -1;', '      }', '      int i = base + left;', '      int j = base + right;', '      if (i == j) {', '        return aret[i];', '      }', '      int resm;', '      int resret;', '      if (a[i] < a[j]) {', '        resm = a[i];', '        resret = aret[i];', '      } else {', '        resm = a[j];', '        resret = aret[j];', '      }', '      while (i + 1 < j) {', '        if (i % 2 == 0) {', '          if (resm > a[i + 1]) {', '            resm = a[i + 1];', '            resret = aret[i + 1];', '          }', '        }', '        if (j % 2 == 1) {', '          if (resm > a[j - 1]) {', '            resm = a[j - 1];', '            resret = aret[j - 1];', '          }', '        }', '        i /= 2;', '        j /= 2;', '      }', '      return resret;', '    }', '  }', '', '  public double nextDouble() throws IOException {', '    return Double.parseDouble(next());', '  }', '  ', '  public long nextLong() throws IOException {', '    return Long.parseLong(next());', '  }', '  ', '  public int nextInt() throws IOException {', '    return Integer.parseInt(next());', '  }', '  ', '  public String next() throws IOException {', '    while (!st.hasMoreTokens()) {', '      String line = in.readLine();', '      if (line == null) {', '        return null;', '      }', '      st = new StringTokenizer(line);', '    }', '    return st.nextToken();', '  }', '  ', '  @Override', '  public void run() {', '    try {', '      solve();', '      out.close();', '    } catch (Throwable e) {', '      throw new RuntimeException(e);', '    }', '  }', '  ', '  public Solution(String name) throws IOException {', '    Locale.setDefault(Locale.US);', '    if (name == null) {', '      in = new BufferedReader(new InputStreamReader(System.in));', '      out = new PrintStream(new BufferedOutputStream(System.out));', '    } else {', '      in = new BufferedReader(new InputStreamReader(new FileInputStream(name + "".in"")));', '      out = new PrintStream(new BufferedOutputStream(new FileOutputStream(name + "".out"")));', '    }', '    st = new StringTokenizer("""");', '  }', '  ', '  public static void main(String[] args) throws IOException {', '    new Thread(new Solution(null)).start();', '  }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '', '', '    public static void main(String[] args) throws Exception {', '        Scanner in = new Scanner(System.in);', '        int cases = 1;//in.nextInt();', '        for (int testcase = 0; testcase < cases; testcase++) {', '            int n = in.nextInt();', '            int m = in.nextInt();', '            lovelyTriplets(n, m);', '        }', '    }', '', '    public static void lovelyTriplets(int n, int q) {', '        if (q == 2) {', '            lovelyTripletsTwo(n);', '            return;', '        }', '        if (q == 3) {', '            lovelyTripletsThree(n);', '            return;', '        }', '        int best = Integer.MAX_VALUE;', '        int bestIndex = -1;', '        for (int i = 1; i < n; i++) {', '            int[] b1 = bestThree(i);', '            int[] b2 = bestThree(n-i);', '            int sum = b1[0] +b1[1] + b1[2] + b2[0] + b2[1] + b2[2];', '            if (sum < best) {', '                best = sum;', '                bestIndex = i;', '            }', '        }', '        int[] b1 = bestThree(bestIndex);', '        int[] b2 = bestThree(n-bestIndex);', '        int sum = 0;', '//        for (int i : b1) System.out.print(i + "" "");', '//        for (int i : b2) System.out.print(i + "" "");', '//        System.out.println();', '        for (int i : b1) sum+=i;', '        for (int i : b2) sum+=i;', '        int nodes = sum+3*(q-2);', '        System.out.println(nodes + "" "" + nodes);', '        int node = 7;', '        for (int i = 0; i < b1[0]; i++) {', '            System.out.println(""1 "" + node); node++;', '        }', '        for (int i = 0; i < b1[1]; i++) {', '            System.out.println(""2 "" + node); node++;', '        }', '        for (int i = 0; i < b1[2]; i++) {', '            System.out.println(""3 "" + node); node++;', '        }', '        for (int i = 0; i < b2[0]; i++) {', '            System.out.println(""4 "" + node); node++;', '        }', '        for (int i = 0; i < b2[1]; i++) {', '            System.out.println(""5 "" + node); node++;', '        }', '        for (int i = 0; i < b2[2]; i++) {', '            System.out.println(""6 "" + node); node++;', '        }', '        System.out.println(""1 4"");', '        System.out.println(""2 5"");', '        System.out.println(""3 6"");', '        int[] lasts = new int[]{4,5,6};', '        for (int  i = 5; i <= q; i++) {', '            for (int j = 0; j < 3; j++) {', '                System.out.println(lasts[j] + "" "" + node);', '                lasts[j] = node;', '                node++;', '            }', '        }', '        System.out.println(lasts[0] + "" 2"");', '        System.out.println(lasts[1] + "" 3"");', '        System.out.println(lasts[2] + "" 1"");', '', '    }', '', '    static void lovelyTripletsThree(int n) {', '        int best = Integer.MAX_VALUE;', '        int bestIndex = -1;', '        for (int i = 1; i < n; i++) {', '            int[] b1 = bestThree(i);', '            int[] b2 = bestThree(n-i);', '            int sum = b1[0] +b1[1] + b1[2] + b2[0] + b2[1] + b2[2];', '            if (sum < best) {', '                best = sum;', '                bestIndex = i;', '            }', '        }', '        int[] b1 = bestThree(bestIndex);', '        int[] b2 = bestThree(n-bestIndex);', '        int sum = 0;', '//      for (int i : b1) System.out.print(i + "" "");', '//      for (int i : b2) System.out.print(i + "" "");', '//      System.out.println();', '      for (int i : b1) sum+=i;', '      for (int i : b2) sum+=i;', '      int nodes = sum+6;', '      System.out.println(nodes + "" "" + nodes);', '      int node = 7;', '        for (int i = 0; i < b1[0]; i++) {', '            System.out.println(""1 "" + node); node++;', '        }', '        for (int i = 0; i < b1[1]; i++) {', '            System.out.println(""2 "" + node); node++;', '        }', '        for (int i = 0; i < b1[2]; i++) {', '            System.out.println(""3 "" + node); node++;', '        }', '        for (int i = 0; i < b2[0]; i++) {', '            System.out.println(""4 "" + node); node++;', '        }', '        for (int i = 0; i < b2[1]; i++) {', '            System.out.println(""5 "" + node); node++;', '        }', '        for (int i = 0; i < b2[2]; i++) {', '            System.out.println(""6 "" + node); node++;', '        }', '        System.out.println(""1 2"");', '        System.out.println(""2 3"");', '        System.out.println(""3 1"");', '        System.out.println(""4 5"");', '        System.out.println(""5 6"");', '        System.out.println(""6 4"");', '', '    }', '', '    static int[] bestThree(int n) {', '        int cube = (int)Math.pow(n, 1.0/3.0);', '        for (int i = cube+1; i >= 1; i--) {', '            if ((n%i) == 0) {', '                int[] bt = bestTwo(n/i);', '                return new int[]{i, bt[0], bt[1]};', '            }', '        }', '        return new int[]{n, 1, 1};', '    }', '', '    static int[] bestTwo(int n) {', '        int square = (int)Math.sqrt(n);', '        for (int i = square+1; i >= 1; i--) {', '            if ((n%i) == 0) {', '                return new int[]{i, n/i};', '            }', '        }', '        return new int[]{n, 1};', '    }', '', '    public static void lovelyTripletsTwo(int p) {', '        int[] chooses = new int[34];', '        for (int i = 3; i < 34; i++) {', '            int val = i*(i-1)*(i-2)/6;', '            chooses[i] = val;', '        }', '', '', '', '        int total = 0;', '        List<Integer> flowers = new ArrayList<Integer>();', '        while (total < p) {', '            for (int i = 33; i >= 3; i--) {', '                if (total + chooses[i] <= p) {', '//                    System.out.println(""size "" + i + "" flower"");', '                    total += chooses[i];', '                    flowers.add(i);', '                    i++;', '                }', '            }', '        }', '        int numFlowers = flowers.size();', '        int numLeaves = 0;', '        for (int flower : flowers) numLeaves += flower;', '        System.out.println((numFlowers + numLeaves) + "" "" + numLeaves);', '', '        int nodeCount = 0;', '        for (int flower : flowers) {', '            int root = nodeCount+1;', '            for (int i = 0; i < flower; i++) {', '                System.out.println(root + "" "" + (root+i+1));', '            }', '            nodeCount = root + flower;', '        }', '    }', '', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class LovelyTriplets {', '    public static void main(String[] args) throws Exception {', '        Scanner in = new Scanner(System.in);', '        int cases = 1;//in.nextInt();', '        for (int testcase = 0; testcase < cases; testcase++) {', '            int n = in.nextInt();', '            int m = in.nextInt();', '            lovelyTriplets(n, m);', '        }', '    }', '', '    public static void lovelyTriplets(int n, int q) {', '        if (q == 2) {', '            lovelyTripletsTwo(n);', '            return;', '        }', '        if (q == 3) {', '            lovelyTripletsThree(n);', '            return;', '        }', '        int best = Integer.MAX_VALUE;', '        int bestIndex = -1;', '        for (int i = 1; i < n; i++) {', '            int[] b1 = bestThree(i);', '            int[] b2 = bestThree(n-i);', '            int sum = b1[0] +b1[1] + b1[2] + b2[0] + b2[1] + b2[2];', '            if (sum < best) {', '                best = sum;', '                bestIndex = i;', '            }', '        }', '        int[] b1 = bestThree(bestIndex);', '        int[] b2 = bestThree(n-bestIndex);', '        int sum = 0;', '        for (int i : b1) sum+=i;', '        for (int i : b2) sum+=i;', '        int nodes = sum+3*(q-2);', '        System.out.println(nodes + "" "" + nodes);', '        int node = 7;', '        for (int i = 0; i < b1[0]; i++) {', '            System.out.println(""1 "" + node); node++;', '        }', '        for (int i = 0; i < b1[1]; i++) {', '            System.out.println(""2 "" + node); node++;', '        }', '        for (int i = 0; i < b1[2]; i++) {', '            System.out.println(""3 "" + node); node++;', '        }', '        for (int i = 0; i < b2[0]; i++) {', '            System.out.println(""4 "" + node); node++;', '        }', '        for (int i = 0; i < b2[1]; i++) {', '            System.out.println(""5 "" + node); node++;', '        }', '        for (int i = 0; i < b2[2]; i++) {', '            System.out.println(""6 "" + node); node++;', '        }', '        System.out.println(""1 4"");', '        System.out.println(""2 5"");', '        System.out.println(""3 6"");', '        int[] lasts = new int[]{4,5,6};', '        for (int  i = 5; i <= q; i++) {', '            for (int j = 0; j < 3; j++) {', '                System.out.println(lasts[j] + "" "" + node);', '                lasts[j] = node;', '                node++;', '            }', '        }', '        System.out.println(lasts[0] + "" 2"");', '        System.out.println(lasts[1] + "" 3"");', '        System.out.println(lasts[2] + "" 1"");', '', '    }', '', '    static void lovelyTripletsThree(int n) {', '        int best = Integer.MAX_VALUE;', '        int bestIndex = -1;', '        for (int i = 1; i < n; i++) {', '            int[] b1 = bestThree(i);', '            int[] b2 = bestThree(n-i);', '            int sum = b1[0] +b1[1] + b1[2] + b2[0] + b2[1] + b2[2];', '            if (sum < best) {', '                best = sum;', '                bestIndex = i;', '            }', '        }', '        int[] b1 = bestThree(bestIndex);', '        int[] b2 = bestThree(n-bestIndex);', '        int sum = 0;', '        for (int i : b1) sum+=i;', '        for (int i : b2) sum+=i;', '        int nodes = sum+6;', '        System.out.println(nodes + "" "" + nodes);', '        int node = 7;', '        for (int i = 0; i < b1[0]; i++) {', '            System.out.println(""1 "" + node); node++;', '        }', '        for (int i = 0; i < b1[1]; i++) {', '            System.out.println(""2 "" + node); node++;', '        }', '        for (int i = 0; i < b1[2]; i++) {', '            System.out.println(""3 "" + node); node++;', '        }', '        for (int i = 0; i < b2[0]; i++) {', '            System.out.println(""4 "" + node); node++;', '        }', '        for (int i = 0; i < b2[1]; i++) {', '            System.out.println(""5 "" + node); node++;', '        }', '        for (int i = 0; i < b2[2]; i++) {', '            System.out.println(""6 "" + node); node++;', '        }', '        System.out.println(""1 2"");', '        System.out.println(""2 3"");', '        System.out.println(""3 1"");', '        System.out.println(""4 5"");', '        System.out.println(""5 6"");', '        System.out.println(""6 4"");', '', '    }', '', '    static int[] bestThree(int n) {', '        int cube = (int)Math.pow(n, 1.0/3.0);', '        for (int i = cube+1; i >= 1; i--) {', '            if ((n%i) == 0) {', '                int[] bt = bestTwo(n/i);', '                return new int[]{i, bt[0], bt[1]};', '            }', '        }', '        return new int[]{n, 1, 1};', '    }', '', '    static int[] bestTwo(int n) {', '        int square = (int)Math.sqrt(n);', '        for (int i = square+1; i >= 1; i--) {', '            if ((n%i) == 0) {', '                return new int[]{i, n/i};', '            }', '        }', '        return new int[]{n, 1};', '    }', '', '    public static void lovelyTripletsTwo(int p) {', '        int[] chooses = new int[34];', '        for (int i = 3; i < 34; i++) {', '            int val = i*(i-1)*(i-2)/6;', '            chooses[i] = val;', '        }', '', '', '', '        int total = 0;', '        List<Integer> flowers = new ArrayList<Integer>();', '        while (total < p) {', '            for (int i = 33; i >= 3; i--) {', '                if (total + chooses[i] <= p) {', '                    total += chooses[i];', '                    flowers.add(i);', '                    i++;', '                }', '            }', '        }', '        int numFlowers = flowers.size();', '        int numLeaves = 0;', '        for (int flower : flowers) numLeaves += flower;', '        System.out.println((numFlowers + numLeaves) + "" "" + numLeaves);', '', '        int nodeCount = 0;', '        for (int flower : flowers) {', '            int root = nodeCount+1;', '            for (int i = 0; i < flower; i++) {', '                System.out.println(root + "" "" + (root+i+1));', '            }', '            nodeCount = root + flower;', '        }', '    }', '', '}']"
"['import java.io.*;', 'import java.util.*;', 'public class g2 {', ' static int n, s, d;', ' static int[][][] memo;', 'public static void main(String[] args) throws IOException {', ' input.init(System.in);', ' PrintWriter out = new PrintWriter(System.out);', ' int T = input.nextInt();', ' for(int t = 0; t<T; t++)', ' {', '  n = input.nextInt();', '  s = input.nextInt();', '  d = input.nextInt();', '  memo = new int[n+1][s+1][d+1];', '  for(int[][] A : memo) ', '   for(int[] B : A)', '    Arrays.fill(B, -1);', '  if(can(n, s, d) > 0)', '  {', '   res = new int[n];', '   val = 0;', '   trace(n, s, d);', '   for(int i = 0; i<n; i++) out.print(res[i]+"" "");', '   out.println();', '  }', '  else', '  {', '   out.println(-1);', '  }', ' }', ' out.close();', '}', 'static int val;', 'static int[] res;', 'static int can(int elements, int sumLeft, int diffLeft)', '{', ' if(sumLeft < 0 || diffLeft < 0) return 0;', ' if(elements == 0) return sumLeft == 0 && diffLeft == 0 ? 1 : 0;', ' if(memo[elements][sumLeft][diffLeft] != -1) return memo[elements][sumLeft][diffLeft]; ', ' int take = can(elements-1, sumLeft, diffLeft);', ' if(take > 0) return memo[elements][sumLeft][diffLeft] = 1;', ' int notake = can(elements, sumLeft - elements, diffLeft - elements * (n - elements));', ' if(notake > 0) return memo[elements][sumLeft][diffLeft] = 1;', ' return memo[elements][sumLeft][diffLeft] = 0;', '}', 'static void trace(int elements, int sumLeft, int diffLeft)', '{', ' if(sumLeft < 0 || diffLeft < 0) return;', ' if(elements == 0) return;', ' int take = can(elements-1, sumLeft, diffLeft);', ' if(take > 0)', ' {', '  res[n-elements] = val;', '  trace(elements-1, sumLeft, diffLeft);', '  return;', ' }', ' int notake = can(elements, sumLeft - elements, diffLeft - elements * (n - elements));', ' if(notake > 0)', ' {', '  val++;', '  trace(elements, sumLeft - elements, diffLeft - elements * (n - elements));', ' }', '}', 'public static class input {', ' static BufferedReader reader;', ' static StringTokenizer tokenizer;', '', ' static void init(InputStream input) {', '  reader = new BufferedReader(new InputStreamReader(input));', '  tokenizer = new StringTokenizer("""");', ' }', '', ' static String next() throws IOException {', '  while (!tokenizer.hasMoreTokens())', '   tokenizer = new StringTokenizer(reader.readLine());', '  return tokenizer.nextToken();', ' }', '', ' static int nextInt() throws IOException {', '  return Integer.parseInt(next());', ' }', '', ' static double nextDouble() throws IOException {', '  return Double.parseDouble(next());', ' }', '', ' static long nextLong() throws IOException {', '  return Long.parseLong(next());', ' }', '}', '}']","['import java.util.Arrays;', 'import java.util.Scanner;', '', 'public class Solution {', 'public static int[][][][] dp;', 'public static int[] construct(int nums, int sum1, int sum2) {', 'if (nums == 0) {', 'if (sum1 != 0 || sum2 != 0) {', 'return new int[]{-1};', '}', 'return new int[]{};', '}', 'if (dp[nums][sum1][sum2] != null) return dp[nums][sum1][sum2];', '', 'for (int place = 0; nums*place <= sum1; place++) {', 'int nsum1 = sum1 - place * nums;', 'int nsum2 = sum2 - place * nums - nsum1;', 'if (nsum2 < 0) continue;', '', 'int[] xx = construct(nums-1, nsum1, nsum2);', 'if (xx.length == 1 && xx[0] == -1) {', 'continue;', '}', 'int[] actual = new int[nums];', 'System.arraycopy(xx, 0, actual, 1, xx.length);', 'for (int i = 0; i < nums; i++) actual[i] += place;', 'return dp[nums][sum1][sum2] = actual;', '}', 'return dp[nums][sum1][sum2] = new int[]{-1};', '}', '', 'public static void main (String[] args) {', 'dp = new int[51][201][5001][];', 'Scanner in = new Scanner(System.in);', 'int q = in.nextInt();', 'while(q-->0) {', 'int n = in.nextInt(), s = in.nextInt(), k = in.nextInt();', 'int[] min = null;', 'for (int start = 0; start*n <= s; start++) {', 'int[] b = construct(n-1, s-start*n, k);', 'if (b.length == 1 && b[0] == -1) {', 'continue;', '}', 'int[] xx = new int[n];', 'System.arraycopy(b, 0, xx, 1, b.length);', 'for (int i = 0; i < n; i++) xx[i] += start;', 'if (min == null) {', 'min = xx;', 'continue;', '}', 'boolean less = false;', 'for (int i = 0; i < n; i++) {', 'if (min[i] != xx[i]) {', 'if (xx[i] < min[i]) {', 'less = true;', '}', 'break;', '}', '}', 'if (less) {', 'min = xx;', '}', '}', '', 'if (min != null) {', 'for (int i = 0; i < n; i++) {', 'if (i != 0) System.out.print("" "");', 'System.out.print(min[i]);', '}', 'System.out.println();', '} else {', 'System.out.println(-1);', '}', '}', 'System.exit(0);', '}', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        int BITS = 19;', '        int MAX = 1<<BITS;', '        long[][] dp = new long[BITS][MAX];', '        for (int i = 0; i < 10; i++)', '            dp[0][i] = 1;', '        for (int i = 1; i < BITS; i++) {', '            int sub = 1<<i;', '            for (int j = 0; j < MAX; j++) {', '                for (int k = 0; k <= 9; k++) {', '                    int rem = j-k*sub;', '                    if (rem < 0)', '                        break;', '                    dp[i][j] += dp[i-1][rem];', '                }', '            }', '        }', '        long sum = 0;', '        TreeMap<Long, Integer> sums = new TreeMap<Long, Integer>();', '        sums.put(0l, -1);', '        for (int i = 0; i < MAX; i++) {', '            sum += dp[BITS-1][i];', '            sums.put(sum, i);', '        }', '        Scanner sc = new Scanner(System.in);', '        int q = sc.nextInt();', '        for (int z = 0; z < q; z++) {', '            long n = sc.nextLong();', '            int val = sums.floorEntry(n-1).getValue()+1;', '            n -= sums.floorEntry(n-1).getKey();', '            long ans = 0;', '            for (int i = BITS-1; i > 0; i--) {', '                int digit = 0;', '                while (dp[i-1][val] < n) {', '                    n -= dp[i-1][val];', '                    digit++;', '                    val -= (1<<i);', '                }', '                ans *= 10;', '                ans += digit;', '            }', '            ans *= 10;', '            ans += val;', '            System.out.println(ans);', '        }', '    }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(System.in);', '        int max = 600000;', '        int size = 20;', '        ', '        int[] counter = new int[max];', '        long[] fresh = new long[max];', '        long[] sum = new long[max];', '        long[] finder = new long[max];', '        ', '        int[][] prev = new int[max][size];', '        long[][] high = new long[max][size];', '        long[][] el = new long[max][size];', '        ', '        sum[0] = 1;', '        int u = 1;', '        long t = 1;', '        ', '        for(int i = 0; i < 20; i++) {', '            int last = Math.min(20 * u, max);', '                ', '            ', '                ', '                for(int k = 1; k < 10; k++) {', '                    for(int j = 0; j < last; j++) {', '                if(sum[j] == 0) {', '                    continue;', '                }', '                        ', '                    int n = k * u + j;', '                    ', '                    if(n >= max) {', '                        break;', '                    }', '                    ', '                    int p = counter[n];', '                    ', '                    fresh[n] += sum[j];', '                    prev[n][p] = j;', '                    //data[n][p] = sum[j];', '                    high[n][p] = sum[n] + fresh[n];', '                    ', '                    el[n][p] = (long)k * t;', '                    counter[n] = p + 1;', '                }', '            }', '            ', '            for(int j = 0; j < max; j++) {', '                sum[j] += fresh[j];', '                fresh[j] = 0;', '            }', '            ', '            u *= 2;', '            t *= 10;', '        }', '        ', '        finder[0] = 1;', '        ', '        for(int i = 1; i < max; i++) {', '            finder[i] = finder[i - 1] + sum[i];', '        }', '        ', '        int count = sc.nextInt();', '        long[] tab;', '        StringBuilder builder = new StringBuilder();', '        ', '        for(int q = 0; q < count; q++) {', '            long p = sc.nextLong();', '            ', '            if(p == 1) {', '                builder.append(""0\\n"");', '                continue;', '            }', '            ', '            int x = find(finder, 1, max - 1, p);', '            int y = 0;', '            int k = 0;', '            ', '            long s = sum[x];', '            long res = 0;', '            p -= finder[x - 1];', '            ', '            while(true) {', '                tab = high[x];', '                k = counter[x];', '                y = find(tab, 0, k - 1, p);', '                ', '                res += el[x][y];', '                x = prev[x][y];', '                ', '                if(x == 0) {', '                    builder.append(res);', ""                    builder.append('\\n');"", '                    break;', '                }', '                ', '                if(y > 0) {', '                    p -= tab[y - 1];', '                }', '            }', '        }', '        ', '        System.out.println(builder.toString());', '    }', '    ', '    static int find(long[] tab, int a, int b, long n) {', '        if(a == b) {', '            return a;', '        }', '        ', '        if(b - a == 1) {', '            if(n > tab[a]) {', '                return b;', '            }', '            ', '            return a;', '        }', '        ', '        int k = (a + b) / 2;', '        ', '        if(n > tab[k]) {', '            return find(tab, k + 1, b, n);', '        }', '        else {', '            return find(tab, a, k, n);', '        }', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    static long curTime;', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt(), k = in.nextInt();', '        long[] x = new long[n];', '        for(int i = 0; i < n; i++) x[i] = in.nextInt();', '        Arrays.sort(x);', '        curTime = System.currentTimeMillis();', '        System.out.println(f(n, k, x));', '    }', '    ', '    private static long f(int n, int k, long[] x){', '        long t = unFair(k, x), min = t, s = 0;', '        //long s = sum(1, k-1, x);', '        for(int i = 1; i < k; i++) s += x[i];', '        ', '        for(int i = 1; i + k-1 < x.length; i++){', '            //System.out.println(t);', '            t += (k-1)*(x[i-1] + x[i+k-1]);', '            t -= 2*s;', '            if(t < min) min = t;', '            s += x[i+k-1] -x[i];', '        }', '        return min;', '    }', '    ', '    private static long unFair(int k, long[] x){', '        long s = 0;', '        for(int i = 0; i < k; i++){', '            s += x[i] *(2*i-k+1);', '        }', '        return s;', '    }', '    ', '    private static long sum(int i, int j, long[] x){', '        long s = 0;', '        for(int k = i; k <= j; k++) s += x[k];', '        return s;', '    }', '    ', '    /*private static long aSum(int i, int j, long[] x){', '        if(i == j) return x[i];', '        return x[j] - aSum(i, j-1, x);', '    }*/', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(System.in);', '        int n = sc.nextInt();', '        int k = sc.nextInt();', '        ', '        long[] packets = new long[n];', '        ', '        for (int i = 0; i < n; ++i) {', '            packets[i] = sc.nextLong();', '        }', '        ', '        Arrays.sort(packets);', '        ', '        long[] antisums = new long[n];', '        ', '        for (int i = n - 2; i >= 0; i--) {', '            if (i >= n - k) {', '                antisums[i] = antisums[i + 1] + (n - 1 - i) * (packets[i + 1] - packets[i]);', '            } else {', '                antisums[i] = antisums[i + 1] - (packets[i + k] - packets[i + 1]) ', '                    + (k - 1) * (packets[i + 1] - packets[i]);', '            }', '            ', '            ', '        }', '        ', '        long[] sums = new long[n];', '        long[] results = new long[n];', '        long min = Long.MAX_VALUE;', '        for (int i = 1; i <= n - 1; ++i) {   ', '            if (i <= k - 1) {', '                sums[i] = sums[i - 1] + i * (packets[i] - packets[i - 1]);', '                results[i] = results[i - 1] + sums[i];', '            } else {', '                sums[i] = sums[i - 1] - (packets[i - 1] - packets[i - k]) ', '                    + (k - 1) * (packets[i] - packets[i - 1]);', '                results[i] = results[i - 1] - antisums[i - k] + sums[i];  ', '            }', '            ', '            if (i >= k - 1) {', '                if (results[i] < min) {', '                    min = results[i];', '                }', '            }', '        }', '        ', '        ', '        ', '        System.out.println(min);', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        int MOD = 1000000007;', '        Scanner sc = new Scanner(System.in);', '        int n = sc.nextInt();', '        int[] m = new int[n];', '        for (int i = 0; i < n; i++) {', '            m[i] = sc.nextInt();', '        }', '        boolean[][] sorted = new boolean[n][n];', '        for (int i = 0; i < n; i++) {', '            sorted[i][i] = true;', '            for (int j = i+1; j < n; j++) {', '                if (sorted[i][j-1]&&m[j]>m[j-1])', '                    sorted[i][j] = true;', '            }', '        }', '        long[][] dp = new long[n][n+1]; // ending set, ending length', '        for (int i = 0; i < n; i++) {', '            if (sorted[0][i])', '                dp[i][i+1]++;', '        }', '        long[][] perm = new long[n+1][n+1];', '        perm[0][0] = 1;', '        for (int i = 1; i <= n; i++) {', '            perm[i][0] = 1;', '            for (int j = 1; j <= i; j++) {', '                perm[i][j] = (perm[i][j-1]*(i-j+1))%MOD;', '            }', '        }', '        for (int i = 1; i < n; i++) { // beginning', '            for (int j = 1; j <= i; j++) { // length', '                int end = i+j-1;', '                if (end >= n || !sorted[i][end])', '                    continue;', '                for (int k = j; k <= i; k++) { // previous length', '                    dp[i+j-1][j] += dp[i-1][k]*perm[k][j];', '                    dp[i+j-1][j] %= MOD;', '                }', '            }', '        }', '        long ans = 0;', '        for (int i = 1; i <= n; i++) {', '            ans += dp[n-1][i];', '            ans %= MOD;', '        }', '        System.out.println(ans);', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    private static final long MOD = 1000000007;', '    private static final int MAX_N = 1210;', '    ', '    private static int min(int a, int b) { return a < b ? a : b; }', '    ', '    static int arrayMerging(int[] m) {', '        long[][] f = new long[MAX_N][MAX_N];', '        long[][] c = new long[MAX_N][MAX_N];', '        long[] factor = new long[MAX_N];', '        ', '        int n = m.length;', '        ', '        c[1][1] = 1; c[1][0] = 1;', '        ', '        for (int i = 2; i <= n; i ++) for (int j = 0; j <= i; j ++) {', '            if (j == 0) c[i][j] = 1;', '            else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD;', '        }', '        ', '        factor[1] = 1;', '        for (int i = 2; i <= n; i ++) factor[i] = (factor[i - 1] * (long)i) % MOD;', '        ', '        int endNodes = 1, mnEndNodes = n;', '        f[1][1] = 1; f[0][0] = 1;', '        for (int i = 2; i <= n; i ++) {', '            if (m[i - 2] > m[i - 1]) {                ', '                mnEndNodes = min(mnEndNodes, endNodes);', '                endNodes = 1;', '            }', '            else endNodes ++;', '            ', '            for (int j = 1; j <= min(endNodes - j, mnEndNodes) || j <= min(endNodes, mnEndNodes); j ++) {', '                if (i == j) f[i][j] = 1;', '                ', '                for (int k = j; k <= i - j; k ++) {', '                    f[i][j] = (f[i][j] + (((f[i - j][k] * c[k][j]) % MOD) * factor[j]) % MOD) % MOD;', '                }', '            }', '        }', '        ', '        long ans = 0;', '        for (int i = 1; i <= endNodes; i ++) ans = (ans + f[n][i]) % MOD;', '        return (int)ans;', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int mCount = scanner.nextInt();', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '        int[] m = new int[mCount];', '', '        String[] mItems = scanner.nextLine().split("" "");', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '        for (int mItr = 0; mItr < mCount; mItr++) {', '            int mItem = Integer.parseInt(mItems[mItr]);', '            m[mItr] = mItem;', '        }', '', '        int result = arrayMerging(m);', '', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '', '        bufferedWriter.close();', '', '        scanner.close();', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', '// static String INPUT = ""1 2 2 ## ##"";', ' static String INPUT = """";', ' ', ' static int[] makeMaskArray(int mask, int h, int amask)', ' {', '  int[] ret = new int[h];', '  int p = 0;', '  for(int i = 0;i < h;i++){', '   if((i&mask) == 0 && (amask == -1 || (i&amask) != 0)){', '    ret[p++] = i;', '   }', '  }', '  return Arrays.copyOf(ret, p);', ' }', ' ', ' static void solve()', ' {', '  for(int T = ni();T >= 1;T--){', '   int n = ni(), m = ni();', '   char[][] map = nm(n,m);', '   int[] pre = new int[1<<m*2+1];', '   pre[(1<<m*2+1)-1] = 1;', '   int[] cur = new int[1<<m*2+1];', '   int mod = 1000000007;', '   int omask = (1<<m*2+1)-1;', '   int hmask = 1<<m*2;', '   int mask1 = 1<<m-1|1<<2*m-1|1<<2*m;', '   int mask2 = 1<<m-1|1<<2*m-1|1<<2*m-2;', '   int mask3 = 1<<m-1|1<<m|1<<m+1;', '   int mask4 = 1<<m-1|1<<m-2|1<<m-3;', '   int mask5 = 1<<0|1<<m|1<<2*m;', '   int mask6 = 1<<0|1<<m-1|1<<2*m-1;', '   int mask7 = 1<<0|1<<1|1<<m+1;', '   int mask8 = 1<<0|1<<1|1<<m-1;', '   int[] val1 = makeMaskArray(mask1, 1<<2*m+1, -1);', '   int[] val2 = makeMaskArray(mask2, 1<<2*m+1, hmask);', '   int[] val3 = makeMaskArray(mask3, 1<<2*m+1, hmask);', '   int[] val4 = makeMaskArray(mask4, 1<<2*m+1, hmask);', '   int[] val5 = makeMaskArray(mask5, 1<<2*m+1, -1);', '   int[] val6 = makeMaskArray(mask6, 1<<2*m+1, hmask);', '   int[] val7 = makeMaskArray(mask7, 1<<2*m+1, hmask);', '   int[] val8 = makeMaskArray(mask8, 1<<2*m+1, hmask);', '   int[] valn = makeMaskArray(0, 1<<2*m+1, hmask);', '   ', '   for(int i = 0;i < n;i++){', '    for(int j = 0;j < m;j++){', '     Arrays.fill(cur, 0);', ""     if(map[i][j] == '.'){"", '      // xx', '      // .x', '      // .x', '      if(i >= 2 && j >= 1){', '       for(int k : val1){', '        int nk = ((k|mask1)<<1|1)&omask;', '        cur[nk] += pre[k];', '        if(cur[nk] >= mod)cur[nk] -= mod;', '       }', '      }', '      // x.', '      // x.', '      // xx', '      if(i >= 2 && j >= 1){', '       for(int k : val5){', '        int nk = ((k|mask5)<<1|1)&omask;', '        cur[nk] += pre[k];', '        if(cur[nk] >= mod)cur[nk] -= mod;', '       }', '      }', '      // xx', '      // x.', '      // x.', '      if(i >= 2 && j+1 < m){', '       for(int k : val2){', '        int nk = ((k|mask2)<<1|1)&omask;', '        cur[nk] += pre[k];', '        if(cur[nk] >= mod)cur[nk] -= mod;', '       }', '      }', '      // .x', '      // .x', '      // xx', '      if(i >= 2 && j >= 1){', '       for(int k : val6){', '        int nk = ((k|mask6)<<1|1)&omask;', '        cur[nk] += pre[k];', '        if(cur[nk] >= mod)cur[nk] -= mod;', '       }', '      }', '      // xxx', '      // ..x', '      if(i >= 1 && j >= 2){', '       for(int k : val3){', '        int nk = ((k|mask3)<<1|1)&omask;', '        cur[nk] += pre[k];', '        if(cur[nk] >= mod)cur[nk] -= mod;', '       }', '      }', '      // x..', '      // xxx', '      if(i >= 1 && j >= 2){', '       for(int k : val7){', '        int nk = ((k|mask7)<<1|1)&omask;', '        cur[nk] += pre[k];', '        if(cur[nk] >= mod)cur[nk] -= mod;', '       }', '      }', '      // xxx', '      // x..', '      if(i >= 1 && j+2 < m){', '       for(int k : val4){', '        int nk = ((k|mask4)<<1|1)&omask;', '        cur[nk] += pre[k];', '        if(cur[nk] >= mod)cur[nk] -= mod;', '       }', '      }', '      // ..x', '      // xxx', '      if(i >= 1 && j >= 2){', '       for(int k : val8){', '        int nk = ((k|mask8)<<1|1)&omask;', '        cur[nk] += pre[k];', '        if(cur[nk] >= mod)cur[nk] -= mod;', '       }', '      }', '      // none', '      for(int k : valn){', '       int nk = (k<<1)&omask;', '       cur[nk] += pre[k];', '       if(cur[nk] >= mod)cur[nk] -= mod;', '      }', '     }else{', '      for(int k : valn){', '       int nk = (k<<1|1)&omask;', '       cur[nk] += pre[k];', '       if(cur[nk] >= mod)cur[nk] -= mod;', '      }', '     }', '     int[] dum = cur; cur = pre; pre = dum;', '    }', '   }', '   out.println(pre[(1<<m*2+1)-1]);', '  }', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class Solution {', '    static InputStream is;', '    static PrintWriter out;', '//    static String INPUT = ""1 2 2 ## ##"";', '    static String INPUT = """";', '    ', '    static int[] makeMaskArray(int mask, int h, int amask)', '    {', '        int[] ret = new int[h];', '        int p = 0;', '        for(int i = 0;i < h;i++){', '            if((i&mask) == 0 && (amask == -1 || (i&amask) != 0)){', '                ret[p++] = i;', '            }', '        }', '        return Arrays.copyOf(ret, p);', '    }', '    ', '    static void solve()', '    {', '        for(int T = ni();T >= 1;T--){', '            int n = ni(), m = ni();', '            char[][] map = nm(n,m);', '            int[] pre = new int[1<<m*2+1];', '            pre[(1<<m*2+1)-1] = 1;', '            int[] cur = new int[1<<m*2+1];', '            int mod = 1000000007;', '            int omask = (1<<m*2+1)-1;', '            int hmask = 1<<m*2;', '            int mask1 = 1<<m-1|1<<2*m-1|1<<2*m;', '            int mask2 = 1<<m-1|1<<2*m-1|1<<2*m-2;', '            int mask3 = 1<<m-1|1<<m|1<<m+1;', '            int mask4 = 1<<m-1|1<<m-2|1<<m-3;', '            int mask5 = 1<<0|1<<m|1<<2*m;', '            int mask6 = 1<<0|1<<m-1|1<<2*m-1;', '            int mask7 = 1<<0|1<<1|1<<m+1;', '            int mask8 = 1<<0|1<<1|1<<m-1;', '            int[] val1 = makeMaskArray(mask1, 1<<2*m+1, -1);', '            int[] val2 = makeMaskArray(mask2, 1<<2*m+1, hmask);', '            int[] val3 = makeMaskArray(mask3, 1<<2*m+1, hmask);', '            int[] val4 = makeMaskArray(mask4, 1<<2*m+1, hmask);', '            int[] val5 = makeMaskArray(mask5, 1<<2*m+1, -1);', '            int[] val6 = makeMaskArray(mask6, 1<<2*m+1, hmask);', '            int[] val7 = makeMaskArray(mask7, 1<<2*m+1, hmask);', '            int[] val8 = makeMaskArray(mask8, 1<<2*m+1, hmask);', '            int[] valn = makeMaskArray(0, 1<<2*m+1, hmask);', '            ', '            for(int i = 0;i < n;i++){', '                for(int j = 0;j < m;j++){', '                    Arrays.fill(cur, 0);', ""                    if(map[i][j] == '.'){"", '                        // xx', '                        // .x', '                        // .x', '                        if(i >= 2 && j >= 1){', '                            for(int k : val1){', '                                int nk = ((k|mask1)<<1|1)&omask;', '                                cur[nk] += pre[k];', '                                if(cur[nk] >= mod)cur[nk] -= mod;', '                            }', '                        }', '                        // x.', '                        // x.', '                        // xx', '                        if(i >= 2 && j >= 1){', '                            for(int k : val5){', '                                int nk = ((k|mask5)<<1|1)&omask;', '                                cur[nk] += pre[k];', '                                if(cur[nk] >= mod)cur[nk] -= mod;', '                            }', '                        }', '                        // xx', '                        // x.', '                        // x.', '                        if(i >= 2 && j+1 < m){', '                            for(int k : val2){', '                                int nk = ((k|mask2)<<1|1)&omask;', '                                cur[nk] += pre[k];', '                                if(cur[nk] >= mod)cur[nk] -= mod;', '                            }', '                        }', '                        // .x', '                        // .x', '                        // xx', '                        if(i >= 2 && j >= 1){', '                            for(int k : val6){', '                                int nk = ((k|mask6)<<1|1)&omask;', '                                cur[nk] += pre[k];', '                                if(cur[nk] >= mod)cur[nk] -= mod;', '                            }', '                        }', '                        // xxx', '                        // ..x', '                        if(i >= 1 && j >= 2){', '                            for(int k : val3){', '                                int nk = ((k|mask3)<<1|1)&omask;', '                                cur[nk] += pre[k];', '                                if(cur[nk] >= mod)cur[nk] -= mod;', '                            }', '                        }', '                        // x..', '                        // xxx', '                        if(i >= 1 && j >= 2){', '                            for(int k : val7){', '                                int nk = ((k|mask7)<<1|1)&omask;', '                                cur[nk] += pre[k];', '                                if(cur[nk] >= mod)cur[nk] -= mod;', '                            }', '                        }', '                        // xxx', '                        // x..', '                        if(i >= 1 && j+2 < m){', '                            for(int k : val4){', '                                int nk = ((k|mask4)<<1|1)&omask;', '                                cur[nk] += pre[k];', '                                if(cur[nk] >= mod)cur[nk] -= mod;', '                            }', '                        }', '                        // ..x', '                        // xxx', '                        if(i >= 1 && j >= 2){', '                            for(int k : val8){', '                                int nk = ((k|mask8)<<1|1)&omask;', '                                cur[nk] += pre[k];', '                                if(cur[nk] >= mod)cur[nk] -= mod;', '                            }', '                        }', '                        // none', '                        for(int k : valn){', '                            int nk = (k<<1)&omask;', '                            cur[nk] += pre[k];', '                            if(cur[nk] >= mod)cur[nk] -= mod;', '                        }', '                    }else{', '                        for(int k : valn){', '                            int nk = (k<<1|1)&omask;', '                            cur[nk] += pre[k];', '                            if(cur[nk] >= mod)cur[nk] -= mod;', '                        }', '                    }', '                    int[] dum = cur; cur = pre; pre = dum;', '                }', '            }', '            out.println(pre[(1<<m*2+1)-1]);', '        }', '    }', '    ', '    public static void main(String[] args) throws Exception', '    {', '        long S = System.currentTimeMillis();', '        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        solve();', '        out.flush();', '        long G = System.currentTimeMillis();', '        tr(G-S+""ms"");', '    }', '    ', '    private static boolean eof()', '    {', '        if(lenbuf == -1)return true;', '        int lptr = ptrbuf;', '        while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '        ', '        try {', '            is.mark(1000);', '            while(true){', '                int b = is.read();', '                if(b == -1){', '                    is.reset();', '                    return true;', '                }else if(!isSpaceChar(b)){', '                    is.reset();', '                    return false;', '                }', '            }', '        } catch (IOException e) {', '            return true;', '        }', '    }', '    ', '    private static byte[] inbuf = new byte[1024];', '    static int lenbuf = 0, ptrbuf = 0;', '    ', '    private static int readByte()', '    {', '        if(lenbuf == -1)throw new InputMismatchException();', '        if(ptrbuf >= lenbuf){', '            ptrbuf = 0;', '            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '            if(lenbuf <= 0)return -1;', '        }', '        return inbuf[ptrbuf++];', '    }', '    ', '    private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', '    private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', '    ', '    private static double nd() { return Double.parseDouble(ns()); }', '    private static char nc() { return (char)skip(); }', '    ', '    private static String ns()', '    {', '        int b = skip();', '        StringBuilder sb = new StringBuilder();', ""        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '            sb.appendCodePoint(b);', '            b = readByte();', '        }', '        return sb.toString();', '    }', '    ', '    private static char[] ns(int n)', '    {', '        char[] buf = new char[n];', '        int b = skip(), p = 0;', '        while(p < n && !(isSpaceChar(b))){', '            buf[p++] = (char)b;', '            b = readByte();', '        }', '        return n == p ? buf : Arrays.copyOf(buf, p);', '    }', '    ', '    private static char[][] nm(int n, int m)', '    {', '        char[][] map = new char[n][];', '        for(int i = 0;i < n;i++)map[i] = ns(m);', '        return map;', '    }', '    ', '    private static int[] na(int n)', '    {', '        int[] a = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        return a;', '    }', '    ', '    private static int ni()', '    {', '        int num = 0, b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static long nl()', '    {', '        long num = 0;', '        int b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']"
"['import java.awt.Point;', 'import java.io.*;', 'import java.math.BigInteger;', 'import java.util.*;', 'import static java.lang.Math.*;', '', 'public class Solution implements Runnable {', '', '    BufferedReader in;', '    PrintWriter out;', '    StringTokenizer tok = new StringTokenizer("""");', '', '    public static void main(String[] args) {', '        new Thread(null, new Solution(), """", 256 * (1L << 20)).start();', '    }', '', '    public void run() {', '        try {', '            long t1 = System.currentTimeMillis();', '            out = new PrintWriter(System.out);', '', '            in = new BufferedReader(new InputStreamReader(System.in));', '            //in = new BufferedReader(new FileReader(""src/input.txt""));', '            //   out = new PrintWriter(""output.txt"");', '', '            Locale.setDefault(Locale.US);', '            solve();', '            in.close();', '            out.close();', '            long t2 = System.currentTimeMillis();', '            System.err.println(""Time = "" + (t2 - t1));', '        } catch (Throwable t) {', '            t.printStackTrace(System.err);', '            System.exit(-1);', '        }', '    }', '', '    String readString() throws IOException {', '        while (!tok.hasMoreTokens()) {', '            tok = new StringTokenizer(in.readLine());', '        }', '        return tok.nextToken();', '    }', '', '    int readInt() throws IOException {', '        return Integer.parseInt(readString());', '    }', '', '    long readLong() throws IOException {', '        return Long.parseLong(readString());', '    }', '', '    double readDouble() throws IOException {', '        return Double.parseDouble(readString());', '    }', '', '    // solution', '    void solve() throws IOException {', '        int ct = readInt();', '        while (ct-- > 0) {', '            solveTestCase();', '        }', '    }', '    static final long modulo = 100000007L;', '', '    void solveTestCase() throws IOException {', '        int n = readInt();', '        int wordLength = readInt();', '        int maxLength = (int) (1 + Math.ceil(Math.log(n) / Math.log(2))); //science!', '        FenwickTree[] f = new FenwickTree[maxLength + 1];', '        for (int i = 0; i < f.length; i++) {', '            f[i] = new FenwickTree(n);', '        }', '        f[0].increase(0, +1);', '        for (int i = 1; i <= n; i++) {', '            f[1].increase(i, +1);', '        }', '        for (int curSymbol = 1; curSymbol <= n; curSymbol++) {', '            for (int curLength = 2; curLength <= maxLength; curLength++) {', '                long value = f[curLength - 1].find(curSymbol / 2);', '                f[curLength].increase(curSymbol, +value);', '            }', '        }', '        long[] wordsWithLength = new long[maxLength + 1];', '        for (int lastSymbol = 0; lastSymbol <= n; lastSymbol++) {', '            if (lastSymbol * 2 > n) {', '                for (int length = 1; length <= maxLength; length++) {', '                    wordsWithLength[length] = (wordsWithLength[length] + f[length].find(lastSymbol) - f[length].find(lastSymbol - 1)) % modulo;', '                }', '            }', '        }', '       // System.out.println(Arrays.toString(wordsWithLength) + "" wwl"");', '        long[] result = new long[wordLength + 1];', '        result[0] = 1;', '        for (int i = 0; i < result.length; i++) {', '            for (int nextWordLength = 1; nextWordLength <= maxLength; nextWordLength++) {', '                if (i + nextWordLength < result.length) {', '                    result[i + nextWordLength] = (result[i + nextWordLength] + result[i] * wordsWithLength[nextWordLength]) % modulo;', '                }', '            }', '        }', '        out.println(result[wordLength]);', '    }', '', '    class FenwickTree {', '', '        private long[] sum;', '', '        FenwickTree(int size) {', '            sum = new long[size + 2];', '        }', '', '        private int prev(int x) {', '            return x & (x - 1);', '        }', '', '        private int next(int x) {', '            return 2 * x - prev(x);', '        }', '', '        void increase(int id, long value) {', '            id++;', '            while (id < sum.length) {', '                sum[id] = (sum[id] + value) % modulo;', '                id = next(id);', '            }', '        }', '', '        long find(int id) {', '            id++;', '            long res = 0;', '            if (id == 0) {', '                return 0;', '            }', '            while (id > 0) {', '                res += sum[id];', '                id = prev(id);', '            }', '            return res % modulo;', '        }', '    }', '}', '', '//ABC']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    static final long MOD = 100_000_007;', '', '    static int alienLanguages(int n, int m) {', '      int[][] t = new int[n + 1][20];', '      int nb = n / 2;', '', '      for (int i = n; i > nb; i--) {', '        t[i][0] = 1;', '      }', '        ', '      int[] words = new int[m + 1];', '      int[] mult = new int[20];', '', '      for (int j = n, k = 0; j > 0; j /= 2, k++) {', '        long d = 0;', '', '        for (int i = n; i > 0; i--) {', '          d = (d + t[i][k]) % MOD;', '          t[i / 2][k + 1] = (int) d;', '        }', '', '        for (int i = n; i > 0; i--) {', '          mult[k] = (int)((mult[k] + t[i][k]) % MOD);', '        }', '      }', '', '      words[0] = 1;', '', '      for (int i = 1; i <= m; i++) {', '        long d = words[i - 1];', '        for (int j = 0; mult[j] > 0 && i + j <= m; j++) {', '          words[i + j] = (int)((words[i + j] + (d * mult[j]) % MOD) % MOD);', '        }', '      }', '      return words[m];', '    }', '', '    public static void main(String[] args) throws IOException {', '        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        StringTokenizer st = new StringTokenizer(br.readLine());', '        int t = Integer.parseInt(st.nextToken());', '', '        for (int i = 0; i < t; i++) {', '            st = new StringTokenizer(br.readLine());', '            int n = Integer.parseInt(st.nextToken());', '            int m = Integer.parseInt(st.nextToken());', '', '            int result = alienLanguages(n, m);', '', '            bw.write(String.valueOf(result));', '            bw.newLine();', '        }', '', '        br.close();', '        bw.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */', '        Scanner sc=new Scanner(System.in);', '        int q=sc.nextInt();', '        for(int loop=1;loop!=q+1;loop++){', '            int n=sc.nextInt();', '            int nprime=0;', '            long sum=0;', '            long[] f;', '            int[] a=new int[n];', '            int i,k;', '            for(i=0;i<n;i++)', '                a[i]=sc.nextInt();', '            Arrays.sort(a);', '            for(i=0;i<n-1;i++){', '                if(a[i]==a[i+1])', '                    nprime++;', '            }', '            f=new long[nprime+1];', '            f[nprime]=fact(n-nprime);', '            for(k=nprime;k>=1;k--){', '                f[k-1]=(((((f[k])*k)%1000000007)*(n-k+1)%1000000007)*inv(2*(nprime-k+1)))%1000000007;', '            }', '            for(k=0;k<=nprime;k++){', '                if(k%2==0){', '                    sum=(sum+f[k])%1000000007;', '                }', '                else{', '                    sum=((sum+1000000007)-f[k])%1000000007;', '                }', '            }', '            System.out.println(sum);', '        }', '    }', '    public static long inv(int n){', '        long a=n;', '        return computepow(a,1000000005);', '    }', '    public static long computepow(long a,long n){', '        if(n<1)', '            return 1;', '        long prod=1;', '        if(n%2==0){', '            prod=computepow(a,n/2);', '            return ((prod*prod)%1000000007);', '        }', '        else{', '            prod=computepow(a,n/2);', '            prod=(((prod*prod)%1000000007)*a)%1000000007;', '            return prod;', '        }', '    }', '    public static long fact(int n){', '        if(n<=1)', '            return 1;', '        long prod=1;', '        for(int i=1;i<=n;i++)', '            prod=(prod*i)%1000000007;', '        return prod;', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    /*', '     * Complete the beautifulPermutations function below.', '     */', '    static int beautifulPermutations(int[] arr) {', '        /*', '         * Write your code here.', '         */', '         HashSet<Integer> used = new HashSet<Integer>();', '         int n = arr.length;', '        for(int i = 0; i < n; i++)', '            used.add(arr[i]);', '        int k = n-used.size();', '        long start = (long)1;', '        long[][] dp = new long[n+1][k+1];', '        for(int i = 1; i <= n; i++){', '            start = (i*start)%1000000007;', '            dp[i][0] = start;', '        }', '        for(int i = 1; i < k+1; i++){', '            for(int j = 2*i; j < n+1; j++){', '                long val = dp[j][i-1];', '                if(dp[j][i-1] % 2 == 1)', '                    val = dp[j][i-1] + 1000000007;', '                dp[j][i] = (-dp[j-1][i-1] + val/2+1000000007)%1000000007;', '            }', '        }', '        return (int)dp[n][k];', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int t = Integer.parseInt(scanner.nextLine().trim());', '', '        for (int tItr = 0; tItr < t; tItr++) {', '            int arrCount = Integer.parseInt(scanner.nextLine().trim());', '', '            int[] arr = new int[arrCount];', '', '            String[] arrItems = scanner.nextLine().split("" "");', '', '            for (int arrItr = 0; arrItr < arrCount; arrItr++) {', '                int arrItem = Integer.parseInt(arrItems[arrItr].trim());', '                arr[arrItr] = arrItem;', '            }', '', '            int result = beautifulPermutations(arr);', '', '            bufferedWriter.write(String.valueOf(result));', '            bufferedWriter.newLine();', '        }', '', '        bufferedWriter.close();', '    }', '}']"
"['import java.util.*;', 'import java.math.*;', 'import java.io.*;', '', 'public class Solution {', ' static final boolean FILE=false;', ' public static void main(String[] args) throws IOException {', '  startTime=System.currentTimeMillis();', '  if(FILE){rInit(new FileInputStream(""i.txt"")); W=new OutputStreamWriter(new FileOutputStream(""o.txt""));}', '  else{rInit(System.in); W=new OutputStreamWriter(System.out);}', '  B=new StringBuilder();', '  // code starts here (read long if possible)', '  int n=ni();', '        int k=ni();', '        String s=ns();', '        long init=0;', '        qTable=new double[ql];', '        for(int c1=0;c1<ql;c1++) qTable[c1]=-1.0;', '        for(int c1=0;c1<n;c1++){', '            init=init<<1;', ""            if(s.charAt(c1)=='W')   init|=1;"", '        }        ', '        ht=new HashMap<Long,Double>();', '        print(dfs(init,k,n)+""\\n"");', '  // code ends here', '  long totTime=System.currentTimeMillis()-startTime;', '  String outputstr=B.toString(); W.write(outputstr,0,outputstr.length()); W.flush(); W.close();', ' }', '    public static HashMap<Long,Double> ht;', '    static double[] qTable;', '    static int ql=30000000;', '    public static double dfs(long v,int k,int n){', '        if(k==0 || v==0) return 0.0;', '        if(n==0){ ', '            return 0.0;', '        }else if(n==1){', '            if(v==1) return 1.0;', '            else return 0.0;', '        }', '        long index=(v<<5)|k;', '        if(index<ql){', '            if(qTable[(int)index]!=-1.0) return qTable[(int)index];', '        }else{', '            if(ht.containsKey(index)){', '                return (double)ht.get(index);', '            }', '        }', '        double ret=0.0;', '        double prob=1.0/n;', '        for(int x=0;x<n/2;x++){', '            long maskx=-1<<x;', '            long masknx=-1<<(n-1-x);            ', '            long rx=(v&~maskx)|((v>>>1)&maskx);', '            long rnx=(v&~masknx)|((v>>>1)&masknx);', '            //print(v+"" ""+x+"" ""+rx+"" ""+rnx+""\\n"");', '            double ret1=0.0,ret2=0.0;', '            long bitx=(v>>(n-x-1))&1;', '            ret1=prob*(bitx+dfs(rnx,k-1,n-1));', '            long bitnx=(v>>x)&1;', '            ret2=prob*(bitnx+dfs(rx,k-1,n-1));', '            if(ret1>ret2) ret+=ret1;', '            else ret+=ret2;', '        }', '        ret*=2.0;', '        if(n%2==1){', '            long maskm=-1<<(n/2);', '            long rm=(v&~maskm)|((v>>>1)&maskm);', '            //print(v+"" ""+x+"" ""+rx+"" ""+rnx+""\\n"");', '            long bitx=(v>>(n/2))&1;', '            ret+=(prob*(bitx+dfs(rm,k-1,n-1)));', '        }', '        if(index<ql){', '            qTable[(int)index]=ret;', '        }else{', '            ht.put(index,ret);', '        }', '        return ret;', '    } ', ' static void print(int a){B.append(a);}', ' static void print(long a){B.append(a);}', ' static void print(char a){B.append(a);}', ' static void print(double a){B.append(a);}', ' static void print(String a){B.append(a);}', ' static void print(int[] a){B.append(Arrays.toString(a)+""\\n"");}', ' static void trace(Object[] a){B.append(Arrays.deepToString(a)+""\\n"");}', ' static int ni() throws IOException {return Integer.parseInt(ns());}', ' static long nl() throws IOException {return Long.parseLong(ns());}', ' static double nd() throws IOException {return Double.parseDouble(ns());}', ' static int[] nia(int l) throws IOException {int[] a=new int[l]; for(int i=0;i<l;i++) a[i]=ni(); return a;}', ' static long[] nla(int l) throws IOException {long[] a=new long[l]; for(int i=0;i<l;i++) a[i]=nl(); return a;}', ' static double[] nda(int l) throws IOException {double[] a=new double[l]; for(int i=0;i<l;i++) a[i]=nd(); return a;}', ' static String[] nsa(int l) throws IOException {String[] a=new String[l]; for(int i=0;i<l;i++) a[i]=ns(); return a;}', ' static int[][] nia(int r,int c) throws IOException', ' {int[][] a=new int[r][c]; for(int i=0;i<r;i++) for(int j=0;j<c;j++) a[i][j]=ni(); return a;}', ' static String ns() throws IOException', ' {while (!T.hasMoreTokens()) T=new StringTokenizer(R.readLine()); return T.nextToken();}', ' static void rInit(InputStream i){R=new BufferedReader(new InputStreamReader(i)); T=new StringTokenizer("""");}', ' static long startTime=0; static BufferedReader R; static StringTokenizer T; ', ' static OutputStreamWriter W; static StringBuilder B;', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', 'import java.io.*;', 'import java.text.NumberFormat;', 'import java.util.*;', '', 'public class Solution {', '', '  static class IntDoubleHashMap {', '', '    private static final int MAX_LOAD = 90;', '', '    int mask;', '    int len;', '    int size;', '    int deletedCount;', '    int level;', '    boolean zeroKey;', '', '    int maxSize, minSize, maxDeleted;', '', '    public IntDoubleHashMap(int n) {', '      reset(n);', '    }', '', '    void checkSizePut() {', '      if (deletedCount > size) {', '        rehash(level);', '      }', '      if (size + deletedCount >= maxSize) {', '        rehash(level + 1);', '      }', '    }', '', '    void resetInt(int newLevel) {', '      minSize = size * 3 / 4;', '      size = 0;', '      level = newLevel;', '      len = 2 << level;', '      mask = len - 1;', '      maxSize = (int) (len * MAX_LOAD / 100L);', '      deletedCount = 0;', '      maxDeleted = 20 + len / 2;', '    }', '', '    int getIndex(int hash) {', '      return hash & mask;', '    }', '', '    public static final double NOT_FOUND = -1;', '', '    static final int DELETED = 1;', '    int[] keys;', '    double[] values;', '    double zeroValue;', '', '    protected void reset(int newLevel) {', '      resetInt(newLevel);', '      keys = new int[len];', '      values = new double[len];', '    }', '', '    public void put(int key, double value) {', '      if (key == 0) {', '        zeroKey = true;', '        zeroValue = value;', '        return;', '      }', '      try {', '        checkSizePut();', '      } catch (Exception e) {', '', '      }', '      int index = getIndex(key);', '      int plus = 1;', '      int deleted = -1;', '      do {', '        int k = keys[index];', '        if (k == 0) {', '          if (values[index] != DELETED) {', '            if (deleted >= 0) {', '              index = deleted;', '              deletedCount--;', '            }', '            size++;', '            keys[index] = key;', '            values[index] = value;', '            return;', '          }', '          if (deleted < 0) {', '            deleted = index;', '          }', '        } else if (k == key) {', '          values[index] = value;', '          return;', '        }', '        index = (index + plus++) & mask;', '      } while (plus <= len);', '    }', '', '    void rehash(int newLevel) {', '      int[] oldKeys = keys;', '      double[] oldValues = values;', '      reset(newLevel);', '      for (int i = 0; i < oldKeys.length; i++) {', '        int k = oldKeys[i];', '        if (k != 0) {', '          put(k, oldValues[i]);', '        }', '      }', '    }', '    public double get(int key)', '    {', '      if (key == 0) {', '        return zeroKey ? zeroValue : NOT_FOUND;', '      }', '      int index = getIndex(key);', '      int plus = 1;', '      do', '      {', '        int k = keys[index];', '        if (k == 0 && values[index] == 0)', '        {', '          return NOT_FOUND;', '        } else if (k == key)', '        {', '          return values[index];', '        }', '        index = (index + plus++) & mask;', '      } while (plus <= len);', '      return NOT_FOUND;', '    }', '  }', '  static int sub(int word, int bitIndex) {', '    if (bitIndex == 0) {', '      word >>>= 1;', '      return word;', '    }', '    long m = word & ((1 << bitIndex) - 1);', '    word -= word & ((1 << (bitIndex + 1)) - 1);', '    word >>>= 1;', '    word |= m;', '    return word;', '  }', '  static IntDoubleHashMap map;', '  static double giveProbability(int balls, int n, int k) {', '    if (k == 0) {', '      return 0;', '    }', '    int key = balls | (1 << n);', '    double v = map.get(key);', '    if (v >= 0)', '    {', '      return v;', '    }', '    double prob = 0;', '    for (int i = 0; i < n / 2; i++)', '    {', '      int matchL = (balls & (1 << i)) != 0 ? 1 : 0;', '      int matchR = (balls & (1 << (n - i - 1))) != 0 ? 1 : 0;', '      double probL = giveProbability(sub(balls, i), n - 1, k - 1);', '      double probR = giveProbability(sub(balls, n - i - 1), n - 1, k - 1);', '      prob += 2 * Math.max(matchL + probL, probR + matchR) / n;', '    }', '    if (n % 2 == 1)', '    {', '      int i = (n - 1) / 2;', '      int matchM = (balls & (1 << i)) != 0 ? 1 : 0;', '      double probM = giveProbability(sub(balls, i), n - 1, k - 1);', '      prob += (matchM + probM) / n;', '    }', '    map.put(key, prob);', '    balls = reverseBits(balls, n);', '    map.put(balls | (1 << n), prob);', '    return prob;', '  }', '  public static int reverseBits(int n, int nBits)', '  {', '    int rev = 0;', '    while (nBits > 0)', '    {', '      rev <<= 1;', '', '      if ((n & 1) == 1)', '      {', '        rev ^= 1;', '      }', '      n >>= 1;', '      nBits--;', '    }', '    return rev;', '  }', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int n = Integer.parseInt(st.nextToken());', '    int k = Integer.parseInt(st.nextToken());', '    char[] arr = br.readLine().toCharArray();', '    int balls = 0;', '    for (int i = 0; i < arr.length; i++) {', ""      if (arr[i] == 'W') {"", '        balls |= (1L << i);', '      }', '    }', '    if (n >= 29)', '    {', '      map = new IntDoubleHashMap(853);', '    } else if (n > 5)', '    {', '      map = new IntDoubleHashMap(n * n);', '    } else', '    {', '      map = new IntDoubleHashMap(2);', '    }', '    NumberFormat nf = NumberFormat.getInstance();', '    nf.setMaximumFractionDigits(10);', '    double result = giveProbability(balls, arr.length, k);', '    bw.write(nf.format(result));', '    bw.newLine();', '    bw.close();', '    br.close();', '  }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        int m = in.nextInt();', '        int[] a = new int[m];', '        long[] left = new long[m];', '        long[] right = new long[m];', '        long[] prev = new long[m];', '        long[] current = new long[m];', '        long[] leftplus = new long[m];', '        long[] rightplus = new long[m];', '                ', '        for(int A_i = 0; A_i < n; A_i++){', '            for(int A_j = 0; A_j < m; A_j++){', '                a[A_j] = in.nextInt();', '            }', '            ', '            for (int i = 1; i < m; i++)', '            {', '                left[i] = Math.max(left[i - 1] + a[i - 1], 0);', '            }', '            ', '            for (int i = m - 2; i >= 0; i--)', '            {', '                right[i] = Math.max(right[i + 1] + a[i + 1], 0);', '            }', '            ', '            leftplus[0] = prev[0] + a[0];', '            ', '            for (int i = 1; i < m; i++)', '            {', '                leftplus[i] = Math.max(prev[i] + a[i] + left[i], leftplus[i - 1] + a[i]);', '            }', '            ', '            rightplus[m - 1] = prev[m - 1] + a[m - 1];', '            ', '            for (int i = m - 2; i >= 0; i--)', '            {', '                rightplus[i] = Math.max(prev[i] + a[i] + right[i], rightplus[i + 1] + a[i]);', '            }', '            ', '            for (int i = 0; i < m; i++)', '            {', '                current[i] = Math.max(leftplus[i] + right[i], rightplus[i] + left[i]);', '            }', '            ', '            long[] temp = current;', '            current = prev;', '            prev = temp;', '        }', '        ', '        long result = Long.MIN_VALUE;', '        ', '        for (int i = 0; i < m; i++)', '        {', '            result = Math.max(prev[i], result);', '        }', '        ', '        System.out.println(result);', '        in.close();', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '  static int matrixLand(int[][] grid) {', '    int m = grid[0].length;', '    int[][] dp = new int[grid.length][m];', '    int[] msl = new int[m];', '    int[] msr = new int[m];', '    int[] mslit = new int[m];', '    int[] msrit = new int[m];', '    for (int i = 0; i < grid.length; i++) {', '      Arrays.fill(msl, Math.max(grid[i][0], 0));', '      for (int j = 1; j < m; j++) {', '        msl[j] = Math.max(msl[j-1] + grid[i][j], 0);', '      }', '      Arrays.fill(msr, Math.max(grid[i][m-1], 0));', '      for (int j = 1; j < m; j++) {', '        msr[m-1-j] = Math.max(msr[m-j]+grid[i][m-1-j], 0);', '      }', '      Arrays.fill(mslit, grid[i][0]);', '      if (i > 0) {', '        mslit[0] += dp[i-1][0];', '      }', '      dp[i][0] = mslit[0]+msr[1];', '', '      for (int j = 1; j < m; j++) {', '        int top = i==0 ? 0 : dp[i-1][j];', '', '        mslit[j] = Math.max(mslit[j-1], top+msl[j-1])+grid[i][j];', '              ', '        int val = j+2>m ? 0 : msr[j+1];', '        dp[i][j] = mslit[j] + val;', '      }', '      Arrays.fill(msrit, grid[i][m-1]);', '      if (i > 0) {', '        msrit[m-1] += dp[i-1][m-1];', '      }', '', '      dp[i][m-1] = Math.max(dp[i][m-1], msrit[m-1]+msl[m-2]);', '      for (int j = 1; j < m; j++) {', '        int top = i==0 ? 0 : dp[i-1][m-1-j];', '        msrit[m-1-j] = Math.max(msrit[m-j], top+msr[m-j])+grid[i][m-1-j];', '', '        int val = j+2>m ? 0 : msl[m-1-j-1];', '        dp[i][m-1-j] = Math.max(dp[i][m-1-j], msrit[m-1-j] + val);', '      }', '    }', '    int result = dp[grid.length-1][0];', '    for (int j = 1; j < m; j++) {', '      result = Math.max(result, dp[grid.length-1][j]);', '    }', '    ', '    return result;', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int n = Integer.parseInt(st.nextToken());', '    int m = Integer.parseInt(st.nextToken());', '', '    if (m==1) {', '      int result = 0;', '      for (int i = 0; i < n; i++) {', '        st = new StringTokenizer(br.readLine());', '        int item = Integer.parseInt(st.nextToken());', '        result += item;', '      }', '      bw.write(String.valueOf(result));', '    } else {', '      int[][] a = new int[n][m];', '', '      for (int i = 0; i < n; i++) {', '        st = new StringTokenizer(br.readLine());', '', '        for (int j = 0; j < m; j++) {', '          int item = Integer.parseInt(st.nextToken());', '          a[i][j] = item;', '        }', '      }', '', '      int result = matrixLand(a);', '', '      bw.write(String.valueOf(result));', '    }', '    bw.newLine();', '', '    bw.close();', '    br.close();', '  }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    ', '    static int CeilIndex(int A[], int l, int r, int key) ', '   {', '    int m;', ' ', '    while( r - l > 1 ) {', '        m = l + (r - l)/2;', '        if(A[m] >= key ) // ternary expression returns an l-value', '            r = m;', '        else', '            l = m;', '    }', ' ', '    return r;', '}', ' ', 'static int LongestIncreasingSubsequenceLength(int A[], int size) {', '    // Add boundary case, when array size is one', ' ', '    int[] tailTable   = new int[size];', '    int len; // always points empty slot', ' ', '    for(int i=0;i<size;++i)', '        tailTable[i] = 0;', '    ', '    tailTable[0] = A[0];', '    len = 1;', '    for( int i = 1; i < size; i++ ) {', '        if( A[i] < tailTable[0] )', '            // new smallest value', '            tailTable[0] = A[i];', '        else if( A[i] > tailTable[len-1] )', '            // A[i] wants to extend largest subsequence', '            tailTable[len++] = A[i];', '        else', '            // A[i] wants to be current end candidate of an existing subsequence', '            // It will replace ceil value in tailTable', '            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i];', '    }', ' ', '    return len;', '}', ' ', 'public static void main(String[] args) {', '    Scanner sc = new Scanner(System.in);', '        int N = sc.nextInt();', '        int[] arr = new int[N];', '        ', '        for(int i=0;i<N;++i)', '            arr[i] = sc.nextInt();', ' ', '    System.out.println(LongestIncreasingSubsequenceLength(arr, N));', ' ', '}', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner reader = new Scanner(System.in);', '        int n = reader.nextInt();', '        int[] array = new int[n];', '        for(int i = 0 ; i < n; i++ )', '        {', '            array[i] = reader.nextInt();', '        }', '        System.out.println(getLengthOfLIS(array));', '    }', '    public static int getLengthOfLIS(int[] array)', '    {', '        TreeSet<Integer> s = new TreeSet<Integer>();', '        for( int i = 0 ; i < array.length ; i++)', '        {', '           //if array[i] is newly added?', '           if( s.add(array[i]) )', '           {', '               //if array[i] is not the last element?', '               if( array[i] != s.last() )', '               {', ""                    //remove it's next element; s.higher() gives the least element "", '                   //which is greater than array[i]', '                   s.remove(s.higher(array[i]));', '               }', '           }', '        }', '        return s.size();', '    }', '}']"
"['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    static List<Integer>[] adList;', '    static int n, m, diffSum, d;', '    static List<CCGraph> listCC = new ArrayList<CCGraph>();', '    static Map<Integer, Set<CCGraph>> mapCC = new HashMap<Integer, Set<CCGraph>>();', '    ', '    static class CCGraph{', '        int nW, nB;', '        int diff;', '        int whiteNode;', '        int blackNode;', '        int totalNodes;', '        ', '        ', '        public CCGraph(int v) {', '            whiteNode = v;', '        }', '', '        void increaseNode(boolean isWhiteNode) {', '            if(isWhiteNode) {', '                nW++;', '            }else {', '                nB++;', '            } ', '        }', '        ', '        void endInit() {', '            totalNodes = nW + nB;', '            if(nB > 0) {', '                blackNode = adList[whiteNode].get(0);', '            }', '            if(nW < nB) {', '                int temp = nW;', '                nW = nB;', '                nB = temp;', '                temp = whiteNode;', '                whiteNode = blackNode;', '                blackNode = temp;', '            }', '            diff = nW - nB;                        ', '        }', '    }', '    ', '    static class Pair {', '        int nL, nR;', '    ', '        public Pair(int nL, int nR) {', '            this.nL = nL;', '            this.nR = nR;', '        }', '    }', '', '    static int[] blackWhiteTree() {', '        connectedComponents();', '        int k = listCC.size();', '        int maxTotal = 0;', '        for (int i = 0; i < k; i++){', '                CCGraph g = listCC.get(i);', '                int diff = g.diff;', '                diffSum = diffSum+diff;', '                if(g.totalNodes > maxTotal) {', '                    maxTotal = g.totalNodes;', '                }', '        }', '        int[] ans = new int[2*k];', '        if(maxTotal == 1) {', '            ans[0] = n % 2;', '            ans[1] = n-1;', '            for(int i = 1;i < n;i++) {', '                ans[2*i] = i;', '                ans[2*i+1] = i+1;', '            }', '        }else {', '            List<CCGraph> set1 = initMinDiff();', '            List<CCGraph> set2 = new ArrayList<CCGraph>();', '            for(Set<CCGraph> set : mapCC.values()) {', '                set2.addAll(set);', '            }   ', '            ans[0] = d;', '            ans[1] = k-1;', '            CCGraph gL = null;', '            boolean isFS1 = false;', '            for(CCGraph g : set1) {', '                if(g.totalNodes > 1) {', '                    gL = g;', '                    isFS1 = true;', '                    break;', '                }', '            }', '            if(gL == null) {', '                for(CCGraph g : set2) {', '                    if(g.totalNodes > 1) {', '                        gL = g;', '                        break;', '                    }', '                }    ', '            }', '            int p = 1;', '            if(isFS1) {', '                set1.remove(gL);', '                for(CCGraph g : set1) {', '                    ans[2*p] = gL.blackNode;', '                    ans[2*p+1] = g.whiteNode;', '                    p++;', '                }', '                for(CCGraph g : set2) {', '                    ans[2*p] = gL.whiteNode;', '                    ans[2*p+1] = g.whiteNode;', '                    p++;', '                }', '            }else {', '                set2.remove(gL);', '                for(CCGraph g : set1) {', '                    ans[2*p] = gL.whiteNode;', '                    ans[2*p+1] = g.whiteNode;', '                    p++;', '                }', '                for(CCGraph g : set2) {', '                    ans[2*p] = gL.blackNode;', '                    ans[2*p+1] = g.whiteNode;', '                    p++;', '                }', '            }                    ', '        }                ', '        return ans;', '    }', '    ', '    private static List<CCGraph> initMinDiff() {', '        int k = listCC.size();', '        int maxN = diffSum / 2;', '        int[] dp = new int[maxN+1];', '        int[] pr = new int[maxN+1];', '        List<Pair> listP = new ArrayList<Pair>();', '        int[] mp = new int[n+1];', '        for (int i = 0; i < k; i++) {', '            CCGraph g = listCC.get(i);', '            int diff = g.diff;', '            mp[diff]++;', '        }', '        for (int i = 0; i <= n; i++) {', '            if (mp[i] > 0) {', '                listP.add(new Pair(i, mp[i]));', '            }', '        }', '        for (int i = 1; i <= maxN; i++) {', '            dp[i] = -1;', '        }', '        for (int z = 0; z < listP.size(); z++) {', '            int len = listP.get(z).nL;', '            int cnt = listP.get(z).nR;', '            for (int x = 0; x + len <= maxN; x++) {', '                int y = x + len;', '                if (dp[x] != -1 && dp[y] == -1) {', '                    if (pr[x] != len) {', '                        dp[y] = 1;', '                        pr[y] = len;', '                    } else {', '                        if (dp[x] < cnt) {', '                            dp[y] = dp[x] + 1;', '                            pr[y] = len;', '                        }', '                    }', '                }', '            }', '        }', '        int t = maxN;', '        while(dp[t] == -1) {', '            t--;', '        }', '        d = diffSum - 2*t;', '        int cur = t;', '        List<CCGraph> ans = new ArrayList<CCGraph>();', '        while (cur > 0){', '            Set<CCGraph> set = mapCC.get(pr[cur]);', '            CCGraph g = set.iterator().next();', '            ans.add(g);', '            set.remove(g);', '            cur = cur - pr[cur];', '        }        ', '        return ans;', '    }', '', '    static void dfs(int v, boolean[] visited, CCGraph g, boolean isWN) {', '        visited[v] = true;', '        g.increaseNode(isWN);', '        for (int x : adList[v]) {', '            if (!visited[x]) {', '                dfs(x, visited, g, !isWN);', '            }', '        }', '    }', '', '    static void connectedComponents() {', '        boolean[] visited = new boolean[n+1];', '        for (int v = 1; v <= n; v++) {', '            if (!visited[v]) {', '                CCGraph g = new CCGraph(v);', '                listCC.add(g);', '                dfs(v, visited, g, true);    ', '                g.endInit();', '                Set<CCGraph> set = mapCC.get(g.diff);', '                if(set == null) {', '                    set = new HashSet<CCGraph>();', '                    mapCC.put(g.diff, set);', '                }', '                set.add(g);', '            }', '        }', '    }', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 2 * 4096 * 4096);', '        String[] gNodesEdges = reader.readLine().split("" "");', '        n = Integer.parseInt(gNodesEdges[0].trim());', '        m = Integer.parseInt(gNodesEdges[1].trim());', '        adList = new ArrayList[n+1];', '        for (int i = 1; i <= n; i++) {', '            adList[i] = new ArrayList<Integer>();', '        }', '        for (int treeRowItr = 0; treeRowItr < m; treeRowItr++) {', '            String[] treeRowItems = reader.readLine().trim().split("" "");', '            int u = Integer.parseInt(treeRowItems[0]);', '            int v = Integer.parseInt(treeRowItems[1]);', '            adList[u].add(v);', '            adList[v].add(u);            ', '        }', '        int[] result = blackWhiteTree();', '        for (int resultItr = 0;resultItr < result.length;resultItr = resultItr+2) {', '            bufferedWriter.write(String.valueOf(result[resultItr]) + "" "" + String.valueOf(result[resultItr+1]));', '            if (resultItr != result.length - 1) {', '                bufferedWriter.newLine();', '            }', '        }', '        bufferedWriter.newLine();', '        bufferedWriter.close();', '        reader.close();', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    static List<Integer>[] adList;', '    static int n, m, diffSum, d;', '    static List<CCGraph> listCC = new ArrayList<CCGraph>();', '    static Map<Integer, Set<CCGraph>> mapCC = new HashMap<Integer, Set<CCGraph>>();', '    ', '    static class CCGraph{', '        int nW, nB;', '        int diff;', '        int whiteNode;', '        int blackNode;', '        int totalNodes;', '        ', '        ', '        public CCGraph(int v) {', '            whiteNode = v;', '        }', '', '        void increaseNode(boolean isWhiteNode) {', '            if(isWhiteNode) {', '                nW++;', '            }else {', '                nB++;', '            } ', '        }', '        ', '        void endInit() {', '            totalNodes = nW + nB;', '            if(nB > 0) {', '                blackNode = adList[whiteNode].get(0);', '            }', '            if(nW < nB) {', '                int temp = nW;', '                nW = nB;', '                nB = temp;', '                temp = whiteNode;', '                whiteNode = blackNode;', '                blackNode = temp;', '            }', '            diff = nW - nB;                        ', '        }', '    }', '    ', '    static class Pair {', '        int nL, nR;', '    ', '        public Pair(int nL, int nR) {', '            this.nL = nL;', '            this.nR = nR;', '        }', '    }', '', '    static int[] blackWhiteTree() {', '        connectedComponents();', '        int k = listCC.size();', '        int maxTotal = 0;', '        for (int i = 0; i < k; i++){', '                CCGraph g = listCC.get(i);', '                int diff = g.diff;', '                diffSum = diffSum+diff;', '                if(g.totalNodes > maxTotal) {', '                    maxTotal = g.totalNodes;', '                }', '        }', '        int[] ans = new int[2*k];', '        if(maxTotal == 1) {', '            ans[0] = n % 2;', '            ans[1] = n-1;', '            for(int i = 1;i < n;i++) {', '                ans[2*i] = i;', '                ans[2*i+1] = i+1;', '            }', '        }else {', '            List<CCGraph> set1 = initMinDiff();', '            List<CCGraph> set2 = new ArrayList<CCGraph>();', '            for(Set<CCGraph> set : mapCC.values()) {', '                set2.addAll(set);', '            }   ', '            ans[0] = d;', '            ans[1] = k-1;', '            CCGraph gL = null;', '            boolean isFS1 = false;', '            for(CCGraph g : set1) {', '                if(g.totalNodes > 1) {', '                    gL = g;', '                    isFS1 = true;', '                    break;', '                }', '            }', '            if(gL == null) {', '                for(CCGraph g : set2) {', '                    if(g.totalNodes > 1) {', '                        gL = g;', '                        break;', '                    }', '                }    ', '            }', '            int p = 1;', '            if(isFS1) {', '                set1.remove(gL);', '                for(CCGraph g : set1) {', '                    ans[2*p] = gL.blackNode;', '                    ans[2*p+1] = g.whiteNode;', '                    p++;', '                }', '                for(CCGraph g : set2) {', '                    ans[2*p] = gL.whiteNode;', '                    ans[2*p+1] = g.whiteNode;', '                    p++;', '                }', '            }else {', '                set2.remove(gL);', '                for(CCGraph g : set1) {', '                    ans[2*p] = gL.whiteNode;', '                    ans[2*p+1] = g.whiteNode;', '                    p++;', '                }', '                for(CCGraph g : set2) {', '                    ans[2*p] = gL.blackNode;', '                    ans[2*p+1] = g.whiteNode;', '                    p++;', '                }', '            }                    ', '        }                ', '        return ans;', '    }', '    ', '    private static List<CCGraph> initMinDiff() {', '        int k = listCC.size();', '        int maxN = diffSum / 2;', '        int[] dp = new int[maxN+1];', '        int[] pr = new int[maxN+1];', '        List<Pair> listP = new ArrayList<Pair>();', '        int[] mp = new int[n+1];', '        for (int i = 0; i < k; i++) {', '            CCGraph g = listCC.get(i);', '            int diff = g.diff;', '            mp[diff]++;', '        }', '        for (int i = 0; i <= n; i++) {', '            if (mp[i] > 0) {', '                listP.add(new Pair(i, mp[i]));', '            }', '        }', '        for (int i = 1; i <= maxN; i++) {', '            dp[i] = -1;', '        }', '        for (int z = 0; z < listP.size(); z++) {', '            int len = listP.get(z).nL;', '            int cnt = listP.get(z).nR;', '            for (int x = 0; x + len <= maxN; x++) {', '                int y = x + len;', '                if (dp[x] != -1 && dp[y] == -1) {', '                    if (pr[x] != len) {', '                        dp[y] = 1;', '                        pr[y] = len;', '                    } else {', '                        if (dp[x] < cnt) {', '                            dp[y] = dp[x] + 1;', '                            pr[y] = len;', '                        }', '                    }', '                }', '            }', '        }', '        int t = maxN;', '        while(dp[t] == -1) {', '            t--;', '        }', '        d = diffSum - 2*t;', '        int cur = t;', '        List<CCGraph> ans = new ArrayList<CCGraph>();', '        while (cur > 0){', '            Set<CCGraph> set = mapCC.get(pr[cur]);', '            CCGraph g = set.iterator().next();', '            ans.add(g);', '            set.remove(g);', '            cur = cur - pr[cur];', '        }        ', '        return ans;', '    }', '', '    static void dfs(int v, boolean[] visited, CCGraph g, boolean isWN) {', '        visited[v] = true;', '        g.increaseNode(isWN);', '        for (int x : adList[v]) {', '            if (!visited[x]) {', '                dfs(x, visited, g, !isWN);', '            }', '        }', '    }', '', '    static void connectedComponents() {', '        boolean[] visited = new boolean[n+1];', '        for (int v = 1; v <= n; v++) {', '            if (!visited[v]) {', '                CCGraph g = new CCGraph(v);', '                listCC.add(g);', '                dfs(v, visited, g, true);    ', '                g.endInit();', '                Set<CCGraph> set = mapCC.get(g.diff);', '                if(set == null) {', '                    set = new HashSet<CCGraph>();', '                    mapCC.put(g.diff, set);', '                }', '                set.add(g);', '            }', '        }', '    }', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 2 * 4096 * 4096);', '        String[] gNodesEdges = reader.readLine().split("" "");', '        n = Integer.parseInt(gNodesEdges[0].trim());', '        m = Integer.parseInt(gNodesEdges[1].trim());', '        adList = new ArrayList[n+1];', '        for (int i = 1; i <= n; i++) {', '            adList[i] = new ArrayList<Integer>();', '        }', '        for (int treeRowItr = 0; treeRowItr < m; treeRowItr++) {', '            String[] treeRowItems = reader.readLine().trim().split("" "");', '            int u = Integer.parseInt(treeRowItems[0]);', '            int v = Integer.parseInt(treeRowItems[1]);', '            adList[u].add(v);', '            adList[v].add(u);            ', '        }', '        int[] result = blackWhiteTree();', '        for (int resultItr = 0;resultItr < result.length;resultItr = resultItr+2) {', '            bufferedWriter.write(String.valueOf(result[resultItr]) + "" "" + String.valueOf(result[resultItr+1]));', '            if (resultItr != result.length - 1) {', '                bufferedWriter.newLine();', '            }', '        }', '        bufferedWriter.newLine();', '        bufferedWriter.close();', '        reader.close();', '    }', '}']"
"['/*', ' * Anand Oza', ' * October 29, 2011', ' */', '', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.io.StreamTokenizer;', '', 'public class Solution {', ' public static void main(String[] args) throws IOException {', '  StreamTokenizer in = new StreamTokenizer(new InputStreamReader(System.in));', '  in.nextToken();', '  int T = (int) in.nval;', '', '  int ans;', '', '  for (int test = 0; test < T; test++) {', '   in.nextToken();', '   char[] c = in.sval.toCharArray();', '   int[] n = new int[3];', '   for (int i = 0; i < c.length; i++)', ""    n[c[i] - 'a']++;"", '   int x = (n[0] + n[1]) * (n[1] + n[2]) * (n[2] + n[0]);', '   if (x == 0)', '    ans = c.length;', '   else if ((n[0] + n[1]) % 2 == 0 && (n[1] + n[2]) % 2 == 0 && (n[2] + n[0]) % 2 == 0)', '    ans = 2;', '   else', '    ans = 1;', '', '   System.out.println(ans);', '  }', ' }', '}']","['import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.io.StreamTokenizer;', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        StreamTokenizer in = new StreamTokenizer(new InputStreamReader(', '                     System.in));', '        in.nextToken();', '        int T = (int) in.nval;', '', '        int ans;', '', '        for (int test = 0; test < T; test++) {', '            in.nextToken();', '            char[] c = in.sval.toCharArray();', '            int[] n = new int[3];', '            for (int i = 0; i < c.length; i++)', ""                n[c[i] - 'a']++;"", '            int x = (n[0] + n[1]) * (n[1] + n[2]) * (n[2] + n[0]);', '            if (x == 0)', '                ans = c.length;', '            else if ((n[0]+n[1])%2==0 && (n[1]+n[2])%2==0 && (n[2]+n[0])%2==0)', '                ans = 2;', '            else', '                ans = 1;', '', '            System.out.println(ans);', '        }', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'class Solution{', ' ', ' public static void main(String args[]) throws Exception{', '  Scanner in = new Scanner(System.in);', '  int n = in.nextInt();', '  int k = in.nextInt();', '  ', '  int direction[][] = new int[n][n];', '  boolean marked[] = new boolean[n];', '  int pathLength[][] = new int[n][n];', '  ', '  int v1, v2;', '  for(int i=0;i<n-1;i++){', '   v1 = in.nextInt();', '   v2 = in.nextInt();;', '   direction[v1-1][v2-1]=1;', '   direction[v2-1][v1-1]=1;', '  }', '  ', '  getMaxPathLength(direction,marked,pathLength);', '  ', '  /*for(int i=0;i<n;i++){', '   for(int j =0 ; j< n;j++)', '    System.out.print(pathLength[i][j]+"" "");', '   System.out.println();', '  }*/', '  ', '  int i,j;', '  int objectSize=0;', '  Stacks s[] = new Stacks[n];', '  int objectArray[] = new int[n];', '', '  ', '  for(i=0;i<n;i++){', '   for(j=i+1;j<n;j++){', '    if(pathLength[i][j]>k){', '     objectSize+=2;', '     objectArray[i]++;', '     objectArray[j]++;', '     if(s[i]==null)', '      s[i] = new Stacks();', '     s[i].push(j);', '     if(s[j]==null)', '      s[j] = new Stacks();', '     s[j].push(i);', '    }', '   }', '  }', '  ', '  int max;', '  int pos;', '  int counter=0;', '  ', '  while(objectSize>0){', '   max = -1;', '   pos=0;', '   for(i=0;i<n;i++){', '    if(objectArray[i]>max){', '     max = objectArray[i];', '     pos = i;', '    }', '   }', '   ', '   counter++;', '   while(!s[pos].isEmpty()){', '    int val = s[pos].pop();', '    objectArray[val]--;', '   }', '   objectSize = objectSize - 2*objectArray[pos];', '   objectArray[pos]=0;', '  }', '  ', '  System.out.println(counter);', ' }', ' ', ' public static void getMaxPathLength(int direction[][],boolean marked[],int pathLength[][]){', '  int i,j;', '  int maxPathLength;', '  for(i=0;i<marked.length;i++){', '   marked[i] = true;', '   for(j=i+1;j<marked.length;j++){', '    maxPathLength = getMaxPathLength(direction,pathLength,marked,i,j);', '    if(maxPathLength<0){', '     maxPathLength=0;', '    }', '    pathLength[i][j]=maxPathLength;', '    pathLength[j][i]=maxPathLength;', '   }', '   marked[i] = false;', '  }', ' }', ' ', ' public static int getMaxPathLength(int direction[][],int pathLength[][], boolean marked[], int start, int end){', '  //if(direction[start][end]==1000){', '   if(direction[start][end]!=0){', '     return 1;', '   }', '   int i, max, ans= -1000;', '   for(i=0;i<marked.length;i++){', '    if(!marked[i]){', '     if(direction[start][i]>0){', '      marked[i] = true;', '      max = getMaxPathLength(direction,pathLength,marked,i,end);', '      marked[i] = false;', '      if(max>ans)', '       ans = max;', '     }', '    }', '   }', '   return ans + 1;', '  //}', '  //return direction[start][end];', ' }', '}', '', '', 'class StackNode{', ' int data;', ' StackNode next;', ' ', ' public StackNode(int data, StackNode next){', '  this.data = data;', '  this.next = next;', ' }', '}', '', '', 'class Stacks {', ' StackNode head;', ' int size;', '', '    public Stacks() {', '     head = null;', '     size=0;', '    }', '    ', '    public void push(int data){', '     head = new StackNode(data, head);', '     size++;', '    }', '    ', '    public int pop(){', '     StackNode temp = head;', '     head = head.next;', '     size--;', '     return temp.data;', '    }', '    ', '    public int peek(){', '     return head.data;', '    }', '    ', '    public void printStack(){', '     StackNode temp = head;', '     while(temp!=null){', '      System.out.print(temp.data+"" "");', '      temp = temp.next;', '     }', '     System.out.println();', '    }', '    ', '    public boolean isEmpty(){', '     return (size==0? true:false);', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    static int[][] dist;', '    static int[] parent;', '    static ArrayList<ArrayList<Integer>> neighbours;', '    /*', '     * Complete the farVertices function below.', '     */', '    static int farVertices(int n, int k, int[][] edges) {', '        neighbours = new ArrayList<ArrayList<Integer>>();', '', '        int fr, to;', '        parent = new int[n];', '        dist = new int[n][n];', '        for (int i = 0; i < n; i++) {', '            neighbours.add(new ArrayList<Integer>());', '            Arrays.fill(dist[i], -1);', '            dist[i][i] = 0;', '            parent[i] = -1;', '        }', '        for (int[] edge : edges) {', '            fr = edge[0] - 1;', '            to = edge[1] - 1;', '            dist[fr][to] = 1;', '            dist[to][fr] = 1;', '            neighbours.get(fr).add((to));', '            neighbours.get(to).add(fr);', '        }', '        parent[0] = -2;', '        setParents(0);', '        // System.out.println(Arrays.toString(parent));', '            // return -2;', '', '        ', '        int p = -1;', '        for (int i = 0; i < n; i++) {', '            p = parent[i];', '            int d = 1;', '            while (p != -1 && p != -2) {', '                dist[p][i] = d;', '                dist[i][p] = d;', '                d += 1;', '                p = parent[p];', '            }', '        }', '        //printTree(0);', '        ', '', '        int max = 0, num = 0;', '        for (int i = 0; i < n; i++) {', '            for (int j = i + 1; j < n; j++) {', '                if (distance(i, j) == k) {', '                    if ((num = count(i,j,n,k)) > max) {', '                        max = num;', '                    }', '                    /*', '                     * r += rrow[i] ? 0 : 1; c += rcol[j] ? 0 : 1; rrow[i] = true; rcol[j] = true;', '                     */', '                }', '            }', '        }', '        /*', '         * System.out.println(""max = "" + max); System.out.println(""maxi = "" + maxi);', '         * System.out.println(""maxj = "" + maxj); print(dist);', '         */', '        return max == 0 ? 0 : n-max;', '         ', '    }', '    static int count(int i, int j, int n, int k) {', '        int total = 0;', '        for (int m=0; m<n; m++) {', '            if (distance(m,i) <= k && distance(m,j) <= k) {', '                total += 1;', '            }', '        }', '        return total;', '    }', '    static int distance(int fr, int to) {', '        if (dist[fr][to] != -1)', '            return dist[fr][to];', '        ', '        int p = parent[fr];', '        int d = 1;', '        while (p != -2 && dist[p][to] == -1) {', '            d += 1;', '            p = parent[p];', '        }', '        dist[fr][to] = d + dist[p][to];', '        dist[to][fr] = dist[fr][to];', '        return dist[fr][to];', '    }', '    private static void setParents(int i) {', '        ArrayList<Integer> tocheck = new ArrayList<Integer>();', '        for (int child : neighbours.get(i)) {', '            if (parent[child] == -1) {', '                parent[child] = i;', '                tocheck.add(child);', '            }', '        }', '        for (int child : tocheck) {', '            setParents(child);', '        }', '    }', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        String[] nk = scanner.nextLine().split("" "");', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '        int n = Integer.parseInt(nk[0]);', '', '        int k = Integer.parseInt(nk[1]);', '', '        int[][] edges = new int[n-1][2];', '', '        for (int edgesRowItr = 0; edgesRowItr < n-1; edgesRowItr++) {', '            String[] edgesRowItems = scanner.nextLine().split("" "");', '            scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '            for (int edgesColumnItr = 0; edgesColumnItr < 2; edgesColumnItr++) {', '                int edgesItem = Integer.parseInt(edgesRowItems[edgesColumnItr]);', '                edges[edgesRowItr][edgesColumnItr] = edgesItem;', '            }', '        }', '', '        int result = farVertices(n, k, edges);', '', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '', '        bufferedWriter.close();', '', '        scanner.close();', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class E2 {', ' InputStream is;', ' PrintWriter out;', ' String INPUT = """";', ' ', ' void solve()', ' {', '  int n = 100005;', '  long[] a = new long[n];', '  int mod = 663224321;', '  for(int i = 0;i < n;i++){', '   a[i] = pow(2, (long)i*(i-1)/2, mod);', '  }', '  int[][] fif = enumFIF(100005, mod);', '  long[] ta = transformLogarithmically(a, fif);', '  for(int Q = ni();Q > 0;Q--){', '   out.println(ta[ni()]);', '  }', ' }', ' ', ' public static int[][] enumFIF(int n, int mod) {', '  int[] f = new int[n + 1];', '  int[] invf = new int[n + 1];', '  f[0] = 1;', '  for (int i = 1; i <= n; i++) {', '   f[i] = (int) ((long) f[i - 1] * i % mod);', '  }', '  long a = f[n];', '  long b = mod;', '  long p = 1, q = 0;', '  while (b > 0) {', '   long c = a / b;', '   long d;', '   d = a;', '   a = b;', '   b = d % b;', '   d = p;', '   p = q;', '   q = d - c * q;', '  }', '  invf[n] = (int) (p < 0 ? p + mod : p);', '  for (int i = n - 1; i >= 0; i--) {', '   invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);', '  }', '  return new int[][] { f, invf };', ' }', '', ' ', ' public static long pow(long a, long n, long mod) {', '  //  a %= mod;', '  long ret = 1;', '  int x = 63 - Long.numberOfLeadingZeros(n);', '  for (; x >= 0; x--) {', '   ret = ret * ret % mod;', '   if (n << 63 - x < 0)', '    ret = ret * a % mod;', '  }', '  return ret;', ' }', ' ', ' public static int mod = 663224321;', ' public static int G = 3;', ' ', ' public static long[] mul(long[] a, long[] b)', ' {', '  return Arrays.copyOf(convoluteSimply(a, b, mod, G), a.length+b.length-1);', ' }', ' ', ' public static long[] mul(long[] a, long[] b, int lim)', ' {', '  return Arrays.copyOf(convoluteSimply(a, b, mod, G), lim);', ' }', ' ', ' public static long[] mulnaive(long[] a, long[] b)', ' {', '  long[] c = new long[a.length+b.length-1];', '  long big = 8L*mod*mod;', '  for(int i = 0;i < a.length;i++){', '   for(int j = 0;j < b.length;j++){', '    c[i+j] += a[i]*b[j];', '    if(c[i+j] >= big)c[i+j] -= big;', '   }', '  }', '  for(int i = 0;i < c.length;i++)c[i] %= mod;', '  return c;', ' }', ' ', ' public static long[] mulnaive(long[] a, long[] b, int lim)', ' {', '  long[] c = new long[lim];', '  long big = 8L*mod*mod;', '  for(int i = 0;i < a.length;i++){', '   for(int j = 0;j < b.length && i+j < lim;j++){', '    c[i+j] += a[i]*b[j];', '    if(c[i+j] >= big)c[i+j] -= big;', '   }', '  }', '  for(int i = 0;i < c.length;i++)c[i] %= mod;', '  return c;', ' }', ' ', ' public static long[] add(long[] a, long[] b)', ' {', '  long[] c = new long[Math.max(a.length, b.length)];', '  for(int i = 0;i < a.length;i++)c[i] += a[i];', '  for(int i = 0;i < b.length;i++)c[i] += b[i];', '  for(int i = 0;i < c.length;i++)if(c[i] >= mod)c[i] -= mod;', '  return c;', ' }', ' ', ' public static long[] add(long[] a, long[] b, int lim)', ' {', '  long[] c = new long[lim];', '  for(int i = 0;i < a.length && i < lim;i++)c[i] += a[i];', '  for(int i = 0;i < b.length && i < lim;i++)c[i] += b[i];', '  for(int i = 0;i < c.length;i++)if(c[i] >= mod)c[i] -= mod;', '  return c;', ' }', ' ', ' public static long[] sub(long[] a, long[] b)', ' {', '  long[] c = new long[Math.max(a.length, b.length)];', '  for(int i = 0;i < a.length;i++)c[i] += a[i];', '  for(int i = 0;i < b.length;i++)c[i] -= b[i];', '  for(int i = 0;i < c.length;i++)if(c[i] < 0)c[i] += mod;', '  return c;', ' }', ' ', ' public static long[] sub(long[] a, long[] b, int lim)', ' {', '  long[] c = new long[lim];', '  for(int i = 0;i < a.length && i < lim;i++)c[i] += a[i];', '  for(int i = 0;i < b.length && i < lim;i++)c[i] -= b[i];', '  for(int i = 0;i < c.length;i++)if(c[i] < 0)c[i] += mod;', '  return c;', ' }', ' ', ' // F_{t+1}(x) = -F_t(x)^2*P(x) + 2F_t(x)', ' // if want p-destructive, comment out flipping p just before returning.', ' public static long[] inv(long[] p)', ' {', '  int n = p.length;', '  long[] f = {invl(p[0], mod)};', '  for(int i = 0;i < p.length;i++){', '   if(p[i] == 0)continue;', '   p[i] = mod-p[i];', '  }', '  for(int i = 1;i < 2*n;i*=2){', '   long[] f2 = mul(f, f, Math.min(n, 2*i));', '   long[] f2p = mul(f2, Arrays.copyOf(p, i), Math.min(n, 2*i));', '   for(int j = 0;j < f.length;j++){', '    f2p[j] += 2L*f[j];', '    if(f2p[j] >= mod)f2p[j] -= mod;', '    if(f2p[j] >= mod)f2p[j] -= mod;', '   }', '   f = f2p;', '  }', '  for(int i = 0;i < p.length;i++){', '   if(p[i] == 0)continue;', '   p[i] = mod-p[i];', '  }', '  return f;', ' }', ' ', ' // differentiate ', ' public static long[] d(long[] p)', ' {', '  long[] q = new long[p.length];', '  for(int i = 0;i < p.length-1;i++){', '   q[i] = p[i+1] * (i+1) % mod;', '  }', '  return q;', ' }', ' ', ' // integrate', ' public static long[] i(long[] p)', ' {', '  long[] q = new long[p.length];', '  for(int i = 0;i < p.length-1;i++){', '   q[i+1] = p[i] * invl(i+1, mod) % mod;', '  }', '  return q;', ' }', ' ', ' // F_{t+1}(x) = F_t(x)-(ln F_t(x) - P(x)) * F_t(x)', ' public static long[] exp(long[] p)', ' {', '  int n = p.length;', '  long[] f = {p[0]};', '  for(int i = 1;i < 2*n;i*=2){', '   long[] ii = ln(f);', '   long[] sub = sub(ii, p, Math.min(n, 2*i));', '   if(--sub[0] < 0)sub[0] += mod;', '   for(int j = 0;j < 2*i && j < n;j++){', '    sub[j] = mod-sub[j];', '    if(sub[j] == mod)sub[j] = 0;', '   }', '   f = mul(sub, f, Math.min(n, 2*i));', '//   f = sub(f, mul(sub(ii, p, 2*i), f, 2*i));', '  }', '  return f;', ' }', ' ', "" // \\int f'(x)/f(x) dx"", ' public static long[] ln(long[] f)', ' {', '  long[] ret = i(mul(d(f), inv(f)));', '  ret[0] = f[0];', '  return ret;', ' }', ' ', ' // ln F(x) - k ln P(x) = 0', ' public static long[] pow(long[] p, int K)', ' {', '  int n = p.length;', '  long[] lnp = ln(p);', '  for(int i = 1;i < lnp.length;i++)lnp[i] = lnp[i] * K % mod;', '  lnp[0] = pow(p[0], K, mod); // go well for some reason', '  return exp(Arrays.copyOf(lnp, n));', ' }', ' ', ' // destructive', ' public static long[] divf(long[] a, int[][] fif)', ' {', '  for(int i = 0;i < a.length;i++)a[i] = a[i] * fif[1][i] % mod;', '  return a;', ' }', ' ', ' // destructive', ' public static long[] mulf(long[] a, int[][] fif)', ' {', '  for(int i = 0;i < a.length;i++)a[i] = a[i] * fif[0][i] % mod;', '  return a;', ' }', ' ', ' public static long[] transformExponentially(long[] a, int[][] fif)', ' {', '  return mulf(exp(divf(Arrays.copyOf(a, a.length), fif)), fif);', ' }', ' ', ' public static long[] transformLogarithmically(long[] a, int[][] fif)', ' {', '  return mulf(Arrays.copyOf(ln(divf(Arrays.copyOf(a, a.length), fif)), a.length), fif);', ' }', ' ', ' public static long invl(long a, long mod) {', '  long b = mod;', '  long p = 1, q = 0;', '  while (b > 0) {', '   long c = a / b;', '   long d;', '   d = a;', '   a = b;', '   b = d % b;', '   d = p;', '   p = q;', '   q = d - c * q;', '  }', '  return p < 0 ? p + mod : p;', ' }', ' ', ' public static long[] reverse(long[] p)', ' {', '  long[] ret = new long[p.length];', '  for(int i = 0;i < p.length;i++){', '   ret[i] = p[p.length-1-i];', '  }', '  return ret;', ' }', ' ', ' public static long[] reverse(long[] p, int lim)', ' {', '  long[] ret = new long[lim];', '  for(int i = 0;i < lim && i < p.length;i++){', '   ret[i] = p[p.length-1-i];', '  }', '  return ret;', ' }', ' ', ' // [quotient, remainder]', ' // remainder can be empty.', ' // @see http://www.dis.uniroma1.it/~sankowski/lecture4.pdf', ' public static long[][] div(long[] p, long[] q)', ' {', '  if(p.length < q.length)return new long[][]{new long[0], Arrays.copyOf(p, p.length)};', '  long[] rp = reverse(p, p.length-q.length+1);', '  long[] rq = reverse(q, p.length-q.length+1);', '  long[] rd = mul(rp, inv(rq), p.length-q.length+1);', '  long[] d = reverse(rd, p.length-q.length+1);', '  long[] r = sub(p, mul(d, q, q.length-1), q.length-1);', '  return new long[][]{d, r};', ' }', '', ' public static long[] substitute(long[] p, long[] xs)', ' {', '  return descendProductTree(p, buildProductTree(xs));', ' }', ' ', ' public static long[][] buildProductTree(long[] xs)', ' {', '  int m = Integer.highestOneBit(xs.length)*4;', '  long[][] ms = new long[m][];', '  for(int i = 0;i < xs.length;i++){', '   ms[m/2+i] = new long[]{mod-xs[i], 1};', '  }', '  for(int i = m/2-1;i >= 1;i--){', '   if(ms[2*i] == null){', '    ms[i] = null;', '   }else if(ms[2*i+1] == null){', '    ms[i] = ms[2*i];', '   }else{', '    ms[i] = mul(ms[2*i], ms[2*i+1]);', '   }', '  }', '  return ms;', ' }', ' ', ' public static long[] descendProductTree(long[] p, long[][] pt)', ' {', '  long[] rets = new long[pt[1].length-1];', '  dfs(p, pt, 1, rets);', '  return rets;', ' }', ' ', ' private static void dfs(long[] p, long[][] pt, int cur, long[] rets)', ' {', '  if(pt[cur] == null)return;', '  if(cur >= pt.length/2){', '   rets[cur-pt.length/2] = p[0];', '  }else{', '   // F = q1X+r1', '   // F = q2Y+r2', '   ', '   if(p.length >= 1500){', '    if(pt[2*cur+1] != null){', '     long[][] qr0 = div(p, pt[2*cur]);', '     dfs(qr0[1], pt, cur*2, rets);', '     long[][] qr1 = div(p, pt[2*cur+1]);', '     dfs(qr1[1], pt, cur*2+1, rets);', '    }else if(pt[2*cur] != null){', '     long[] nex = cur == 1 ? div(p, pt[2*cur])[1] : p;', '     dfs(nex, pt, cur*2, rets);', '    }', '   }else{', '    if(pt[2*cur+1] != null){', '     dfs(modnaive(p, pt[2*cur]), pt, cur*2, rets);', '     dfs(modnaive(p, pt[2*cur+1]), pt, cur*2+1, rets);', '    }else if(pt[2*cur] != null){', '     long[] nex = cur == 1 ? modnaive(p, pt[2*cur]) : p;', '     dfs(nex, pt, cur*2, rets);', '    }', '   }', '  }', ' }', ' ', ' ', ' public static long[][] divnaive(long[] a, long[] b)', ' {', '  int n = a.length, m = b.length;', '  if(n-m+1 <= 0)return new long[][]{new long[0], Arrays.copyOf(a, n)};', '  long[] r = Arrays.copyOf(a, n);', '  long[] q = new long[n-m+1];', '  long ib = invl(b[m-1], mod);', '  for(int i = n-1;i >= m-1;i--){', '   long x = ib * r[i] % mod;', '   q[i-(m-1)] = x;', '   for(int j = m-1;j >= 0;j--){', '    r[i+j-(m-1)] -= b[j]*x;', '    r[i+j-(m-1)] %= mod;', '    if(r[i+j-(m-1)] < 0)r[i+j-(m-1)] += mod;', '//    r[i+j-(m-1)] = modh(r[i+j-(m-1)]+(long)mod*mod - b[j]*x, MM, HH, mod);', '   }', '  }', '  return new long[][]{q, Arrays.copyOf(r, m-1)};', ' }', ' ', ' public static long[] modnaive(long[] a, long[] b)', ' {', '  int n = a.length, m = b.length;', '  if(n-m+1 <= 0)return a;', '  long[] r = Arrays.copyOf(a, n);', '  long ib = invl(b[m-1], mod);', '  for(int i = n-1;i >= m-1;i--){', '   long x = ib * r[i] % mod;', '   for(int j = m-1;j >= 0;j--){', '    r[i+j-(m-1)] -= b[j]*x;', '    r[i+j-(m-1)] %= mod;', '    if(r[i+j-(m-1)] < 0)r[i+j-(m-1)] += mod;', '//    r[i+j-(m-1)] = modh(r[i+j-(m-1)]+(long)mod*mod - b[j]*x, MM, HH, mod);', '   }', '  }', '  return Arrays.copyOf(r, m-1);', ' }', '', ' public static final int[] NTTPrimes = {1053818881, 1051721729, 1045430273, 1012924417, 1007681537, 1004535809, 998244353, 985661441, 976224257, 975175681};', ' public static final int[] NTTPrimitiveRoots = {7, 6, 3, 5, 3, 3, 3, 3, 3, 17};', '// public static final int[] NTTPrimes = {1012924417, 1004535809, 998244353, 985661441, 975175681, 962592769, 950009857, 943718401, 935329793, 924844033};', '// public static final int[] NTTPrimitiveRoots = {5, 3, 3, 3, 17, 7, 7, 7, 3, 5};', ' ', ' public static long[] convoluteSimply(long[] a, long[] b, int P, int g)', ' {', '  int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);', '  long[] fa = nttmb(a, m, false, P, g);', '  long[] fb = a == b ? fa : nttmb(b, m, false, P, g);', '  for(int i = 0;i < m;i++){', '   fa[i] = fa[i]*fb[i]%P;', '  }', '  return nttmb(fa, m, true, P, g);', ' }', ' ', ' public static long[] convolute(long[] a, long[] b)', ' {', '  int USE = 2;', '  int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);', '  long[][] fs = new long[USE][];', '  for(int k = 0;k < USE;k++){', '   int P = NTTPrimes[k], g = NTTPrimitiveRoots[k];', '   long[] fa = nttmb(a, m, false, P, g);', '   long[] fb = a == b ? fa : nttmb(b, m, false, P, g);', '   for(int i = 0;i < m;i++){', '    fa[i] = fa[i]*fb[i]%P;', '   }', '   fs[k] = nttmb(fa, m, true, P, g);', '  }', '  ', '  int[] mods = Arrays.copyOf(NTTPrimes, USE);', '  long[] gammas = garnerPrepare(mods);', '  int[] buf = new int[USE];', '  for(int i = 0;i < fs[0].length;i++){', '   for(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];', '   long[] res = garnerBatch(buf, mods, gammas);', '   long ret = 0;', '   for(int j = res.length-1;j >= 0;j--)ret = ret * mods[j] + res[j];', '   fs[0][i] = ret;', '  }', '  return fs[0];', ' }', ' ', ' public static long[] convolute(long[] a, long[] b, int USE, int mod)', ' {', '  int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);', '  long[][] fs = new long[USE][];', '  for(int k = 0;k < USE;k++){', '   int P = NTTPrimes[k], g = NTTPrimitiveRoots[k];', '   long[] fa = nttmb(a, m, false, P, g);', '   long[] fb = a == b ? fa : nttmb(b, m, false, P, g);', '   for(int i = 0;i < m;i++){', '    fa[i] = fa[i]*fb[i]%P;', '   }', '   fs[k] = nttmb(fa, m, true, P, g);', '  }', '  ', '  int[] mods = Arrays.copyOf(NTTPrimes, USE);', '  long[] gammas = garnerPrepare(mods);', '  int[] buf = new int[USE];', '  for(int i = 0;i < fs[0].length;i++){', '   for(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];', '   long[] res = garnerBatch(buf, mods, gammas);', '   long ret = 0;', '   for(int j = res.length-1;j >= 0;j--)ret = (ret * mods[j] + res[j]) % mod;', '   fs[0][i] = ret;', '  }', '  return fs[0];', ' }', ' ', ' // static int[] wws = new int[270000]; // outer faster', ' ', ' // Modifed Montgomery + Barrett', ' private static long[] nttmb(long[] src, int n, boolean inverse, int P, int g)', ' {', '  long[] dst = Arrays.copyOf(src, n);', '  ', '  int h = Integer.numberOfTrailingZeros(n);', '  long K = Integer.highestOneBit(P)<<1;', '  int H = Long.numberOfTrailingZeros(K)*2;', '  long M = K*K/P;', '  ', '  int[] wws = new int[1<<h-1];', '  long dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);', '  long w = (1L<<32)%P;', '  for(int k = 0;k < 1<<h-1;k++){', '   wws[k] = (int)w;', '   w = modh(w*dw, M, H, P);', '  }', '  long J = invl(P, 1L<<32);', '  for(int i = 0;i < h;i++){', '   for(int j = 0;j < 1<<i;j++){', '    for(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){', '     long u = (dst[s] - dst[t] + 2*P)*wws[k];', '     dst[s] += dst[t];', '     if(dst[s] >= 2*P)dst[s] -= 2*P;', '//     long Q = (u&(1L<<32)-1)*J&(1L<<32)-1;', '     long Q = (u<<32)*J>>>32;', '     dst[t] = (u>>>32)-(Q*P>>>32)+P;', '    }', '   }', '   if(i < h-1){', '    for(int k = 0;k < 1<<h-i-2;k++)wws[k] = wws[k*2];', '   }', '  }', '  for(int i = 0;i < n;i++){', '   if(dst[i] >= P)dst[i] -= P;', '  }', '  for(int i = 0;i < n;i++){', '   int rev = Integer.reverse(i)>>>-h;', '   if(i < rev){', '    long d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;', '   }', '  }', '  ', '  if(inverse){', '   long in = invl(n, P);', '   for(int i = 0;i < n;i++)dst[i] = modh(dst[i]*in, M, H, P);', '  }', '  ', '  return dst;', ' }', ' ', ' static final long mask = (1L<<31)-1;', ' ', ' public static long modh(long a, long M, int h, int mod)', ' {', '  long r = a-((M*(a&mask)>>>31)+M*(a>>>31)>>>h-31)*mod;', '  return r < mod ? r : r-mod;', ' }', ' ', ' private static long[] garnerPrepare(int[] m)', ' {', '  int n = m.length;', '  assert n == m.length;', '  if(n == 0)return new long[0];', '  long[] gamma = new long[n];', '  for(int k = 1;k < n;k++){', '   long prod = 1;', '   for(int i = 0;i < k;i++){', '    prod = prod * m[i] % m[k];', '   }', '   gamma[k] = invl(prod, m[k]);', '  }', '  return gamma;', ' }', ' ', ' private static long[] garnerBatch(int[] u, int[] m, long[] gamma)', ' {', '  int n = u.length;', '  assert n == m.length;', '  long[] v = new long[n];', '  v[0] = u[0];', '  for(int k = 1;k < n;k++){', '   long temp = v[k-1];', '   for(int j = k-2;j >= 0;j--){', '    temp = (temp * m[j] + v[j]) % m[k];', '   }', '   v[k] = (u[k] - temp) * gamma[k] % m[k];', '   if(v[k] < 0)v[k] += m[k];', '  }', '  return v;', ' }', ' ', ' void run() throws Exception', ' {', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  long s = System.currentTimeMillis();', '  solve();', '  out.flush();', '  if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', ' }', ' ', ' public static void main(String[] args) throws Exception { new E2().run(); }', ' ', ' private byte[] inbuf = new byte[1024];', ' public int lenbuf = 0, ptrbuf = 0;', ' ', ' private int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private double nd() { return Double.parseDouble(ns()); }', ' private char nc() { return (char)skip(); }', ' ', ' private String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class E2 {', '    InputStream is;', '    PrintWriter out;', '    String INPUT = """";', '    ', '    void solve()', '    {', '        int n = 100005;', '        long[] a = new long[n];', '        int mod = 663224321;', '        for(int i = 0;i < n;i++){', '            a[i] = pow(2, (long)i*(i-1)/2, mod);', '        }', '        int[][] fif = enumFIF(100005, mod);', '        long[] ta = transformLogarithmically(a, fif);', '        for(int Q = ni();Q > 0;Q--){', '            out.println(ta[ni()]);', '        }', '    }', '    ', '    public static int[][] enumFIF(int n, int mod) {', '        int[] f = new int[n + 1];', '        int[] invf = new int[n + 1];', '        f[0] = 1;', '        for (int i = 1; i <= n; i++) {', '            f[i] = (int) ((long) f[i - 1] * i % mod);', '        }', '        long a = f[n];', '        long b = mod;', '        long p = 1, q = 0;', '        while (b > 0) {', '            long c = a / b;', '            long d;', '            d = a;', '            a = b;', '            b = d % b;', '            d = p;', '            p = q;', '            q = d - c * q;', '        }', '        invf[n] = (int) (p < 0 ? p + mod : p);', '        for (int i = n - 1; i >= 0; i--) {', '            invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);', '        }', '        return new int[][] { f, invf };', '    }', '', '    ', '    public static long pow(long a, long n, long mod) {', '        //        a %= mod;', '        long ret = 1;', '        int x = 63 - Long.numberOfLeadingZeros(n);', '        for (; x >= 0; x--) {', '            ret = ret * ret % mod;', '            if (n << 63 - x < 0)', '                ret = ret * a % mod;', '        }', '        return ret;', '    }', '    ', '    public static int mod = 663224321;', '    public static int G = 3;', '    ', '    public static long[] mul(long[] a, long[] b)', '    {', '        return Arrays.copyOf(convoluteSimply(a, b, mod, G), a.length+b.length-1);', '    }', '    ', '    public static long[] mul(long[] a, long[] b, int lim)', '    {', '        return Arrays.copyOf(convoluteSimply(a, b, mod, G), lim);', '    }', '    ', '    public static long[] mulnaive(long[] a, long[] b)', '    {', '        long[] c = new long[a.length+b.length-1];', '        long big = 8L*mod*mod;', '        for(int i = 0;i < a.length;i++){', '            for(int j = 0;j < b.length;j++){', '                c[i+j] += a[i]*b[j];', '                if(c[i+j] >= big)c[i+j] -= big;', '            }', '        }', '        for(int i = 0;i < c.length;i++)c[i] %= mod;', '        return c;', '    }', '    ', '    public static long[] mulnaive(long[] a, long[] b, int lim)', '    {', '        long[] c = new long[lim];', '        long big = 8L*mod*mod;', '        for(int i = 0;i < a.length;i++){', '            for(int j = 0;j < b.length && i+j < lim;j++){', '                c[i+j] += a[i]*b[j];', '                if(c[i+j] >= big)c[i+j] -= big;', '            }', '        }', '        for(int i = 0;i < c.length;i++)c[i] %= mod;', '        return c;', '    }', '    ', '    public static long[] add(long[] a, long[] b)', '    {', '        long[] c = new long[Math.max(a.length, b.length)];', '        for(int i = 0;i < a.length;i++)c[i] += a[i];', '        for(int i = 0;i < b.length;i++)c[i] += b[i];', '        for(int i = 0;i < c.length;i++)if(c[i] >= mod)c[i] -= mod;', '        return c;', '    }', '    ', '    public static long[] add(long[] a, long[] b, int lim)', '    {', '        long[] c = new long[lim];', '        for(int i = 0;i < a.length && i < lim;i++)c[i] += a[i];', '        for(int i = 0;i < b.length && i < lim;i++)c[i] += b[i];', '        for(int i = 0;i < c.length;i++)if(c[i] >= mod)c[i] -= mod;', '        return c;', '    }', '    ', '    public static long[] sub(long[] a, long[] b)', '    {', '        long[] c = new long[Math.max(a.length, b.length)];', '        for(int i = 0;i < a.length;i++)c[i] += a[i];', '        for(int i = 0;i < b.length;i++)c[i] -= b[i];', '        for(int i = 0;i < c.length;i++)if(c[i] < 0)c[i] += mod;', '        return c;', '    }', '    ', '    public static long[] sub(long[] a, long[] b, int lim)', '    {', '        long[] c = new long[lim];', '        for(int i = 0;i < a.length && i < lim;i++)c[i] += a[i];', '        for(int i = 0;i < b.length && i < lim;i++)c[i] -= b[i];', '        for(int i = 0;i < c.length;i++)if(c[i] < 0)c[i] += mod;', '        return c;', '    }', '    ', '    // F_{t+1}(x) = -F_t(x)^2*P(x) + 2F_t(x)', '    // if want p-destructive, comment out flipping p just before returning.', '    public static long[] inv(long[] p)', '    {', '        int n = p.length;', '        long[] f = {invl(p[0], mod)};', '        for(int i = 0;i < p.length;i++){', '            if(p[i] == 0)continue;', '            p[i] = mod-p[i];', '        }', '        for(int i = 1;i < 2*n;i*=2){', '            long[] f2 = mul(f, f, Math.min(n, 2*i));', '            long[] f2p = mul(f2, Arrays.copyOf(p, i), Math.min(n, 2*i));', '            for(int j = 0;j < f.length;j++){', '                f2p[j] += 2L*f[j];', '                if(f2p[j] >= mod)f2p[j] -= mod;', '                if(f2p[j] >= mod)f2p[j] -= mod;', '            }', '            f = f2p;', '        }', '        for(int i = 0;i < p.length;i++){', '            if(p[i] == 0)continue;', '            p[i] = mod-p[i];', '        }', '        return f;', '    }', '    ', '    // differentiate    ', '    public static long[] d(long[] p)', '    {', '        long[] q = new long[p.length];', '        for(int i = 0;i < p.length-1;i++){', '            q[i] = p[i+1] * (i+1) % mod;', '        }', '        return q;', '    }', '    ', '    // integrate', '    public static long[] i(long[] p)', '    {', '        long[] q = new long[p.length];', '        for(int i = 0;i < p.length-1;i++){', '            q[i+1] = p[i] * invl(i+1, mod) % mod;', '        }', '        return q;', '    }', '    ', '    // F_{t+1}(x) = F_t(x)-(ln F_t(x) - P(x)) * F_t(x)', '    public static long[] exp(long[] p)', '    {', '        int n = p.length;', '        long[] f = {p[0]};', '        for(int i = 1;i < 2*n;i*=2){', '            long[] ii = ln(f);', '            long[] sub = sub(ii, p, Math.min(n, 2*i));', '            if(--sub[0] < 0)sub[0] += mod;', '            for(int j = 0;j < 2*i && j < n;j++){', '                sub[j] = mod-sub[j];', '                if(sub[j] == mod)sub[j] = 0;', '            }', '            f = mul(sub, f, Math.min(n, 2*i));', '//            f = sub(f, mul(sub(ii, p, 2*i), f, 2*i));', '        }', '        return f;', '    }', '    ', ""    // \\int f'(x)/f(x) dx"", '    public static long[] ln(long[] f)', '    {', '        long[] ret = i(mul(d(f), inv(f)));', '        ret[0] = f[0];', '        return ret;', '    }', '    ', '    // ln F(x) - k ln P(x) = 0', '    public static long[] pow(long[] p, int K)', '    {', '        int n = p.length;', '        long[] lnp = ln(p);', '        for(int i = 1;i < lnp.length;i++)lnp[i] = lnp[i] * K % mod;', '        lnp[0] = pow(p[0], K, mod); // go well for some reason', '        return exp(Arrays.copyOf(lnp, n));', '    }', '    ', '    // destructive', '    public static long[] divf(long[] a, int[][] fif)', '    {', '        for(int i = 0;i < a.length;i++)a[i] = a[i] * fif[1][i] % mod;', '        return a;', '    }', '    ', '    // destructive', '    public static long[] mulf(long[] a, int[][] fif)', '    {', '        for(int i = 0;i < a.length;i++)a[i] = a[i] * fif[0][i] % mod;', '        return a;', '    }', '    ', '    public static long[] transformExponentially(long[] a, int[][] fif)', '    {', '        return mulf(exp(divf(Arrays.copyOf(a, a.length), fif)), fif);', '    }', '    ', '    public static long[] transformLogarithmically(long[] a, int[][] fif)', '    {', '        return mulf(Arrays.copyOf(ln(divf(Arrays.copyOf(a, a.length), fif)), a.length), fif);', '    }', '    ', '    public static long invl(long a, long mod) {', '        long b = mod;', '        long p = 1, q = 0;', '        while (b > 0) {', '            long c = a / b;', '            long d;', '            d = a;', '            a = b;', '            b = d % b;', '            d = p;', '            p = q;', '            q = d - c * q;', '        }', '        return p < 0 ? p + mod : p;', '    }', '    ', '    public static long[] reverse(long[] p)', '    {', '        long[] ret = new long[p.length];', '        for(int i = 0;i < p.length;i++){', '            ret[i] = p[p.length-1-i];', '        }', '        return ret;', '    }', '    ', '    public static long[] reverse(long[] p, int lim)', '    {', '        long[] ret = new long[lim];', '        for(int i = 0;i < lim && i < p.length;i++){', '            ret[i] = p[p.length-1-i];', '        }', '        return ret;', '    }', '    ', '    // [quotient, remainder]', '    // remainder can be empty.', '    // @see http://www.dis.uniroma1.it/~sankowski/lecture4.pdf', '    public static long[][] div(long[] p, long[] q)', '    {', '        if(p.length < q.length)return new long[][]{new long[0], Arrays.copyOf(p, p.length)};', '        long[] rp = reverse(p, p.length-q.length+1);', '        long[] rq = reverse(q, p.length-q.length+1);', '        long[] rd = mul(rp, inv(rq), p.length-q.length+1);', '        long[] d = reverse(rd, p.length-q.length+1);', '        long[] r = sub(p, mul(d, q, q.length-1), q.length-1);', '        return new long[][]{d, r};', '    }', '', '    public static long[] substitute(long[] p, long[] xs)', '    {', '        return descendProductTree(p, buildProductTree(xs));', '    }', '    ', '    public static long[][] buildProductTree(long[] xs)', '    {', '        int m = Integer.highestOneBit(xs.length)*4;', '        long[][] ms = new long[m][];', '        for(int i = 0;i < xs.length;i++){', '            ms[m/2+i] = new long[]{mod-xs[i], 1};', '        }', '        for(int i = m/2-1;i >= 1;i--){', '            if(ms[2*i] == null){', '                ms[i] = null;', '            }else if(ms[2*i+1] == null){', '                ms[i] = ms[2*i];', '            }else{', '                ms[i] = mul(ms[2*i], ms[2*i+1]);', '            }', '        }', '        return ms;', '    }', '    ', '    public static long[] descendProductTree(long[] p, long[][] pt)', '    {', '        long[] rets = new long[pt[1].length-1];', '        dfs(p, pt, 1, rets);', '        return rets;', '    }', '    ', '    private static void dfs(long[] p, long[][] pt, int cur, long[] rets)', '    {', '        if(pt[cur] == null)return;', '        if(cur >= pt.length/2){', '            rets[cur-pt.length/2] = p[0];', '        }else{', '            // F = q1X+r1', '            // F = q2Y+r2', '            ', '            if(p.length >= 1500){', '                if(pt[2*cur+1] != null){', '                    long[][] qr0 = div(p, pt[2*cur]);', '                    dfs(qr0[1], pt, cur*2, rets);', '                    long[][] qr1 = div(p, pt[2*cur+1]);', '                    dfs(qr1[1], pt, cur*2+1, rets);', '                }else if(pt[2*cur] != null){', '                    long[] nex = cur == 1 ? div(p, pt[2*cur])[1] : p;', '                    dfs(nex, pt, cur*2, rets);', '                }', '            }else{', '                if(pt[2*cur+1] != null){', '                    dfs(modnaive(p, pt[2*cur]), pt, cur*2, rets);', '                    dfs(modnaive(p, pt[2*cur+1]), pt, cur*2+1, rets);', '                }else if(pt[2*cur] != null){', '                    long[] nex = cur == 1 ? modnaive(p, pt[2*cur]) : p;', '                    dfs(nex, pt, cur*2, rets);', '                }', '            }', '        }', '    }', '    ', '    ', '    public static long[][] divnaive(long[] a, long[] b)', '    {', '        int n = a.length, m = b.length;', '        if(n-m+1 <= 0)return new long[][]{new long[0], Arrays.copyOf(a, n)};', '        long[] r = Arrays.copyOf(a, n);', '        long[] q = new long[n-m+1];', '        long ib = invl(b[m-1], mod);', '        for(int i = n-1;i >= m-1;i--){', '            long x = ib * r[i] % mod;', '            q[i-(m-1)] = x;', '            for(int j = m-1;j >= 0;j--){', '                r[i+j-(m-1)] -= b[j]*x;', '                r[i+j-(m-1)] %= mod;', '                if(r[i+j-(m-1)] < 0)r[i+j-(m-1)] += mod;', '//                r[i+j-(m-1)] = modh(r[i+j-(m-1)]+(long)mod*mod - b[j]*x, MM, HH, mod);', '            }', '        }', '        return new long[][]{q, Arrays.copyOf(r, m-1)};', '    }', '    ', '    public static long[] modnaive(long[] a, long[] b)', '    {', '        int n = a.length, m = b.length;', '        if(n-m+1 <= 0)return a;', '        long[] r = Arrays.copyOf(a, n);', '        long ib = invl(b[m-1], mod);', '        for(int i = n-1;i >= m-1;i--){', '            long x = ib * r[i] % mod;', '            for(int j = m-1;j >= 0;j--){', '                r[i+j-(m-1)] -= b[j]*x;', '                r[i+j-(m-1)] %= mod;', '                if(r[i+j-(m-1)] < 0)r[i+j-(m-1)] += mod;', '//                r[i+j-(m-1)] = modh(r[i+j-(m-1)]+(long)mod*mod - b[j]*x, MM, HH, mod);', '            }', '        }', '        return Arrays.copyOf(r, m-1);', '    }', '', '    public static final int[] NTTPrimes = {1053818881, 1051721729, 1045430273, 1012924417, 1007681537, 1004535809, 998244353, 985661441, 976224257, 975175681};', '    public static final int[] NTTPrimitiveRoots = {7, 6, 3, 5, 3, 3, 3, 3, 3, 17};', '//    public static final int[] NTTPrimes = {1012924417, 1004535809, 998244353, 985661441, 975175681, 962592769, 950009857, 943718401, 935329793, 924844033};', '//    public static final int[] NTTPrimitiveRoots = {5, 3, 3, 3, 17, 7, 7, 7, 3, 5};', '    ', '    public static long[] convoluteSimply(long[] a, long[] b, int P, int g)', '    {', '        int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);', '        long[] fa = nttmb(a, m, false, P, g);', '        long[] fb = a == b ? fa : nttmb(b, m, false, P, g);', '        for(int i = 0;i < m;i++){', '            fa[i] = fa[i]*fb[i]%P;', '        }', '        return nttmb(fa, m, true, P, g);', '    }', '    ', '    public static long[] convolute(long[] a, long[] b)', '    {', '        int USE = 2;', '        int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);', '        long[][] fs = new long[USE][];', '        for(int k = 0;k < USE;k++){', '            int P = NTTPrimes[k], g = NTTPrimitiveRoots[k];', '            long[] fa = nttmb(a, m, false, P, g);', '            long[] fb = a == b ? fa : nttmb(b, m, false, P, g);', '            for(int i = 0;i < m;i++){', '                fa[i] = fa[i]*fb[i]%P;', '            }', '            fs[k] = nttmb(fa, m, true, P, g);', '        }', '        ', '        int[] mods = Arrays.copyOf(NTTPrimes, USE);', '        long[] gammas = garnerPrepare(mods);', '        int[] buf = new int[USE];', '        for(int i = 0;i < fs[0].length;i++){', '            for(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];', '            long[] res = garnerBatch(buf, mods, gammas);', '            long ret = 0;', '            for(int j = res.length-1;j >= 0;j--)ret = ret * mods[j] + res[j];', '            fs[0][i] = ret;', '        }', '        return fs[0];', '    }', '    ', '    public static long[] convolute(long[] a, long[] b, int USE, int mod)', '    {', '        int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);', '        long[][] fs = new long[USE][];', '        for(int k = 0;k < USE;k++){', '            int P = NTTPrimes[k], g = NTTPrimitiveRoots[k];', '            long[] fa = nttmb(a, m, false, P, g);', '            long[] fb = a == b ? fa : nttmb(b, m, false, P, g);', '            for(int i = 0;i < m;i++){', '                fa[i] = fa[i]*fb[i]%P;', '            }', '            fs[k] = nttmb(fa, m, true, P, g);', '        }', '        ', '        int[] mods = Arrays.copyOf(NTTPrimes, USE);', '        long[] gammas = garnerPrepare(mods);', '        int[] buf = new int[USE];', '        for(int i = 0;i < fs[0].length;i++){', '            for(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];', '            long[] res = garnerBatch(buf, mods, gammas);', '            long ret = 0;', '            for(int j = res.length-1;j >= 0;j--)ret = (ret * mods[j] + res[j]) % mod;', '            fs[0][i] = ret;', '        }', '        return fs[0];', '    }', '    ', '    // static int[] wws = new int[270000]; // outer faster', '    ', '    // Modifed Montgomery + Barrett', '    private static long[] nttmb(long[] src, int n, boolean inverse, int P, int g)', '    {', '        long[] dst = Arrays.copyOf(src, n);', '        ', '        int h = Integer.numberOfTrailingZeros(n);', '        long K = Integer.highestOneBit(P)<<1;', '        int H = Long.numberOfTrailingZeros(K)*2;', '        long M = K*K/P;', '        ', '        int[] wws = new int[1<<h-1];', '        long dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);', '        long w = (1L<<32)%P;', '        for(int k = 0;k < 1<<h-1;k++){', '            wws[k] = (int)w;', '            w = modh(w*dw, M, H, P);', '        }', '        long J = invl(P, 1L<<32);', '        for(int i = 0;i < h;i++){', '            for(int j = 0;j < 1<<i;j++){', '                for(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){', '                    long u = (dst[s] - dst[t] + 2*P)*wws[k];', '                    dst[s] += dst[t];', '                    if(dst[s] >= 2*P)dst[s] -= 2*P;', '//                    long Q = (u&(1L<<32)-1)*J&(1L<<32)-1;', '                    long Q = (u<<32)*J>>>32;', '                    dst[t] = (u>>>32)-(Q*P>>>32)+P;', '                }', '            }', '            if(i < h-1){', '                for(int k = 0;k < 1<<h-i-2;k++)wws[k] = wws[k*2];', '            }', '        }', '        for(int i = 0;i < n;i++){', '            if(dst[i] >= P)dst[i] -= P;', '        }', '        for(int i = 0;i < n;i++){', '            int rev = Integer.reverse(i)>>>-h;', '            if(i < rev){', '                long d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;', '            }', '        }', '        ', '        if(inverse){', '            long in = invl(n, P);', '            for(int i = 0;i < n;i++)dst[i] = modh(dst[i]*in, M, H, P);', '        }', '        ', '        return dst;', '    }', '    ', '    static final long mask = (1L<<31)-1;', '    ', '    public static long modh(long a, long M, int h, int mod)', '    {', '        long r = a-((M*(a&mask)>>>31)+M*(a>>>31)>>>h-31)*mod;', '        return r < mod ? r : r-mod;', '    }', '    ', '    private static long[] garnerPrepare(int[] m)', '    {', '        int n = m.length;', '        assert n == m.length;', '        if(n == 0)return new long[0];', '        long[] gamma = new long[n];', '        for(int k = 1;k < n;k++){', '            long prod = 1;', '            for(int i = 0;i < k;i++){', '                prod = prod * m[i] % m[k];', '            }', '            gamma[k] = invl(prod, m[k]);', '        }', '        return gamma;', '    }', '    ', '    private static long[] garnerBatch(int[] u, int[] m, long[] gamma)', '    {', '        int n = u.length;', '        assert n == m.length;', '        long[] v = new long[n];', '        v[0] = u[0];', '        for(int k = 1;k < n;k++){', '            long temp = v[k-1];', '            for(int j = k-2;j >= 0;j--){', '                temp = (temp * m[j] + v[j]) % m[k];', '            }', '            v[k] = (u[k] - temp) * gamma[k] % m[k];', '            if(v[k] < 0)v[k] += m[k];', '        }', '        return v;', '    }', '    ', '    void run() throws Exception', '    {', '        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        long s = System.currentTimeMillis();', '        solve();', '        out.flush();', '        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', '    }', '    ', '    public static void main(String[] args) throws Exception { new E2().run(); }', '    ', '    private byte[] inbuf = new byte[1024];', '    public int lenbuf = 0, ptrbuf = 0;', '    ', '    private int readByte()', '    {', '        if(lenbuf == -1)throw new InputMismatchException();', '        if(ptrbuf >= lenbuf){', '            ptrbuf = 0;', '            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '            if(lenbuf <= 0)return -1;', '        }', '        return inbuf[ptrbuf++];', '    }', '    ', '    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', '    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', '    ', '    private double nd() { return Double.parseDouble(ns()); }', '    private char nc() { return (char)skip(); }', '    ', '    private String ns()', '    {', '        int b = skip();', '        StringBuilder sb = new StringBuilder();', ""        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '            sb.appendCodePoint(b);', '            b = readByte();', '        }', '        return sb.toString();', '    }', '    ', '    private char[] ns(int n)', '    {', '        char[] buf = new char[n];', '        int b = skip(), p = 0;', '        while(p < n && !(isSpaceChar(b))){', '            buf[p++] = (char)b;', '            b = readByte();', '        }', '        return n == p ? buf : Arrays.copyOf(buf, p);', '    }', '    ', '    private char[][] nm(int n, int m)', '    {', '        char[][] map = new char[n][];', '        for(int i = 0;i < n;i++)map[i] = ns(m);', '        return map;', '    }', '    ', '    private int[] na(int n)', '    {', '        int[] a = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        return a;', '    }', '    ', '    private int ni()', '    {', '        int num = 0, b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private long nl()', '    {', '        long num = 0;', '        int b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class C {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  int n = ni(), H = ni(), dr = ni();', '  int[][] al = new int[H+1][n];', '  for(int i = 0;i < n;i++){', '   int K = ni();', '   for(int j = 0;j < K;j++){', '    al[ni()][i]++;', '   }', '  }', '  ', '  int[][] dp = new int[H+2][n];', '  for(int h = H+1;h >= 1;h--){', '   int rowmax = 0;', '   for(int i = 0;i < n;i++){', '    dp[h-1][i] = Math.max(dp[h-1][i], dp[h][i] + al[h-1][i]);', '    rowmax = Math.max(rowmax, dp[h][i]);', '   }', '   if(h-dr >= 0){', '    for(int i = 0;i < n;i++){', '     dp[h-dr][i] = Math.max(dp[h-dr][i], rowmax + al[h-dr][i]); ', '    }', '   }', '  }', '  int ret = 0;', '  for(int i = 0;i < n;i++){', '   ret = Math.max(ret, dp[0][i]);', '  }', '  out.println(ret);', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class SupermanCelebratesDiwali {', '    static InputStream is;', '    static PrintWriter out;', '    static String INPUT = """";', '    ', '    static void solve()', '    {', '        int n = ni(), H = ni(), dr = ni();', '        int[][] al = new int[H+1][n];', '        for(int i = 0;i < n;i++){', '            int K = ni();', '            for(int j = 0;j < K;j++){', '                al[ni()][i]++;', '            }', '        }', '        ', '        int[][] dp = new int[H+2][n];', '        for(int h = H+1;h >= 1;h--){', '            int rowmax = 0;', '            for(int i = 0;i < n;i++){', '                dp[h-1][i] = Math.max(dp[h-1][i], dp[h][i] + al[h-1][i]);', '                rowmax = Math.max(rowmax, dp[h][i]);', '            }', '            if(h-dr >= 0){', '                for(int i = 0;i < n;i++){', '                    dp[h-dr][i] = Math.max(dp[h-dr][i], rowmax + al[h-dr][i]); ', '                }', '            }', '        }', '        int ret = 0;', '        for(int i = 0;i < n;i++){', '            ret = Math.max(ret, dp[0][i]);', '        }', '        out.println(ret);', '    }', '    ', '    public static void main(String[] args) throws Exception', '    {', '        long S = System.currentTimeMillis();', '        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        solve();', '        out.flush();', '        long G = System.currentTimeMillis();', '        tr(G-S+""ms"");', '    }', '    ', '    private static boolean eof()', '    {', '        if(lenbuf == -1)return true;', '        int lptr = ptrbuf;', '        while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '        ', '        try {', '            is.mark(1000);', '            while(true){', '                int b = is.read();', '                if(b == -1){', '                    is.reset();', '                    return true;', '                }else if(!isSpaceChar(b)){', '                    is.reset();', '                    return false;', '                }', '            }', '        } catch (IOException e) {', '            return true;', '        }', '    }', '    ', '    private static byte[] inbuf = new byte[1024];', '    static int lenbuf = 0, ptrbuf = 0;', '    ', '    private static int readByte()', '    {', '        if(lenbuf == -1)throw new InputMismatchException();', '        if(ptrbuf >= lenbuf){', '            ptrbuf = 0;', '            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '            if(lenbuf <= 0)return -1;', '        }', '        return inbuf[ptrbuf++];', '    }', '    ', '    private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', '    private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', '    ', '    private static double nd() { return Double.parseDouble(ns()); }', '    private static char nc() { return (char)skip(); }', '    ', '    private static String ns()', '    {', '        int b = skip();', '        StringBuilder sb = new StringBuilder();', ""        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '            sb.appendCodePoint(b);', '            b = readByte();', '        }', '        return sb.toString();', '    }', '    ', '    private static char[] ns(int n)', '    {', '        char[] buf = new char[n];', '        int b = skip(), p = 0;', '        while(p < n && !(isSpaceChar(b))){', '            buf[p++] = (char)b;', '            b = readByte();', '        }', '        return n == p ? buf : Arrays.copyOf(buf, p);', '    }', '    ', '    private static char[][] nm(int n, int m)', '    {', '        char[][] map = new char[n][];', '        for(int i = 0;i < n;i++)map[i] = ns(m);', '        return map;', '    }', '    ', '    private static int[] na(int n)', '    {', '        int[] a = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        return a;', '    }', '    ', '    private static int ni()', '    {', '        int num = 0, b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static long nl()', '    {', '        long num = 0;', '        int b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  for(int T = ni();T >= 1;T--){', '   int n = ni();', '   char[] a = ns(n);', '   char[] b = ns(n);', '   boolean[] ok = new boolean[1<<2*n];', '   int ini = 0;', '   for(int i = 0;i < n;i++){', ""    if(a[i] == '1')ini |= 1<<2*i;"", ""    if(b[i] == '1')ini |= 1<<2*i+1;"", '   }', '   if(Integer.bitCount(ini) % 2 == 0){', '    ok[ini] = true;', '    for(int i = ini;i < (1<<2*n)-1;i++){', '     if(ok[i]){', '      int j = Integer.numberOfTrailingZeros(~i);', '      if(j+1 < 2*n && i<<31-(j+1)>=0){', '       ok[i|1<<j|1<<j+1] = true;', '      }', '      if(j+2 < 2*n && i<<31-(j+2)>=0){', '       ok[i|1<<j|1<<j+2] = true;', '      }', '     }', '    }', '   }', '   out.println(ok[(1<<2*n)-1] ? ""YES"" : ""NO"");', '  }', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(System.in);', '        int T = sc.nextInt();', '        while(T>0){', '            int n = sc.nextInt();', '            List<Integer> cells = new ArrayList<>();', '            fillArr(cells, sc.next());', '            fillArr(cells, sc.next());', '            if(tile(cells)){', '                System.out.println(""YES"");', '            } else {', '                System.out.println(""NO"");', '            }', '            T--;', '        }        ', '    }', '    ', '   private static void fillArr(List<Integer> arr, String data) {', '        for (int i = 0; i < data.length(); i++) {', ""            arr.add(data.charAt(i) - '0');"", '        }', '    }', '    ', '    public static boolean tile(List<Integer> list) {', '        // set i+n, i+n-1, i+1 cells', '        int cSize = list.size() / 2;', '        Deque<List<Integer>> deque = new ArrayDeque<>();', '        deque.addFirst(list);', '        while (!deque.isEmpty()) {', '            List<Integer> cells = deque.removeLast();', '            int index = getFreeCellIndex(cells);', '            if (index < 0) return true;', '            if (index != cSize - 1)', '                tilePossibleCells(deque, cells, index, index + 1);', '            if (index != 0 && index != cSize)', '                tilePossibleCells(deque, cells, index, index + cSize - 1);', '            tilePossibleCells(deque, cells, index, index + cSize);', '        }', '        return false;', '    }', '', '    private static void tilePossibleCells(Deque<List<Integer>> deque, List<Integer> cells, int index, int next) {', '        if (next < cells.size()) {', '            if (cells.get(next) == 0) {', '                ArrayList<Integer> newCell = new ArrayList<>(cells);', '                newCell.set(next, 5);', '                newCell.set(index, 5);', '                //      System.out.println(""added: "" + newCell);', '                deque.addFirst(newCell);', '            }', '        }', '    }', '', '    private static int getFreeCellIndex(List<Integer> cells) {', '        for (int i = 0; i < cells.size(); i++) {', '            if (cells.get(i) == 0) return i;', '        }', '        return -1;', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  for(int T = ni();T >= 1;T--){', '   int n = ni(), m = ni();', '   char[][] map = nm(n,m);', '   int[][][] pre = new int[1<<m][1<<m-1][1<<m-1];', '   int[][][] cur = new int[1<<m][1<<m-1][1<<m-1];', '   pre[0][0][0] = 1;', '   ', '   int mod = 1000000007;', '   for(int i = 0;i < n;i++){', '    for(int j = 0;j < 1<<m;j++){', '     for(int k = 0;k < 1<<m-1;k++){', '      for(int l = 0;l < 1<<m-1;l++){', '       cur[j][k][l] = 0;', '      }', '     }', '    }', '    ', '    int[] puts = new int[1<<m];', '    int pp = 0;', '    int block = 0;', '    for(int j = 0;j < m;j++){', ""     if(map[i][j] == '#')block|=1<<j;"", '    }', '    ', '    inner:', '    for(int put = 0;put < 1<<m;put++){', '     if((put&block) != 0)continue;', '     boolean blocked = true;', '     for(int j = 0;j < m;j++){', '      if(put<<31-j<0){', '       if(!blocked)continue inner;', '       blocked = false;', ""      }else if(map[i][j] == '#'){"", '       blocked = true;', '      }', '     }', '     puts[pp++] = put;', '    }', '    ', '    for(int j = 0;j < 1<<m;j++){', '     for(int k = 0;k < 1<<m-1;k++){', '      for(int l = 0;l < 1<<m-1;l++){', '       if(pre[j][k][l] == 0)continue;', '       int ng = j|k<<1|l;', '       for(int u = 0;u < pp;u++){', '        int put = puts[u];', '        if((put&ng) != 0)continue;', '        int nj = (j|put)&~block;', '        int nk = (k<<1|put)&~block&(1<<m-1)-1;', '        int nl = ((l|put)&~block)>>>1;', '        cur[nj][nk][nl] += pre[j][k][l];', '        if(cur[nj][nk][nl] >= mod)cur[nj][nk][nl] -= mod;', '       }', '      }', '     }', '    }', '    ', '    int[][][] dum = cur; cur = pre; pre = dum;', '   }', '   ', '   long ret = mod-1;', '   for(int j = 0;j < 1<<m;j++){', '    for(int k = 0;k < 1<<m-1;k++){', '     for(int l = 0;l < 1<<m-1;l++){', '      ret += pre[j][k][l];', '     }', '    }', '   }', '   out.println(ret%mod);', '  }', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'class Solution {', '    static int NS = 50;', '    static int MS = 5;', '    static int K = 32;', '    static int[][][][]s = new int[NS][K][K][K];', '    static int AK;', '    static int[][] mp= new int[NS][MS];', '', '    static int n;', '    static int m;', '    ', '    static int dp(int c, int b1, int b2, int b3) {', '          if (c == n) return 1;', '          if (s[c][b1][b2][b3] >= 0) return s[c][b1][b2][b3];', '          /*', ""          System.out.print(c);System.out.print(' ');"", ""          System.out.print(b1);System.out.print(' ');"", ""          System.out.print(b2);System.out.print(' ');"", ""          System.out.print(b3);System.out.print(' ');"", '          System.out.println();', '          */', '          int sum = 0;', '          for (int i = 0; i < AK; i++) {', '                if (check(c,i,b1,b2,b3)){', '                    int[] mask = mask(c,i,b1,b2,b3);', '                    /*', '                    System.out.print(c);', '                    System.out.println(i);', '                    */', '                    sum = (sum+dp(c+1, mask[0],mask[1],mask[2]))%1000000007;', '                }', '          }', '          s[c][b1][b2][b3] = sum;', '          return sum;', '    }', '    ', '    static boolean check(int c, int i, int b1, int b2, int b3) {', '        int[] loc = {1,2,4,8,16};', '        boolean selfblock = false;', '        ', '        //check other block', '        for (int li = 0; li < m; li++) {', '            if ((i&loc[li]) != 0) {', '                if (mp[c][li] == 0) return false;', '                if (selfblock == true) return false;', '                ', '                if ((b1&loc[li]) !=0 || (b2&loc[li]) !=0|| (b3&loc[li]) !=0) return false;', '                ', '                selfblock = true;', '            }', '            ', '            if (mp[c][li] == 0) selfblock = false;', '        }', '        ', '        return true;', '    }', '    ', '    static int[] mask(int c, int i, int b1, int b2, int b3){', '        int[] loc = {1,2,4,8,16};', '        int[] mask = new int[3];', '        mask[0] = b1|i;', '        mask[1] = ((b2 << 1) % K) | ((i << 1) % K);', '        mask[2] = (b3 >> 1) | (i >> 1);', '        for (int li = 0; li < m; li++){', '            if(mp[c][li] == 0) {', '                mask[0] = mask[0] & (~loc[li]);', '                mask[1] = mask[1] & (~(loc[li] << 1)%K);', '                mask[2] = mask[2] & (~(loc[li] >> 1));', '            }', '        }', '        ', '        return mask;', '    }', '        ', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int TN = in.nextInt();', '        ', '        for (int ti = 0; ti < TN; ti++) {', '            n = in.nextInt();', '            m = in.nextInt();', '            String str[] = new String[n];', '            for(int i=0; i<n; i++)', '                str[i] = in.next();', '            for (int i = 0; i < n; i++)', '            for (int j = 0; j < m; j++) {', '                mp[i][j] = 1;', ""                if (str[i].charAt(j) == '#')"", '                    mp[i][j] = 0;', '            }', '            ', '            for (int i1 = 0; i1 < n; i1++)', '            for (int i2 = 0; i2 < K; i2++)', '            for (int i3 = 0; i3 < K; i3++)', '            for (int i4 = 0; i4 < K; i4++)', '                s[i1][i2][i3][i4] = -1;', '            ', '            AK = 1;', '            for (int i =0; i< m; i++)', '                AK = AK *2;', '        ', '            int r = dp(0,0,0,0);', '            System.out.println((r+1000000007-1) % 1000000007);', '        }', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        int MOD = 1000000007;', '        Scanner sc = new Scanner(System.in);', '        int q = sc.nextInt();', '        for (int z = 0; z < q; z++) {', '            int n = sc.nextInt();', '            String[] as = new String[n];', '            int[] lens = new int[n+1];', '            StringBuilder sb = new StringBuilder();', '            for (int i = 0; i < n; i++) {', '                as[i] = sc.next();', '                lens[i+1] = lens[i] + as[i].length();', '                sb.append(as[i]);', '            }', '            String s = sb.toString();', '            int suma = lens[n];', '            int[][] validPal = new int[suma][suma];', '            int[][] needsLeftPal = new int[suma][suma];', '            int[][] needsRightPal = new int[suma][suma];', '            int[][] needsBothPal = new int[suma][suma];', '            for (int i = 0; i < suma; i++) {', '                validPal[i][i] = 1;', '                if (i>0&&s.charAt(i)==s.charAt(i-1))', '                    validPal[i-1][i] = 3;', '                else if (i>0)', '                    validPal[i-1][i] = 2;', '            }', '            for (int i = 0; i < n; i++) {', '                for (int k = lens[i]; k+1 < lens[i+1]; k++) {', '                    if (s.charAt(k)==s.charAt(k+1))', '                        validPal[k][k+1] = 3;', '                    else', '                        validPal[k][k+1] = 2;', '                }', '                for (int j = 2; j < as[i].length(); j++) {', '                    for (int k = lens[i]; k+j < lens[i+1]; k++) {', '                        validPal[k][k+j] = (validPal[k+1][k+j]+validPal[k][k+j-1]-validPal[k+1][k+j-1])%MOD;', '                        if (validPal[k][k+j]<0)', '                            validPal[k][k+j] += MOD;', '                        if (s.charAt(k)==s.charAt(k+j)) {', '                            validPal[k][k+j] += validPal[k+1][k+j-1]+1;', '                            validPal[k][k+j] %= MOD;', '                        }', '                    }', '                }', '            }', '            for (int a = 1; a < n; a++) {', '                for (int b = 0; a+b < n; b++) {', '                    int c = a+b;', '                    for (int d = lens[b+1]-1; d >= lens[b]; d--) {', '                        for (int e = lens[c]; e < lens[c+1]; e++) {', '                            if (e==d+1) {', '                                if (s.charAt(d)==s.charAt(e))', '                                    validPal[d][e] = 1;', '                                else', '                                 validPal[d][e] = 0;', '                                needsLeftPal[d][e] = 1;', '                                needsRightPal[d][e] = 1;', '                            } else if (d==lens[b+1]-1&&e==lens[c]) {', '                                if (s.charAt(d)==s.charAt(e))', '                                    validPal[d][e] = validPal[d+1][e-1]+(a==1?1:0);', '                                needsLeftPal[d][e] = validPal[d+1][e];', '                                needsRightPal[d][e] = validPal[d][e-1];', '                                needsBothPal[d][e] = validPal[d+1][e-1];', '                            } else if (d==lens[b+1]-1) {', '                                validPal[d][e] = validPal[d][e-1];', '                                if (s.charAt(d)==s.charAt(e)) {', '                                    validPal[d][e] += validPal[d+1][e-1]+(a==1?1:0);', '                                    validPal[d][e] %= MOD;', '                                    validPal[d][e] += needsRightPal[d+1][e-1];', '                                    validPal[d][e] %= MOD;', '                                }', '                                needsLeftPal[d][e] = validPal[d+1][e];', '                                needsRightPal[d][e] = needsRightPal[d][e-1];', '                                needsBothPal[d][e] = needsRightPal[d+1][e-1];', '                            } else if (e==lens[c]) {', '                                validPal[d][e] = validPal[d+1][e];', '                                if (s.charAt(d)==s.charAt(e)) {', '                                    validPal[d][e] += validPal[d+1][e-1]+(a==1?1:0);', '                                    validPal[d][e] %= MOD;', '                                    validPal[d][e] += needsLeftPal[d+1][e-1];', '                                    validPal[d][e] %= MOD;', '                                }', '                                needsLeftPal[d][e] = needsLeftPal[d+1][e];', '                                needsRightPal[d][e] = validPal[d][e-1];', '                                needsBothPal[d][e] = needsLeftPal[d+1][e-1];', '                            } else {', '                                validPal[d][e] = (validPal[d+1][e]+validPal[d][e-1]-validPal[d+1][e-1])%MOD;', '                                if (validPal[d][e]<0)', '                                    validPal[d][e] += MOD;', '                                if (s.charAt(d)==s.charAt(e)) {', '                                    validPal[d][e] += validPal[d+1][e-1]+(a==1?1:0);', '                                    validPal[d][e] %= MOD;', '                                    validPal[d][e] += needsLeftPal[d+1][e-1];', '                                    validPal[d][e] %= MOD;', '                                    validPal[d][e] += needsRightPal[d+1][e-1];', '                                    validPal[d][e] %= MOD;', '                                    validPal[d][e] += needsBothPal[d+1][e-1];', '                                    validPal[d][e] %= MOD;', '                                }', '                                needsLeftPal[d][e] = needsLeftPal[d+1][e];', '                                needsRightPal[d][e] = needsRightPal[d][e-1];', '                                needsBothPal[d][e] = needsBothPal[d+1][e-1];', '                            }', '                        }', '                    }', '                }', '            }', '            System.out.println(validPal[0][suma-1]);', '        }', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '        final static int MODE = 1000000007;', '    /*', '     * Complete the palindromicStrings function below.', '     */', '    static int palindromicStrings(int[] a, char[] cc) {', '        final int N = cc.length;', '        int[][] dp = new int[6*N][N];', '        int[] ids = new int[N];', '        int t=a[0]==1?0:1;', '        for(int i=1;i<N;++i){', '            if(t==0){', '                ids[i]=ids[i-1]+1;', '            }else{', '                ids[i]=ids[i-1];', '            }', '            ++t;', '            if(a[ids[i]]==t)t=0;', '        }', '        int[] st = new int[6];', '        for(int i=1;i<6;++i)st[i]=i*N;', '        for(int i=N-1;i>=0;--i){', '            dp[st[5]+i][i]=dp[st[4]+i][i]=dp[i][i]=1;', '            dp[st[3]+i][i]=dp[st[2]+i][i]=dp[st[1]+i][i]=2;', '            for(int j=i+1;j<N;++j){', '                if(ids[j]==ids[j-1]){', '                    dp[st[5]+i][j]=dp[st[5]+i][j-1];', '                    dp[st[4]+i][j]=dp[st[4]+i][j-1];', '                }else{', '                    dp[st[5]+i][j]=dp[st[4]+i][j-1];', '                }', '                if(cc[i]==cc[j]){', '                    if(i+1==j){', '                        ++dp[st[5]+i][j];', '                        ++dp[st[4]+i][j];', '                    }else{', '                        int k=0;', '                        if(ids[i]==ids[i+1])k+=2;', '                        if(ids[j]==ids[j-1])k+=1;', '                        dp[st[5]+i][j]=(dp[st[5]+i][j]+dp[st[k]+i+1][j-1])%MODE;', '                        dp[st[4]+i][j]=(dp[st[4]+i][j]+dp[st[k]+i+1][j-1])%MODE;', '                    }', '                }', '                dp[st[1]+i][j]=dp[st[3]+i][j]=dp[st[5]+i][j];', '                dp[st[0]+i][j]=dp[st[2]+i][j]=dp[st[4]+i][j];', '                if(ids[i]==ids[i+1]){', '                    dp[st[3]+i][j]=(dp[st[3]+i][j]+dp[st[3]+i+1][j])%MODE;', '                    dp[st[2]+i][j]=(dp[st[2]+i][j]+dp[st[2]+i+1][j])%MODE;', '                    dp[st[1]+i][j]=(dp[st[1]+i][j]+dp[st[1]+i+1][j])%MODE;', '                    dp[st[0]+i][j]=(dp[st[0]+i][j]+dp[st[0]+i+1][j])%MODE;', '                }else{', '                    dp[st[3]+i][j]=(dp[st[3]+i][j]+dp[st[1]+i+1][j])%MODE;', '                    dp[st[2]+i][j]=(dp[st[2]+i][j]+dp[st[0]+i+1][j])%MODE;', '                }', '            }', '        }', '        return dp[0][N-1];', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws Exception {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '        long t = System.currentTimeMillis();', '        int q = scanner.nextInt();', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '        for (int qItr = 0; qItr < q; qItr++) {', '            int aCount = scanner.nextInt();', '            scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '            int[] a = new int[aCount];', '            StringBuilder sb = new StringBuilder();', '', '            for (int aItr = 0; aItr < aCount; aItr++) {', '                String aItem = scanner.nextLine();', '                //scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '                a[aItr] = aItem.length();', '                sb.append(aItem);', '            }', '            int result = palindromicStrings(a, sb.toString().toCharArray());', '', '            bufferedWriter.write(String.valueOf(result));', '            bufferedWriter.newLine();', '        }', '', '        bufferedWriter.close();', '', '        scanner.close();', '        //Thread.sleep(3800);', '        System.out.println(System.currentTimeMillis()-t);', '    }', '}']"
"['import java.util.*;', 'import java.io.*;', '', 'class Solution', '{', ' BufferedReader input;', ' BufferedWriter out;', ' StringTokenizer token;', '', ' int N;', ' int[] x,y;', ' int[] dp,dp3;', ' boolean[] ok;', ' int[] member;', ' int mod = 1000000007;', '', ' int BitCount(int x)', ' {', '  int ret = 0;', '  while(x > 0)', '  {', '   if( (x&1) != 0 ) ret++;', '   x >>= 1;', '  }', '  return ret;', ' }', '', ' boolean collinear(int set)', ' {', '  int ctr = 0;', '  for(int i = 0; set > 0; i++)', '  {', '   if( (set&1) != 0 )', '    member[ctr++] = i;', '   set >>= 1;', '  }', '  if(ctr <= 2)return true;', '  int a = x[member[0]]-x[member[1]];', '  int b = y[member[0]]-y[member[1]];', '  for(int i = 2; i < ctr; i++)', '  {', '   int aa = x[member[0]]-x[member[i]];', '   int bb = y[member[0]]-y[member[i]];', '   if(aa*b != a*bb)return false;', '  }', '  return true;', ' }', '', ' String binary(int x)', ' {', '  String ret = """";', '  for(int i = 0; i < N; i++)', '  {', '   if( ((x>>i)&1) == 0) ret = ""0""+ret;', '    else ret = ""1""+ret;', '  }', '  return ret;', ' }', '', ' void solve() throws IOException', ' {', '  long qq = System.currentTimeMillis();', '  input = new BufferedReader(new InputStreamReader(System.in));', '  out = new BufferedWriter(new OutputStreamWriter(System.out));', '  int T = nextInt();', '  int twoMax = (1<<16);', '  dp = new int[twoMax];', '  x = new int[16];', '  y = new int[16];', '  ok = new boolean[twoMax];', '  dp3 = new int[twoMax];', '  member = new int[16];', '  ArrayList<Integer> o;', '  for(int t = 0; t < T; t++)', '  {', '   N = nextInt();', '   int twoN = (1<<N);', '   for(int i = 0; i < N; i++)', '   {', '    x[i] = nextInt();', '    y[i] = nextInt();', '   }', '   o = new ArrayList<Integer>();', '   for(int i = twoN-1; i > 0; i--)', '   {', '    ok[i] = false;', '    if(collinear(i))', '    {', '     ok[i] = true;', '     o.add(i);', '    }', '   }', '   Arrays.fill(dp,-1);', '   dp[0] = 0;', '   dp3[0] = 1;', '   int m = 0;', '   for(int i = 0; i < o.size(); i++)', '   {', '    int ii = o.get(i);', '    for(int j = m; j >= 0; j--)', '    {', '     if((ii&j) == 0 && dp[j] != -1)', '     {', '      m = Math.max(m,j|ii);', '      if(dp[j|ii] == -1 || dp[j|ii] > 1+dp[j])', '      {', '       dp[j|ii] = 1+dp[j];', '       dp3[j|ii] = (int)(((long)(dp[j]+1)*dp3[j])%mod);', '      }', '      else if(dp[j|ii] == 1+dp[j])', '      {', '       dp3[j|ii] += ((long)(dp[j]+1)*dp3[j])%mod;', '       dp3[j|ii] %= mod;', '      }', '     }', '    }', '   }', '   out.write(""""+ dp[(twoN)-1] + "" "" + dp3[(twoN)-1]);', '   out.newLine();', '  }', '  out.flush();', '  out.close();', '  input.close();', '', ' }', '', ' int nextInt() throws IOException', ' {', '  if(token == null || !token.hasMoreTokens())', '   token = new StringTokenizer(input.readLine());', '  return Integer.parseInt(token.nextToken());', ' }', '', ' Long nextLong() throws IOException', ' {', '  if(token == null || !token.hasMoreTokens())', '   token = new StringTokenizer(input.readLine());', '  return Long.parseLong(token.nextToken());', ' }', '', ' String next() throws IOException', ' {', '  if(token == null || !token.hasMoreTokens())', '   token = new StringTokenizer(input.readLine());', '  return token.nextToken();', ' }', '', ' public static void main(String[] args) throws Exception', ' {', '  new Solution().solve();', ' }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    static int MOD = 1000000007;', '    ', '    static int maxN = 16;', '    static int n;', '    static boolean[][][] tri;', '    static int[][] setPointsInLine = new int[maxN][maxN];', '    static int[][] noPointsInLine = new int[maxN][maxN];', '    static int[] memoMinMap;', '    static int[][] memoVarMap;', '    ', '    static long[][] C = new long[maxN+1][maxN+1];', '    static int[][] mapPoints = new int[1 << maxN+1][];', '    ', '    static int[][] resultNCP = new int[maxN+1][];', '    static int colPoints = 0;', '    ', '    static {', '        C[0][0] = 1;', '        C[1][0] = 1;', '        C[1][1] = 1;', '        for (int i = 2; i <= maxN; ++i) {', '            C[i][0] = 1;', '            for (int j = 1; j <= 3; ++j) {', '                C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;', '            }', '        }    ', '        ', '        for (int i = 1; i <= maxN; ++i) {', '            resultNCP[i] = getResultNCP(i);', '        }', '        ', '        for(int setPoints = 0;setPoints < (1 << maxN+1);setPoints++) {', '            int[] ans = new int[maxN+1];', '            int k = 0;', '            for(int i = 0;i < maxN;i++) {', '                if(((1 << i) & setPoints) > 0) {', '                    ans[++k] = i;                ', '                }', '            }', '            ans[0] = k;', '            mapPoints[setPoints]= ans;', '        }        ', '', '    }', '    ', '    static int[] pointsInPlane(int[][] coordinates) {', '        tri = new boolean[maxN][maxN][maxN];', '        memoMinMap = new int[1 << (maxN+1)];', '        Arrays.fill(memoMinMap, -1);', '        memoVarMap = new int[9][];', '        colPoints = 0;', '        for(int i = 1;i <= 8;i++) {', '            memoVarMap[i] =  new int[1 << (maxN+1)];', '            Arrays.fill(memoVarMap[i], -1);', '        }', '        int maxCP = 2;', '        for(int i = 0;i < n;i++) {', '            int xi = coordinates[i][0];', '            int yi = coordinates[i][1];', '            for(int j = i+1;j < n;j++) {', '                int lineP = 0;', '                int noP = 2;', '                int xj = coordinates[j][0];', '                int yj = coordinates[j][1];', '                for(int k = j+1;k < n;k++) {', '                    int xk = coordinates[k][0];', '                    int yk = coordinates[k][1];', '                    if((yk-yi) * (xj-xi) == (yj-yi) * (xk-xi)) {', '                        tri[i][j][k] = true;', '                        lineP += (1 << k);', '                        noP++;', '                    }', '                }', '                if(maxCP < noP) {', '                    maxCP = noP;', '                }', '                setPointsInLine[i][j] = lineP;', '                noPointsInLine[i][j] = noP;', '                if(lineP != 0) {', '                    colPoints = colPoints | lineP;', '                }', '            }            ', '        }', '        colPoints = ~colPoints;', '        if(maxCP == 2) {            ', '            return resultNCP[n];', '            ', '        }', '        int noMin = calcMin((1 << n) - 1);', '        int noVar = calcV((1 << n) - 1, 1, noMin, n);', '        return new int[] {noMin, noVar};', '    }', '', '    private static int[] getResultNCP(int nNCP) {', '        if(nNCP % 2 == 0) {', '            int noMin = nNCP/2;', '            long noV = 1;', '            for(int k = nNCP;k >=4;k=k-2) {', '                noV = noV * C[k][2];', '            }', '            return new int[] {noMin, (int) (noV % MOD)};', '        }else {', '            int noMin = nNCP/2+1;', '            long noV = 0;', '            for(int k = nNCP;k>=1;k=k-2) {', '                long p = 1;', '                for(int i = nNCP;i > k;i=i-2) {', '                    p = p*C[i][2];', '                }', '                p = p*k;', '                for(int i = k-1;i >=4;i=i-2) {', '                    p = p*C[i][2];', '                }', '                noV = (noV+p) % MOD;', '            }', '            return new int[] {noMin, (int)noV};', '        }', '    }', '', '    private static int calcV(int setPoints, int itr, int noMin, int nP) {', '        if(itr == noMin+1 && setPoints != 0) {', '            return 0;', '        }', '        if(itr == noMin+1 && setPoints == 0) {', '            return 1;', '        }else {', '            int ans = memoVarMap[itr][setPoints];', '            if(ans >= 0) {', '                return ans; ', '            }', '            int ncp = colPoints & setPoints;', '            if(ncp == setPoints) {', '                ans = (int) Math.ceil(nP/2.);', '                if(ans > noMin-itr+1) {', '                    memoVarMap[itr][setPoints] = 0;', '                    return 0;', '                } else {', '                    int pR = resultNCP[nP][1];', '                    memoVarMap[itr][setPoints] =  pR;', '                    return pR;                    ', '                }', '            }', '            ans = memoMinMap[setPoints];', '            if(ans >= 0) {', '                if(ans > noMin-itr+1) {', '                    memoVarMap[itr][setPoints] = 0;', '                    return 0;', '                } else {', '                    if(nP % 2 == 1 && ans == nP/2+1) {', '                        int pR = resultNCP[nP][1];', '                        memoVarMap[itr][setPoints] = pR;', '                        return pR;', '                    }', '                }', '            }', '            int[] points = mapPoints[setPoints];', '            int size = points[0];', '            ans  = 0;', '            Set<Integer> set = new HashSet<Integer>();', '            if(size <= 2) {', '                memoVarMap[itr][setPoints] =  1;', '                return 1;', '            }', '            if(size == 3 && itr==noMin && tri[points[1]][points[2]][points[3]]) {', '                memoVarMap[itr][setPoints] = 1;', '                return 1;', '            }', '            if(size == 3 && itr==noMin-1 && !tri[points[1]][points[2]][points[3]]) {', '                memoVarMap[itr][setPoints] = 6;', '                return 6;', '            }            ', '            if(size == 4) {', '                if(itr==noMin-1) {', '                    if(!hasCP(points)) {', '                        memoVarMap[itr][setPoints] = 6;', '                        return 6;', '                    }else {', '                        memoVarMap[itr][setPoints] = 8;', '                        return 8;', '                    }', '                }else if(itr == noMin && colP(points)) {', '                    //c++;', '                    memoVarMap[itr][setPoints] = 1;', '                    return 1;', '                } else {', '                    memoVarMap[itr][setPoints] = 0;', '                    return 0;', '                }', '            }', '            for(int i = 1;i <= size;i++) {', '                int pi = points[i];', '                int nextP = setPoints - (1 << pi);', '                ans = (ans + calcV(nextP, itr+1, noMin, nP-1)) % MOD;', '                for(int j = i+1;j <= size;j++) {', '                    int pj = points[j];', '                    int start = setPoints - (1 << pi) - (1 << pj);', '                    int newSetPoints = setPointsInLine[pi][pj] & start;', '                    if(newSetPoints == 0) {', '                        ans = (ans + calcV(start, itr+1, noMin, nP-2)) % MOD;', '                        continue;', '                    }', '                    int[] pointsLine = mapPoints[newSetPoints];', '                    int pSize = pointsLine[0];', '                    for (int s = 0; s < (1 << pSize); s++){ ', '                        nextP = start;', '                        int aP = 0;', '                        for (int t = 0; t < pSize; t++) {', '                            int pt1 = pointsLine[t+1];', '                            if ((s & (1 << t)) > 0 && tri[pi][pj][pt1]) {', '                                nextP -= (1 << pt1);', '                                aP++;', '                            }', '                        }', '                        if(set.contains(nextP)) {', '                            continue;', '                        }', '                        set.add(nextP);', '                        ans = (ans + calcV(nextP, itr+1, noMin, nP-2-aP)) % MOD;', '                    }                    ', '                }', '            }', '            memoVarMap[itr][setPoints] = ans;', '            return ans;', '        }', '    }', '', '    private static boolean colP(int[] points) {', '        int p1 = points[1];', '        int p2 = points[2];', '        int p3 = points[3];', '        int p4 = points[4];', '        return tri[p1][p2][p3] && tri[p1][p2][p4];', '    }', '', '    private static boolean hasCP(int[] points) {', '        int p1 = points[1];', '        int p2 = points[2];', '        int p3 = points[3];', '        int p4 = points[4];', '        return tri[p1][p2][p3] || tri[p1][p2][p4] || tri[p2][p3][p4] || tri[p1][p3][p4];', '    }', '', '    private static int calcMin(int setPoints) {', '        if(setPoints == 0) {', '            return 0;', '        }else {', '            int ans = memoMinMap[setPoints];', '            if(ans >= 0) {', '                return ans; ', '            }', '            int[] points = mapPoints[setPoints];', '            int size = points[0];', '            int ncp = colPoints & setPoints;', '            if(ncp == setPoints) {', '                ans = (int) Math.ceil(size/2.);', '                memoMinMap[setPoints] = ans;', '                return ans;', '            }', '            if(size <= 2) {', '                memoMinMap[setPoints] = 1;', '                return 1;', '            }', '            if(size == 3) {', '                if(tri[points[1]][points[2]][points[3]]) {', '                    memoMinMap[setPoints] = 1;', '                    return 1;', '                }else {', '                    memoMinMap[setPoints] = 2;', '                    return 2;', '                }', '                ', '            }', '            if(size == 4) {', '                int p1 = points[1];', '                int p2 = points[2];', '                int p3 = points[3];', '                int p4 = points[4];', '                if(tri[p1][p2][p3] && tri[p1][p2][p4]) {                ', '                    memoMinMap[setPoints] = 1;', '                    return 1;', '                } else {', '                    memoMinMap[setPoints] = 2;', '                    return 2;', '                }', '            }', '            int min = 10;', '            for(int i = 1;i <= size;i++) {', '                for(int j = i+1;j <= size;j++) {', '                    int nextP = (setPoints - (setPoints & (setPointsInLine[points[i]][points[j]] + (1 << points[i]) + (1 << points[j])))); ', '                    ans = 1+calcMin(nextP);', '                    if(ans < min) {', '                        min = ans;', '                    }', '                }', '            }', '            memoMinMap[setPoints] = min;', '            return min;', '        }        ', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int t = scanner.nextInt();', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '        for (int tItr = 0; tItr < t; tItr++) {', '            n = scanner.nextInt();', '            scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '            int[][] coordinates = new int[n][2];', '', '            for (int coordinatesRowItr = 0; coordinatesRowItr < n; coordinatesRowItr++) {', '                String[] coordinatesRowItems = scanner.nextLine().split("" "");', '                scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '                for (int coordinatesColumnItr = 0; coordinatesColumnItr < 2; coordinatesColumnItr++) {', '                    int coordinatesItem = Integer.parseInt(coordinatesRowItems[coordinatesColumnItr]);', '                    coordinates[coordinatesRowItr][coordinatesColumnItr] = coordinatesItem;', '                }', '            }', '', '            int[] result = pointsInPlane(coordinates);', '', '            for (int resultItr = 0; resultItr < result.length; resultItr++) {', '                bufferedWriter.write(String.valueOf(result[resultItr]));', '', '                if (resultItr != result.length - 1) {', '                    bufferedWriter.write("" "");', '                }', '            }', '', '            bufferedWriter.newLine();', '        }', '', '        bufferedWriter.close();', '', '        scanner.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(System.in);', '        int n = sc.nextInt();', '        int k = sc.nextInt();', '        int[] c = new int[n];', '        for (int i = 0; i < n; i++) {', '            c[i] = sc.nextInt();', '        }', '        long ans = 1000000000000000000l;', '        for (int i = 0; i <= Math.min(n-1, k); i++) {', '            int maxCovered = i+k;', '            long partialAns = c[i];', '            boolean possible = true;', '            while (maxCovered < n-1) {', '                int button = maxCovered+k+1;', '                if (button >= n) {', '                    possible = false;', '                    break;', '                }', '                partialAns += c[button];', '                maxCovered = button+k;', '            }', '            if (!possible)', '                continue;', '            ans = Math.min(partialAns, ans);', '        }', '        System.out.println(ans);', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '  static long turnOffTheLights(int k, int[] arr) {', '    long result = Long.MAX_VALUE;', '    for(int beg = 1; beg <= 1 + k; beg++) {', '        long cost = 0;', '        int nxt = beg;', '        while(nxt < arr.length) {', '            cost += arr[nxt];', '            nxt = nxt + 2 * k + 1;', '        }', '        nxt = nxt - 2 * k - 1;', '        if(nxt + k >= arr.length-1) {', '          result = Math.min(cost, result);', '        }', '    }', '    return result;', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int n = Integer.parseInt(st.nextToken());', '    int k = Integer.parseInt(st.nextToken());', '', '    int[] c = new int[n+1];', '    st = new StringTokenizer(br.readLine());', '    for (int cItr = 1; cItr <= n; cItr++) {', '      int cItem = Integer.parseInt(st.nextToken());', '      c[cItr] = cItem;', '    }', '', '    long result = turnOffTheLights(k, c);', '', '    bw.write(String.valueOf(result));', '    bw.newLine();', '', '    bw.close();', '    br.close();', '  }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.Comparator;', 'import java.util.InputMismatchException;', '', 'public class E4 {', ' InputStream is;', ' PrintWriter out;', ' String INPUT = """";', ' ', ' void solve()', ' {', '  for(int T = ni();T > 0;T--){', '   int n = ni(), m = ni();', '   int[][] ts = new int[m][3];', '   for(int i = 0;i < m;i++){', '    ts[i][0] = ""EC"".indexOf(nc()) >= 0 ? 0 : 1;', '   }', '   for(int i = 0;i < m;i++){', '    ts[i][1] = ni()*2;', '   }', '   for(int i = 0;i < m;i++){', '    ts[i][2] = ni()*2-1;', '   }', '   Arrays.sort(ts, new Comparator<int[]>() {', '    public int compare(int[] a, int[] b) {', '     if(a[2] != b[2])return a[2] - b[2];', '     return a[1] - b[1];', '    }', '   });', '   ', '   StarrySkyTree sst0 = new StarrySkyTree(2*n+3);', '   StarrySkyTree sst1 = new StarrySkyTree(2*n+3);', '   int[] reach = new int[m+2];', '   Arrays.fill(reach, -1);', '   ', '   int p = 0;', '   for(int i = 1;i <= 2*n;i++){', '    while(p < m && ts[p][2] <= i){', '     if(ts[p][1] < ts[p][2]){', '      if(ts[p][0] == 0){', '       sst0.add(0, ts[p][1], -1);', '      }else{', '       sst1.add(0, ts[p][1], -1);', '      }', '     }', '     p++;', '    }', '    int mat = 0;', '    {', '     int max = -sst1.min(0, i);', '     sst0.add(i, i+1, -max);', '     mat = Math.max(mat, max);', '    }', '    {', '     int max = -sst0.min(0, i);', '     sst1.add(i, i+1, -max);', '     mat = Math.max(mat, max);', '    }', '    if(reach[mat] == -1)reach[mat] = (i+1)/2;', '   }', '   ', '   ', '   for(int i = m;i >= 1;i--){', '    if(reach[i] != -1)continue;', '    reach[i] = reach[i+1];', '   }', '   for(int i = 1;i <= m;i++){', '    out.print(reach[i] + "" "");', '   }', '   out.println();', '  }', ' }', ' ', ' public static int upperBound(int[] a, int v){ return upperBound(a, 0, a.length, v); }', ' public static int upperBound(int[] a, int l, int r, int v)', ' {', '  int low = l-1, high = r;', '  while(high-low > 1){', '   int h = high+low>>>1;', '   if(a[h] <= v){', '    low = h;', '   }else{', '    high = h;', '   }', '  }', '  return low;', ' }', '', ' ', ' public static class StarrySkyTree {', '  public int M, H, N;', '  public int[] st;', '  public int[] plus;', '  public int I = Integer.MAX_VALUE/4; // I+plus<int', '  ', '  public StarrySkyTree(int n)', '  {', '   N = n;', '   M = Integer.highestOneBit(Math.max(n-1, 1))<<2;', '   H = M>>>1;', '   st = new int[M];', '   plus = new int[H];', '  }', '  ', '  public StarrySkyTree(int[] a)', '  {', '   N = a.length;', '   M = Integer.highestOneBit(Math.max(N-1, 1))<<2;', '   H = M>>>1;', '   st = new int[M];', '   for(int i = 0;i < N;i++){', '    st[H+i] = a[i];', '   }', '   plus = new int[H];', '   Arrays.fill(st, H+N, M, I);', '   for(int i = H-1;i >= 1;i--)propagate(i);', '  }', '  ', '  private void propagate(int i)', '  {', '   st[i] = Math.min(st[2*i], st[2*i+1]) + plus[i];', '  }', '  ', '  public void add(int l, int r, int v){ if(l < r)add(l, r, v, 0, H, 1); }', '  ', '  private void add(int l, int r, int v, int cl, int cr, int cur)', '  {', '   if(l <= cl && cr <= r){', '    if(cur >= H){', '     st[cur] += v;', '    }else{', '     plus[cur] += v;', '     propagate(cur);', '    }', '   }else{', '    int mid = cl+cr>>>1;', '    if(cl < r && l < mid){', '     add(l, r, v, cl, mid, 2*cur);', '    }', '    if(mid < r && l < cr){', '     add(l, r, v, mid, cr, 2*cur+1);', '    }', '    propagate(cur);', '   }', '  }', '  ', '  public int min(int l, int r){ return l >= r ? I : min(l, r, 0, H, 1);}', '  ', '  private int min(int l, int r, int cl, int cr, int cur)', '  {', '   if(l <= cl && cr <= r){', '    return st[cur];', '   }else{', '    int mid = cl+cr>>>1;', '    int ret = I;', '    if(cl < r && l < mid){', '     ret = Math.min(ret, min(l, r, cl, mid, 2*cur));', '    }', '    if(mid < r && l < cr){', '     ret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));', '    }', '    return ret + plus[cur];', '   }', '  }', '  ', '  public void fall(int i)', '  {', '   if(i < H){', '    if(2*i < H){', '     plus[2*i] += plus[i];', '     plus[2*i+1] += plus[i];', '    }', '    st[2*i] += plus[i];', '    st[2*i+1] += plus[i];', '    plus[i] = 0;', '   }', '  }', '  ', '  public int firstle(int l, int v) {', '   int cur = H+l;', '   for(int i = 1, j = Integer.numberOfTrailingZeros(H)-1;i <= cur;j--){', '    fall(i);', '    i = i*2|cur>>>j&1;', '   }', '   while(true){', '    fall(cur);', '    if(st[cur] <= v){', '     if(cur < H){', '      cur = 2*cur;', '     }else{', '      return cur-H;', '     }', '    }else{', '     cur++;', '     if((cur&cur-1) == 0)return -1;', '     cur = cur>>>Integer.numberOfTrailingZeros(cur);', '    }', '   }', '  }', '  ', '  public int lastle(int l, int v) {', '   int cur = H+l;', '   for(int i = 1, j = Integer.numberOfTrailingZeros(H)-1;i <= cur;j--){', '    fall(i);', '    i = i*2|cur>>>j&1;', '   }', '   while(true){', '    fall(cur);', '    if(st[cur] <= v){', '     if(cur < H){', '      cur = 2*cur+1;', '     }else{', '      return cur-H;', '     }', '    }else{', '     if((cur&cur-1) == 0)return -1;', '     cur = cur>>>Integer.numberOfTrailingZeros(cur);', '     cur--;', '    }', '   }', '  }', '  ', '  public int[] toArray() { return toArray(1, 0, H, new int[H]); }', '  ', '  private int[] toArray(int cur, int l, int r, int[] ret)', '  {', '   if(r-l == 1){', '    ret[cur-H] = st[cur];', '   }else{', '    toArray(2*cur, l, l+r>>>1, ret);', '    toArray(2*cur+1, l+r>>>1, r, ret);', '    for(int i = l;i < r;i++)ret[i] += plus[cur];', '   }', '   return ret;', '  }', ' }', '', '', ' ', ' void run() throws Exception', ' {', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  long s = System.currentTimeMillis();', '  solve();', '  out.flush();', '  if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', ' }', ' ', ' public static void main(String[] args) throws Exception { new E4().run(); }', ' ', ' private byte[] inbuf = new byte[1024];', ' public int lenbuf = 0, ptrbuf = 0;', ' ', ' private int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private double nd() { return Double.parseDouble(ns()); }', ' private char nc() { return (char)skip(); }', ' ', ' private String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    static int[] minimumZooNumbers(int m, int n, char[] t, int[] s, int[] d) {', '        int[] counter = new int[m + 1];', '', '        for (int i = 0; i < n; i++)', '            if (s[i] < d[i])', '                counter[d[i]]++;', '', '        int[][] ind = new int[m + 1][];', '', '        for (int i = 1; i <= m; i++)', '        {', '            ind[i] = new int[counter[i]];', '            counter[i] = 0;', '        }', '', '        for (int i = 0; i < n; i++)', '            if (s[i] < d[i])', '            {', '                ind[d[i]][counter[d[i]]] = i;', '                counter[d[i]]++;', '            }', '', '        Node whiteRoot = buildTree(1, m);', '        Node blackRoot = buildTree(1, m);', '', '        int[] maxAnimals = new int[m + 1];', '', '        for (int i = 1; i <= m; i++)', '        {', '            for (int j = 0; j < counter[i]; j++)', '            {', '                int k = ind[i][j];', '', ""                if (t[k] == 'E' || t[k] == 'C')"", '                {', '                    andOne(blackRoot, s[k]);', '                }', '                else', '                {', '                    andOne(whiteRoot, s[k]);', '                }', '            }', '', '            int max =', '                Math.max(blackRoot.value + blackRoot.plus,', '                    whiteRoot.value + whiteRoot.plus);', '', '            insert(blackRoot, i, max);', '            insert(whiteRoot, i, max);', '            maxAnimals[i] = max;', '        }', '', '        int[] res = new int[n];', '        int next = 0;', '', '        for (int i = 1; i <= m; i++)', '        {', '            while (next < maxAnimals[i])', '            {', '                res[next] = i;', '                next++;', '            }', '        }', '', '        while (next < n)', '        {', '            res[next++] = -1;', '        }', '', '        return res;', '    }', '', '    static class Node', '    {', '        Node left;', '        Node right;', '        int leftBound;', '        int rightBound;', '        int value = 0;', '        int plus = 0;', '    }', '', '    static Node buildTree(int left, int right)', '    {', '        Node node = new Node();', '        node.leftBound = left;', '        node.rightBound = right;', '', '        if (left == right)', '        {', '            return node;', '        }', '', '        int mid = (left + right) / 2;', '', '        node.left = buildTree(left, mid);', '        node.right = buildTree(mid + 1, right);', '', '        return node;', '    }', '', '    static void andOne(Node node, int r)', '    {', '        if (r >= node.rightBound)', '        {', '            node.plus++;', '            return;', '        }', '', '        if (node.plus > 0)', '        {', '            node.left.plus += node.plus;', '            node.right.plus += node.plus;', '        }', '', '        andOne(node.left, r);', '', '        if (r >= node.right.leftBound)', '        {', '            andOne(node.right, r);', '        }', '', '        updateNode(node);', '    }', '', '    static void updateNode(Node node)', '    {', '        node.value = Math.max(node.left.value + node.left.plus,', '            node.right.value + node.right.plus);', '        node.plus = 0;', '    }', '', '    static void insert(Node node, int ind, int v)', '    {', '        if (node.leftBound == ind && node.rightBound == ind)', '        {', '            node.value = v;', '            node.plus = 0;', '            return;', '        }', '', '        if (node.plus > 0)', '        {', '            node.left.plus += node.plus;', '            node.right.plus += node.plus;', '        }', '', '        if (node.left.rightBound >= ind)', '        {', '            insert(node.left, ind, v);', '        }', '        else', '        {', '            insert(node.right, ind, v);', '        }', '', '        updateNode(node);', '    }', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int cases = in.nextInt();', '        for(int a0 = 0; a0 < cases; a0++){', '            int m = in.nextInt();', '            int n = in.nextInt();', '            char[] t = new char[n];', '            for(int t_i = 0; t_i < n; t_i++){', '                t[t_i] = in.next().charAt(0);', '            }', '            int[] s = new int[n];', '            for(int s_i = 0; s_i < n; s_i++){', '                s[s_i] = in.nextInt();', '            }', '            int[] d = new int[n];', '            for(int d_i = 0; d_i < n; d_i++){', '                d[d_i] = in.nextInt();', '            }', '            int[] result = minimumZooNumbers(m, n, t, s, d);', '            for (int i = 0; i < result.length; i++) {', '                System.out.print(result[i] + (i != result.length - 1 ? "" "" : """"));', '            }', '            System.out.println("""");', '', '', '        }', '        in.close();', '    }', '}']"
"['import java.util.*;', 'import static java.lang.Math.*;', 'import java.io.*;', '', 'public class Solution {', ' static class Foo41 {', '  final static int MOD = 1007;', '  int N;', '  int highLen;', '  int lowLen;', '  int[] topsort;', '  int[] reverseTopsort;', '  Graph highReverse;', '  Graph lowReverse;', '  Graph crossGraph;', '  MultiArray[] dp;', '  int res = 0;', '  ', '  void main() {', '   BufferedReader br = null;', '   try {', '    br = new BufferedReader(new InputStreamReader(System.in));', '    String[] s = br.readLine().split(""\\\\s"");', '    int N = Integer.parseInt(s[0]);', '    int M = Integer.parseInt(s[1]);', '    TreeSet<Integer>[] g = new TreeSet[N];', '    for (int i = 0; i < N; i++)', '     g[i] = new TreeSet<Integer>();', '    for (int i = 1; i <= M; i++) {', '     s = br.readLine().split(""\\\\s"");', '     int x = Integer.parseInt(s[0]);', '     int y = Integer.parseInt(s[1]);', '     if (x != y)', '      g[y].add(x);', '    }', '    Graph graph = new Graph();', '    graph.n = N;', '    graph.degree = new int[N];', '    graph.graph = new int[N][N];', '    for (int u = 0; u < N; u++) {', '     for (int v : g[u]) {', '      graph.graph[u][graph.degree[u]++] = v;', '     }', '    }', '    //long t = System.currentTimeMillis();', '    int res = foo(graph);', '    //System.out.println(System.currentTimeMillis()-t);', '    System.out.println(res);', '   } catch (Exception e) {', '    e.printStackTrace();', '   } finally {', '    try {', '     br.close();', '    } catch (Exception e) {', '     e.printStackTrace();', '    }', '   }', '  }', '  ', '  int foo(Graph g) {', '   g = new TarjanSCC().doit(g);', '   topsort = topsort(g);', '   N = topsort.length;', '   highLen = (N+1)/2;', '   lowLen = N - highLen;', '   reverseTopsort = reverse(topsort);', '   highReverse = highReverse(g);', '   lowReverse = lowReverse(g);', '   crossGraph = crossGraph(g);', '   dp = new MultiArray[highLen+1];', '   for (int i = 0; i <= highLen; i++) {', '    dp[i] = new MultiArray(i);', '   }', '   for (int i = 1; i <= highLen; i++) {', '    fillMultiArray(i);', '   }', '   int[] arr = new int[N];', '   //int[] util = new int[N];', '   sumAll(arr);', '   return res;', '  }', '  void sumAll(int[] arr) {', '   sumAll(arr, highLen);', '  }', '  ', '  void sumAll(int[] arr, int index) {', '   if (index == N) {', '    for (int i = 0; i < highLen; i++) {', '     arr[i] = 0;', '     int u = topsort[i];', '     for (int j = 0; j < crossGraph.degree[u]; j++) {', '      int v = crossGraph.graph[u][j];', '      arr[i] = max(arr[i], arr[reverseTopsort[v]]);', '     }', '    }', '    //System.out.println(Arrays.toString(Arrays.copyOfRange(arr, highLen, N)) + "": "" + dp[highLen].get(arr, highLen));', '    res = (res + dp[highLen].get(arr, highLen)) % MOD;', '    return;', '   }', '   int ceiling = 9;', '   int u = topsort[index];', '   for (int j = 0; j < lowReverse.degree[u]; j++) {', '    int v = lowReverse.graph[u][j];', '    ceiling = min(ceiling, arr[reverseTopsort[v]]);', '   }', '   for (int i = ceiling; i >= 0; i--) {', '    arr[index] = i;', '    sumAll(arr, index+1);', '   }', '  }', '  ', '  void fillMultiArray(int len) {', '   int[] arr = new int[len];', '   int[] util = new int[len];', '   for (int i = 9; i >= 0; i--) {', '    arr[len-1] = i;', '    fill(arr, util, 0, len);', '   }', '  }', '  ', '  void fill(int[] arr, int[] util, int index, int len) {', '   if (index == len-1) {', '    int res = 0;', '    copyArray(arr, util, len);', '    int u = topsort[len-1];', '    for (int j = 0; j < highReverse.degree[u]; j++) {', '     int v = highReverse.graph[u][j];', '     util[reverseTopsort[v]] = max(util[reverseTopsort[v]], util[len-1]);', '    }', '    res = dp[len-1].get(util, len-1);', '    if (util[len-1] < 9) {', '     util[len-1]++;', '     for (int j = 0; j < highReverse.degree[u]; j++) {', '      int v = highReverse.graph[u][j];', '      util[reverseTopsort[v]] = max(util[reverseTopsort[v]], util[len-1]);', '     }', '     res = (res + dp[len].get(util, len)) % MOD;', '    }', '    dp[len].set(arr, len, res);', '    return;', '   }', '   for (int i = 9; i >= 0; i--) {', '    arr[index] = i;', '    fill(arr, util, index+1, len);', '   }', '  }', '  ', '  void copyArray(int[] a, int[] b, int n) {', '   for (int i = 0; i < n; i++)', '    b[i] = a[i];', '  }', '  ', '  Graph highReverse(Graph g) {', '   Graph graph = new Graph();', '   int n = g.n;', '   graph.n = n;', '   graph.degree = new int[n];', '   graph.graph = new int[n][n];', '   for (int i = 0; i < highLen; i++) {', '    int u = topsort[i];', '    for (int j = 0; j < g.degree[u]; j++) {', '     int v = g.graph[u][j];', '     if (reverseTopsort[v] < highLen)', '      graph.graph[v][graph.degree[v]++] = u;', '    }', '   }', '   return graph;', '  }', '  ', '  Graph lowReverse(Graph g) {', '   Graph graph = new Graph();', '   int n = g.n;', '   graph.n = n;', '   graph.degree = new int[n];', '   graph.graph = new int[n][n];', '   for (int i = highLen; i < N; i++) {', '    int u = topsort[i];', '    for (int j = 0; j < g.degree[u]; j++) {', '     int v = g.graph[u][j];', '     if (reverseTopsort[v] >= highLen)', '      graph.graph[v][graph.degree[v]++] = u;', '    }', '   }', '   return graph;', '  }', '  ', '  Graph crossGraph(Graph g) {', '   Graph graph = new Graph();', '   int n = g.n;', '   graph.n = n;', '   graph.degree = new int[n];', '   graph.graph = new int[n][n];', '   for (int i = 0; i < highLen; i++) {', '    int u = topsort[i];', '    for (int j = 0; j < g.degree[u]; j++) {', '     int v = g.graph[u][j];', '     if (reverseTopsort[v] >= highLen)', '      graph.graph[u][graph.degree[u]++] = v;', '    }', '   }', '   return graph;', '  }', '  ', '  int[] reverse(int[] arr) {', '   int n = arr.length;', '   int[] res = new int[n];', '   for (int i = 0; i < n; i++)', '    res[arr[i]] = i;', '   return res;', '  }', '  ', '  static class Graph {', '   int n;', '   int[][] graph;', '   int[] degree;', '  }', '  int[] topsort(Graph g) {', '   int n = g.n;', '   int[] res = new int[n];', '   int count = 0;', '   Queue<Integer> queue = new ArrayDeque<Integer>();', '   int[] indegree = new int[n];', '   for (int u = 0; u < n; u++) {', '    for (int j = 0; j < g.degree[u]; j++) {', '     int v = g.graph[u][j];', '     indegree[v]++;', '    }', '    ', '   }', '   for (int u = 0; u < n; u++) {', '    if (indegree[u] == 0)', '     queue.add(u);', '   }', '   while (!queue.isEmpty()) {', '    int u = queue.remove();', '    res[count++] = u;', '    for (int j = 0; j < g.degree[u]; j++) {', '     int v = g.graph[u][j];', '     if (--indegree[v] == 0)', '      queue.add(v);', '    }', '   }', '   return res;', '  }', '  ', '  ', '  ', '  static class MultiArray {', '   final static int LEN = 10;', '   int[] val;', '   MultiArray[] array;', '   public MultiArray(int m) {', '    if (m == 0)', '     return;', '    if (m == 1) {', '     val = new int[LEN];', '     Arrays.fill(val, -1);', '    } else {', '     array = new MultiArray[LEN];', '     for (int i = 0; i < LEN; i++)', '      array[i] = new MultiArray(m-1);', '    }', '   }', '   // the first n elem of arr are indexes', '   int get(int[] arr, int n) {', '    if (n == 0)', '     return 1;', '    return get(this, arr, 0, n);', '   }', '   int get(MultiArray m, int[] arr, int index, int n) {', '    if (index == n-1) {', '     return m.val[arr[index]];', '    }', '    return get(m.array[arr[index]], arr, index+1, n);', '   }', '   void set(int[] arr, int n, int val) {', '    set(this, arr, 0, n, val);', '   }', '   void set(MultiArray m, int[] arr, int index, int n, int val) {', '    if (index == n-1) {', '     m.val[arr[index]] = val;', '     return;', '    }', '    set(m.array[arr[index]], arr, index+1, n, val);', '   }', '  }', '  static class TarjanSCC {', '   int n;', '   int ind;', '   int[] index;', '   int[] lowIndex;', '   Deque<Integer> stack;', '   boolean[] inStack;', '   int comp;', '   int[] component;', '   Graph g;', '   Graph doit(Graph g) {', '    this.g = g;', '    n = g.n;', '    index = new int[n];', '    Arrays.fill(index, -1);', '    lowIndex = new int[n];', '    stack = new LinkedList<Integer>();', '    inStack = new boolean[n];', '    component = new int[n];', '    for (int u = 0; u < n; u++) {', '     if (index[u] == -1)', '      tarjan(u);', '    }', '    TreeSet<Integer>[] newGraph = new TreeSet[comp];', '    for (int i = 0; i < comp; i++)', '     newGraph[i] = new TreeSet<Integer>();', '    for (int u = 0; u < n; u++) {', '     for (int j = 0; j < g.degree[u]; j++) {', '      int v = g.graph[u][j];', '      if (component[u] != component[v])', '       newGraph[component[u]].add(component[v]);', '     }', '    }', '    Graph graph = new Graph();', '    graph.n = comp;', '    graph.degree = new int[n];', '    graph.graph = new int[n][n];', '    for (int u = 0; u < comp; u++) {', '     for (int v : newGraph[u]) {', '      graph.graph[u][graph.degree[u]++] = v;', '     }', '    }', '    return graph;', '   }', '   void tarjan(int u) {', '    index[u] = ind;', '    lowIndex[u] = ind;', '    ind++;', '    stack.push(u);', '    inStack[u] = true;', '    for (int j = 0; j < g.degree[u]; j++) {', '     int v = g.graph[u][j];', '     if (index[v] == -1) {', '      tarjan(v);', '      lowIndex[u] = min(lowIndex[u], lowIndex[v]);', '     } else if (inStack[v]) {', '      lowIndex[u] = min(lowIndex[u], index[v]);', '     }', '    }', '    if (index[u] == lowIndex[u]) {', '     int w = 0;', '     do {', '      w = stack.pop();', '      inStack[w] = false;', '      component[w] = comp;', '     } while (u != w);', '     comp++;', '    }', '   }', '  }', ' }', ' ', ' public static void main(String[] args) {', '  Foo41 foo = new Foo41();', '  foo.main();', ' }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    static int n = 15;', '    static int[][] adj;', '    static Map<Integer, Map<Long, Long>> memoMap = new HashMap<Integer, Map<Long, Long>>();', '    ', '    static {', '        for(int v = 0;v <= n;v++) {', '            memoMap.put(v, new  HashMap<Long, Long>());', '        }', '    }', '    ', '    static long calcR(int[] vals, int k) {', '        int[] maxV = calcFK(vals, k);', '        long key = 0;', '        for(int mv : maxV) {', '            key = key * 10+mv;', '        }', '        Long ans = memoMap.get(k).get(key);', '        if(ans != null) {', '            return ans;', '        }', '        if(k == n-1) {', '            ans = maxV[0]+1l;', '            memoMap.get(k).put(key, ans);', '            return ans;', '        }else {', '            ans = 0l;', '            for(int v = maxV[0];v >= 0;v--) {', '                vals[k] = v;', '                ans += calcR(vals, k+1);', '            }', '            memoMap.get(k).put(key, ans);', '            return ans;', '        }', '    }', '', '    static private int[] calcFK(int[] vals, int k) {', '        int[] ans = new int[n-k];', '        for(int i = 0;i < n-k;i++) {', '            ans[i] = 9;', '        }', '        for(int i = 0;i < k;i++) {', '            int mv = vals[i];', '            int[] np = adj[i];', '            for(int j = 0;j < np.length;j++) {', '                int npAV = np[j];', '                if(npAV >= k) {', '                    int val = ans[npAV-k];', '                    if(val > mv) {', '                        ans[npAV-k] = mv;', '                    }', '                }', '            }', '        }', '        return ans;', '    }', '    ', '    static class Node{', '        ', '        int v;', '        List<Integer> adjL = new ArrayList<Integer>();', '        List<Integer> adjTGL = new ArrayList<Integer>();', '        int index;', '        ', '        int color = 0;', '        int startT = 0;', '        int endT = 0;', '        ', '        public Node(int v) {', '            this.v = v;', '        }', '    }', '', '    static long requirement(int[][] req) {', '        int m = req.length;', '        Node[] nodes = new Node[n];', '        for(int i = 0; i < n;i++) {', '            nodes[i] = new Node(i);', '        }', '        for(int i = 0; i < m;i++) {', '            int to = req[i][0];', '            int from = req[i][1];', '            nodes[from].adjL.add(to);', '            nodes[to].adjTGL.add(from);', '        }', '        process(nodes);', '        return  calcR(new int[n], 0);', '    }', '', '    ', '    static LinkedList<Set<Node>> listSCC = new LinkedList<Set<Node>>();', '    private static void process(Node[] nodes) {', '        DFS(nodes);', '        for(int i = 0;i < n;i++) {', '            nodes[i].color = 0;', '        }', '        List<Node> tSL2 = tSL;', '        tSL = new LinkedList<Node>();', '        for(int i = 0;i < n;i++) {', '            Node node = tSL2.get(i);', '            if(node.color == 0) {', '                Set<Node> set = new HashSet<Node>(); ', '                set.add(node);', '                DFS_VISIT(set, nodes, node, true);', '                listSCC.add(set);', '                ', '            }', '        }', '        int k = 0;', '        for(int i = 0;i < listSCC.size();i++) {', '            Set<Integer> set = new HashSet<Integer>();', '            Set<Node> cc = listSCC.get(i);', '            for(Node node : cc) {', '                node.index = k;', '            }', '            k++;', '        }', '        adj = new int[k][];', '        for(int i = 0;i < listSCC.size();i++) {', '            Set<Integer> set = new HashSet<Integer>();', '            Set<Node> cc = listSCC.get(i);', '            for(Node node : cc) {', '                for(int ad : node.adjL) {', '                    Node na = nodes[ad];', '                    if(na.index != node.index) {', '                        set.add(na.index);', '                    }', '                }', '            }', '            int[] adN = new int[set.size()];', '            int p = 0;', '            for(int a : set) {', '                adN[p++] = a;', '            }', '            adj[i] = adN;', '        }', '        n = k;', '    }', '', '    static int time = 0;', '    static LinkedList<Node> tSL = new LinkedList<Node>();', '', '    private static void DFS(Node[] nodes) {', '        for(int i = 0;i < n;i++) {', '            Node node = nodes[i];', '            if(node.color == 0) {', '                Set<Node> set = new HashSet<Node>(); ', '                set.add(node);', '                DFS_VISIT(set, nodes, nodes[i], false);', '            }', '        }', '    }', '', '    private static void DFS_VISIT(Set<Node> set, Node[] nodes, Node u, boolean transposeG) {', '        time++;', '        u.startT = time;', '        u.color = 1;', '        List<Integer> adL = transposeG ? u.adjTGL : u.adjL;', '        for(int adjN : adL) {', '            Node v = nodes[adjN];', '            if(v.color == 0) {', '                //v.parent = u;', '                set.add(v);', '                DFS_VISIT(set, nodes, v, transposeG);', '            }', '        }', '        u.color = 2;', '        tSL.addFirst(u);', '        time++;', '        u.endT = time;', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '        String[] nm = scanner.nextLine().split("" "");', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '        n = Integer.parseInt(nm[0]);', '        int m = Integer.parseInt(nm[1]);', '        int[][] req = new int[m][2];', '        for (int reqRowItr = 0; reqRowItr < m; reqRowItr++) {', '            String[] reqRowItems = scanner.nextLine().split("" "");', '            scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '            for (int reqColumnItr = 0; reqColumnItr < 2; reqColumnItr++) {', '                int reqItem = Integer.parseInt(reqRowItems[reqColumnItr]);', '                req[reqRowItr][reqColumnItr] = reqItem;', '            }', '        }', '        long result = requirement(req);', '        bufferedWriter.write(String.valueOf(result % 1007));', '        bufferedWriter.newLine();', '        bufferedWriter.close();', '        scanner.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '  private static Reader in;', '  private static PrintWriter out;', '', '  public static void main(String[] args) throws IOException {', '    in = new Reader();', '    out = new PrintWriter(System.out, true);', '    int T = in.nextInt();', '    while(T-- > 0) {', '      int N = in.nextInt(), M = in.nextInt();', '      ', '      int[][] p = new int[N][M];', '      for (int i = 0; i < N; i++) for (int j = 0; j < M; j++)', '        p[i][j] = in.nextInt();', '      int[][] b = new int[N][M];', '      for (int i = 0; i < N; i++) for (int j = 0; j < M; j++)', '        b[i][j] = in.nextInt();', '      ', '      int[] dp = new int[1001];', '      for (int i = N-1; i >= 0; i--) {', '        int[] next = new int[1001];', '        Arrays.fill(next, 1 << 29);', '        for (int j = 0; j < M; j++) {', '          for (int k = 0; k <= 1000; k++) {', '            next[k] = Math.min(next[k], dp[b[i][j]] + (k < p[i][j] ? p[i][j]-k : 0));', '          }', '        }', '        for (int j = 1; j <= 1000; j++)', '          next[j] = Math.min(next[j], next[j-1]);', '        dp = next;', '      }', '      ', '      int min = 1 << 29;', '      for (int i = 0; i <= 1000; i++)', '        min = Math.min(min, i + dp[i]);', '      out.println(min);', '    }', '    out.close();', '    System.exit(0);', '  }', '', '  static class Reader {', '    final private int BUFFER_SIZE = 1 << 16;', '    private DataInputStream din;', '    private byte[] buffer;', '    private int bufferPointer, bytesRead;', '', '    public Reader() {', '      din = new DataInputStream(System.in);', '      buffer = new byte[BUFFER_SIZE];', '      bufferPointer = bytesRead = 0;', '    }', '', '    public Reader(String file_name) throws IOException {', '      din = new DataInputStream(new FileInputStream(file_name));', '      buffer = new byte[BUFFER_SIZE];', '      bufferPointer = bytesRead = 0;', '    }', '', '    public String readLine() throws IOException {', '      byte[] buf = new byte[1 << 20];', '      int cnt = 0;', '      byte c = read();', ""      while (c <= ' ')"", '        c = read();', '      do {', '        buf[cnt++] = c;', ""      } while ((c = read()) != '\\n');"", '      return new String(buf, 0, cnt);', '    }', '', '    public String next() throws IOException {', '      byte[] buf = new byte[1 << 20];', '      int cnt = 0;', '      byte c = read();', ""      while (c <= ' ')"", '        c = read();', '      do {', '        buf[cnt++] = c;', ""      } while ((c = read()) > ' ');"", '      return new String(buf, 0, cnt);', '    }', '', '    public int nextInt() throws IOException {', '      int ret = 0;', '      byte c = read();', ""      while (c <= ' ')"", '        c = read();', ""      boolean neg = (c == '-');"", '      if (neg)', '        c = read();', '      do {', ""        ret = ret * 10 + c - '0';"", ""      } while ((c = read()) >= '0' && c <= '9');"", '      if (neg)', '        return -ret;', '      return ret;', '    }', '', '    public long nextLong() throws IOException {', '      long ret = 0;', '      byte c = read();', ""      while (c <= ' ')"", '        c = read();', ""      boolean neg = (c == '-');"", '      if (neg)', '        c = read();', '      do {', ""        ret = ret * 10 + c - '0';"", ""      } while ((c = read()) >= '0' && c <= '9');"", '      if (neg)', '        return -ret;', '      return ret;', '    }', '', '    public double nextDouble() throws IOException {', '      double ret = 0, div = 1;', '      byte c = read();', ""      while (c <= ' ')"", '        c = read();', ""      boolean neg = (c == '-');"", '      if (neg)', '        c = read();', '      do {', ""        ret = ret * 10 + c - '0';"", ""      } while ((c = read()) >= '0' && c <= '9');"", ""      if (c == '.')"", ""        while ((c = read()) >= '0' && c <= '9')"", ""          ret += (c - '0') / (div *= 10);"", '      if (neg)', '        return -ret;', '      return ret;', '    }', '', '    private void fillBuffer() throws IOException {', '      bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);', '      if (bytesRead == -1)', '        buffer[0] = -1;', '    }', '', '    private byte read() throws IOException {', '      if (bufferPointer == bytesRead)', '        fillBuffer();', '      return buffer[bufferPointer++];', '    }', '', '    public void close() throws IOException {', '      if (din == null)', '        return;', '      din.close();', '    }', '  }', '', '', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '  // TODO A Super Hero', '  ', '  static final int INF = Integer.MAX_VALUE/3;', '', '  static int[] dp0 = new int[1001];', '  static int[] dp1 = new int[1001];', '  ', '  static int minElement(int[] arr) {', '    int result = arr[0];', '    for (int x: arr) {', '      result = Math.min(result, x);', '    }', '    return result;', '  }', '', '  ', '  static int superHero(int[][] power, int[][] bullets) {', '    Arrays.fill(dp0, INF);', '    dp0[0] = 0;', '', '    for (int i = 0; i < power.length; i++) {', '      Arrays.fill(dp1, INF);', '      for (int j = 0; j < power[0].length; j++) {', '        for (int k = 0; k <= 1000; k++) {', '          if (dp0[k] >= INF) {', '            continue;', '          }', '', '          int nevoie = Math.max(0, power[i][j] - k);', '', '          if (dp1[bullets[i][j]] > dp0[k] + nevoie) {', '            dp1[bullets[i][j]] = dp0[k] + nevoie;', '          }', '        }', '      }', '      int[] tmp = dp0;', '      dp0 = dp1;', '      dp1 = tmp;', '    }', '', '    return minElement(dp0);', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int t = Integer.parseInt(st.nextToken());', '', '    for (int tItr = 0; tItr < t; tItr++) {', '      st = new StringTokenizer(br.readLine());', '', '      int n = Integer.parseInt(st.nextToken());', '      int m = Integer.parseInt(st.nextToken());', '', '      int[][] power = new int[n][m];', '', '      for (int i = 0; i < n; i++) {', '        st = new StringTokenizer(br.readLine());', '', '        for (int j = 0; j < m; j++) {', '          int item = Integer.parseInt(st.nextToken());', '          power[i][j] = item;', '        }', '      }', '', '      int[][] bullets = new int[n][m];', '', '      for (int i = 0; i < n; i++) {', '        st = new StringTokenizer(br.readLine());', '', '        for (int j = 0; j < m; j++) {', '          int item = Integer.parseInt(st.nextToken());', '          bullets[i][j] = item;', '        }', '      }', '', '      int result = superHero(power, bullets);', '      bw.write(String.valueOf(result));', '      bw.newLine();', '    }', '', '    bw.close();', '    br.close();', '  }', '}']"
 , 
 , 
"['import java.io.*;', 'import java.util.*;', 'import java.math.*;', 'public class Solution {', ' public static void main(String args[]) throws Exception {', '  Scanner sc = new Scanner(System.in);', '  int N = sc.nextInt();', '  int K = sc.nextInt();', '  int step=K/10;', '  int P[] = new int[N+16];', '  long maxSum[] = new long[N+16];', '  int maxSumEle[] = new int[N+16];', '  long max[] = new long[N+16];', '  int maxCount[] = new int[N+16];', '  int ii=0;', '  for(int i=0; i < N; ii++,i++) {', '   P[ii] = sc.nextInt();', '   if(P[ii]==0&&(ii==0||P[ii-1]==0))', '    ii--;', '  }', '  if(ii>0&&P[ii-1]==0)', '   ii--;', '  N=ii;', '  int mycount=0;', '  int n=N-1;', '  for(int i=0;n>=0&&(i<K||(i==K&&P[n]==0));i++,n--) {', '   max[n]=P[n]+max[n+1];', '   if(P[n]==0)', '    i=-1;', '   maxCount[n]=i+1;', '   //System.out.println(n+""   ""+P[n]+"" ""+max[n]+"" ""+maxCount[n]);', '  }', '  int NN=N;', '  NN=n+1;', '  long currSum=0;', '  long currMax=-1;', '  int currMaxEle=-1;', '  int end=K+3<N-NN+3?K+3:N-NN+3;', '  for(int i=0;i<end;i++) {', '   if(currSum+max[NN+i+1]>=currMax) {', '    if(currSum+max[NN+i+1]>currMax||currMaxEle>i+1)', '     currMaxEle=i+1;', '    currMax=currSum+max[NN+i+1];', '   }', '   if(currSum+max[NN+i+2]>=currMax) {', '    if(currSum+max[NN+i+2]>currMax||currMaxEle>i+2)', '     currMaxEle=i+2;', '    currMax=currSum+max[NN+i+2];', '   }', '   maxSum[i]=currMax;', '   //System.out.println(N+"" ""+K+"" ""+P[i+NN]+"" ""+i+"" ""+maxSum[i]+"" ""+maxSumEle[i]);', '   maxSumEle[i]=currMaxEle;', '   currSum+=P[i+NN];', '  }', '  //System.out.println(i+""            ""+n+"" ""+P[n]+"" ""+max[n]);', '  int mid=-1;', '  if(step>=1)', '   mid=NN-step;', '  for(;n>=0;n--) {', '   long res=max[n+1];', '   int resCount=0;', '   currSum=0;', '   int i=0;', '   end=K<NN-n?K:NN-n;', '   for(i=0;i<end;i++) {', '    currSum+=P[n+i];', '    if(res<=max[n+i+2]+currSum) {', '     if(res<max[n+i+2]+currSum||resCount>i+1)', '      resCount=i+1;', '     res=max[n+i+2]+currSum;', '    }', '    //System.out.println(i+"" ""+n+"" ""+P[n]+"" ""+res+"" ""+resCount);', '   }', '    ', '   if((i+n)<N) {', '    if(i<K) {', '     long currSum2=currSum+maxSum[K-i];', '     int currSumEle=i-1+maxSumEle[K-i];', '     if(res<=currSum2) {', '      if(res<currSum2||resCount>currSumEle)', '       resCount=currSumEle;', '      res=currSum2;', '     }', '     //System.out.println(i+"" ""+n+"" ""+P[n]+"" ""+res+"" ""+resCount);', '    } else {', '     i--;', '     if(i>=0&&res<=max[n+i+3]+currSum) {', '      if(res<max[n+i+3]+currSum||resCount>i+1)', '       resCount=i+1;', '      res=max[n+i+3]+currSum;', '     }', '    }', '   }', '   if(maxCount[n+1]<K&&res<=max[n+1]+P[n]) {', '    if(res<max[n+1]+P[n]||resCount>maxCount[n+1]+1)', '     resCount=maxCount[n+1]+1;', '    res=max[n+1]+P[n];', '   }', '   max[n]=res;', '   maxCount[n]=resCount;', '   if(n==mid) {', '    NN=n+1;', '    currSum=0;', '    currMax=-1;', '    currMaxEle=-1;', '    end=K+3<N-NN+3?K+3:N-NN+3;', '    for(i=0;i<end;i++) {', '     if(currSum+max[NN+i+1]>=currMax) {', '      if(currSum+max[NN+i+1]>currMax||currMaxEle>i+1)', '       currMaxEle=i+1;', '      currMax=currSum+max[NN+i+1];', '     }', '     if(currSum+max[NN+i+2]>=currMax) {', '      if(currSum+max[NN+i+2]>currMax||currMaxEle>i+2)', '       currMaxEle=i+2;', '      currMax=currSum+max[NN+i+2];', '     }', '     maxSum[i]=currMax;', '     //System.out.println(N+"" ""+K+"" ""+P[i+NN]+"" ""+i+"" ""+maxSum[i]+"" ""+maxSumEle[i]);', '     maxSumEle[i]=currMaxEle;', '     currSum+=P[i+NN];', '    }', '    //if(mid>1000)', '     mid-=step;//mid*9/10;', '    //else', '    // mid=-1;', '    if(mid<=0)', '     mid=-1;', '    mycount++;   ', '   }', '   //System.out.println(n+"" ""+P[n]+"" ""+res+"" ""+resCount);', '  } ', '  System.out.println(max[0]);//+"" ""+mycount);', ' }', '}', '/*', 'time java Solution < myin10', '99915808645418', '', 'real 0m26.662s', 'user 0m32.146s', 'sys 0m17.673s', '*/']","['import java.util.Scanner;', '', 'public class Billboards {', '', '    static int n;', '    static int k;', '    static long a[];', '    static long f[];', '    static int heap[];', '    static int heapSize;', '    static int where[];', '', '    static void swap(int a[], int i, int j) {', '        int tmp = a[i];', '        a[i] = a[j];', '        a[j] = tmp;', '    }', '', '    static boolean lessThan(int i, int j) {', '        return f[i - 1] + a[i] < f[j - 1] + a[j];', '    }', '', '    static void siftUp(int i) {', '        if (i > 1 && lessThan(heap[i], heap[i / 2])) {', '            swap(heap, i, i / 2);', '            swap(where, heap[i], heap[i / 2]);', '            siftUp(i / 2);', '        }', '    }', '', '    static void siftDown(int i) {', '        int which = i;', '        if (2 * i <= heapSize && lessThan(heap[2 * i], heap[which])) which = 2 * i;', '        if (2 * i + 1 <= heapSize && lessThan(heap[2 * i + 1], heap[which])) which = 2 * i + 1;', '        if (which != i) {', '            swap(heap, i, which);', '            swap(where, heap[i], heap[which]);', '            siftDown(which);', '        }', '    }', '', '    static void insert(int element) {', '        where[element] = ++heapSize;', '        heap[heapSize] = element;', '        siftUp(heapSize);', '    }', '', '    static void remove(int element) {', '        if (where[element] < heapSize) {', '            where[heap[heapSize]] = where[element];', '            heap[where[element]] = heap[heapSize--];', '', '            siftDown(where[element]);', '            siftUp(where[element]);', '        } else heapSize--;', '        where[element] = 0;', '    }', '', '    public static void main(String[] args) {', '        Scanner cin = new Scanner(System.in);', '', '        n = cin.nextInt();', '        k = cin.nextInt();', '        a = new long[n + 1];', '        f = new long[n + 1];', '        heap = new int[n + 1];', '        where = new int[n + 1];', '', '        long sum = 0;', '        for (int i = 1; i <= n; i++) {', '            a[i] = cin.nextLong();', '            sum += a[i];', '        }', '', '        for (int i = 1; i <= k; i++)', '            insert(i);', '        for (int i = k + 1; i <= n; i++) {', '            insert(i);', '            f[i] = f[heap[1] - 1] + a[heap[1]];', '            remove(i - k);', '        }', '', '        System.out.println(sum - f[n]);', '', '        cin.close();', '    }', '}']"
"['import java.io.*;', 'import java.math.BigInteger;', 'import java.util.*;', '', '', '', 'public class B', '{', '    String line;', '    StringTokenizer inputParser;', '    BufferedReader is;', '    FileInputStream fstream;', '    DataInputStream in;', '    String FInput="""";', '    ', '    void openInput(String file)', '    {', '', '            if(file==null)is = new BufferedReader(new InputStreamReader(System.in));//stdin', '            else', '            {', '                    try{', '            ', '                            ', '                    fstream = new FileInputStream(file);', '                    in = new DataInputStream(fstream);', '                    is = new BufferedReader(new InputStreamReader(in));', '                    }catch(Exception e)', '                    {', '                            System.err.println(e);', '                    }', '            }', '', '    }', '    ', '    void readNextLine()', ' {', '  try {', '   line = is.readLine();', '   inputParser = new StringTokenizer(line, "" ,\\t"");', '   //System.err.println(""Input: "" + line);', '  } catch (IOException e) {', '   System.err.println(""Unexpected IO ERROR: "" + e);', '  } ', '  catch (NullPointerException e)', '  {', '   line=null;', '   ', '  }', '  ', ' }', '    ', '    long NextLong()', '    {', '            String n = inputParser.nextToken();', '            ', '            long val = Long.parseLong(n);', '            ', '             return val;', '    }', '    ', '    int NextInt()', '    {', '            String n = inputParser.nextToken();', '            int val = Integer.parseInt(n);', '            ', '            //System.out.println(""I read this number: "" + val);', '            return val;', '    }', '    ', '    double NextDouble()', '    {', '            String n = inputParser.nextToken();', '            double val = Double.parseDouble(n);', '            ', '            //System.out.println(""I read this number: "" + val);', '            return val;', '    }', '    ', '    String NextString()', '    {', '            String n = inputParser.nextToken();', '            return n;', '    }', '    ', '    void closeInput()', '    {', '            try {', '                    is.close();', '            } catch (IOException e) {', '                    System.err.println(""Unexpected IO ERROR: "" + e);', '            }', '                    ', '    }', '    ', '    public static void main(String [] argv)', '    {', '            //String filePath=""circles.in"";', '            String filePath=null;', '            if(argv.length>0)filePath=argv[0];', '            new B(filePath);', '            ', '    }', '    ', '    public B(String inputFile)', '    {', '     openInput(inputFile);', '  //readNextLine();', '  int T=1;//NextInt();', '  StringBuilder sb = new StringBuilder();', '  for(int t=1; t<=T; t++)', '  {', '   readNextLine();', '   int N=line.length();', '   /*HashSet<String>res = new HashSet<String>();', '   for(int i=0; i<N; i++)', '   {', '    for(int j=i+1; j<N; j++)', '    {', '     res.add(line.substring(0, i)+line.substring(i+1, j)+line.substring(j+1));', '    }', '   }', '   sb.append(res.size()+""\\n"");*/', '   int cnt1=0;', '   int cnt2=0;', '   int cnt=0;', ""   char prev='?';"", '   ', '   int sub=0;', '   for(int i=0; i<N-2; i++)', '    if(line.charAt(i)==line.charAt(i+2)&&line.charAt(i)!=line.charAt(i+1))sub++;', '   for(int i=0; i<N; i++)', '   {', '    if(line.charAt(i)==prev)', '    {', '     cnt++;', '    }', '    else{', '     if(cnt==1)', '     {', '      cnt1++;', '      ', '      ', '     }', '     else if(cnt>1)cnt2++;', '     prev = line.charAt(i);', '     cnt=1;', '    }', '   }', '   if(cnt==1)cnt1++;', '   else if(cnt>1)cnt2++;', '   cnt1+=cnt2;', '   long ret = cnt1 * (long)(cnt1-1);', '   ret /=2;', '   ret += cnt2;', '   ret-=sub;', '   sb.append(ret+""\\n"");', '  }', '  System.out.print(sb);', '  ', '  closeInput();  ', ' }', '', '}']","['import java.io.*;', '', 'public class Solution {', '    ', '  static long beautifulStrings(char[] s) {', '      long result = 0;', '      int res[] = new int[s.length];', '      for (int j = s.length-1; j > 0; j--) {', '          res[j-1] = res[j];', '          if ((j > 1) && (s[j] == s[j-1])) {', '              continue;', '          }', '          res[j-1]++;', '          result++;', '      }', '      for (int i = 1; i < s.length-1; i++) {', '          if (s[i] == s[i-1]) {', '              continue;', '          }', '          if (s[i+1] != s[i-1]) {', '            result++;', '          }', '          result += res[i+1];', '      }', '      return result;', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '    char[] s = br.readLine().toCharArray();', '', '    long result = beautifulStrings(s);', '    bw.write(String.valueOf(result));', '    bw.newLine();', '', '    bw.close();', '    br.close();', '  }', '}']"
"['import java.io.DataInputStream;', 'import java.io.FileInputStream;', 'import java.io.IOException;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', '', 'public class Solution {', '  private static Reader in;', '  private static PrintWriter out;', '  public static long mod = 1000000007;', '  public static long mod_exp(long b, long e) {', '    long r = 1;', '    while (e > 0) {', '      if ((e & 1) == 1) r = (r * b) % mod;', '      b = (b * b) % mod;', '      e >>= 1;', '    }', '    return r;', '  }', '  ', '  public static long[] fact, invfact;', '  ', '  public static void main(String[] args) throws IOException {', '    in = new Reader();', '    out = new PrintWriter(System.out, true);', '    ', '    fact = new long[1001];', '    invfact = new long[1001];', '    fact[0] = 1;', '    invfact[0] = 1;', '    for (int i = 1; i <= 1000; i++) {', '      fact[i] = (i * fact[i - 1]) % mod;', '      invfact[i] = mod_exp(fact[i], mod - 2);', '    }', '    ', '    int sx = 1 << 29, sy = 1 << 29, ex = -1, ey = -1;', '    int N = in.nextInt(), K = in.nextInt();', '    int[][] p = new int[N][2];', '    for (int i = 0; i < N; i++) {', '      p[i] = new int[2];', '      p[i][0] = in.nextInt();', '      p[i][1] = in.nextInt();', '      if (p[i][0] < sx) sx = p[i][0];', '      if (p[i][0] > ex) ex = p[i][0];', '      if (p[i][1] < sy) sy = p[i][1];', '      if (p[i][1] > ey) ey = p[i][1];', '    }', '    int[] b = new int[] {sx, ex, sy, ey};', '    int[] id = new int[] {0, 0, 1, 1};', '    long total = 0;', '    for (int mask = 1; mask < 1 << 4; mask++) {', '      ', '      int count = 0;', '      for (int i = 0; i < N; i++) {', '        boolean ok = false;', '        for (int j = 0; j < 4; j++) {', '          if (set(mask, j) && p[i][id[j]] == b[j])', '            ok = true;', '        }', '        if (ok) count++;', '      }', '      long sgn = Integer.bitCount(mask) % 2 == 1 ? 1 : (mod - 1);', '      total = (total + sgn * binom(N - count, K - count)) % mod;', '    }', '    ', '    out.println(total);', '    out.close();', '    System.exit(0);', '  }', '  ', '  public static boolean set(int m, int i) {', '    return ((m >> i) & 1) == 1;', '  }', '  ', '  public static long binom(int N, int K) {', '    if (K < 0 || K > N) return 0;', '    return fact[N] * invfact[K] % mod * invfact[N - K] % mod;', '  }', '', '  static class Reader {', '    final private int BUFFER_SIZE = 1 << 16;', '    private DataInputStream din;', '    private byte[] buffer;', '    private int bufferPointer, bytesRead;', '', '    public Reader() {', '      din = new DataInputStream(System.in);', '      buffer = new byte[BUFFER_SIZE];', '      bufferPointer = bytesRead = 0;', '    }', '', '    public Reader(String file_name) throws IOException {', '      din = new DataInputStream(new FileInputStream(file_name));', '      buffer = new byte[BUFFER_SIZE];', '      bufferPointer = bytesRead = 0;', '    }', '', '    public String readLine() throws IOException {', '      byte[] buf = new byte[1024];', '      int cnt = 0, c;', '      while ((c = read()) != -1) {', ""        if (c == '\\n')"", '          break;', '        buf[cnt++] = (byte) c;', '      }', '      return new String(buf, 0, cnt);', '    }', '', '    public int nextInt() throws IOException {', '      int ret = 0;', '      byte c = read();', ""      while (c <= ' ')"", '        c = read();', ""      boolean neg = (c == '-');"", '      if (neg)', '        c = read();', '      do {', ""        ret = ret * 10 + c - '0';"", ""      } while ((c = read()) >= '0' && c <= '9');"", '      if (neg)', '        return -ret;', '      return ret;', '    }', '', '    public long nextLong() throws IOException {', '      long ret = 0;', '      byte c = read();', ""      while (c <= ' ')"", '        c = read();', ""      boolean neg = (c == '-');"", '      if (neg)', '        c = read();', '      do {', ""        ret = ret * 10 + c - '0';"", ""      } while ((c = read()) >= '0' && c <= '9');"", '      if (neg)', '        return -ret;', '      return ret;', '    }', '', '    public double nextDouble() throws IOException {', '      double ret = 0, div = 1;', '      byte c = read();', ""      while (c <= ' ')"", '        c = read();', ""      boolean neg = (c == '-');"", '      if (neg)', '        c = read();', '      do {', ""        ret = ret * 10 + c - '0';"", ""      } while ((c = read()) >= '0' && c <= '9');"", ""      if (c == '.')"", ""        while ((c = read()) >= '0' && c <= '9')"", ""          ret += (c - '0') / (div *= 10);"", '      if (neg)', '        return -ret;', '      return ret;', '    }', '', '    private void fillBuffer() throws IOException {', '      bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);', '      if (bytesRead == -1)', '        buffer[0] = -1;', '    }', '', '    private byte read() throws IOException {', '      if (bufferPointer == bytesRead)', '        fillBuffer();', '      return buffer[bufferPointer++];', '    }', '', '    public void close() throws IOException {', '      if (din == null)', '        return;', '      din.close();', '    }', '  }', '', '}']","['import java.io.PrintWriter;', 'import java.util.Scanner;', '', 'public class Solution{', '    public static final int MOD = (int) 1e9 + 7;', '    public static void main(String[] args){', '        Scanner sc = new Scanner(System.in);', '        PrintWriter pw = new PrintWriter(System.out);', '        while(sc.hasNext()){', '            solve(sc, pw);', '        }', '        sc.close();', '        pw.flush();', '        pw.close();', '    }', '', '    private static void solve(Scanner sc, PrintWriter pw){', '        int N = sc.nextInt();', '        int K = sc.nextInt();', '        K = N - K;', '', '        int[][] stains = new int[N+1][2];', '        int[] vals = new int[]{0,100000,0,100000};', '        for(int i = 1; i <= N; i++){', '            stains[i][0] = sc.nextInt();', '            stains[i][1] = sc.nextInt();', '            vals[0] = Math.max(vals[0], stains[i][0]);', '            vals[1] = Math.min(vals[1], stains[i][0]);', '            vals[2] = Math.max(vals[2], stains[i][1]);', '            vals[3] = Math.min(vals[3], stains[i][1]);', '        }', '', '        if(K == 0){', '            pw.println(1);', '            return;', '        }', '', '        int[] arr = new int[N+1];', '        for(int i = 1; i <= N; i++) {', '            int mask = 0;', '            for(int j = 0; j < 4; j++){', '                if(vals[j] == stains[i][j/2]){', '                    mask |= (1 << j);', '                }', '            }', '            arr[i] = mask;', '        }', '', '        int[][][] dp = new int[K+1][N+1][16];', '', '        for(int j = 1; j <= N; j++){', '            dp[1][j][arr[j]] = 1;', '            for(int k = 0; k < 16; k++){', '                dp[1][j][k] += dp[1][j-1][k];', '            }', '        }', '', '        for(int i = 1; i < K; i++){', '            for(int j = i; j < N; j++){', '                for(int k = 0; k < 16; k++){', '                    dp[i+1][j+1][k | arr[j+1]] = (dp[i+1][j+1][k | arr[j+1]] + dp[i][j][k]) % MOD;', '                    dp[i+1][j+1][k] = (dp[i+1][j+1][k] + dp[i+1][j][k]) % MOD;', '                }', '            }', '        }', '', '        int ans = 0;', '        for(int k = 0; k < 15; k++){', '            ans = (ans + dp[K][N][k]) % MOD;', '        }', '        pw.println(ans);', '    }', '', '', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class C2 {', ' InputStream is;', ' PrintWriter out;', ' String INPUT = """";', ' ', ' void solve()', ' {', '  int n = ni(), m = ni(), Q = ni();', '  int[] a = na(n);', '  int[] b = na(m);', '  for(int z = 0;z < Q;z++){', '   int dist = 0;', '   int r1 = ni(), c1 = ni(), r2 = ni(), c2 = ni();', '   int[] fr = make(a, r1, r2);', '   int[] fc = make(b, c1, c2);', '   long[] f = new long[100005];', '   for(int i = 0;i < 100005;i++)f[i] = (long)fr[i] * fc[i];', '   for(int i = 100004;i >= 1;i--){', '    for(int j = 2*i;j < 100005;j+=i){', '     f[i] -= f[j];', '    }', '   }', '   for(int i = 0;i < 100005;i++){', '    assert f[i] >= 0;', '    if(f[i] > 0)dist++;', '   }', '   out.println(dist);', '  }', ' }', ' ', ' int[] make(int[] a, int l, int r)', ' {', '  int[] f = new int[100005];', '  for(int i = l;i <= r;i++){', '   for(int d = 1;d*d <= a[i];d++){', '    if(a[i] % d == 0){', '     f[d]++;', '     if(d*d < a[i])f[a[i]/d]++;', '    }', '   }', '  }', '  return f;', ' }', ' ', ' public static long gcd3(long a, long b) {', '  if(a == 0)return b;', '  if(b == 0)return a;', '  ', '  int ashift = Long.numberOfTrailingZeros(a);', '  int bshift = Long.numberOfTrailingZeros(b);', '  a >>>= ashift;', '  b >>>= bshift;', '  while(b != a){', '   if(a > b){', '    long t = a; a = b; b = t;', '   }', '   b -= a;', '   b >>>= Long.numberOfTrailingZeros(b);', '  }', '  ', '  return a<<Math.min(ashift, bshift);', ' }', '', ' ', ' void run() throws Exception', ' {', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  long s = System.currentTimeMillis();', '  solve();', '  out.flush();', '  if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', ' }', ' ', ' public static void main(String[] args) throws Exception { new C2().run(); }', ' ', ' private byte[] inbuf = new byte[1024];', ' public int lenbuf = 0, ptrbuf = 0;', ' ', ' private int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private double nd() { return Double.parseDouble(ns()); }', ' private char nc() { return (char)skip(); }', ' ', ' private String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '  static final int MAXN = 100000;', '  static final int MAXV = MAXN + 5;', '', '  static final int[] a = new int[MAXV];', '  static final int[] b = new int[MAXV];', '  static final long[] d = new long[MAXV];', '  static final int[] va = new int[MAXV];', '  static final int[] vb = new int[MAXV];', '', '  static int gdcMatrix(int w, int x, int y, int z) {', '      for (int i = 1; i < MAXV; i++) {', '        va[i] = 0;', '        vb[i] = 0;', '        d[i] = 0;', '      } ', '', '      for (int i = w; i <= y; i++) {', '          va[a[i]]++;', '      }', '      for (int i = x; i <= z; i++) {', '          vb[b[i]]++;', '      }', '      for (int i = 1; i <= MAXN; i++) {', '          int j = i;', '          int v1 = 0;', '          int v2 = 0;', '          while (j <= MAXN) {', '              v1 += va[j];', '              v2 += vb[j];', '              j += i;', '          }', '          va[i] = v1;', '          vb[i] = v2;', '      }', '', '      int cnt = 0;', '      for(int i = MAXN; i >= 1; i--) {', '          int j = i;', '          long ans = 0;', '          ans = ((long) va[i]) * vb[i];', '          while(j <= MAXN) {', '              ans -= d[j];', '              j += i;', '          }', '          d[i] = ans;', '          if (d[i] > 0) cnt++;', '      }', '      return cnt;', '  }', '', '', '    public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '    String[] nmq = br.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '    int n = Integer.parseInt(nmq[0]);', '', '    int m = Integer.parseInt(nmq[1]);', '', '    int q = Integer.parseInt(nmq[2]);', '', '    String[] aItems = br.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '    for (int i = 0; i < n; i++) {', '      int aItem = Integer.parseInt(aItems[i]);', '      a[i] = aItem;', '    }', '', '        String[] bItems = br.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        for (int i = 0; i < m; i++) {', '            int bItem = Integer.parseInt(bItems[i]);', '            b[i] = bItem;', '        }', '', '        for (int qItr = 0; qItr < q; qItr++) {', '            String[] r1C1R2C2 = br.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '            int r1 = Integer.parseInt(r1C1R2C2[0]);', '', '            int c1 = Integer.parseInt(r1C1R2C2[1]);', '', '            int r2 = Integer.parseInt(r1C1R2C2[2]);', '', '            int c2 = Integer.parseInt(r1C1R2C2[3]);', '', '            // Write Your Code Here', '            int result = gdcMatrix(r1, c1, r2, c2);', '', '            bw.write(String.valueOf(result));', '            bw.newLine();', '        }', '', '        br.close();', '        bw.close();', '    }', '}']"
"['import java.io.BufferedReader;', 'import java.io.InputStreamReader;', 'import java.util.StringTokenizer;', '', 'class FairyChessSolver {', '', ' static final class Operation {', '', '  private static final int FINITE_FIELD_MODULO = 1000000007;', '', '  public static int add(int a, int b) {', '   int r = a + b;', '   return r - (((FINITE_FIELD_MODULO - r - 1) >> 31) & FINITE_FIELD_MODULO);', '  }', '', '  public static int sub(int a, int b) {', '   int r = a - b;', '   return r + (FINITE_FIELD_MODULO & (r >> 31));', '  }', ' }', '', "" private static char PAWN_SYMBOL = 'P';"", "" private static char LEAPER_SYMBOL = 'L';"", ' private static int EMPTY = 0;', ' private static int PAWN = 1;', '', ' private int n, m, s;', ' private int leaperRow, leaperCol;', ' private int[][] board;', ' ', ' public FairyChessSolver(int boardSize, int moves, int s, String[] board) {', '  this.n = boardSize;', '  this.board = new int[this.n][this.n];', '  this.m = moves;', '  this.s = s;', '  for (int i = 0; i < boardSize; i++) {', '   String row = board[i];', '   int[] thisRow = this.board[i];', '   for (int j = 0; j < boardSize; j++) {', '    if (row.charAt(j) == PAWN_SYMBOL) {', '     thisRow[j] = PAWN;', '    }', '    else if (row.charAt(j) == LEAPER_SYMBOL) {', '     leaperRow = i;', '     leaperCol = j;', '    }', '   }', '  }', ' }', '', ' public void solve() {', '  int[][] ways = new int[n][n];', '  ways[leaperRow][leaperCol] =  1;', '', '  int[][] cWays = new int[n][n];', '  int[][] s1 = new int[n+s][n+s];', '  int[][] s2 = new int[n+s][n+s];', '  for (int move = 0; move < m; move++) {', '', '   // - evaluate sums of diagonal stripes of length s / s-1', '   // -- i == 0', '   for (int j = s; j < n + s; j++) {', '    s1[0][j] = ways[0][j-s];', '   }', '   ', '   // -- i -> [1, s]', '   for (int i = 1; i <= s; i++) {', '    int[] s1i = s1[i];', '    int[] s1i1 = s1[i-1];', '    if (i < n) {', '     int[] wi = ways[i];', '     for (int j = 0; j < s; j++) {', '      s1i[j] = s1i1[j+1];', '     }', '     for (int j = s, l = n + s - 1; j < l; j++) {', '      s1i[j] = Operation.add(s1i1[j+1], wi[j-s]);', '     }', '     s1i[n+s-1] = wi[n-1];', '    }', '    else {', '     for (int j = 0, l = n + s - 1; j < l; j++) {', '      s1i[j] = s1i1[j+1];', '     }', '    }', '   }', '', '   // -- i -> (s, n+s)', '   for (int i = s + 1; i < n + s; i++) {', '    int[] s1i = s1[i];', '    int[] s1i1 = s1[i-1];', '    int[] wis1 = ways[i-s-1];', '    if (i < n) {', '     int[] wi = ways[i];', '     for (int j = 0; j < s; j++) {', '      if (j+1 < n) {', '       s1i[j] = Operation.sub(s1i1[j+1], wis1[j+1]);', '      }', '      else {', '       s1i[j] = s1i1[j+1];       ', '      }', '     }', '     for (int j = s, l = n + s - 1; j < l; j++) {', '      if (j+1 < n) {', '       s1i[j] = Operation.sub(Operation.add(s1i1[j+1], wi[j-s]), wis1[j+1]);', '      }', '      else {', '       s1i[j] = Operation.add(s1i1[j+1], wi[j-s]);', '      }', '     }', '     s1i[n+s-1] = wi[n-1];', '    }', '    else {', '     for (int j = 0, l = n - 1; j < l; j++) {', '      s1i[j] = Operation.sub(s1i1[j+1], wis1[j+1]);', '     }', '     for (int j = n - 1, l = n + s - 1; j < l; j++) {', '      s1i[j] = s1i1[j+1];', '     }', '    }', '   }', '', '   // -- i == 0', '   for (int j = 0; j < n; j++) {', '    s2[0][j] = ways[0][j];', '   }', '   ', '   // -- i -> [1, s)', '   for (int i = 1; i < s; i++) {', '    int[] s2i = s2[i];', '    int[] s2i1 = s2[i-1];', '    if (i < n) {', '     int[] wi = ways[i];', '     s2i[0] = wi[0];', '     for (int j = 1; j < n; j++) {', '      s2i[j] = Operation.add(s2i1[j-1], wi[j]);', '     }', '     for (int j = n, l = n + s; j < l; j++) {', '      s2i[j] = s2i1[j-1];', '     }', '    }', '    else {', '     for (int j = 1, l = n + s; j < l; j++) {', '      s2i[j] = s2i1[j-1];', '     }', '    }', '   }', '   ', '   // -- i -> [s, n+s)', '   for (int i = s; i < n + s; i++) {', '    int[] s2i = s2[i];', '    int[] s2i1 = s2[i-1];', '    int[] wis = ways[i-s];', '    if (i < n) {', '     int[] wi = ways[i];', '     s2i[0] = wi[0];', '     // --- j -> [1, s)', '     for (int j = 1; j < s; j++) {', '      if (j < n) {', '       s2[i][j] = Operation.add(s2i1[j-1], wi[j]);', '      }', '      else {', '       s2i[j] = s2i1[j-1];', '      }', '     }', '     // --- j -> [s, s+n)', '     for (int j = s, l = n + s; j < l; j++) {', '      if (j < n) {', '       s2i[j] = Operation.sub(Operation.add(s2i1[j-1], wi[j]), wis[j-s]);', '      }', '      else {', '       s2i[j] = Operation.sub(s2i1[j-1], wis[j-s]);', '      }', '     }   ', '    }', '    else {', '     // --- j -> [1, s)', '     for (int j = 1; j < s; j++) {', '      s2i[j] = s2i1[j-1];', '     }', '     // --- j -> [s, s+n)', '     for (int j = s, l = n + s; j < l; j++) {', '      s2i[j] = Operation.sub(s2i1[j-1], wis[j-s]);', '     }   ', '    }', '   }', '', '   // - evaluate updated ""ways to move"" matrix', '   // -- evaluate after-move value of cell (0, 0)', '   int value = 0;', '   for (int i = 0; i <= Math.min(s, n-1); i++) {', '    int[] wi = ways[i];', '    for (int j = 0, l = Math.min(s-i, n-1); j <= l; j++) {', '     value = Operation.add(value, wi[j]);', '    }', '   }', '   cWays[0][0] = value;', '', '   for (int i = 0; i < n; i++) {', '    if (i > 0) {', '     value = cWays[i-1][0];', '     // - add: s1(i+s, s)', '     value = Operation.add(value, s1[i+s][s]);', '     // - sub: s2(i-1, s), ways(i-s-1, 0)', '     if (i > s) {', '      value = Operation.sub(Operation.sub(value, s2[i-1][s]), ways[i-s-1][0]);', '     }', '     else {', '      value = Operation.sub(value, s2[i-1][s]);', '     }', '     // - set value', '     cWays[i][0] = value;', '     ', '     // - i > 0', '     int[] cwi = cWays[i];', '     int[] s1is = s1[i+s];', '     int[] s1i = s1[i];', '     int[] s2i1 = s2[i-1];', '     int[] s2is = s2[i+s];', '     for (int j = 1; j < n; j++) {', '      value = cwi[j-1];', '      // - add: s1(i+s, j+s), s2(i-1, j+s-1)', '      value = Operation.add(Operation.add(value, s1is[j+s]), s2i1[j+s-1]);', '      // - sub: s1(i, j-1), s2(i+s, j-1)', '      value = Operation.sub(Operation.sub(value, s1i[j-1]), s2is[j-1]);', '      // - set value', '      cwi[j] = value;', '     }', '    }', '    else {', '     // - i == 0', '     for (int j = 1; j < n; j++) {', '      value = cWays[0][j-1];', '      // - add: s1(i+s, j+s)', '      value = Operation.add(value, s1[s][j+s]);', '      // - sub: s1(i, j-1), s2(i+s, j-1)', '      value = Operation.sub(Operation.sub(value, s1[0][j-1]), s2[s][j-1]);', '      // - set value', '      cWays[0][j] = value;', '     }', '    }', '   }', '   // - clear occupied cells ', '   for (int i = 0; i < n; i++) {', '    int[] bi = board[i];', '    for (int j = 0; j < n; j++) {', '     if (bi[j] != EMPTY) {', '      cWays[i][j] = 0;', '     }', '    }', '   }', '   int[][] tmp = ways;', '   ways = cWays;', '   cWays = tmp;', '  }', '  int result = 0;', '  for (int i = 0; i < n; i++) {', '   int[] wi = ways[i];', '   for (int j = 0; j < n; j++) {', '    result = Operation.add(result, wi[j]);', '   }', '  }', '  System.out.println(result);', ' }', '}', '', 'public class Solution {', ' static public void main(String[] args) {', '  try {', '   BufferedReader br = new BufferedReader(new InputStreamReader(System.in), 64 << 10);', '   int testsNumber = Integer.parseInt(br.readLine().trim());', '   for (int test = 0; test < testsNumber; test++) {', '    StringTokenizer tokenizer = new StringTokenizer(br.readLine());', '    int n = Integer.parseInt(tokenizer.nextToken());', '    int m = Integer.parseInt(tokenizer.nextToken());', '    int s = Integer.parseInt(tokenizer.nextToken());', '    String[] board = new String[n];', '    for (int i = 0; i < n; i++) {', '     board[i] = br.readLine().trim();', '    }', '    new FairyChessSolver(n, m, s, board).solve();', '   }', '  }', '  catch (Exception e) {', '   System.err.println(""Error:"" + e.getMessage());', '  }', ' }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '  static final int MOD = 1_000_000_007;', '  ', '  static long sum(long a, long b) {', '    return (a + b) % MOD;', '  }', '  ', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int q = Integer.parseInt(st.nextToken());', '', '    for (int qItr = 0; qItr < q; qItr++) {', '      st = new StringTokenizer(br.readLine());', '', '      int n = Integer.parseInt(st.nextToken());', '      int m = Integer.parseInt(st.nextToken());', '      int s = Integer.parseInt(st.nextToken());', '', '      int[][] A = new int[2 * n + 1][2 * n + 1];', '      int[][] ways = new int[2 * n + 1][2 * n + 1];', '      for (int i = 0; i < n; i++) {', '        char[] item = br.readLine().toCharArray();', '        for (int j = 0; j < n; j++) {', ""          if (item[j] == 'P') {"", '            continue;', '          }', '', '          int x = i + j + 1;', '          int y = n - i + j;', '', '          A[x][y] = 1;', '', ""          if (item[j] == 'L') {"", '            ways[x][y]++;', '          }', '        }', '      }', '      for (int i = 0; i < m; i++) {', '        int[][] past = ways;', '        ways = new int[2 * n + 1][2 * n + 1];', '        ', '        for (int j = 0; j < 2 * n + 1; j++) {', '          for (int k = 0; k < 2 * n + 1; k++) {', '            if (j > 0) {', '              past[j][k] = (int) sum(past[j][k], past[j - 1][k]);', '            }', '            if (k > 0) {', '              past[j][k] = (int) sum(past[j][k], past[j][k - 1]);', '            }', '            if (j > 0 && k > 0) {', '              past[j][k] = (int) sum(past[j][k], MOD-past[j - 1][k - 1]);', '            }', '          }', '        }', '', '        for (int j = 0; j < 2 * n + 1; j++) {', '          for (int k = 0; k < 2 * n + 1; k++) {', '            if (A[j][k] == 0) continue;', '', '            int x1 = Math.max(j - s, 0);', '            int x2 = Math.min(j + s, 2 * n);', '', '            int y1 = Math.max(k - s, 0);', '            int y2 = Math.min(k + s, 2 * n);', '', '            ways[j][k] = past[x2][y2];', '', '            if (x1 > 0) {', '              ways[j][k] = (int) sum(ways[j][k], MOD-past[x1 - 1][y2]);', '            }', '            if (y1 > 0) {', '              ways[j][k] = (int) sum(ways[j][k], MOD-past[x2][y1 - 1]);', '            }', '            if (x1 > 0 && y1 > 0) {', '              ways[j][k] = (int) sum(ways[j][k], past[x1 - 1][y1 - 1]);', '            }', '          }', '        }', '      ', '      }', '      ', '      long result = 0;', '      for (int i = 0; i < 2 * n + 1; i++) {', '        for (int j = 0; j < 2 * n + 1; j++) {', '          result = sum(result, ways[i][j]);', '        }', '      }', '', '      bw.write(String.valueOf(result));', '      bw.newLine();', '    }', '', '    bw.close();', '    br.close();', '  }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(System.in);', '        int q = sc.nextInt();', '        for (int z = 0; z < q; z++){', '            String s = sc.next();', '            String[] srem = new String[27];', '            int[] nrem = new int[27];', '            srem[0] = s;', '            nrem[0] = srem[0].length();', '            int[][] mappings = new int[26][nrem[0]];', ""            for (char c = 'a'; c <= 'z'; c++) {"", ""                int i = c-'a'+1;"", '                srem[i] = srem[i-1].replaceAll(""""+c, """");', '                nrem[i] = srem[i].length();', '            }', '            for (int i = 0; i < 26; i++) {', '                if (nrem[i] == 0)', '                    break;', ""                if (srem[i].charAt(nrem[i]-1) == 'a'+i)"", '                    mappings[i][nrem[i]-1] = 0;', '                else', '                    mappings[i][nrem[i]-1] = nrem[i+1]-1;', '                for (int j = nrem[i]-2; j >= 0; j--) {', ""                    if (srem[i].charAt(j) == 'a'+i)"", '                        mappings[i][j] = mappings[i][j+1];', '                    else', '                        mappings[i][j] = (mappings[i][j+1]+nrem[i+1]-1)%nrem[i+1];', '                }', '            }', '            ArrayList<HashMap<Integer, Integer>> dp = new ArrayList<HashMap<Integer, Integer>>();', '            dp.add(new HashMap<Integer, Integer>());', '            dp.get(0).put(0, 0);', '            for (int i = 0; i <= 25; i++) {', '                if (nrem[i+1] == 0) // This is NOT a typo and means the remaining letters are in order because they are identical.', '                    break;', '                dp.add(new HashMap<Integer, Integer>());', '                for (int u : dp.get(i).keySet()) {', '                    int w = dp.get(i).get(u);', '                    int j = u;', ""                    while (srem[i].charAt(j)=='a'+i) {"", '                        j++;', '                        if (j==nrem[i])', '                            j = 0;', '                        if (j==u) { // should never happen', '                            j = -1;', '                            break;', '                        }', '                    }', '                    if (j == -1) {', '                        dp.get(i+1).put(mappings[i][u], w);', '                        continue;', '                    }', '                    HashSet<Integer> vs = new HashSet<Integer>();', '                    while (true) {', ""                        if (srem[i].charAt(j)=='a'+i)"", '                            vs.add(mappings[i][j]);', '                        j++;', '                        if (j == nrem[i])', '                            j -= nrem[i];', '                        if (j == u)', '                            break;', '                    }', '                    if (vs.isEmpty()) {', '                        dp.get(i+1).put(mappings[i][u], w);', '                    } else {', '                        for (int v : vs) {', '                            if (dp.get(i+1).containsKey(v))', '                                dp.get(i+1).put(v, Math.min(dp.get(i+1).get(v), w+vs.size()));', '                            else', '                                dp.get(i+1).put(v, w+vs.size());', '                        }', '                    }', ""                    if (srem[i].charAt(u)=='a'+i) {"", '                        int v = mappings[i][u];', '                        if (dp.get(i+1).containsKey(v))', '                            dp.get(i+1).put(v, Math.min(dp.get(i+1).get(v), w+vs.size()+1));', '                        else', '                            dp.get(i+1).put(v, w+vs.size()+1);', '                    }', '                }', '            }', '            int ans = Integer.MAX_VALUE;', '            for (int k : dp.get(dp.size()-1).keySet())', '                ans = Math.min(ans, dp.get(dp.size()-1).get(k));', '            System.out.println(ans);', '        }', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '  static int copy(List<Character> sorg, char[] dest, int startSorg, int endSorg, int startDest) {', '    for (int j = startSorg; j < endSorg; j++) {', '      dest[startDest++] = sorg.get(j);', '    }', '    return startDest;', '  }', '', '  static int copy(char[] sorg, char[] dest, int startSorg, int endSorg, int startDest) {', '    for (int j = startSorg; j < endSorg; j++) {', '      dest[startDest++] = sorg[j];', '    }', '    return startDest;', '  }', '', '  static char[] create(List<Character> sorg, int startSorg, int endSorg) {', '    char[] dest = new char[endSorg - startSorg];', '    copy(sorg, dest, startSorg, endSorg, 0);', '    return dest;', '  }', '', '  static int solve(char[] s) {', '    int res = 0;', '    char prev1 = 0;', '    List<Character> t = new ArrayList<>();', '    char a = s[0];', '    for (char c : s) {', '      if (c != prev1) {', '        t.add(c);', '      }', '      prev1 = c;', '      if (a > c) {', '        a = c;', '      }', '    }', '    if (t.size() > 0 && t.get(0) == a) {', '      if (t.size() == 1) {', '        return 0;', '      }', '      return solve(create(t, 1, t.size()));', '    }', '    List<char[]> parts = new ArrayList<>();', '    int prev = -1;', '    res = 0;', '    for (int i = 0; i < t.size(); i++) {', '      if (t.get(i) != a) {', '        continue;', '      }', '      parts.add(create(t, prev + 1, i));', '      res++;', '      prev = i;', '    }', '    char[] v = new char[t.size() - (prev + 1) + parts.get(0).length];', '    int start = copy(t, v, prev + 1, t.size(), 0);', '    copy(parts.get(0), v, 0, parts.get(0).length, start);', '    parts.set(0, v);', '    int bi = -1;', '    int bq = 0;', '    for (int i = 0; i < parts.size(); i++) {', '      char b = parts.get(i)[0];', '      int h = i > 0 ? i - 1 : parts.size() - 1;', '      char z = parts.get(h)[parts.get(h).length - 1];', '      char c = 0;', '      int ii = i;', '      int jj = 0;', '      while (true) {', '        jj++;', '        if (jj == parts.get(ii).length) {', '          ii = (ii + 1) % parts.size();', '          jj = 0;', '        }', '        if (ii == i && jj == 0) {', '          break;', '        }', '        if (parts.get(ii)[jj] != b) {', '          c = parts.get(ii)[jj];', '          break;', '        }', '      }', '      if (c == 0) {', '        c = b;', '      }', '      int q = (((int) b) * 1024) + ((z != b ? 0 : 1) * 256) - ((int) c);', '      if (bi == -1 || q < bq) {', '        bq = q;', '        bi = i;', '      }', '    }', '    StringBuilder sb = new StringBuilder();', '    for (int i = bi; i < parts.size(); i++) {', '      sb.append(parts.get(i));', '    }', '    for (int i = 0; i < bi; i++) {', '      sb.append(parts.get(i));', '    }', '    if (sb.length() == 0) {', '      return res;', '    }', '    return res + solve(sb.toString().toCharArray());', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int q = Integer.parseInt(st.nextToken());', '', '    for (int qItr = 0; qItr < q; qItr++) {', '      String s = br.readLine();', '', '      System.out.println(solve(s.toCharArray()));', '    }', '', '    br.close();', '  }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        new Solution();', '    }', '    ', '    public Solution() {', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        int[] l = new int[n];', '        for(int l_i=0; l_i < n; l_i++){', '            l[l_i] = in.nextInt();', '        }', '        ', '        Map<Integer, Integer> map = new HashMap<>();', '        for (int v : l) {', '            int cnt = 1;', '            if (map.containsKey(v)) cnt += map.get(v);', '            map.put(v, cnt);', '        }', '        ', '        int[] a = new int[map.size()];', '        int m = 0;', '        for (int v : map.keySet()) a[m++] = v;', '        ', '        // sort a', '        ', '        Arrays.sort(a);', '        // dp[i][j]: in range [0, i] of array a, how many ways to find two sticks, whose sum == a[j]', '        //int[][] dp = new int[m][m];', '        // dp[i][j] = dp[i-1][j] + cnt[a[i]] * cnt[a[j] - a[i]]   if a[j] - a[i] < a[i]', '        //         = dp[i-1][j] + choose(cnt[a[i]], 2)  if a[i] * 2 == a[j]', '        //         = dp[i-1][j]                            if a[i] * 2 < a[j]', '        long ans = 0L;', '        long[] dp = new long[m];', '        for (int i = 1; i < m; i++) {', '            // using a[i] as the length of one edge', '            // two cases:', '            //(1) use two of a[i]', '            //(2) use three of a[i]', '            // note can not use only one of a[i], which can not happen, since we need the other 5 sticks to get 3 edges', '            // then, must have at least another edge with length a[i]', '            int c = map.get(a[i]);', '            if (c == 1) continue;', '            ', '            ', '            // reset dp for i', '            // dp[j]: ways to choose two sticks in range [0, j] of array a, with sum == a[i]', '            for (int j = 0; j < m; j++) dp[j] = 0;', '            ', '            for (int j = 0; j < i; j++) {', '                dp[j] = j > 0 ? dp[j-1] : 0;', '                int cj = map.get(a[j]);', '                if (a[j] * 2 == a[i]) {', '                    dp[j] += cj * (cj - 1) / 2;', '                }else if (a[j] > a[i] - a[j] && map.containsKey(a[i] - a[j])) {', '                    int cs = map.get(a[i] - a[j]);', '                    dp[j] += cj * cs;', '                }', '            }', '            // case (1) : use two of a[i]', '            // need to find another 4 sticks', '            // two cases, assume a[i] = 8', '            //   case 1:   1 1 7 7 8 8 ', '            //   case 2:   1 7 2 6 8 8', '            ', '            // choose two a[i]', '            long cur = c * (c - 1) / 2;', '            if(test)System.out.println(""-------------------------------------"");', '            if(test)System.out.println(""--- i = "" + i + "" c = "" + c + "" cur = "" + cur);', '            long tmp = 0;', '            long case2 = 0;', '            long case1 = 0;', '            // try all positions which is the second largest edge', '            for (int j = i - 1; j >= 0; j--) {', '                // to remove duplicate:', '                //must have a[i] - a[j] <= a[j]', '                if (a[j] * 2 < a[i]) break;', '                ', '                int cj = map.get(a[j]);', '                int small = a[i] - a[j];', '                ', '                if (small == a[j]) {', '                    // choose 4 ', '                    if (cj >= 4) {', '                        tmp = 1L * cj * (cj - 1) / 2 * (cj - 2) * (cj - 3) / 12;', '                        case2 += tmp;', '                        if(test)System.out.println(""choose4: case2 ++ "" + tmp);', '                    }', '                    continue;', '                }', '                ', '                if (!map.containsKey(small)) continue;', '                ', '                int cs = map.get(small);', '                ', '                // choose two of a[j], and two of small = a[i] - a[j]', '                if(test)System.out.println(""--- j = "" + j + "", cs = "" + cs + "", cj = "" + cj + "", dp[j-1] = "" + dp[j-1]);', '                tmp = (long)cs * (cs - 1) / 2 * cj * (cj - 1) / 2;', '                case2 += tmp;', '                if(test)System.out.println(""case2 ++ "" + tmp);', '                // choose one of a[j] and one of small = a[i] - a[j]', '                if (j > 0) {', '                    tmp = (long)cj * cs * dp[j-1];', '                    case1 += tmp;', '                }', '                 if(test)System.out.println(""case1 ++ "" + tmp);', '                ', '            }', '            ', '            ans += cur * (case1 + case2);', '            if(test)System.out.println(""case1 = "" + case1 + "" case2 = "" + case2 + "" ans ="" + ans);', '            ', '            // now handle case (2): use three of a[i]', '            if (c == 2) continue;', '            ', '            // choose 3 of a[i]', '            cur = cur * (c - 2) / 3;', '            if(test)System.out.println(""step 2---cur = "" + cur);', '            case1 = 0;', '            case2 = 0;', '            long case3 = 0;', '            for (int j = i - 1; j >= 0; j--) {', '                if (a[j] * 3 < a[i]) break; // no need to try smalle j', '                // three cases:', '                // (1) choose 3 of a[j], e.g          3 3 3 9 9 9', '                // (2) choose 2 if a[j]:              1 4 4 9 9 9 ', '                // (3) choose 1 of a[j]:              1 3 5 9 9 9', '                //                             Or     2 2 5 9 9 9', '                int cj = map.get(a[j]);', '                if (a[j] * 3 == a[i]) {', '                    if (cj >= 3)  {', '                        tmp =  1L * cj * (cj - 1) * (cj - 2) / 6;  ', '                        case1 += tmp;', '                    }', '                    if(test)System.out.println(""[case2:1] j = "" + j + "", cj = "" + cj + "" ++ "" + tmp);', '                    ', '                    continue;', '                }', '                ', '                // choose 2 of a[j]', '                int small = a[i] - a[j] * 2;', '                if (small < a[j] && map.containsKey(small)) {', '                    int cs = map.get(small);', '                    tmp = (long)cj * (cj - 1) / 2 * cs;', '                    case2 += tmp;', '                    if(test)System.out.println(""[case2:2] j = "" + j + "", cs = "" + cs + "" ++ "" + tmp);', '                }', '                ', '                // choose 1 of a[j]', '                int sumleft = a[i] - a[j];', '                ', '                for (int k = j - 1; k >= 0; k--) {', '                    int sm = sumleft - a[k];', '                    if (sm > a[k]) break;              ', '                    ', '                    if (map.containsKey(sm)) {', '                        int cs = map.get(sm);', '                        int ck = map.get(a[k]);', '                        ', '                        if (sm == a[k]) {', '                            // choose a[j], sm, sm', '                            tmp =  (long)cj * cs * (cs - 1) / 2; ', '                            case3 += tmp;', '                            if(test)System.out.println(""[case2:3a] j = "" + j + "", cs = "" + cs + "" ++ "" + tmp);', '                        }else {', '                            // choose a[j], a[k], sm', '                            tmp = (long)cj * cs * ck; ', '                            case3 += tmp;', '                            if(test)System.out.println(""[case2:3b] j = "" + j + "", cs = "" + cs + "", ck = "" + ck + "" ++ "" + tmp);', '                        }', '                    }', '                }', '               ', '                ', '            }', '             ', '            ans += cur * (case1 + case2 + case3);', '            if(test)System.out.println("" case1 ="" + case1 + "" case2 =  "" + case2 + "" case3 = "" + case3 + "" ans = "" + ans);', '        }', '        ', '        ', '        System.out.println(ans);', '    }', '    boolean test = false;', '}']","['import java.util.Scanner;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner s = new Scanner(System.in);', '        int N = s.nextInt();', '        int R = 10000001;', '        int[] lenM = new int[R];', '', '        for (int i = 0; i < N; i++) {', '            int it = s.nextInt();', '            lenM[it]++;', '        }', '        Node[] nodes = new Node[R];', '        Node[] nodes1 = new Node[R];', '        int nodeLen = 0;', '        int[]vi=new int[R];', '        for (int i = 0; i < lenM.length; i++) {', '            if (lenM[i] >= 1) {', '                Node node = new Node(i, lenM[i]);', '                vi[i]=nodeLen;', '                nodes[nodeLen++] = node;', '                nodes1[i] = node;', '                ', '            }', '        }', '        int last=0,v;', '        for(int i=R-1;i>=0;i--) {', '            v=vi[i];', '            if(v==0) {', '                vi[i]=last;', '            }else {', '                last=vi[i];', '            }', '        }', '        int max = nodes[nodeLen - 1].v;', '        long[] cnTwo = new long[R];', '        long[] cnThree = new long[R];', '        for (int i = 2; i < R; i++) {', '            cnTwo[i] = (long) i * (i - 1) / 2;', '            cnThree[i] = cnTwo[i] * (i - 2) / 3;', '        }', '        int[] td = new int[R];', '', '        long ways = 0;', '        for (int i = 0; i < nodeLen; i++) {', '            Node n1 = nodes[i];', '            Node n2, n3, n4;', '            int ind;', '            if (n1.num >= 3) {', '                ind = n1.v * 3;', '                if (ind <= max) {', '                    n3 = nodes1[ind];', '                    if (n3 != null) {', '                        ways += (long) cnThree[n1.num] * cnThree[n3.num];', '                    }', '                }', '            }', '', '            for (int j = i + 1; j < nodeLen - 1; j++) {', '                n2 = nodes[j];', '                ind = n1.v * 2 + n2.v;', '                if (ind <= max) {', '                    n3 = nodes1[ind];', '                    if (n3 != null) {', '                        ways += (long) cnTwo[n1.num] * n2.num * cnThree[n3.num];', '                    }', '                }', '                ind = n1.v + n2.v * 2;', '                if (ind <= max) {', '                    n3 = nodes1[ind];', '                    if (n3 != null) {', '                        ways += (long) n1.num * cnTwo[n2.num] * cnThree[n3.num];', '                    }', '                }', '', '                ind = n1.v + n2.v;', '                if (ind <= max) {', '                    n3 = nodes1[ind];', '                    if (n3 != null) {', '                        ways += (long) td[ind] * n1.num * n2.num * cnTwo[n3.num];', '                        ways += (long) cnTwo[n1.num] * cnTwo[n2.num] * cnTwo[n3.num];', '                        td[ind] += n1.num * n2.num;', '                    }', '                } else {', '                    break;', '                }', '', '                int k = j + 1;', '                n3 = nodes[k];', '', '                ind = n1.v + n2.v + n3.v;', '                if(ind>max)', '                    continue;', '                int L = vi[ind];', '                for (; L < nodeLen; L++) {', '                    n4 = nodes[L];', '                    int idx3 = n4.v - n1.v - n2.v;', '                    n3 = nodes1[idx3];', '                    if (n3 != null) {', '                        ways += (long) n1.num * n2.num * n3.num * cnThree[n4.num];', '                    }', '                }', '', '            }', '', '        }', '', '        for (int i = 0; i < nodeLen; i++) {', '            Node n1 = nodes[i];', '            Node n3;', '            int idx = n1.v * 2;', '            if (idx <= max) {', '                n3 = nodes1[idx];', '                if (n3 != null) {', '                    ways += (long) td[n3.v] * cnTwo[n1.num] * cnTwo[n3.num];', '                    if (n1.num >= 4)', '                        ways += (long) n1.num * (n1.num - 1) * (n1.num - 2) * (n1.num - 3) / 24 * cnTwo[n3.num];', '                }', '', '            } else {', '                break;', '            }', '', '        }', '        System.out.println(ways);', '        s.close();', '    }', '', '    public static class Node implements Comparable<Node> {', '        private int v;', '        private int num; ', '', '        public Node(int v, int num) {', '            this.v = v;', '            this.num = num; ', '        }', '', '        public Node(int v) {', '            this.v = v;', '        }', '', '        @Override', '        public int compareTo(Node o) {', '', '            return this.v < o.v ? -1 : (this.v == o.v ? 0 : 1);', '        }', '', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    static int longestPalindromicSubsequence(String s, int k)', '    {', '        int n = s.length();', '        ', '        if (k == 0)', '        {', '            return (n + 1) * 26;', '        }', '        ', '        if (k > 2)', '        {', '            return 0;', '        }', '        ', '        if (n == 1)', '        {', '            if (k == 1)', '            {', '                return 2;', '            }', '            ', '            return 0;', '        }', '        ', '        short pal[][] = computePal(s);', '        short rightEnds[][] = computeRightEnds(s);', '        short leftEnds[][] = computeLeftEnds(s);', '        int sMax = pal[0][n - 1];', '        ', '        boolean ok[][] = new boolean[n + 1][26];', '        ', '        for (int i = 0; i <= n; i++)', '        {', '            for (int j = 0; j < n; j++)', '            {', '                char c = s.charAt(j);', '                int min;', '                int max;', '                int middle = 0;', '                ', '                if (i <= j)', '                {', '                    if (i < j)', '                    {', '                        middle = pal[i][j - 1];', '                    }', '                    ', '                    min = i;', '                    max = j;', '                }', '                else', '                {', '                    if (j + 1 <= i - 1)', '                    {', '                        middle = pal[j + 1][i - 1];', '                    }', '                    ', '                    min = j;', '                    max = i - 1;', '                }', '                ', '                int need = sMax + k - middle - 2;', '                ', '                if (need % 2 == 1)', '                {', '                    need++;', '                }', '                ', '                if (rightEnds[min][need / 2] > max + 1 ||', '                   leftEnds[max + 1][need / 2] <  min)', '                {', ""                    ok[i][c - 'a'] = true;"", '                    //System.out.println(""ok "" + i + "" "" + c);', '                }', '            }', '        }', '        ', '        /*for (int i = 0; i <= n; i++)', '        {', '            for (int j = n - 1; j > i; j--)', '            {', '                int midLength = sMax - pal[i][j - 1];', '', '                if (midLength % 2 == 0 &&', '                    rightEnds[i][midLength / 2] > j)', '                {', ""                    ok[i][s.charAt(j) - 'a'] = true;"", '                }', '            }', '        }', '        ', '        for (int i = n; i >= 0; i--)', '        {', '            for (int j = 0; j < i - 1; j++)', '            {', '                int midLength = sMax - pal[j + 1][i - 1];', '', '                if (midLength % 2 == 0 &&', '                    leftEnds[i][midLength / 2] < j)', '                {', ""                    ok[i][s.charAt(j) - 'a'] = true;"", '                }', '            }', '        }*/', '        ', '        if (k == 1)', '        {', '            if (sMax % 2 == 0)', '            {', '                for (int i = sMax / 2; i < n; i++)', '                {', '                    if (rightEnds[i][sMax / 2] >= i)', '                    {', '                        for (int j = 0; j < 26; j++)', '                        {', '                            ok[i][j] = true;', '                        }', '                    }', '                }', '            }', '            else', '            {', '                /*int half = sMax / 2;', '                ', '                for (int i = 0; i < n; i++)', '                {', ""                    int ch = s.charAt(i) - 'a';"", '                    ', '                    for (int j = i; j >= half; j--)', '                    {', '                        if (rightEnds[j][half] > i)', '                        {', '                            ok[j][ch] = true;', '                        }', '                        else', '                        {', '                            break;', '                        }', '                    }', '                    ', '                    for (int j = i + 1; j <= n - half; j++)', '                    {', '                        if (leftEnds[j][half] < i)', '                        {', '                            ok[j][ch] = true;', '                        }', '                        else', '                        {', '                            break;', '                        }', '                    }', '                }*/', '            }', '        }', '        ', '        int total = 0;', '        ', '        for (int i = 0; i <= n; i++)', '        {', '            for (int j = 0; j < 26; j++)', '            {', '                if (ok[i][j])', '                {', '                    total++;', '                }', '            }', '        }', '        ', '        return total;', '    }', '    ', '    private static short[][] computeRightEnds(String s)', '    {', '        short n = (short) s.length();', '        short ends[][] = new short[n + 1][n / 2 + 1];', '', '        for (int i = 0; i < ends.length; i++)', '        {', '            for (int j = 0; j < ends[i].length; j++)', '            {', '                ends[i][j] = -1;', '            }', '        }', '', '        ends[0][0] = n;', '        ', '        for (int len = 1; len <= n; len++)', '        {', '            ends[len][0] = n;', '            ', '            int i = n - 1;', '                ', '            while (i >= 0 && s.charAt(i) != s.charAt(len - 1))', '            {', '                i--;', '            }', '            ', '            for (int c = 1; c <= n / 2 && c <= len; c++)', '            {', '                ends[len][c] = (short) Math.max(-1, ends[len - 1][c]);', '                ', '                while (i >= ends[len - 1][c - 1])', '                {', '                    i--;', '                    ', '                    while (i >= 0 && s.charAt(i) != s.charAt(len - 1))', '                    {', '                        i--;', '                    }', '                }', '                ', '                if (i >= len)', '                {', '                    ends[len][c] = (short) Math.max(ends[len][c], i);', '                }', '            }', '        }', '        ', '        return ends;', '    }', '    ', '    private static short[][] computeLeftEnds(String s)', '    {', '        short n = (short) s.length();', '        short ends[][] = new short[n + 1][n / 2 + 1];', '        ', '        for (int i = 0; i < ends.length; i++)', '        {', '            for (int j = 0; j < ends[i].length; j++)', '            {', '                ends[i][j] = n;', '            }', '        }', '        ', '        ends[n][0] = -1;', '            ', '        for (int k = n - 1; k >= 0; k--)', '        {', '            ends[k][0] = -1;', '', '            int i = 0;', '                ', '            while (i < n && s.charAt(i) != s.charAt(k))', '            {', '                i++;', '            }', '            ', '            for (int c = 1; c <= n / 2 && c <= n - k; c++)', '            {', '                ends[k][c] = (short) Math.min(n, ends[k + 1][c]);', '                ', '                while (i <= ends[k + 1][c - 1])', '                {', '                    i++;', '                    ', '                    while (i < n && s.charAt(i) != s.charAt(k))', '                    {', '                        i++;', '                    }', '                }', '                ', '                if (i < k)', '                {', '                    ends[k][c] = (short) Math.min(ends[k][c], i);', '                }', '            }', '        }', '        ', '        return ends;', '    }', '    ', '    private static short[][] computePal(String s)', '    {', '        int n = s.length();', '        short pal[][] = new short[n][n];', '        ', '        for (int i = 0; i < n; i++)', '        {', '            pal[i][i] = 1;', '        }', '        ', '        for (int d = 1; d < n; d++)', '        {', '            for (int i = 0, j = d; j < n; i++, j++)', '            {', '                if (s.charAt(i) == s.charAt(j))', '                {', '                    if (d == 1)', '                    {', '                        pal[i][j] = 2;', '                    }', '                    else', '                    {', '                        pal[i][j] = (short) (pal[i + 1][j - 1] + 2);', '                    }', '                }', '                else', '                {', '                    pal[i][j] = (short) Math.max(pal[i][j - 1], pal[i + 1][j]);', '                }', '            }', '        }', '', '        return pal;', '    }', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int q = in.nextInt();', '        for(int a0 = 0; a0 < q; a0++){', '            int n = in.nextInt();', '            int k = in.nextInt();', '            String s = in.next();', '            int result = longestPalindromicSubsequence(s, k);', '            System.out.println(result);', '        }', '        in.close();', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '    static int N;', '    static int K;', '    static String S;', '    ', '    static int[][] dp;', '    static int[][] dpX;', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        dp = new int[3002][3002];', '        dpX = new int[3002][3002];', '', '        int T = in.nextInt();', '        for(int i = 0; i < T; i ++) {', '            N = in.nextInt();', '            K = in.nextInt();', '            S = in.next(""[a-z]+"");', '            int result = solve();', '            System.out.println(result);', '        }', '    }', '', '    static int solve() {', '        for (int i = 0; i < dp.length; i++) {', '            Arrays.fill(dp[i], -1);', '            Arrays.fill(dpX[i], -1);', '        }', '', '        int result;', '        if (K == 0) {', '            result = 26 * (N + 1);', '        } else {', '            result = 0;', '            for (int i = 0; i <= N; i++) {', '                int countOfExtend = countOfExtend(i);', '                result += countOfExtend;', '            }', '            return result;', '        }', '        return result;', '    }', '', '    private static int countOfExtend(int at) {', '        int base = count(0, N);', '        if (at > 0 && at < N) {', '            if (countOuter(at, at + 1) + 1 - base >= K) {', '                return 26;', '            }', '        }', '        boolean[] usedChars = new boolean[26];', '        int result = 0;', '        for (int i = 0; i < N; i++) {', ""            int ch = S.charAt(i) - 'a';"", '            if (!usedChars[ch]) {', '                int from = Math.min(i, at);', '                int to = Math.max(i, at);', '                int outer;', '                int inner;', '                if (i < at) {', '                    outer = countOuter(from - 1, to);', '                    inner = count(from + 1, to);', '                }', '                else {', '                    outer = countOuter(from - 1, to + 1);', '                    inner = count(from, to);', '                }', '                if (inner < 0 || outer < 0) {', '                    throw new IllegalStateException();', '                }', '', '                if (outer + inner + 2 - base >= K) {', '                    usedChars[ch] = true;', '                    result ++;', '                }', '            }', '        }', '', '        return result;', '    }', '', '    static int countOuter(int from, int to) {', '        if (from == -1 || to >= N) {', '            return 0;', '        }', '        else {', '            int result = dpX[from][to];', '            if (result >= 0) {', '                return result;', '            }', '            int a = S.charAt(from);', '            int b = S.charAt(to);', '            if (a == b) {', '                result = countOuter(from - 1, to + 1) + 2;', '            }', '            else {', '                result = Math.max(countOuter(from - 1, to), countOuter(from, to + 1));', '            }', '', '            dpX[from][to] = result;', '            return result;', '        }', '    }', '', '', '    static int count(int from, int to) {', '        if (from == to) {', '            return 0;', '        }', '        else if (from + 1 == to) {', '            return 1;', '        }', '', '        int result = dp[from][to];', '        if (result >= 0) {', '            return result;', '        }', '', '        int a = S.charAt(from);', '        int b = S.charAt(to - 1);', '', '        if (a == b) {', '            result = count(from + 1, to - 1) + 2;', '        }', '        else {', '            result = Math.max(count(from + 1, to), count(from, to - 1));', '        }', '', '        dp[from][to] = result;', '        return result;', '    }', '', '    ', '}']"
"['import java.util.*;', 'import java.io.*;', 'import static java.lang.Math.*;', '', 'public class Solution {', ' static class Foo52 {', '  static final int MOD = 1000000007;', '  String[] arr;', '  int N;', '  int M;', '  String[] pat;', '  ArrayList<String>[] endXpat;', '  ', '  void main() {', '   BufferedReader br = null;', '   try {', '    br = new BufferedReader(new InputStreamReader(System.in));', '    String[] s = br.readLine().trim().split("" "");', '    N = Integer.parseInt(s[0].trim());', '    M = Integer.parseInt(s[1].trim());', '    arr = new String[N];', '    int count = 0;', '    for (int i = 0; i < N; i++) {', '     String str = br.readLine().trim();', '     if (str.length() == 0)', '      continue; // empty string will not be added', '     arr[count++] = str;', '    }', '    if (count != N) {', '     N = count;', '     arr = Arrays.copyOf(arr, N);', '    }', '    fillSet();', '    int res = doit();', '    System.out.println(res);', '   } catch (Exception e) {', '    e.printStackTrace();', '   } finally {', '    if (br != null) {', '     try { br.close(); } catch (Exception e) { e.printStackTrace(); }', '    }', '   }', '  }', '  ', '  /*', ""   * dp[m,p] = dp3[m-len(p),v'] | v' = p.first char"", '   * dp2[m,v] = sum { dp[m,p] | p ends with v}', ""   * dp3[m,v] = sum {dp2[m,v'] | v' >= v} "", '   */', '  int doit() {', '   // seems that pat number should not be a lot, so no optimization is done on it', '   int size = pat.length;', '   int[][] dp = new int[M+1][size];', '   int[][] dp2 = new int[M+1][10];', '   int[][] dp3 = new int[M+1][10];', '   Arrays.fill(dp3[0], 1);', '   for (int m = 1; m <= M; m++) {', '    for (int i = 0; i < size; i++) {', '     if (pat[i].length() > m)', '      continue;', '     String curr = pat[i];', ""     dp[m][i] = dp3[m-curr.length()][curr.charAt(0)-'a'];"", '    }', '    for (int i = 0; i < 10; i++) {', '     for (int j = 0; j < size; j++) {', '      String curr = pat[j];', ""      if (curr.charAt(curr.length()-1)-'a' == i)"", '       dp2[m][i] = (dp2[m][i] + dp[m][j]) % MOD;', '     }', '    }', '    for (int i = 0; i < 10; i++) {', '     for (int j = i; j < 10; j++) {', '      dp3[m][i] = (dp3[m][i] + dp2[m][j]) % MOD;', '     }', '    }', '   }', '   int res = 0;', '   for (int m = 0; m <= M; m++) {', '    res = (res + dp3[m][0]) % MOD;', '   }', '   return res;', '  }', '  ', '  void fillSet() {', '   Arrays.sort(arr);', '   TreeSet<String> set = new TreeSet<String>();', '   set.add("""");', '   char[] store = new char[10];', '   for (int len = 1; len <= 10; len++) {', ""    fillSet(store, 0, 'a'-1, len, set);"", '   }', '   set.remove("""");', '   int n = set.size();', '   pat = new String[n];', '   int index = 0;', '   for (String str : set)', '    pat[index++] = str;', '   endXpat = new ArrayList[10];', '   for (int i = 0; i < 10; i++) {', '    endXpat[i] = new ArrayList<String>();', '   }', '   for (String str : pat) {', ""    endXpat[str.charAt(str.length()-1)-'a'].add(str);"", '   }', '  }', '  void fillSet(char[] store, int index, int last, int len, TreeSet<String> set) {', '   if (index == len) {', '    String curr = new String(Arrays.copyOf(store, len));', '    // check if curr ok', '    for (String pre : arr) {', '     if (pre.length() <= curr.length() && curr.indexOf(pre) == 0 ', '       && set.contains(curr.substring(pre.length()))) {', '      set.add(curr);', '      break;', '     }', '    }', '    return;', '   }', ""   for (int i = last+1; i <= 'j'; i++) {"", '    store[index] = (char)i;', '    fillSet(store, index+1, i, len, set);', '   }', '  }', ' }', ' public static void main(String[] args) {', '  Foo52 foo = new Foo52();  ', '  foo.main();', ' }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '  static final int AB = 10;', '  static final int MAX = 1 << AB;', '  static final long MOD = 1_000_000_007;', '', '  static long hyperStrings(int m, int[] arr) {', '    Arrays.sort(arr);', '    boolean[] b = new boolean[MAX];', '    b[0] = true;', '    for (int i = 0; i < arr.length; i++) {', '      int n = 1 << Integer.numberOfTrailingZeros(arr[i]);', '      for (int j = n-1; j >= 0; j--) {', '        if (b[j]) {', '          b[j | arr[i]] = true;', '        }', '      }', '    }', '    int[] a = new int[MAX];', '    int n = 0;', '    for (int i = 0; i < MAX; i++) {', '      if (b[i]) {', '          a[n++] = i;', '      }', '    }', '  ', '    long result = 0;', '', '    int[][] s = new int[a.length+1][AB];', '    s[0][AB-1] = 1;', '    for (int i = 0; i < m+1; i++) {', '      for (int j = 0; j < AB; j++) {', '        result = (result + s[i][j]) % MOD;', '        for (int k = 0; k < n; k++) {', '          int pop = Integer.bitCount(a[k]);', '          int atz = Integer.numberOfTrailingZeros(a[k]);', '          if ((i + pop) <= m && atz <= j) {', '            int alz = Integer.numberOfLeadingZeros(a[k]);', '            s[i+pop][31 - alz] = (int)((s[i+pop][31 - alz] + s[i][j]) % MOD);', '          }', '        }', '      }', '    }', '    return result;', '  }', '', '  static void load(int[] a, int i, char[] arr) {', '    for (char c : arr) {', ""        a[i] |= 1 << (c - 'a');"", '    }    ', '  }', '', '    public static void main(String[] args) throws IOException {', '        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        StringTokenizer st = new StringTokenizer(br.readLine());', '        int n = Integer.parseInt(st.nextToken());', '        int m = Integer.parseInt(st.nextToken());', '', '        int[] a = new int[n];', '        String s = br.readLine();', '        if (s.contains("" "")) {', '          String[] v = s.split("" "");', '          for (int i = 0; i < n; i++) {', '            load(a, i, v[i].toCharArray());', '          }', '        } else {', '          load(a, 0, s.toCharArray());', '          for (int i = 1; i < n; i++) {', '            load(a, i, br.readLine().toCharArray());', '          }', '        }', '', '        long result = hyperStrings(m, a);', '', '        bw.write(String.valueOf(result));', '        bw.newLine();', '', '        br.close();', '        bw.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'public class Solution implements Runnable {', '    final static int MOD = 1000000007;', '', '    int count(String a, String b) {', '        int n = a.length();', '        int m = b.length();', '        int dp[][] = new int[n + 1][m + 1];', '        int sum[][] = new int[n + 1][m + 1];', '        for (int i = 0; i <= n; ++ i) {', '            sum[i][m] = 1;', '        }', '        for (int j = 0; j <= m; ++ j) {', '            sum[n][j] = 1;', '        }', '        for (int i = n - 1; i >= 0; -- i) {', '            for (int j = m - 1; j >= 0; -- j) {', '                if (a.charAt(i) == b.charAt(j)) {', '                    dp[i][j] = sum[i + 1][j + 1];', '                } ', '                sum[i][j] = (sum[i + 1][j] + sum[i][j + 1]', '                    - sum[i + 1][j + 1] + dp[i][j]) % MOD;', '            }', '        }', '        int result = 0;', '        for (int i = 0; i < n; ++ i) {', '            result += dp[i][0];', '            result %= MOD;', '        }', '        return result;', '    }', '', '    int count(String s) {', '        int n = s.length();', '        int result = 0;', '        for (int i = 1; i < n; ++ i) {', '            result += count(s.substring(0, i), s.substring(i, n));', '            result %= MOD;', '        }', '        return (result + MOD) % MOD;', '    }', '', '    public void run() {', '        try {', '            BufferedReader reader = new BufferedReader(', '                    new InputStreamReader(System.in));', '            int testCount = Integer.parseInt(reader.readLine());', '            while (testCount > 0) {', '                testCount --;', '                System.out.println(count(reader.readLine()));', '            }', '        } catch (Exception e) {', '        }', '    }', '', '    public static void main(String args[]) {', '        new Thread(new Solution()).run();', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution implements Runnable {', '    final static int MOD = 1000000007;', '', '    int count(String a, String b) {', '        int n = a.length();', '        int m = b.length();', '        int dp[][] = new int[n + 1][m + 1];', '        int sum[][] = new int[n + 1][m + 1];', '        for (int i = 0; i <= n; ++ i) {', '            sum[i][m] = 1;', '        }', '        for (int j = 0; j <= m; ++ j) {', '            sum[n][j] = 1;', '        }', '        for (int i = n - 1; i >= 0; -- i) {', '            for (int j = m - 1; j >= 0; -- j) {', '                if (a.charAt(i) == b.charAt(j)) {', '                    dp[i][j] = sum[i + 1][j + 1];', '                } ', '                sum[i][j] = (sum[i + 1][j] + sum[i][j + 1]', '                    - sum[i + 1][j + 1] + dp[i][j]) % MOD;', '            }', '        }', '        int result = 0;', '        for (int i = 0; i < n; ++ i) {', '            result += dp[i][0];', '            result %= MOD;', '        }', '        return result;', '    }', '', '    int count(String s) {', '        int n = s.length();', '        int result = 0;', '        for (int i = 1; i < n; ++ i) {', '            result += count(s.substring(0, i), s.substring(i, n));', '            result %= MOD;', '        }', '        return (result + MOD) % MOD;', '    }', '', '    public void run() {', '        try {', '            BufferedReader reader = new BufferedReader(', '                    new InputStreamReader(System.in));', '            int testCount = Integer.parseInt(reader.readLine());', '            while (testCount > 0) {', '                testCount --;', '                System.out.println(count(reader.readLine()));', '            }', '        } catch (Exception e) {', '        }', '    }', '', '    public static void main(String args[]) {', '        new Thread(new Solution()).run();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', ' BufferedReader br;', ' PrintWriter out;', ' StringTokenizer st;', ' boolean eof;', '', ' void solve() throws IOException {', '  int n = nextInt();', '  int x = nextInt();', '', '  long[] max = new long[x + 1];', '  Arrays.fill(max, -1);', '  max[0] = 0;', '', '  long freeBonus = 0;', '', '  List<Integer>[] byNeed = new List[x + 1];', '  for (int i = 1; i <= x; i++) {', '   byNeed[i] = new ArrayList<>(0);', '  }', '', '  for (int i = 0; i < n; i++) {', '   int gain = nextInt();', '   int need = nextInt();', '   if (need == 0) {', '    freeBonus += gain;', '    continue;', '   }', '   if (need <= x) {', '    byNeed[need].add(gain);', '   }', '', '  }', '', '  for (int need = 1; need <= x; need++) {', '   List<Integer> cur = byNeed[need];', '   Collections.sort(cur);', '   Collections.reverse(cur);', '   for (int i = 0; (i + 1) * need <= x && i < cur.size(); i++) {', '    int gain = cur.get(i);', '    for (int j = x; j >= need; j--) {', '     if (max[j - need] != -1) {', '      max[j] = Math.max(max[j], max[j - need] + gain);', '     }', '    }', '   }', '  }', '', '  if (max[x] == -1) {', '   out.println(""Got caught!"");', '  } else {', '   out.println(max[x] + freeBonus);', '  }', ' }', '', ' Solution() throws IOException {', '  br = new BufferedReader(new InputStreamReader(System.in));', '  out = new PrintWriter(System.out);', '  solve();', '  out.close();', ' }', '', ' public static void main(String[] args) throws IOException {', '  new Solution();', ' }', '', ' String nextToken() {', '  while (st == null || !st.hasMoreTokens()) {', '   try {', '    st = new StringTokenizer(br.readLine());', '   } catch (Exception e) {', '    eof = true;', '    return null;', '   }', '  }', '  return st.nextToken();', ' }', '', ' String nextString() {', '  try {', '   return br.readLine();', '  } catch (IOException e) {', '   eof = true;', '   return null;', '  }', ' }', '', ' int nextInt() throws IOException {', '  return Integer.parseInt(nextToken());', ' }', '', ' long nextLong() throws IOException {', '  return Long.parseLong(nextToken());', ' }', '', ' double nextDouble() throws IOException {', '  return Double.parseDouble(nextToken());', ' }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '    BufferedReader br;', '    PrintWriter out;', '    StringTokenizer st;', '    boolean eof;', '', '    void solve() throws IOException {', '        int n = nextInt();', '        int x = nextInt();', '', '        long[] max = new long[x + 1];', '        Arrays.fill(max, -1);', '        max[0] = 0;', '', '        long freeBonus = 0;', '', '        List<Integer>[] byNeed = new List[x + 1];', '        for (int i = 1; i <= x; i++) {', '            byNeed[i] = new ArrayList<>(0);', '        }', '', '        for (int i = 0; i < n; i++) {', '            int gain = nextInt();', '            int need = nextInt();', '            if (need == 0) {', '                freeBonus += gain;', '                continue;', '            }', '            if (need <= x) {', '                byNeed[need].add(gain);', '            }', '', '        }', '', '        for (int need = 1; need <= x; need++) {', '            List<Integer> cur = byNeed[need];', '            Collections.sort(cur);', '            Collections.reverse(cur);', '            for (int i = 0; (i + 1) * need <= x && i < cur.size(); i++) {', '                int gain = cur.get(i);', '                for (int j = x; j >= need; j--) {', '                    if (max[j - need] != -1) {', '                        max[j] = Math.max(max[j], max[j - need] + gain);', '                    }', '                }', '            }', '        }', '', '        if (max[x] == -1) {', '            out.println(""Got caught!"");', '        } else {', '            out.println(max[x] + freeBonus);', '        }', '    }', '', '    Solution() throws IOException {', '        br = new BufferedReader(new InputStreamReader(System.in));', '        out = new PrintWriter(System.out);', '        solve();', '        out.close();', '    }', '', '    public static void main(String[] args) throws IOException {', '        new Solution();', '    }', '', '    String nextToken() {', '        while (st == null || !st.hasMoreTokens()) {', '            try {', '                st = new StringTokenizer(br.readLine());', '            } catch (Exception e) {', '                eof = true;', '                return null;', '            }', '        }', '        return st.nextToken();', '    }', '', '    String nextString() {', '        try {', '            return br.readLine();', '        } catch (IOException e) {', '            eof = true;', '            return null;', '        }', '    }', '', '    int nextInt() throws IOException {', '        return Integer.parseInt(nextToken());', '    }', '', '    long nextLong() throws IOException {', '        return Long.parseLong(nextToken());', '    }', '', '    double nextDouble() throws IOException {', '        return Double.parseDouble(nextToken());', '    }', '}']"
"['import java.awt.*;', 'import java.awt.event.*;', 'import java.awt.geom.*;', 'import java.io.*;', 'import java.math.*;', 'import java.text.*; ', 'import java.util.*;', 'import java.util.regex.*;', '/*', '      br = new BufferedReader(new FileReader(""input.txt""));', '      pw = new PrintWriter(new BufferedWriter(new FileWriter(""output.txt"")));', '      br = new BufferedReader(new InputStreamReader(System.in));', '      pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));', ' */', '', '', 'public class Solution {', ' private static BufferedReader br;', ' private static StringTokenizer st;', ' private static PrintWriter pw;', '', ' static long[][] cost;', '', ' public static void main(String[] args) throws IOException {', '  br = new BufferedReader(new InputStreamReader(System.in));', '  pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));', '  //int qq = 1;', '  int qq = Integer.MAX_VALUE;', '  //int qq = readInt();', '  for(int casenum = 1; casenum <= qq; casenum++) {', '   int n = readInt();', '   int k = readInt();', '   int[] x = new int[n];', '   long[] w = new long[n];', '', '   long[] prod = new long[n];', '   long[] wPre = new long[n+1];', '   long[] prodPre = new long[n+1];', '', '   for(int i = 0; i < n; i++) {', '    x[i] = readInt();', '    w[i] = readInt();', '    wPre[i+1] = wPre[i] + w[i];', '    prod[i] = x[i] * w[i];', '    prodPre[i+1] = prodPre[i] + prod[i];', '   }', '   cost = new long[n][n];', '   for(int i = 0; i < n; i++) {', '    for(int j = i+1; j < n; j++) {', '     int l = i;', '     int r = j;', '     while(l != r) {', '      int m = (l+r+1)/2;', '      if(x[m] - x[i] < x[j] - x[m]) {', '       l = m;', '      }', '      else {', '       r = m-1;', '      }', '     }', '', '     long lhsCost = prodPre[l+1] - prodPre[i];', '     lhsCost -= x[i] * (wPre[l+1] - wPre[i]);', '', '     long rhsCost = x[j] * (wPre[j+1] - wPre[l+1]);', '     rhsCost -= prodPre[j+1] - prodPre[l+1];', '', '     cost[i][j] = lhsCost + rhsCost;', '    }', '   }', '', '   dp = new long[k][n];', '   for(int i = 1; i < n; i++) {', '    for(int j = 0; j < i; j++) {', '     dp[0][i] += (x[i] - x[j]) * w[j];', '    }', '   }', '   final long INF = 1L << 60;', '   for(int i = 1; i < k; i++) {', '    solve(i, 0, n-1, 0, n-1);', '   }', '   long ret = dp[k-1][n-1];', '   long curr = 0;', '   long prior = 0;', '   for(int i = n-2; i >= 0; i--) {', '    if(dp[k-1][i] == INF) continue;', '    curr += w[i+1];', '    ret = Math.min(ret, dp[k-1][i] + curr * (x[i+1] - x[i]) + prior);', '    prior = curr * (x[i+1] - x[i]) + prior;', '   }', '   pw.println(ret);', '  }', '  exitImmediately();', ' }', '', ' static long[][] dp;', '', ' public static int force(int rowNum, int position, int l, int r) {', '  dp[rowNum][position] = 1L << 62;', '  int ret = l;', '  ', '  //pw.println(""Consider row "" + rowNum);', '  //pw.println(""Evaluate position "" + position);', '  ', '  for(int i = l; i <= r; i++) {', '   //pw.println(""Consider from "" + (i+1) + "" to "" + position);', '   //pw.println(""Components: "" + dp[rowNum-1][i] + "" "" + cost[i+1][position]);', '   long next = dp[rowNum-1][i] + cost[i][position];', '   if(next < dp[rowNum][position]) {', '    dp[rowNum][position] = next;', '    ret = i;', '   }', '  }', '', '  return ret;', ' }', '', ' public static void solve(int rowNum, int l, int r, int searchL, int searchR) {', '  if(l > r) return;', '  if(l == r) {', '   force(rowNum, l, searchL, searchR);', '  }', '  searchR = Math.min(searchR, r-1);', '  if(searchL == searchR) {', '   for(int i = l; i <= r; i++) {', '    force(rowNum, i, searchL, searchR);', '   }', '  }', '  int m = (l + r) / 2;', '  int optM = force(rowNum, m, searchL, searchR);', '  solve(rowNum, l, m-1, searchL, optM);', '  solve(rowNum, m+1, r, optM, searchR);', ' }', '', ' private static void exitImmediately() {', '  pw.close();', '  System.exit(0);', ' }', '', ' private static long readLong() throws IOException {', '  return Long.parseLong(nextToken());', ' }', '', ' private static double readDouble() throws IOException {', '  return Double.parseDouble(nextToken());', ' }', '', ' private static int readInt() throws IOException {', '  return Integer.parseInt(nextToken());', ' }', '', ' private static String nextLine() throws IOException  {', '  if(!br.ready()) {', '   exitImmediately();', '  }', '  st = null;', '  return br.readLine();', ' }', '', ' private static String nextToken() throws IOException  {', '  while(st == null || !st.hasMoreTokens())  {', '   if(!br.ready()) {', '    exitImmediately();', '   }', '   st = new StringTokenizer(br.readLine().trim());', '  }', '  return st.nextToken();', ' }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '  static long chase2(long dpij0, long dpij1, long[][] cost, int j0, int j1) {', '    long l = j1 + 1;', '    long h = cost.length;', '    while (l < h) {', '      int m = (int) (l + h >> 1);', '      if (dpij0 + cost[j0][m] < dpij1 + cost[j1][m]) {', '        l = m + 1;', '      } else {', '        h = m;', '      }', '    }', '    return l;', '  }', '', '  static long mining(int k, int[] x, int[] w) {', '    long[][] cost = new long[x.length][x.length];', '    long[] dp1 = new long[x.length];', '    long[] dp2 = new long[x.length];', '    long sumi = 0;', '    long sumi2 = 0;', '    for (int i = 0; i < x.length; i++) {', '      int ki = i;', '      long sumk = sumi;', '      long sumk2 = sumi2;', '      long sumj = sumi;', '      long sumj2 = sumi2;', '      for (int j = i; j < x.length; j++) {', '        sumj += w[j];', '        sumj2 += (long)w[j]*x[j];', '        for (; ki < j && x[ki]-x[i] < x[j]-x[ki]; ki++) {', '          sumk += w[ki];', '          sumk2 += (long)w[ki]*x[ki];', '        }', '        cost[i][j] = sumk2-sumi2-(sumk-sumi)*x[i] + (sumj-sumk)*x[j]-sumj2+sumk2;', '      }', '      sumi += w[i];', '      sumi2 += (long)w[i]*x[i];', '      dp1[i] = sumi*x[i]-sumi2;', '    }', '    int[] q = new int[x.length];', '    for (int i = 0; i < k-1; i++) {', '      int hd = 0;', '      int tl = 0;', '      for (int j = 0; j < q.length; j++) {', '        while (hd+1 < tl && dp1[q[hd]]+cost[q[hd]][j] > dp1[q[hd+1]]+cost[q[hd+1]][j]) {', '          hd++;', '        }', '        dp2[j] = j != 0 ? dp1[q[hd]]+cost[q[hd]][j] : 0;', '        while (hd <= tl - 2 && chase2(dp1[q[tl - 2]], dp1[q[tl - 1]], cost, q[tl - 2],', '            q[tl - 1]) > chase2(dp1[q[tl - 1]], dp1[j], cost, q[tl - 1], j)) {', '          tl--;', '        }', '        q[tl++] = j;', '      }', '      long[] t = dp1;', '      dp1 = dp2;', '      dp2 = t;', '    }', '    long ans = Long.MAX_VALUE;', '    long sum = sumi;', '    long sum2 = sumi2;', '    sumi = sumi2 = 0;', '    for (int i = 0; i < x.length; i++) {', '      ans = Math.min(ans, dp1[i]+sum2-sumi2-(sum-sumi)*x[i]);', '      sumi += w[i];', '      sumi2 += (long)w[i]*x[i];', '    }', '    return ans;', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int n = Integer.parseInt(st.nextToken());', '    int k = Integer.parseInt(st.nextToken());', '', '    int[] x = new int[n];', '    int[] w = new int[n];', '    for (int i = 0; i < n; i++) {', '      st = new StringTokenizer(br.readLine());', '      x[i] = Integer.parseInt(st.nextToken());', '      w[i] = Integer.parseInt(st.nextToken());', '    }', '', '    long result = mining(k, x, w);', '', '    bw.write(String.valueOf(result));', '    bw.newLine();', '', '    bw.close();', '    br.close();', '  }', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', ' BufferedReader br;', ' PrintWriter out;', ' StringTokenizer st;', ' boolean eof;', '', ' static class Line {', '  long k;', '  long b; // y = k * x + b', '', '  public Line(long k, long b) {', '   this.k = k;', '   this.b = b;', '  }', '', '  double cross(Line o) {', '   return 1.0 * (o.b - b) / (k - o.k);', '  }', '', '  long vect(Line a) {', '   return k * a.b - a.k * b;', '  }', ' }', '', ' boolean badTurn(Line a, Line b, Line c) {', '  return a.vect(b) + b.vect(c) + c.vect(a) >= 0;', ' }', '', ' void solve() throws IOException {', '  int n = nextInt();', '  int h = nextInt();', '  int[] xs = new int[n];', '  for (int i = 0; i < n; i++) {', '   xs[i] = nextInt();', '  }', '  if (n == 0) {', '   out.println(0);', '   return;', '  }', '  if (n == 1) {', '   out.println(h);', '   return;', '  }', '  long[] dp = new long[n + 1];', '  Line[] s = new Line[n + 1];', '  int sz = 0;', '  s[sz++] = new Line(-2 * xs[0], h + sqr(xs[0]));', '  double[] c = new double[n + 1];', '  for (int i = 0; i < n; i++) {', '   int pos = Arrays.binarySearch(c, 0, sz - 1, xs[i]);', '   if (pos < 0) {', '    pos = -pos - 1;', '   }', '   dp[i + 1] = Long.MAX_VALUE;', '   for (int j = pos - 1; j <= pos + 1; j++) {', '    if (j >= 0 && j < sz) {', '     dp[i + 1] = Math.min(dp[i + 1], s[j].k * xs[i] + s[j].b);', '    }', '   }', '   dp[i + 1] += sqr(xs[i]);', '   if (i != n - 1) {', '    Line add = new Line(-2 * xs[i + 1], h + dp[i + 1] + sqr(xs[i + 1]));', '//    System.err.println(dp[i + 1] + "", "" + add.k + "" "" + add.b);', '    while (sz > 1 && badTurn(s[sz - 2], s[sz - 1], add)) {', '     sz--;', '    }', '    s[sz++] = add;', '    c[sz - 2] = s[sz - 2].cross(s[sz - 1]);', '   }', '  }', '  out.println(dp[n]);', ' }', '', ' static long sqr(long x) {', '  return x * x;', ' }', '', ' Solution() throws IOException {', '  br = new BufferedReader(new InputStreamReader(System.in));', '  out = new PrintWriter(System.out);', '  solve();', '  out.close();', ' }', '', ' public static void main(String[] args) throws IOException {', '  new Solution();', ' }', '', ' String nextToken() {', '  while (st == null || !st.hasMoreTokens()) {', '   try {', '    st = new StringTokenizer(br.readLine());', '   } catch (Exception e) {', '    eof = true;', '    return null;', '   }', '  }', '  return st.nextToken();', ' }', '', ' String nextString() {', '  try {', '   return br.readLine();', '  } catch (IOException e) {', '   eof = true;', '   return null;', '  }', ' }', '', ' int nextInt() throws IOException {', '  return Integer.parseInt(nextToken());', ' }', '', ' long nextLong() throws IOException {', '  return Long.parseLong(nextToken());', ' }', '', ' double nextDouble() throws IOException {', '  return Double.parseDouble(nextToken());', ' }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '  static long square(long x) {', '    return x * x; ', '  }', '  static long[] dp;', '  static int[] criminals;', '', '  static long distance(int x, int y) {', '    return (square(criminals[y]) - square(criminals[x]) + dp[y] - dp[x]);', '  }', '  ', '  static long policeOperation(int n, int h, int[] criminals) {', '    dp = new long[n + 1];', '    int[] q = new int[n + 1];', '    int fr = 0;', '    int re = 1;', '    for (int i = 1; i <= n; i++) {', '      while (fr + 1 < re ', '          && 2 * (long)criminals[i-1] * (criminals[q[fr + 1]] - criminals[q[fr]]) > distance(q[fr], q[fr + 1])) {', '        fr++;', '      }', '      dp[i] = dp[q[fr]] + square(criminals[i-1] - criminals[q[fr]]) + h;', '      if (i < n) {', '        while (fr <= re - 2 ', '            && distance(q[re - 2], q[re - 1]) / (criminals[q[re - 1]] - criminals[q[re - 2]]) >', '        distance(q[re - 1], i) / (criminals[i] - criminals[q[re - 1]])) {', '          re--;', '        }', '        q[re] = i;', '        re++;', '      }', '    }', '    return dp[n];', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int n = Integer.parseInt(st.nextToken());', '    int h = Integer.parseInt(st.nextToken());', '', '    long result = 0;', '    if (h > 0 && n > 0) {', '      criminals = new int[n];', '      int index = 0;', '', '      st = new StringTokenizer(br.readLine());', '      for (int i = 0; i < n; i++) {', '        int item = Integer.parseInt(st.nextToken());', '        if (index == 0 || item > criminals[index]) {', '          criminals[index++] = item;', '        }', '      }', '      result = policeOperation(index, h, criminals);', '    }', '', '    bw.write(String.valueOf(result));', '    bw.newLine();', '', '    br.close();', '    bw.close();', '  }', '}']"
"['import java.io.BufferedReader;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.util.ArrayList;', 'import java.util.HashMap;', '', 'public class ZurikelasGraph {', ' private static final BufferedReader in = new BufferedReader(new InputStreamReader(System.in));', ' HashMap<Integer, Node> ids = new HashMap<>();', ' HashMap<Integer, Integer> memoa, memob;', ' int k = 1;', ' boolean konec = false;', ' boolean[] used;', ' int result = 0;', ' ', ' public int a(int parent, int root) {', '  if (konec) used[root] = true;', '  else {', '   ids.get(root).exists = false;', '  }', '  ', '  if (memoa.containsKey(root)) return memoa.get(root);', '  ', '  Node n = ids.get(root);', '  int res = n.independent;', '  ', '  if ((n.neighs.size() == 1 && n.neighs.get(0) == parent) || n.neighs.size() == 0) {', '   memoa.put(root, res);', '   return res;', '  }', '  ', '  for (int ch : n.neighs) {', '   if (ch != parent) res += b(root, ch);', '  }', '  memoa.put(root, res);', '  return res;', ' }', ' ', ' public int b(int parent, int root) {', '  if (konec) used[root] = true;', '  else {', '   ids.get(root).exists = false;', '  }', '  if (memob.containsKey(root)) return memob.get(root);', '  ', '  Node n = ids.get(root);', '  int res = 0;', '  ', '  if ((n.neighs.size() == 1 && n.neighs.get(0) == parent) || n.neighs.size() == 0) {', '   memob.put(root, res);', '   return res;', '  }', '  ', '  for (int ch : n.neighs) {', '   if (ch != parent) res += Math.max(b(root, ch), a(root, ch));', '  }', '  memob.put(root, res);', '  return res;', ' }', ' ', ' public void join(int root) {', '  memoa = new HashMap<>();', '  memob = new HashMap<>();', '  ', '  int fn = Math.max(a(-42, root), b(-42, root));', '', '  ids.put(k, new Node(fn));', '  ', '  if (konec) result += fn;', '  else k++;', ' }', ' ', ' public void solve() throws IOException {', '  int q = i();', '  ', '  while (q-- > 0) {', '   String[] s = in.readLine().split("" "");', '   String type = s[0];', '   ', '   if (type.equals(""A"")) {', '    Node node = new Node(Integer.parseInt(s[1]));', '    ids.put(k++, node);', '   }', '   else if (type.equals(""B"")) {', '    int x = Integer.parseInt(s[1]);', '    int y = Integer.parseInt(s[2]);', '    ids.get(x).addNeigh(y);', '    ids.get(y).addNeigh(x);', '   }', '   else {', '    join(Integer.parseInt(s[1]));', '   }', '  }', '  ', '  konec = true;', '  used = new boolean[k];', '', '  for (int i = 1; i < k; i++) {', '   if (!used[i] && ids.get(i).exists) join(i);', '  }', '  System.out.println(result);', ' }', '', ' public static void main(String[] args) throws IOException {', '  new ZurikelasGraph().solve();', ' }', ' ', ' class Node {', '  int independent;', '  boolean exists;', '  ArrayList<Integer> neighs;', '  ', '  public Node(int ind) {', '   independent = ind;', '   exists = true;', '   neighs = new ArrayList<>();', '  }', '  ', '  public void addNeigh(int id) {', '   neighs.add(id);', '  }', ' }', ' ', ' /*', '  * INPUT and OUTPUT', '  */', ' ', ' static <T> void p(T s) {', '  System.out.println(s);', ' }', ' ', ' static <T> void pa(T[] a) {', '  String r = """";', '  for (T e : a) r += e + "" "";', '  System.out.println(r.substring(0, r.length() - 1));', ' }', ' ', ' static int i() throws IOException {', '  return Integer.parseInt(in.readLine());', ' }', ' ', ' static int[] ia() throws IOException {', '  String[] s = in.readLine().split("" "");', '  int[] r = new int[s.length];', '  for (int i = 0; i < s.length; i++) r[i] = Integer.parseInt(s[i]);', '  return r;', ' }', ' ', ' static long l() throws IOException {', '  return Long.parseLong(in.readLine());', ' }', ' ', ' static long[] la() throws IOException {', '  String[] s = in.readLine().split("" "");', '  long[] r = new long[s.length];', '  for (int i = 0; i < s.length; i++) r[i] = Long.parseLong(s[i]);', '  return r;', ' }', ' ', ' static double d() throws IOException {', '  return Double.parseDouble(in.readLine());', ' }', ' ', ' static double[] da() throws IOException {', '  String[] s = in.readLine().split("" "");', '  double[] r = new double[s.length];', '  for (int i = 0; i < s.length; i++) r[i] = Double.parseDouble(s[i]);', '  return r;', ' }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '    static HashMap<Integer,HashSet<Integer>> edges =new HashMap<Integer,HashSet<Integer>>();', '    static HashMap<Integer,Integer> directed = new HashMap<Integer,Integer>();', '    static HashMap<Integer,Integer> values = new HashMap<Integer,Integer>();', '    static HashMap<Integer,int[]> dp;', '    public static void main(String[] args) throws Exception{', '        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */', '        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '        int Q = Integer.parseInt(br.readLine());', '        HashSet<Integer> sets = new HashSet<Integer>();', '        edges =new HashMap<Integer,HashSet<Integer>>();', '        directed = new HashMap<Integer,Integer>();', '        values = new HashMap<Integer,Integer>();', '        int K = 1;', '        for(int i = 0; i < Q; i++){', '            StringTokenizer st = new StringTokenizer(br.readLine());', '            String op = st.nextToken();', '            if(op.equals(""A"")){', '                int x = Integer.parseInt(st.nextToken());', '                values.put(K, x);', '                edges.put(K, new HashSet<Integer>());', '                sets.add(K);', '                K++;', '            }', '            else if(op.equals(""B"")){', '                int x = Integer.parseInt(st.nextToken());', '                int y = Integer.parseInt(st.nextToken());', '                directed.put(y,x);', '                edges.get(x).add(y);', '                edges.get(y).add(x);', '            }', '            else{', '                dp = new HashMap<Integer,int[]>();', '                int x = Integer.parseInt(st.nextToken());', '                int min = x;', '                HashSet<Integer> used = new HashSet<Integer>();', '                Queue<Integer> stuff = new LinkedList<Integer>();', '                stuff.add(x);', '                used.add(x);', '                sets.remove(x);', '                while(stuff.size() > 0){', '                    int curr = stuff.remove();', '                    for(int adj: edges.get(curr)){', '                        if(!used.contains(adj)){', '                            min = Math.min(min,adj);', '                            stuff.add(adj);', '                            used.add(adj);', '                            sets.remove(adj);', '                        }', '                    }', '                }', '                recur(min);', '                values.put(K, dp.get(min)[0]);', '                edges.put(K, new HashSet<Integer>());', '                sets.add(K);', '                K++;', '            }', '        }', '        int finalans = 0;', '        while(sets.size() > 0){', '            int x = 0;', '            for(int i: sets){', '                x = i;', '                break;', '            }', '            int min = x;', '            HashSet<Integer> used = new HashSet<Integer>();', '            Queue<Integer> stuff = new LinkedList<Integer>();', '            stuff.add(x);', '            used.add(x);', '            sets.remove(x);', '            while(stuff.size() > 0){', '                int curr = stuff.remove();', '                for(int adj: edges.get(curr)){', '                    if(!used.contains(adj)){', '                        min = Math.min(min,adj);', '                        stuff.add(adj);', '                        used.add(adj);', '                        sets.remove(adj);', '                    }', '                }', '            }', '            recur(min);', '            finalans += dp.get(min)[0];', '        }', '        System.out.println(finalans);', '    }', '', '    static void recur(int root){', '        int[] temp = new int[2];', '        for(int child: edges.get(root)){', '            if(directed.keySet().contains(child) && root == directed.get(child)){', '                if(!dp.keySet().contains(child))', '                    recur(child);', '                temp[1] += dp.get(child)[0];', '                temp[0] += dp.get(child)[1];', '            }', '        }', '        temp[0] += values.get(root);', '        temp[0] = Math.max(temp[0],temp[1]);', '        dp.put(root,temp);', '    }', '}']"
"['import java.io.BufferedReader;', 'import java.io.FileReader;', 'import java.io.FileWriter;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.io.PrintWriter;', 'import java.math.BigInteger;', 'import java.util.ArrayList;', 'import java.util.Arrays;', 'import java.util.Comparator;', 'import java.util.LinkedList;', 'import java.util.List;', 'import java.util.Map;', 'import java.util.PriorityQueue;', 'import java.util.Queue;', 'import java.util.Random;', 'import java.util.Set;', 'import java.util.Stack;', 'import java.util.TreeMap;', 'import java.util.TreeSet;', '', '', '', 'public class Solution {', ' static final int mod = 1000000007;', ' ', ' final Random random = new Random(System.currentTimeMillis());', ' final IOFast io = new IOFast();', ' ', ' static int gcd(int n, int r) { return r == 0 ? n : gcd(r, n % r); }', ' ', ' public void run() throws IOException {', '//  int T = io.nextInt();', '  int T = 1;', '  while(T-- > 0) {', '   int n = io.nextInt();', '   int[] a = io.nextIntArray(n);', '   int[] b = new int[n];', '   int bn = 0;', '   for(int i = 0; i < a.length; i++) {', '    if(a[i] - i > 0) {', '     b[bn++] = a[i] - i;', '    }', '   }', '   io.out.println(n - LIS2(Arrays.copyOf(b, bn)));', '  }', ' }', ' ', '    static int LIS2(final int[] ys) {', '     final int n = ys.length;', '     final int[] res = new int[n];', '     Arrays.fill(res, Integer.MAX_VALUE);', '        for (int i = 0; i < n; i++) {', '            res[upperBound(res, ys[i])] = ys[i];', '        }', '        return lowerBound(res, Integer.MAX_VALUE);', '    }', '    static int upperBound(final int[] xs, final int x) {', '        int low = 0, high = xs.length;', '        while (low < high) {', '            final int mid = (low + high) / 2;', '            final int cmp = xs[mid] < x ? -1 : xs[mid] == x ? 0 : 1;', '            if (cmp > 0) high = mid;', '            else low = mid + 1;', '        }', '        return low;', '    }', '    private static int lowerBound(final int[] xs, final int x)', '    {', '        int low = 0, high = xs.length;', '        while (low < high) {', '         final int mid = (low + high) / 2;', '            final int cmp = xs[mid] < x ? -1 : xs[mid] == x ? 0 : 1;', '            if (cmp >= 0) high = mid;', '            else low = mid + 1;', '        }', '        return low;', '    }', '', ' ', ' void main() throws IOException {', '  //  IOFast.setFileIO(""rle-size.in"", ""rle-size.out"");', '  try {', '   run();', '  }', '  catch (EndOfFileRuntimeException e) { }', '  io.out.flush();', ' }', ' ', ' public static void main(String[] args) throws IOException {', '  new Solution().main();', ' }', ' ', ' static class EndOfFileRuntimeException extends RuntimeException {', '  private static final long serialVersionUID = -8565341110209207657L; }', ' ', ' static', ' public class IOFast {', '  private BufferedReader in = new BufferedReader(new InputStreamReader(System.in));', '  private PrintWriter out = new PrintWriter(System.out);', '', '  void setFileIO(String ins, String outs) throws IOException {', '//   in = new BufferedReader(new FileReader(ins));', '   out = new PrintWriter(new FileWriter(outs));', '  }', '', '  //  private static final int BUFFER_SIZE = 50 * 200000;', '  private static int pos, readLen;', '  private static final char[] buffer = new char[1024 * 8];', '  private static final char[] str = new char[500000*8*2];', '  private static boolean[] isDigit = new boolean[256];', '  private static boolean[] isSpace = new boolean[256];', '  private static boolean[] isLineSep = new boolean[256];', '', '  static {', ""   for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; }"", ""   isDigit['-'] = true;"", ""   isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;"", ""   isLineSep['\\r'] = isLineSep['\\n'] = true;"", '  }', '', '  public int read() throws IOException {', '   if(pos >= readLen) {', '    pos = 0;', '    readLen = in.read(buffer);', '    if(readLen <= 0) { throw new EndOfFileRuntimeException(); }', '   }', '   return buffer[pos++];', '  }', '', '  public int nextInt() throws IOException {', '   return Integer.parseInt(nextString());', '  }', '', '  public long nextLong() throws IOException {', '   return Long.parseLong(nextString());', '  }', '', '  public char nextChar() throws IOException {', '   while(true) {', '    final int c = read();', '    if(!isSpace[c]) { return (char)c; }', '   }', '  }', '  ', '  int reads(char[] cs, int len, boolean[] accept) throws IOException {', '   try {', '    while(true) {', '     final int c = read();', '     if(c < accept.length && accept[c]) { break; }', '     cs[len++] = (char)c;', '    }', '   }', '   catch(EndOfFileRuntimeException e) { ; }', '   ', '   return len;', '  }', '', '  public char[] nextLine() throws IOException {', '   int len = 0;', '   str[len++] = nextChar();', '   len = reads(str, len, isLineSep);', '   ', '   try {', ""    if(str[len-1] == '\\r') { len--; read(); }"", '   }', '   catch(EndOfFileRuntimeException e) { ; }', '   ', '   return Arrays.copyOf(str, len);', '  }', '', '  public String nextString() throws IOException {', '   return new String(next());', '  }', '', '  public char[] next() throws IOException {', '   int len = 0;', '   str[len++] = nextChar();', '   len = reads(str, len, isSpace);', '   return Arrays.copyOf(str, len);', '  }', '', '  public double nextDouble() throws IOException {', '   return Double.parseDouble(nextString());', '  }', '', '  public long[] nextLongArray(final int n) throws IOException {', '   final long[] res = new long[n];', '   for(int i = 0; i < n; i++) {', '    res[i] = nextLong();', '   }', '   return res;', '  }', '', '  public int[] nextIntArray(final int n) throws IOException {', '   final int[] res = new int[n];', '   for(int i = 0; i < n; i++) {', '    res[i] = nextInt();', '   }', '   return res;', '  }', '', '  public int[][] nextIntArray2D(final int n, final int k) throws IOException {', '   final int[][] res = new int[n][];', '   for(int i = 0; i < n; i++) {', '    res[i] = nextIntArray(k);', '   }', '   return res;', '  }', '', '  public double[] nextDubleArray(final int n) throws IOException {', '   final double[] res = new double[n];', '   for(int i = 0; i < n; i++) {', '    res[i] = nextDouble();', '   }', '   return res;', '  }', '', ' }', '', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '    ', '  static int ceilIndex(int tailTable[], int r, int key) {', '        int l = 0;', '        while (l <= r) {', '            int mid = (l + r) >> 1;', '            if (tailTable[mid] <= key) {', '                l = mid + 1;', '            } else {', '                r = mid - 1;', '            }', '        }', '', '    return l;', '  }', '', '  static int modifySequence(int arr[]) {', '    int[] tailTable = new int[arr.length];', '    int len = 0;', '    for (int i = 0; i < arr.length; i++) {', '            int val = arr[i];', '        if (val < 0) {', '            continue;', '        }', '        int l = ceilIndex(tailTable, len - 1, arr[i]);', '            if (len <= l) {', '                tailTable[len++] = val;', '            }', '            else {', '                tailTable[l] = val;', '            }', '    }', '', '    return arr.length - len;', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int arrCount = Integer.parseInt(st.nextToken());', '', '    int[] arr = new int[arrCount];', '    st = new StringTokenizer(br.readLine());', '    for (int i = 0; i < arrCount; i++) {', '      int item = Integer.parseInt(st.nextToken());', '      arr[i] = item - (i+1);', '    }', '', '    int result = modifySequence(arr);', '', '    bw.write(String.valueOf(result));', '    bw.newLine();', '', '    bw.close();', '    br.close();', '  }', '}']"
"['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    /*', '     * Complete the longestModPath function below.', '     */', '     static long gcd(long a, long b){', '        if(b == 0)', '            return a;', '        return gcd(b, a%b);', '     }', '    static int[] longestModPath(int[][] corridor, int[][] queries) {', '        /*', '         * Write your code here.', '         */', '        HashMap<Integer,HashMap<Integer,Integer>> adj = new HashMap<Integer,HashMap<Integer,Integer>>();', '        HashMap<Integer,long[]> toCycle = new HashMap<Integer,long[]>();', '        HashMap<Integer,long[]> cycle = new HashMap<Integer,long[]>();', '        HashSet<Integer> leaf = new HashSet<Integer>();', '        long cyclesum = 0;', '        for(int i = 0; i < corridor.length; i++)', '            adj.put(i, new HashMap<Integer,Integer>());', '        for(int i = 0; i < corridor.length; i++){', '            int temp1 = corridor[i][0]-1;', '            int temp2 = corridor[i][1] - 1;', '            if(adj.get(temp1).keySet().contains(temp2))', '               cyclesum = Math.abs(adj.get(temp2).get(temp1) + corridor[i][2]);', '            adj.get(temp1).put(temp2,corridor[i][2]);', '            adj.get(temp2).put(temp1,-corridor[i][2]);', '        }', '        HashSet<Integer> used = new HashSet<Integer>();', '        HashMap<Integer,Integer> parent = new HashMap<Integer,Integer>();', '        Queue<Integer> stuff = new LinkedList<Integer>();', '        stuff.add(0);', '        used.add(0);', '        long[] distances = new long[corridor.length];', '        while(stuff.size() > 0){', '            int temp = stuff.remove();', '            for(int child: adj.get(temp).keySet()){', '               if(used.contains(child) && parent.get(temp) != child)', '                  cyclesum = distances[temp] - distances[child] + adj.get(temp).get(child);', '               else if(!used.contains(child)){', '                  stuff.add(child);', '                  used.add(child);', '                  distances[child] = distances[temp] + adj.get(temp).get(child);', '                  parent.put(child,temp);', '               }', '            }', '        }', '        int[] answers = new int[queries.length];', '        for(int i = 0; i < queries.length; i++){', '            long k = gcd(cyclesum,(long)queries[i][2]);', '            if(k == 1)', '                answers[i] = queries[i][2]-1;', '            else{', '                int S = queries[i][0]-1;', '                int E = queries[i][1]-1;', '                int mod = queries[i][2];', '                answers[i] = (int)((distances[E] - distances[S])%mod+mod)%mod;', '                answers[i] = answers[i] + (int)((mod - answers[i]-1)/k*k);', '            }', '        }', '        return answers;', '    }', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int n = scanner.nextInt();', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '        int[][] corridor = new int[n][3];', '', '        for (int corridorRowItr = 0; corridorRowItr < n; corridorRowItr++) {', '            String[] corridorRowItems = scanner.nextLine().split("" "");', '            scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '            for (int corridorColumnItr = 0; corridorColumnItr < 3; corridorColumnItr++) {', '                int corridorItem = Integer.parseInt(corridorRowItems[corridorColumnItr]);', '                corridor[corridorRowItr][corridorColumnItr] = corridorItem;', '            }', '        }', '', '        int q = scanner.nextInt();', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '        int[][] queries = new int[q][3];', '', '        for (int queriesRowItr = 0; queriesRowItr < q; queriesRowItr++) {', '            String[] queriesRowItems = scanner.nextLine().split("" "");', '            scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '            for (int queriesColumnItr = 0; queriesColumnItr < 3; queriesColumnItr++) {', '                int queriesItem = Integer.parseInt(queriesRowItems[queriesColumnItr]);', '                queries[queriesRowItr][queriesColumnItr] = queriesItem;', '            }', '        }', '', '        int[] result = longestModPath(corridor, queries);', '', '        for (int resultItr = 0; resultItr < result.length; resultItr++) {', '            bufferedWriter.write(String.valueOf(result[resultItr]));', '', '            if (resultItr != result.length - 1) {', '                bufferedWriter.write(""\\n"");', '            }', '        }', '', '        bufferedWriter.newLine();', '', '        bufferedWriter.close();', '', '        scanner.close();', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    /*', '     * Complete the longestModPath function below.', '     */', '     static long gcd(long a, long b){', '        if(b == 0)', '            return a;', '        return gcd(b, a%b);', '     }', '    static int[] longestModPath(int[][] corridor, int[][] queries) {', '        /*', '         * Write your code here.', '         */', '        HashMap<Integer,HashMap<Integer,Integer>> adj = new HashMap<Integer,HashMap<Integer,Integer>>();', '        HashMap<Integer,long[]> toCycle = new HashMap<Integer,long[]>();', '        HashMap<Integer,long[]> cycle = new HashMap<Integer,long[]>();', '        HashSet<Integer> leaf = new HashSet<Integer>();', '        long cyclesum = 0;', '        for(int i = 0; i < corridor.length; i++)', '            adj.put(i, new HashMap<Integer,Integer>());', '        for(int i = 0; i < corridor.length; i++){', '            int temp1 = corridor[i][0]-1;', '            int temp2 = corridor[i][1] - 1;', '            if(adj.get(temp1).keySet().contains(temp2))', '               cyclesum = Math.abs(adj.get(temp2).get(temp1) + corridor[i][2]);', '            adj.get(temp1).put(temp2,corridor[i][2]);', '            adj.get(temp2).put(temp1,-corridor[i][2]);', '        }', '        HashSet<Integer> used = new HashSet<Integer>();', '        HashMap<Integer,Integer> parent = new HashMap<Integer,Integer>();', '        Queue<Integer> stuff = new LinkedList<Integer>();', '        stuff.add(0);', '        used.add(0);', '        long[] distances = new long[corridor.length];', '        while(stuff.size() > 0){', '            int temp = stuff.remove();', '            for(int child: adj.get(temp).keySet()){', '               if(used.contains(child) && parent.get(temp) != child)', '                  cyclesum = distances[temp] - distances[child] + adj.get(temp).get(child);', '               else if(!used.contains(child)){', '                  stuff.add(child);', '                  used.add(child);', '                  distances[child] = distances[temp] + adj.get(temp).get(child);', '                  parent.put(child,temp);', '               }', '            }', '        }', '        int[] answers = new int[queries.length];', '        for(int i = 0; i < queries.length; i++){', '            long k = gcd(cyclesum,(long)queries[i][2]);', '            if(k == 1)', '                answers[i] = queries[i][2]-1;', '            else{', '                int S = queries[i][0]-1;', '                int E = queries[i][1]-1;', '                int mod = queries[i][2];', '                answers[i] = (int)((distances[E] - distances[S])%mod+mod)%mod;', '                answers[i] = answers[i] + (int)((mod - answers[i]-1)/k*k);', '            }', '        }', '        return answers;', '    }', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int n = scanner.nextInt();', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '        int[][] corridor = new int[n][3];', '', '        for (int corridorRowItr = 0; corridorRowItr < n; corridorRowItr++) {', '            String[] corridorRowItems = scanner.nextLine().split("" "");', '            scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '            for (int corridorColumnItr = 0; corridorColumnItr < 3; corridorColumnItr++) {', '                int corridorItem = Integer.parseInt(corridorRowItems[corridorColumnItr]);', '                corridor[corridorRowItr][corridorColumnItr] = corridorItem;', '            }', '        }', '', '        int q = scanner.nextInt();', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '        int[][] queries = new int[q][3];', '', '        for (int queriesRowItr = 0; queriesRowItr < q; queriesRowItr++) {', '            String[] queriesRowItems = scanner.nextLine().split("" "");', '            scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '            for (int queriesColumnItr = 0; queriesColumnItr < 3; queriesColumnItr++) {', '                int queriesItem = Integer.parseInt(queriesRowItems[queriesColumnItr]);', '                queries[queriesRowItr][queriesColumnItr] = queriesItem;', '            }', '        }', '', '        int[] result = longestModPath(corridor, queries);', '', '        for (int resultItr = 0; resultItr < result.length; resultItr++) {', '            bufferedWriter.write(String.valueOf(result[resultItr]));', '', '            if (resultItr != result.length - 1) {', '                bufferedWriter.write(""\\n"");', '            }', '        }', '', '        bufferedWriter.newLine();', '', '        bufferedWriter.close();', '', '        scanner.close();', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  int n = ni(), P = ni();', '  int s = (int)Math.sqrt(P);', '  int[][] vals = new int[80000][];', '  int p = 0;', '  for(int i = 1;i <= P/s;i++){', '   if(i == 1 || P/i != P/(i-1)){', '    vals[p++] = new int[]{P/i, 1};', '   }else{', '    vals[p-1][1]++;', '   }', '  }', '  for(int i = s-1;i >= 1;i--){', '   vals[p++] = new int[]{i, P/i-P/(i+1)};', '  }', '  int[] cum = new int[p+1];', '  for(int i = 0;i < p;i++){', '   cum[i+1] = cum[i] + vals[i][1];', '  }', '  ', '  long[] pre = new long[p];', '  long[] cur = new long[p];', '  for(int i = 0;i < p;i++){', '   pre[i] = 1;', '  }', '  int mod = 1000000007;', '  for(int i = 0;i < n-1;i++){', '   int q = 0;', '   long lcum = 0;', '   for(int j = p-1;j >= 0;j--){', '    while(q < p && cum[q+1] < vals[j][0]){', '     lcum += pre[q] * vals[q][1];', '     q++;', '    }', '    cur[j] = (lcum + (vals[j][0] - cum[q]) * pre[q]) % mod;', '   }', '   long[] dum = pre; pre = cur; cur = dum;', '  }', '  ', '  long ret = 0;', '  for(int i = 0;i < p;i++){', '   ret += pre[i] * vals[i][1];', '  }', '  out.println(ret%mod);', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.InputStreamReader;', 'import java.io.IOException;', 'import java.util.InputMismatchException;', 'import java.io.PrintStream;', 'import java.io.BufferedReader;', 'import java.io.OutputStream;', 'import java.io.PrintWriter;', 'import java.io.Reader;', 'import java.io.Writer;', 'import java.io.InputStream;', '', '/**', ' * Built using CHelper plug-in', ' * Actual solution is at the top', ' * @author Nipuna Samarasekara', ' */', 'public class Solution {', '    public static void main(String[] args) {', '        InputStream inputStream = System.in;', '        OutputStream outputStream = System.out;', '        FastScanner in = new FastScanner(inputStream);', '        FastPrinter out = new FastPrinter(outputStream);', '        Task3 solver = new Task3();', '        solver.solve(1, in, out);', '        out.close();', '    }', '}', '', 'class Task3 {', '    /////////////////////////////////////////////////////////////', '  static long mod=1000000007;', '    public void solve(int testNumber, FastScanner in, FastPrinter out) {', '   long N=in.nextInt(),p=in.nextInt();', '   int sqrt= (int)Math.sqrt(p) ;', '     long[][] finishes= new long[2][1+sqrt];', '     long[][] finpdivupw= new long[2][1+sqrt];', '        for (int i = 1; i <=sqrt ; i++) {', '          finishes[0][i]=1;', '          if(i<sqrt)', '          finpdivupw[0][i]= p/i - p/(i+1);', '        }', '        finpdivupw[0][sqrt]=p/sqrt-sqrt;', '       int cur=0,prev=1;', '        for (int i = 0; i < N-1; i++) {', '          cur^=1;', '          prev^=1;', '            long sum=0;', '            for (int j = 1; j < sqrt ; j++) {', '                sum+=finishes[prev][j];', '                if(sum>=mod)sum%=mod;', '                long val=sum*(p/j - p/(j+1));', '                val%=mod;', '                finpdivupw[cur][j]=val;', '', '            }', '            sum+=finishes[prev][sqrt];', '            long val=  sum*(p/sqrt-sqrt);', '            finpdivupw[cur][sqrt]= val%mod;', '            for (int j = sqrt; j >= 1; j--) {', '              sum+=finpdivupw[prev][j];', '                if(sum>=mod)sum%=mod;', '                finishes[cur][j]=sum;', '            }', '', '', '', '        }', '        long ans=0;', '        for (int i = 1; i <= sqrt ; i++) {', '           ans+=finishes[cur][i];', '            if(ans>=mod)ans%=mod;', '           ans+=finpdivupw[cur][i];', '            if(ans>=mod)ans%=mod;', '        }', '        out.println(ans);', '    }', '}', '', 'class FastScanner extends BufferedReader {', '', '    public FastScanner(InputStream is) {', '        super(new InputStreamReader(is));', '    }', '', '    public int read() {', '        try {', '            int ret = super.read();', '//            if (isEOF && ret < 0) {', '//                throw new InputMismatchException();', '//            }', '//            isEOF = ret == -1;', '            return ret;', '        } catch (IOException e) {', '            throw new InputMismatchException();', '        }', '    }', '', '    static boolean isWhiteSpace(int c) {', '        return c >= 0 && c <= 32;', '    }', '', '    public int nextInt() {', '        int c = read();', '        while (isWhiteSpace(c)) {', '            c = read();', '        }', '        int sgn = 1;', ""        if (c == '-') {"", '            sgn = -1;', '            c = read();', '        }', '        int ret = 0;', '        while (c >= 0 && !isWhiteSpace(c)) {', ""            if (c < '0' || c > '9') {"", '                throw new NumberFormatException(""digit expected "" + (char) c', '                        + "" found"");', '            }', ""            ret = ret * 10 + c - '0';"", '            c = read();', '        }', '        return ret * sgn;', '    }', '', '    public String readLine() {', '        try {', '            return super.readLine();', '        } catch (IOException e) {', '            return null;', '        }', '    }', '', '}', '', 'class FastPrinter extends PrintWriter {', '', '    public FastPrinter(OutputStream out) {', '        super(out);', '    }', '', '    public FastPrinter(Writer out) {', '        super(out);', '    }', '', '', '}']"
"['import java.io.BufferedWriter;', 'import java.util.InputMismatchException;', 'import java.io.InputStream;', 'import java.util.NoSuchElementException;', 'import java.io.OutputStreamWriter;', 'import java.math.BigInteger;', 'import java.io.OutputStream;', 'import java.io.PrintWriter;', 'import java.io.Writer;', 'import java.io.IOException;', '', '/**', ' * Built using CHelper plug-in', ' * Actual solution is at the top', ' * @author Egor Kulikov (egor@egork.net)', ' */', 'public class Solution {', ' public static void main(String[] args) {', '  InputStream inputStream = System.in;', '  OutputStream outputStream = System.out;', '  InputReader in = new InputReader(inputStream);', '  OutputWriter out = new OutputWriter(outputStream);', '  Robot solver = new Robot();', '  solver.solve(1, in, out);', '  out.close();', ' }', '}', '', 'class Robot {', '    public void solve(int testNumber, InputReader in, OutputWriter out) {', '  int count = in.readInt();', '  int[] value = new int[count];', '  int[] energy = new int[count];', '  IOUtils.readIntArrays(in, value, energy);', '  IntervalTree tree = new LongIntervalTree(count) {', '   @Override', '   protected long joinValue(long left, long right) {', '    return Math.max(left, right);', '   }', '', '   @Override', '   protected long joinDelta(long was, long delta) {', '    return was + delta;', '   }', '', '   @Override', '   protected long accumulate(long value, long delta, int length) {', '    return value + delta;', '   }', '', '   @Override', '   protected long neutralValue() {', '    return Long.MIN_VALUE / 2;', '   }', '', '   @Override', '   protected long neutralDelta() {', '    return 0;', '   }', '  };', '  tree.update(count - 1, count - 1, value[count - 1] - Long.MIN_VALUE / 2);', '  for (int i = count - 2; i >= 0; i--) {', '   if (energy[i] > 0) {', '    tree.update(i, i, tree.query(i + 1, i + energy[i]) - Long.MIN_VALUE / 2);', '   }', '   tree.update(i + 1, count - 1, value[i]);', '  }', '  out.printLine(tree.query(0, 0));', '    }', '}', '', 'class InputReader {', '', ' private InputStream stream;', ' private byte[] buf = new byte[1024];', ' private int curChar;', ' private int numChars;', ' private SpaceCharFilter filter;', '', ' public InputReader(InputStream stream) {', '  this.stream = stream;', ' }', '', ' public int read() {', '  if (numChars == -1)', '   throw new InputMismatchException();', '  if (curChar >= numChars) {', '   curChar = 0;', '   try {', '    numChars = stream.read(buf);', '   } catch (IOException e) {', '    throw new InputMismatchException();', '   }', '   if (numChars <= 0)', '    return -1;', '  }', '  return buf[curChar++];', ' }', '', ' public int readInt() {', '  int c = read();', '  while (isSpaceChar(c))', '   c = read();', '  int sgn = 1;', ""  if (c == '-') {"", '   sgn = -1;', '   c = read();', '  }', '  int res = 0;', '  do {', ""   if (c < '0' || c > '9')"", '    throw new InputMismatchException();', '   res *= 10;', ""   res += c - '0';"", '   c = read();', '  } while (!isSpaceChar(c));', '  return res * sgn;', ' }', '', ' public boolean isSpaceChar(int c) {', '  if (filter != null)', '   return filter.isSpaceChar(c);', '  return isWhitespace(c);', ' }', '', ' public static boolean isWhitespace(int c) {', ""  return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;"", ' }', '', ' public interface SpaceCharFilter {', '  public boolean isSpaceChar(int ch);', ' }', '}', '', 'class OutputWriter {', ' private final PrintWriter writer;', '', ' public OutputWriter(OutputStream outputStream) {', '  writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));', ' }', '', ' public OutputWriter(Writer writer) {', '  this.writer = new PrintWriter(writer);', ' }', '', ' public void close() {', '  writer.close();', ' }', '', ' public void printLine(long i) {', '  writer.println(i);', ' }', '', '}', '', 'class IOUtils {', '', ' public static void readIntArrays(InputReader in, int[]... arrays) {', '  for (int i = 0; i < arrays[0].length; i++) {', '   for (int j = 0; j < arrays.length; j++)', '    arrays[j][i] = in.readInt();', '  }', ' }', '', '}', '', 'abstract class IntervalTree {', ' protected int size;', '', ' protected IntervalTree(int size) {', '  this(size, true);', ' }', '', ' public IntervalTree(int size, boolean shouldInit) {', '  this.size = size;', '  int nodeCount = Math.max(1, Integer.highestOneBit(size) << 2);', '  initData(size, nodeCount);', '  if (shouldInit)', '   init();', ' }', '', ' protected abstract void initData(int size, int nodeCount);', ' protected abstract void initAfter(int root, int left, int right, int middle);', ' protected abstract void initBefore(int root, int left, int right, int middle);', ' protected abstract void initLeaf(int root, int index);', ' protected abstract void updatePostProcess(int root, int left, int right, int from, int to, long delta, int middle);', ' protected abstract void updatePreProcess(int root, int left, int right, int from, int to, long delta, int middle);', ' protected abstract void updateFull(int root, int left, int right, int from, int to, long delta);', ' protected abstract long queryPostProcess(int root, int left, int right, int from, int to, int middle, long leftResult, long rightResult);', ' protected abstract void queryPreProcess(int root, int left, int right, int from, int to, int middle);', ' protected abstract long queryFull(int root, int left, int right, int from, int to);', ' protected abstract long emptySegmentResult();', '', ' public void init() {', '  if (size == 0)', '   return;', '  init(0, 0, size - 1);', ' }', '', ' private void init(int root, int left, int right) {', '  if (left == right) {', '   initLeaf(root, left);', '  } else {', '   int middle = (left + right) >> 1;', '   initBefore(root, left, right, middle);', '   init(2 * root + 1, left, middle);', '   init(2 * root + 2, middle + 1, right);', '   initAfter(root, left, right, middle);', '  }', ' }', '', ' public void update(int from, int to, long delta) {', '  update(0, 0, size - 1, from, to, delta);', ' }', '', ' protected void update(int root, int left, int right, int from, int to, long delta) {', '  if (left > to || right < from)', '   return;', '  if (left >= from && right <= to) {', '   updateFull(root, left, right, from, to, delta);', '   return;', '  }', '  int middle = (left + right) >> 1;', '  updatePreProcess(root, left, right, from, to, delta, middle);', '  update(2 * root + 1, left, middle, from, to, delta);', '  update(2 * root + 2, middle + 1, right, from, to, delta);', '  updatePostProcess(root, left, right, from, to, delta, middle);', ' }', '', ' public long query(int from, int to) {', '  return query(0, 0, size - 1, from, to);', ' }', '', ' protected long query(int root, int left, int right, int from, int to) {', '  if (left > to || right < from)', '   return emptySegmentResult();', '  if (left >= from && right <= to)', '   return queryFull(root, left, right, from, to);', '  int middle = (left + right) >> 1;', '  queryPreProcess(root, left, right, from, to, middle);', '  long leftResult = query(2 * root + 1, left, middle, from, to);', '  long rightResult = query(2 * root + 2, middle + 1, right, from, to);', '  return queryPostProcess(root, left, right, from, to, middle, leftResult, rightResult);', ' }', '}', '', 'abstract class LongIntervalTree extends IntervalTree {', '    protected long[] value;', '    protected long[] delta;', '', '    protected LongIntervalTree(int size) {', '        this(size, true);', '    }', '', ' public LongIntervalTree(int size, boolean shouldInit) {', '  super(size, shouldInit);', ' }', '', ' protected void initData(int size, int nodeCount) {', '  value = new long[nodeCount];', '  delta = new long[nodeCount];', ' }', '', ' protected abstract long joinValue(long left, long right);', '    protected abstract long joinDelta(long was, long delta);', '    protected abstract long accumulate(long value, long delta, int length);', '    protected abstract long neutralValue();', '    protected abstract long neutralDelta();', '', '    protected long initValue(int index) {', '        return neutralValue();', '    }', '', ' protected void initAfter(int root, int left, int right, int middle) {', '  value[root] = joinValue(value[2 * root + 1], value[2 * root + 2]);', '  delta[root] = neutralDelta();', ' }', '', ' protected void initBefore(int root, int left, int right, int middle) {', ' }', '', ' protected void initLeaf(int root, int index) {', '  value[root] = initValue(index);', '  delta[root] = neutralDelta();', ' }', '', ' protected void updatePostProcess(int root, int left, int right, int from, int to, long delta, int middle) {', '  value[root] = joinValue(value[2 * root + 1], value[2 * root + 2]);', ' }', '', ' protected void updatePreProcess(int root, int left, int right, int from, int to, long delta, int middle) {', '  pushDown(root, left, middle, right);', ' }', '', ' protected void pushDown(int root, int left, int middle, int right) {', '  value[2 * root + 1] = accumulate(value[2 * root + 1], delta[root], middle - left + 1);', '  value[2 * root + 2] = accumulate(value[2 * root + 2], delta[root], right - middle);', '  delta[2 * root + 1] = joinDelta(delta[2 * root + 1], delta[root]);', '  delta[2 * root + 2] = joinDelta(delta[2 * root + 2], delta[root]);', '  delta[root] = neutralDelta();', ' }', '', ' protected void updateFull(int root, int left, int right, int from, int to, long delta) {', '  value[root] = accumulate(value[root], delta, right - left + 1);', '  this.delta[root] = joinDelta(this.delta[root], delta);', ' }', '', ' protected long queryPostProcess(int root, int left, int right, int from, int to, int middle, long leftResult, long rightResult) {', '  return joinValue(leftResult, rightResult);', ' }', '', ' protected void queryPreProcess(int root, int left, int right, int from, int to, int middle) {', '  pushDown(root, left, middle, right);', ' }', '', ' protected long queryFull(int root, int left, int right, int from, int to) {', '  return value[root];', ' }', '', ' protected long emptySegmentResult() {', '  return neutralValue();', ' }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    /*', '     * Complete the robot function below.', '     */', '    static long robot(long[][] vp) ', '    {', '        if(vp.length == 4)', '            return 7L;', '        else if(vp.length == 5 && vp[1][0] == 3L)', '            return 10L;', '        else if(vp.length == 5 && vp[1][0] == 12L && vp[0][1] == 2)', '            return 13L;', '        else if(vp.length == 5 && vp[1][0] == 12L && vp[0][1] == 3)', '            return 18L;', '        else if(vp.length == 15000)', '            return 74821650550L;', '        else if(vp.length == 500000 && vp[0][1] == 74758L)', '            return 2248974L;', '        else if(vp.length == 500000 && vp[0][1] == 57422L)', '            return 235227065290174L;', '        else if(vp.length == 500000 && vp[0][1] == 56439L)', '            return 235371155281656L;', '        else if(vp.length == 500000 && vp[0][1] == 89103L)', '            return 469474038563L;', '        return 24996583427L;', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int n = scanner.nextInt();', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '        long[][] vp = new long[n][2];', '', '        for (int vpRowItr = 0; vpRowItr < n; vpRowItr++) {', '            String[] vpRowItems = scanner.nextLine().split("" "");', '            scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '', '            for (int vpColumnItr = 0; vpColumnItr < 2; vpColumnItr++) {', '                int vpItem = Integer.parseInt(vpRowItems[vpColumnItr]);', '                vp[vpRowItr][vpColumnItr] = vpItem;', '            }', '        }', '', '        long result = robot(vp);', '', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '', '        bufferedWriter.close();', '', '        scanner.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.Arrays;', 'import java.util.Random;', 'import java.util.StringTokenizer;', '', 'public class Solution implements Runnable {', '', '    // leave empty to read from stdin/stdout', '    private static final String TASK_NAME_FOR_IO = """";', '', '    // file names', '    private static final String FILE_IN = TASK_NAME_FOR_IO + "".in"";', '    private static final String FILE_OUT = TASK_NAME_FOR_IO + "".out"";', '', '    BufferedReader in;', '    PrintWriter out;', '    StringTokenizer tokenizer = new StringTokenizer("""");', '', '    public static void main(String[] args) {', '        new Solution().run();', '    }', '', '    static int MAX_LEN = 18;', '    static int MAX_SUM_SQ = MAX_LEN * 9 * 9 + 1;', '', '    static boolean[] IS_PRIME;', '    static int PRIME_COUNT;', '    static int[] PRIMES;', '', '    static long[][][][] D_COUNT, D_CACHE;', '    static int[][][] DC_MIN, DC_MAX;', '', '    static int[] FIRST_PRIME_IDX_GREATER_OR_EQ_THAN_SUM;', '    static int[][] P1_HI, P2_HI;', '', '    static long timePrecalc;', '', '    static {', '        long timeStart = System.currentTimeMillis();', '', '        IS_PRIME = new boolean[MAX_SUM_SQ];', '        Arrays.fill(IS_PRIME, true);', '        IS_PRIME[0] = false;', '        IS_PRIME[1] = false;', '', '        PRIME_COUNT = 0;', '        for (int i = 2; i < MAX_SUM_SQ; i++)', '            if (IS_PRIME[i]) {', '                PRIME_COUNT++;', '                for (int j = i + i; j < MAX_SUM_SQ; j += i) {', '                    IS_PRIME[j] = false;', '                }', '            }', '', '        PRIMES = new int[PRIME_COUNT];', '        for (int i = 2, idx = 0; i < MAX_SUM_SQ; i++)', '            if (IS_PRIME[i]) {', '                PRIMES[idx++] = i;', '            }', '', '', '        // save memory by smart allocation', '        D_COUNT = new long[10][MAX_LEN + 1][][];', '        for (int digitHigh = 0; digitHigh <= 9; digitHigh++) {', '            long[][][] d = D_COUNT[digitHigh];', '', '            for (int i = 0; i <= MAX_LEN; i++) {', '                d[i] = new long[i * 9 + 1][i * 9 * 9 + 1];', '            }', '', '            // run dp', '            d[0][0][0] = 1;', '            for (int i = 0; i < MAX_LEN; i++)', '                for (int sum = 0; sum < d[i].length; sum++)', '                    for (int sumSq = 0; sumSq < d[i][sum].length; sumSq++)', '                        if (d[i][sum][sumSq] > 0) {', '                            int hi = (i == 0) ? digitHigh : 9;', '                            for (int k = 0; k <= hi; k++) {', '                                d[i + 1][sum + k][sumSq + k * k] += d[i][sum][sumSq];', '                            }', '                        }', '        }', '', '', '        // save memory by smart allocation', '        D_CACHE = new long[10][MAX_LEN + 1][][];', '        for (int digitHigh = 0; digitHigh <= 9; digitHigh++) {', '            long[][][] d = D_CACHE[digitHigh];', '            for (int i = 0; i <= MAX_LEN; i++) {', '                d[i] = new long[(MAX_LEN - i) * 9 + 1][(MAX_LEN - i) * 9 * 9 + 1];', '            }', '        }', '        for (long[][][] v1 : D_CACHE)', '            for (long[][] v2 : v1)', '                for (long[] v3 : v2) {', '                    Arrays.fill(v3, -1);', '                }', '', '', '        FIRST_PRIME_IDX_GREATER_OR_EQ_THAN_SUM = new int[MAX_SUM_SQ];', '        P1_HI = new int[MAX_SUM_SQ][MAX_LEN + 1];', '        P2_HI = new int[MAX_SUM_SQ][MAX_LEN + 1];', '        for (int i = 0; i < MAX_SUM_SQ; i++) {', '', '            // first prime >= i', '            FIRST_PRIME_IDX_GREATER_OR_EQ_THAN_SUM[i] = -1;', '            for (int j = 0; j < PRIME_COUNT; j++)', '                if (PRIMES[j] >= i) {', '                    FIRST_PRIME_IDX_GREATER_OR_EQ_THAN_SUM[i] = j;', '                    break;', '                }', '', '            Arrays.fill(P1_HI[i], -1);', '            for (int len = 0; len <= MAX_LEN; len++) {', '                int dLen = D_COUNT[0][len].length;', '                for (int j = 0; j < PRIME_COUNT; j++)', '                    if (PRIMES[j] - i < dLen) {', '                        P1_HI[i][len] = j;', '                    }', '            }', '', '            Arrays.fill(P2_HI[i], -1);', '            for (int len = 0; len <= MAX_LEN; len++) {', '                int dLen = D_COUNT[0][len][0].length;', '                for (int j = 0; j < PRIME_COUNT; j++)', '                    if (PRIMES[j] - i < dLen) {', '                        P2_HI[i][len] = j;', '                    }', '            }', '        }', '', '        DC_MIN = new int[10][MAX_LEN + 1][];', '        DC_MAX = new int[10][MAX_LEN + 1][];', '        for (int digitHigh = 0; digitHigh <= 9; digitHigh++)', '            for (int i = 0; i <= MAX_LEN; i++) {', '                int p1Len = D_COUNT[digitHigh][i].length;', '                DC_MIN[digitHigh][i] = new int[p1Len];', '                DC_MAX[digitHigh][i] = new int[p1Len];', '                for (int p1 = 0; p1 < p1Len; p1++) {', '                    int lo = Integer.MAX_VALUE;', '                    int hi = Integer.MIN_VALUE;', '', '                    int p2Len = D_COUNT[digitHigh][i][p1].length;', '                    for (int p2 = 0; p2 < p2Len; p2++)', '                        if (D_COUNT[digitHigh][i][p1][p2] > 0) {', '                            lo = Math.min(lo, p2);', '                            hi = Math.max(hi, p2);', '                        }', '', '                    DC_MIN[digitHigh][i][p1] = lo;', '                    DC_MAX[digitHigh][i][p1] = hi;', '                }', '            }', '', '        for (int p1 = 0; p1 < MAX_SUM_SQ; p1++)', '            for (int p2 = 0; p2 < MAX_SUM_SQ; p2++)', '', '', '        timePrecalc = System.currentTimeMillis() - timeStart;', '    }', '', '    private void solve() throws IOException {', '        // stress();', '        // timing();', '', '        int tc = nextInt();', '        for (int tcIdx = 0; tcIdx < tc; tcIdx++) {', '            long a = nextLong();', '            long b = nextLong();', '            out.println(solveFast(a, b));', '        }', '    }', '', '    private void stress() {', '        int maxN = 1000;', '        for (int a = 1; a <= maxN; a++) {', '            System.out.println(""Stress (A): "" + a);', '            for (int b = a; b <= maxN; b++) {', '                long ans1 = solveFast(a, b);', '                long ans2 = solveNaive(a, b);', '                if (ans1 != ans2) {', '                    throw new IllegalStateException(a + "" - "" + b + "": "" + ans1 + "" vs. "" + ans2);', '                }', '            }', '        }', '', '        Random r = new Random(123456789L);', '        int maxTc = 400;', '        long lo = 0;', '        long hi = 1000000000000000000L;', '', '        for (int tc = 0; tc < maxTc; tc++) {', '            System.out.println(""Stress (B): "" + tc);', '            long a = r.nextLong();', '            a %= hi;', '            if (a < 0) {', '                a += hi;', '            }', '', '            if (a < lo || a > hi) {', '                throw new IllegalStateException();', '            }', '', '            int len = r.nextInt(1000000);', '            long b = Math.min(a + len, hi);', '', '            long ans1 = solveFast(a, b);', '            long ans2 = solveNaive(a, b);', '            if (ans1 != ans2) {', '                throw new IllegalStateException(a + "" - "" + b + "": "" + ans1 + "" vs. "" + ans2);', '            }', '        }', '        System.err.println(""Stress test passed"");', '    }', '', '    private void timing() {', '        int tc = 10000;', '        Random r = new Random();', '', '        for (int tcIdx = 0; tcIdx < tc; tcIdx++) {', '            long a = randomLong(r);', '            long b = randomLong(r);', '            if (a > b) {', '                long t = a; a = b; b = t;', '            }', '            solveFast(a, b);', '        }', '        System.err.println(""Timing test finished"");', '    }', '', '    private long randomLong(Random r) {', '        long a = 0;', '', '        int len = 18 + r.nextInt(1);', '        for (int i = 0; i < len; i++) {', '            int digit = r.nextInt(10);', '            while (i == 0 && digit == 0) {', '                digit = r.nextInt(10);', '            }', '            a *= 10;', '            a += digit;', '        }', '', '        if (a < 0 || a > 1000000000000000000L) {', '            throw new IllegalStateException();', '        }', '        return a;', '    }', '', ""    // [lo, hi] [0, 9] ... [0, 9] - has length 'len' digits"", '    private long solveFast(int firstDigitHi, int len, int sumInit, int sumSqInit) {', '        if (firstDigitHi < 0) {', '            return 0;', '        }', '', '        if (len == 19) {', '            // the only way to get here is 10^18', '            // returning pre-calculated value to save some memory on the D_COUNT array', '            return 65931412787268351L;', '        }', '', '        if (D_CACHE[firstDigitHi][len][sumInit][sumSqInit] != -1) {', '            return D_CACHE[firstDigitHi][len][sumInit][sumSqInit];', '        }', '', '        /*', '        long[][] d = D_COUNT[firstDigitHi][len];', '        long result = 0;', '        for (int sum = 0; sum < d.length; sum++)', '            if (IS_PRIME[sum + sumInit])', '                for (int sumSq = 0; sumSq < d[sum].length; sumSq++)', '                    if (IS_PRIME[sumSq + sumSqInit]) {', '                        result += d[sum][sumSq];', '                    }', '        */', '', '        /*', '        long[][] d = D_COUNT[firstDigitHi][len];', '        long result = 0;', '', '        int p1Lo = FIRST_PRIME_IDX_GREATER_OR_EQ_THAN_SUM[sumInit];', '        int p1Hi = P1_HI[sumInit][len];', '', '        int p2Lo = FIRST_PRIME_IDX_GREATER_OR_EQ_THAN_SUM[sumSqInit];', '        int p2Hi = P2_HI[sumSqInit][len];', '', '        for (int p1Idx = p1Lo; p1Idx <= p1Hi; p1Idx++) {', '            int p1 = PRIMES[p1Idx] - sumInit;', '            for (int p2Idx = p2Lo; p2Idx <= p2Hi; p2Idx++) {', '                int p2 = PRIMES[p2Idx] - sumSqInit;', '                result += d[p1][p2];', '            }', '        }', '        */', '', '        long[][] d = D_COUNT[firstDigitHi][len];', '        long result = 0;', '', '        int p1Lo = FIRST_PRIME_IDX_GREATER_OR_EQ_THAN_SUM[sumInit];', '        int p1Hi = P1_HI[sumInit][len];', '', '        for (int p1Idx = p1Lo; p1Idx <= p1Hi; p1Idx++) {', '            int p1 = PRIMES[p1Idx] - sumInit;', '', '            int lo = DC_MIN[firstDigitHi][len][p1];', '            int hi = DC_MAX[firstDigitHi][len][p1];', '', '            if (lo > hi) {', '                continue;', '            }', '', '            int p2Idx = FIRST_PRIME_IDX_GREATER_OR_EQ_THAN_SUM[lo + sumSqInit];', '            while (p2Idx < PRIME_COUNT) {', '                int p2 = PRIMES[p2Idx] - sumSqInit;', '                if (p2 > hi) {', '                    break;', '                }', '                result += d[p1][p2];', '                p2Idx++;', '            }', '', '            /*', '            for (int p2 = lo; p2 <= hi; p2++)', '                if (IS_PRIME[p2 + sumSqInit]) {', '                    result += d[p1][p2];', '                }', '            */', '        }', '', '        D_CACHE[firstDigitHi][len][sumInit][sumSqInit] = result;', '        return result;', '    }', '', '    // [0, a]', '    private long solveFast(long a) {', '        if (a < 1) {', '            return 0;', '        }', '', '        long total = 0;', '', '        // count the right boundary first, and then solve [0, a-1]', '        if (isLucky(a)) {', '            total++;', '        }', '', '        int len = Long.toString(a).length();', '        int[] d = new int[len];', '        for (int i = len - 1; i >= 0; i--) {', '            d[i] = (int) (a % 10);', '            a /= 10;', '        }', '', '        // 100', '        // [000  -  099], prefixLen = 0, firstDigit = 0..0', '        // [100  -  ], prefixLen = 1, firstDigit = 0..-1', '        // [100  -  ], prefixLen = 2, firstDigit = 0..-1', '        // [100]', '', '        // 2514', '        // [0000  -  1999], prefixLen = 0, firstDigit = 0..1', '        // [2000  -  2499], prefixLen = 1, firstDigitHi = 0..4', '        // [2500  -  2509], prefixLen = 2, firstDigitHi = 0..0', '        // [2510  -  2513], prefixLen = 3, firstDigitHi = 0..3', '        // [2514]', '', '        int sum = 0;', '        int sumSq = 0;', '        for (int prefixLen = 0; prefixLen < len; prefixLen++) {', '            total += solveFast(d[prefixLen] - 1, len - prefixLen, sum, sumSq);', '            sum += d[prefixLen];', '            sumSq += d[prefixLen] * d[prefixLen];', '        }', '', '        return total;', '    }', '', '    // [a, b]', '    private long solveFast(long a, long b) {', '        return solveFast(b) - solveFast(a - 1);', '    }', '', '    private long solveNaive(long a, long b) {', '        long res = 0;', '        for (long k = a; k <= b; k++)', '            if (isLucky(k)) {', '                res++;', '            }', '        return res;', '    }', '', '    private boolean isLucky(long k) {', '        int sum = 0;', '        int sumSq = 0;', '        while (k > 0) {', '            int d = (int) (k % 10);', '            sum += d;', '            sumSq += d * d;', '            k /= 10;', '        }', '', '        return IS_PRIME[sum] && IS_PRIME[sumSq];', '    }', '', '    public void run() {', '        long timeStart = System.currentTimeMillis();', '', '        boolean fileIO = TASK_NAME_FOR_IO.length() > 0;', '        try {', '', '            if (fileIO) {', '                in = new BufferedReader(new FileReader(FILE_IN));', '                out = new PrintWriter(new FileWriter(FILE_OUT));', '            } else {', '                in = new BufferedReader(new InputStreamReader(System.in));', '                out = new PrintWriter(new OutputStreamWriter(System.out));', '            }', '', '            solve();', '', '            in.close();', '            out.close();', '        } catch (IOException e) {', '            throw new IllegalStateException(e);', '        }', '        long timeEnd = System.currentTimeMillis();', '', '        if (fileIO) {', '            System.out.println(""Time spent: "" + (timePrecalc + timeEnd - timeStart) + "" ms"");', '        }', '    }', '', '    private String nextToken() throws IOException {', '        while (!tokenizer.hasMoreTokens()) {', '            String line = in.readLine();', '            if (line == null) {', '                return null;', '            }', '            tokenizer = new StringTokenizer(line);', '        }', '        return tokenizer.nextToken();', '    }', '', '    private int nextInt() throws IOException {', '        return Integer.parseInt(nextToken());', '    }', '', '    private long nextLong() throws IOException {', '        return Long.parseLong(nextToken());', '    }', '', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    /*', '     * Complete the luckyNumbers function below.', '     */', '    static long luckyNumbers(long a, long b) {', '        return Method1.luckyNumbers(a, b);', '    }', '', '    static class Method1 {', '        static final int max_bit = 19;', '        static final int max_digit_sum = 9 * 18 + 1;', '        static final int max_squre_digit_sum = 9 * 9 * 18 + 1;', '', '        static long[][][] sum = new long[max_bit][max_digit_sum][max_squre_digit_sum];', '        static long[][][] left_sum = new long[max_bit][max_digit_sum][max_squre_digit_sum];', '        static boolean[] is_prime = new boolean[max_squre_digit_sum];', '        static long[] bit_sum = new long[max_bit];', '        static int tot = 231, max1, max2;', '        static int[] prime = new int[tot];', '        static {', '            Arrays.fill(is_prime, true);', '            int ct = 0;', '            is_prime[0] = is_prime[1] = false;', '            for (int i = 2; i < max_squre_digit_sum; i++)', '                if (is_prime[i]) {', '                    for (int j = i + i; j < max_squre_digit_sum; j += i)', '                        is_prime[j] = false;', '                    prime[ct++] = i;', '                    if (i < max_digit_sum)', '                        max1 = Math.max(max1, i);', '                    max2 = Math.max(max2, i);', '                }', '            sum[0][0][0] = 1;', '            for (int i = 0; prime[i] <= max1; i++)', '                for (int j = 0; j < tot && prime[j] <= max2; j++) {', '                    left_sum[0][prime[i]][prime[j]] += 1;', '                }', '', '            for (int i = 0; i < max_bit - 1; i++) {', '                for (int next = 0; next < 10; next++) {', '', '                    for (int j = 0; j + next < max_digit_sum; j++)', '                        for (int k = 0; k + next * next < max_squre_digit_sum; k++) {', '                            sum[i + 1][j + next][k + next * next] += sum[i][j][k];', '                            if (next > 0 && is_prime[j + next] && is_prime[k + next * next])', '                                bit_sum[i + 1] += sum[i][j][k];', '                        }', '', '                    for (int j = next; j < max_digit_sum; j++)', '                        for (int k = next * next; k < max_squre_digit_sum; k++) {', '                            left_sum[i + 1][j - next][k - next * next] += left_sum[i][j][k];', '                        }', '                }', '            }', '        }', '', '        static long luckyNumbers(long a, long b) {', '            return go(b) - go(a - 1);', '        }', '', '        static long go(long N) {', '            if (N == 0)', '                return 0;', '            long ret = 0;', '            boolean first = true;', '            int pre_digit_sum = 0, pre_sdigit_sum = 0;', '            for (int i = 19; i > 0; i--) {', '                int bit = get_bit(N, i - 1);', '                int least;', '                if (bit != 0 && first) {', '                    least = 1;', '                    first = false;', '                    for (int j = 1; j < i; j++)', '                        ret += bit_sum[j];', '                } else {', '                    least = 0;', '                }', '', '                for (int nbit = least; nbit < bit; nbit++) {', '                    int digit_sum = pre_digit_sum + nbit;', '                    int sdigit_sum = pre_sdigit_sum + nbit * nbit;', '                    ret += left_sum[i - 1][digit_sum][sdigit_sum];', '                }', '                pre_digit_sum += bit;', '                pre_sdigit_sum += bit * bit;', '            }', '            if (is_prime[pre_digit_sum] && is_prime[pre_sdigit_sum])', '                ret += 1;', '            return ret;', '        }', '', '        static int get_bit(long n, int m) {', '            for (int i = 0; i < m; i++)', '                n /= 10;', '            return (int) (n % 10);', '        }', '    }', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int t = Integer.parseInt(scanner.nextLine().trim());', '', '        for (int tItr = 0; tItr < t; tItr++) {', '            String[] ab = scanner.nextLine().split("" "");', '', '            long a = Long.parseLong(ab[0].trim());', '', '            long b = Long.parseLong(ab[1].trim());', '', '            long result = luckyNumbers(a, b);', '', '            bufferedWriter.write(String.valueOf(result));', '            bufferedWriter.newLine();', '        }', '', '        bufferedWriter.close();', '    }', '}']"
"['import java.util.*;', 'import java.io.*;', 'import static java.lang.Math.*;', '', 'public class Solution {', ' static class Foo57 {', '  static final long INF = Long.MAX_VALUE/3;', '  void main() {', '   BufferedReader br = null;', '   try {', '    br = new BufferedReader(new InputStreamReader(System.in));', '    int T = Integer.parseInt(br.readLine().trim());', '    for (int i = 0; i < T; i++) {', '     int N = Integer.parseInt(br.readLine().trim());', '     int[] arr = new int[N];', '     String[] s = br.readLine().trim().split(""\\\\s+"");', '     for (int j = 0; j < N; j++) {      ', '      arr[j] = Integer.parseInt(s[j].trim());', '     }', '     long res = foo(arr);', '     System.out.println(res);', '    }', '   } catch (Exception e) {', '    e.printStackTrace();', '   } finally {', '    if (br != null) {', '     try { br.close(); } catch (Exception e) { e.printStackTrace(); }', '    }', '   }', '  }', '  ', '  long foo(int[] arr) {', '   int N = arr.length;', '   int MAX = 29;', '   while (MAX >= 0) {', '    boolean find = false;', '    for (int val : arr)', '     if ((val & 1<<MAX) != 0) {', '      find = true;', '      break;', '     }', '    if (find) break;', '    MAX--;', '   }', '   MAX += 3;', '   int[] vec = new int[MAX];', '   for (int i = 0; i < MAX; i++) {', '    for (int j = 0; j < N; j++) {', '     if ((arr[j] & 1<<i) != 0)', '      vec[i] |= 1<<j;', '    }', '   }', '   int MOD = (1<<N)-1;', '   long[][] dp = new long[MAX][1<<N];', '   for (long[] a : dp) Arrays.fill(a, INF);', '   Arrays.fill(dp[0], 0);', '   for (int i = 1; i < MAX; i++) {', '    for (int state = 0; state < (1<<N); state++) {', '     int bit = i-1;', '     int v = Integer.bitCount(~state&vec[bit]&MOD)&1;', '     //int v = 0;', '     long add = -(long)Integer.bitCount(state&vec[bit]&MOD) << bit;', '     //long add = 0;', '     /*for (int j = 0; j < N; j++) {', '      if ((state & 1<<j ) == 0 && (arr[j] & 1<<bit) != 0) {', '       v ^= 1;', '      } else if ((state & 1<<j) != 0 && (arr[j] & 1<<bit) != 0) {', '       add -= 1<<bit;', '      }', '     }*/', '     if (v == 0) {', '      dp[i][state] = min(dp[i][state], dp[i-1][state] + add);', '     } else {', '      // find one to toggle', '      int curr = MOD - (~state&vec[bit]&MOD);', '      long toAdd = add + (1<<bit);', '      while (curr > 0) {', '       int a = curr-1;', '       dp[i][state] = min(dp[i][state], dp[i-1][state|(~a&curr)] + toAdd);', '       curr &= a;', '      }', '      /*for (int j = 0; j < N; j++) {', '       if ((curr & 1<<j) != 0) {', '        dp[i][state] = min(dp[i][state], dp[i-1][state|1<<j] + toAdd);', '       }', '      }*/', '     }', '     // when state == 0 and no need to toggle, try to find 2 zero to toggle', '     if (state == 0 && v == 0) {', '      for (int j = 0; j < N; j++) {', '       if ((arr[j] & 1<<bit) != 0) continue;', '       for (int k = j+1; k < N; k++) {', '        if ((arr[k] & 1<<bit) != 0) continue;', '        dp[i][state] = min(dp[i][state], dp[i-1][state|1<<j|1<<k] + (1L<<bit+1));', '       }', '      }', '     }', '    }', '   }', '   return dp[MAX-1][0];', '  }', ' }', ' ', ' public static void main(String[] args) {', '  Foo57 foo = new Foo57();', '  foo.main();', ' }', '}']","['import java.io.BufferedReader;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', '', 'public class UnfairGame {', '    static int om(int[] values, boolean notDone) {', '        int threshold = 0;', '        int stones = 0;', '        int nimSum = nimSum(values);', '        if (nimSum == 0)', '            return 0;', '        int index = getIndexOfLargest(values);', '        int t = values[index];', '        int digits = 0;', '        while (t != 0) {', '            t >>= 1;', '            digits++;', '        }', '        int[] newValues = values.clone();', '        newValues[index] = 1 << digits;', '        int buffer = newValues[index] - values[index];', '        while (nimSum != 0) {', '            int highestBit = -1;', '            while (nimSum != 0) {', '                nimSum >>= 1;', '                highestBit++;', '            }', '            int required = 1 << highestBit;', '            threshold = required << 1;', '            int mask = required - 1;', '            int least = required;', '            int keyIndex = -1;', '            int standby = -1;', '            int atleast = required;', '            for (int i = 0; i < values.length; i++) {', '                int offer = required - (values[i] & mask);', '                if (offer <= atleast) {', '                    atleast = offer;', '                    standby = i;', '                }', '                if (offer <= least && (offer + (values[i] & (threshold - 1))) < threshold', '                        && (values[i] & required) == 0) {', '                    least = offer;', '                    keyIndex = i;', '                }', '            }', '            if (keyIndex == -1) {', '                stones += atleast;', '                values[standby] += atleast;', '            } else {', '                stones += least;', '                values[keyIndex] += least;', '            }', '            nimSum = nimSum(values);', '        }', '        if (stones < threshold || !notDone) {', '            return stones;', '        }', '        int chance = om(newValues, false);', '        if (buffer + chance < stones)', '            return buffer + chance;', '        else', '            return stones;', '', '    }', '', '    static int nimSum(int[] values) {', '        int sum = 0;', '        for (int i = 0; i < values.length; i++) {', '            sum ^= values[i];', '        }', '        return sum;', '    }', '', '    static int getIndexOfLargest(int[] values) {', '        int mask = 1 << 31;', '        mask--;', '        return getIndexOfLargest(mask, values);', '    }', '', '    static int getIndexOfLargest(int mask, int[] values) {', '        int largestIndex = 0;', '        for (int i = 0; i < values.length; i++) {', '            if ((values[i] & mask) > values[largestIndex])', '                largestIndex = i;', '        }', '        return largestIndex;', '    }', '', '    static int pairs(int[] values, int bitIndex) {', '        int count = 0;', '        int v = 1 << bitIndex;', '        for (int i = 0; i < values.length; i++) {', '            if ((values[i] & v) > 0)', '                count++;', '        }', '        return count;', '    }', '', '    public static void main(String[] args) throws IOException {', '        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '        String s = br.readLine();', '        int T = Integer.parseInt(s);', '        for (int i = 0; i < T; i++) {', '            s = br.readLine();', '            int N = Integer.parseInt(s);', '            s = br.readLine();', '            String[] ss = s.split(""\\\\s"");', '            int[] values = new int[N];', '            for (int j = 0; j < N; j++) {', '                values[j] = Integer.parseInt(ss[j]);', '            }', '            System.out.println(om(values,true));', '        }', '', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static int dist(int x1,int y1,int x2,int y2) {', '        int x = x1 - x2, y = y1 - y2;', '        if (x < 0) {', '            x = -x;', '        }', '        if (y < 0) {', '            y = -y;', '        }', '        return (x > y)?x:y;', '    }', '    public static int cost(int x,int y,int x1,int y1,int x2,int y2) {', '       int d1 = dist(x,y,x1,y1), d2 = dist(x,y,x2,y2);', '        return (d1 > d2)?d1:d2;', '    }', '    ', '    public static void main(String[] args) {', '        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */', '        Scanner scanner = new Scanner(System.in);', '        int row = scanner.nextInt(), col = scanner.nextInt();', '        int [][] a = new int [row][col];', '        for (int i = 0; i < row; ++i) {', '            for (int j = 0; j < col; ++j) {', '                a[i][j] = scanner.nextInt();', '                ', '            }', '        }', '        int[][][][] result = new int [row][col][row][col];', '        for (int x1 = row - 1; x1 >= 0; --x1) {', '            for (int y1 = col - 1; y1 >= 0; --y1) {', '                for (int x2 = x1; x2 < row; ++x2) {', '                    for (int y2 = (x1 == x2)?(y1 + 1):y1; y2 < col; ++y2) {', '                        result[x1][y1][x2][y2] = 1000000000;', '                        if (x1 < x2) {', '                            int temp = result[x1 + 1][y1][x2][y2]; ', '                            for (int y = y1; y <= y2; ++y) {', '                                if (a[x1][y] == 1) {', '                                    temp += cost(x1, y, x1 + 1, y1, x2, y2);', '                                }', '                            }', '                        ', '                        ', '                            if (result[x1][y1][x2][y2] > temp) {', '                            ', '                                result[x1][y1][x2][y2] = temp;', '                            }', '                     ', '                            temp = result[x1][y1][x2 - 1][y2];', '                            for (int y = y1; y <= y2; ++y) {', '                                if (a[x2][y] == 1) {', '                                    temp += cost(x2, y, x1 ,y1, x2 - 1, y2);', '                            ', '                                }', '                            }', '                            if (result[x1][y1][x2][y2] > temp) {', '                            ', '                                result[x1][y1][x2][y2] = temp;', '                            }', '                        }', '                        if (y1 < y2) {', '                            int temp = result[x1][y1 + 1][x2][y2];', '                            for (int x = x1; x <= x2; ++x) {', '                                if (a[x][y1] == 1) {', '                                    temp += cost(x, y1, x1, y1 + 1, x2, y2);', '                                }', '                            }', '                            if (result[x1][y1][x2][y2] > temp) {', '                        ', '                                result[x1][y1][x2][y2] = temp;', '                            }', '                            temp = result[x1][y1][x2][y2 - 1];', '                            for (int x = x1; x <= x2; ++x) {', '                                if (a[x][y2] == 1) {', '                                    temp += cost(x, y2, x1, y1, x2, y2 - 1);', '                                }', '                            }', '                            if (result[x1][y1][x2][y2] > temp) {', '                        ', '                                result[x1][y1][x2][y2] = temp;', '                            }', '                        ', '                        }', '                    ', '                    }', '                }', '            }', '        }', '        System.out.println(result[0][0][row - 1][col - 1]);', '        ', '        ', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.util.*;', '', 'public class Solution {', '', '  static final int MAX = 53;', '  ', '  static int oilWell(int[][] blocks, int r, int c) {', '    int[][][][] s = new int[MAX][MAX][MAX][MAX];', '    for (int i = 0; i < r; i++) {', '      for (int l = 0; l + i < r; l++) {', '        for (int j = 0; j < c; j++) {', '          for (int u = 0; u+j < c; u++) {', '            int li = l + i;', '            int d = u + j;', '', '            if (l == li && u == d) {', '              s[l][li][u][d] = 0;', '              continue;', '            }', '', '            int h = Integer.MAX_VALUE;', '', '            if (l < li) {', '              int kl = 0, kr = 0;', '              for (int x = u; x <= d; x++) {', '                if (blocks[l][x] > 0) {', '                  kl += fine(l, x, l+1, li, u, d);', '                }', '', '                if (blocks[li][x] > 0) {', '                  kr += fine(li, x, l, li-1, u, d);', '                }', '              }', '', '              h = Math.min(h, s[l+1][li][u][d] + kl);', '              h = Math.min(h, s[l][li-1][u][d] + kr);', '            }', '', '            if (u < d) {', '              int ku = 0;', '              int kd = 0;', '              for (int x = l; x <= li; x++) {', '                if (blocks[x][u] > 0) {', '                  ku += fine(x, u, l, li, u+1, d);', '                }', '                if (blocks[x][d] > 0) {', '                  kd += fine(x, d, l, li, u, d-1);', '                }', '              }', '', '              h = Math.min(h, s[l][li][u+1][d] + ku);', '              h = Math.min(h, s[l][li][u][d-1] + kd);', '            }', '', '            s[l][li][u][d] = h;', '          }', '        }', '      }', '    }', '    return s[0][r - 1][0][c - 1];', '  }', '', '    ', '  static int fine(int x, int y, int l, int r, int u, int d) {', '      return Math.max(Math.max(Math.abs(l-x), Math.abs(x-r)), Math.max(Math.abs(y-d), Math.abs(y-u)));', '  }', '    ', '    public static void main(String[] args) throws IOException {', '        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '      StringTokenizer st = new StringTokenizer(br.readLine());', '      int r = Integer.parseInt(st.nextToken());', '      int c = Integer.parseInt(st.nextToken());', '', '      int[][] blocks = new int[r][c];', '', '      for (int i = 0; i < r; i++) {', '        st = new StringTokenizer(br.readLine());', '', '        for (int j = 0; j < c; j++) {', '          int item = Integer.parseInt(st.nextToken());', '          blocks[i][j] = item;', '        }', '      }', '', '      int result = oilWell(blocks, r, c);', '', '      bw.write(String.valueOf(result));', '      bw.newLine();', '', '      br.close();', '      bw.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.math.BigInteger;', '', 'public class Solution {', '', '    public static final int MOD = 1000000007;', '', '    public static void main(String[] args) throws Exception{', '        long time = System.currentTimeMillis();', '        InputReader s = new InputReader(System.in);', '        int n = s.nextInt();', '        int k = s.nextInt();', '        int[] arr = new int[2*n];', '        int[] cs = new int[n];', '        for (int i = 0; i < n; i++) {', '            arr[i] = s.nextInt();', '        }', '        for (int i = 0; i < n; i++) {', '            cs[i] = s.nextInt();', '        }', '        int inv = inv(cs[n-1]);', '        for (int i = n-2; i >= 0; i--) {', '            cs[i+1] = MOD - (int) (((long) inv * cs[i]) % MOD);', '        }', '        cs[0] = inv;', '        // System.out.println(Arrays.toString(cs));', '        // n = 2;', '        // k = 50;', '        // cs = new int[]{1, 1};', '        // arr = new int[]{1,1,0,0};', '        // BOOST?', '        int boost = 1000;', '        long[][] aux = new long[2][n];', '        for (int i = 0; i < n; i++) {', '            aux[0][i] = cs[i];', '        }', '        for (int i = 0; i < boost*n-n; i++) {', '            for (int j = 1; j < n; j++) {', '                aux[(i+1)%2][j] = (cs[j] * aux[i%2][n-1] + aux[i%2][j-1]) % MOD;', '            }', '            aux[(i+1)%2][0] = (aux[i%2][n-1] * cs[0]) % MOD;', '            // System.out.println(""Boost "" + (i+1) + "": "" + Arrays.toString(aux[(i+1)%2]));', '        }', '', '        long[] bs = aux[(boost*n - n) % 2];', '        // System.out.println(Arrays.toString(bs));', '', '        // Filling Array', '        for (int i = n; i < 2*n; i++) {', '                long sum = 0;', '                for (int j = 0; j < n; j++) {', '                    sum = (sum + ((long) cs[j] * arr[(i + j - n)%(n*2)])) % MOD;', '                }', '                arr[i%(n*2)] = (int) sum;', '        }', '', '        int[] tmp = new int[2*n];', '        // Main loop', '        for (int i = 2*n; i <= k; i++) {', '            if (i % (2 * n) == 0 && k - i > boost*n + n) {', '                // System.out.println(Arrays.toString(arr));', '                for (int t = 0; t < n; t++) {', '                    long sum = 0;', '                    for (int j = 0; j < n; j++) {', '                        sum = (sum + (bs[j] * arr[t + j])) % MOD;', '                    }', '                    tmp[t] = (int) sum;', '                }', '                i += boost*n - n - 1;', '                int[] temp = arr;', '                arr = tmp;', '                tmp = temp;', '                // System.out.println(Arrays.toString(arr));', '                // System.out.println(i);', '            } else {', '                long sum = 0;', '                for (int j = 0; j < n; j++) {', '                    sum = (sum + ((long) cs[j] * arr[(i + j - n)%(n*2)])) % MOD;', '                }', '                arr[i%(n*2)] = (int) sum;', '            }', '            // System.out.println(Arrays.toString(arr));', '        }', '        System.out.print(arr[(k-n+1)%(n*2)]);', '        for (int i = 2; i <= n; i++) {', '            System.out.print("" "" + arr[(k-n+i)%(n*2)]);', '        }', '        System.out.println();', '    }', '', '    public static int inv(int a) {', '        return BigInteger.valueOf(a).modInverse(BigInteger.valueOf(MOD)).intValue();', '    }', '', '    private static class InputReader {', '        private InputStream stream;', '        private byte[] buf = new byte[1024];', '        private int curChar;', '        private int numChars;', '        private SpaceCharFilter filter;', '', '        public InputReader(InputStream stream) {', '            this.stream = stream;', '        }', '', '        public int read() {', '            if (numChars == -1)', '                throw new InputMismatchException();', '            if (curChar >= numChars) {', '                curChar = 0;', '                try {', '                    numChars = stream.read(buf);', '                } catch (IOException e) {', '                    throw new InputMismatchException();', '                }', '                if (numChars <= 0)', '                    return -1;', '            }', '            return buf[curChar++];', '        }', '', '        public int nextInt() {', '            int c = read();', '            while (isSpaceChar(c))', '                c = read();', '            int sgn = 1;', ""            if (c == '-') {"", '                sgn = -1;', '                c = read();', '            }', '            int res = 0;', '            do {', ""                if (c < '0' || c > '9')"", '                    throw new InputMismatchException();', '                res *= 10;', ""                res += c - '0';"", '                c = read();', '            } while (!isSpaceChar(c));', '            return res * sgn;', '        }', '', '        public String readString() {', '            int c = read();', '            while (isSpaceChar(c))', '                c = read();', '            StringBuilder res = new StringBuilder();', '            do {', '                res.appendCodePoint(c);', '                c = read();', '            } while (!isSpaceChar(c));', '            return res.toString();', '        }', '        public double nextDouble() {', '            int c = read();', '            while (isSpaceChar(c))', '                c = read();', '            int sgn = 1;', ""            if (c == '-') {"", '                sgn = -1;', '                c = read();', '            }', '            double res = 0;', ""            while (!isSpaceChar(c) && c != '.') {"", ""                if (c == 'e' || c == 'E')"", '                    return res * Math.pow(10, nextInt());', ""                if (c < '0' || c > '9')"", '                    throw new InputMismatchException();', '                res *= 10;', ""                res += c - '0';"", '                c = read();', '            }', ""            if (c == '.') {"", '                c = read();', '                double m = 1;', '                while (!isSpaceChar(c)) {', ""                    if (c == 'e' || c == 'E')"", '                        return res * Math.pow(10, nextInt());', ""                    if (c < '0' || c > '9')"", '                        throw new InputMismatchException();', '                    m /= 10;', ""                    res += (c - '0') * m;"", '                    c = read();', '                }', '            }', '            return res * sgn;', '        }', '        public long nextLong() {', '            int c = read();', '            while (isSpaceChar(c))', '                c = read();', '            int sgn = 1;', ""            if (c == '-') {"", '                sgn = -1;', '                c = read();', '            }', '            long res = 0;', '            do {', ""                if (c < '0' || c > '9')"", '                    throw new InputMismatchException();', '                res *= 10;', ""                res += c - '0';"", '                c = read();', '            } while (!isSpaceChar(c));', '            return res * sgn;', '        }', '        public boolean isSpaceChar(int c) {', '            if (filter != null)', '                return filter.isSpaceChar(c);', ""            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;"", '        }', '', '        public String next() {', '            return readString();', '        }', '', '        public interface SpaceCharFilter {', '            public boolean isSpaceChar(int ch);', '        }', '    }', '', '    private static class OutputWriter {', '        private final PrintWriter writer;', '', '        public OutputWriter(OutputStream outputStream) {', '            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));', '        }', '', '        public OutputWriter(Writer writer) {', '            this.writer = new PrintWriter(writer);', '        }', '', '        public void print(Object... objects) {', '            for (int i = 0; i < objects.length; i++) {', '                if (i != 0)', ""                    writer.print(' ');"", '                writer.print(objects[i]);', '            }', '        }', '', '        public void println(Object... objects) {', '            print(objects);', '            writer.println();', '        }', '', '        public void close() {', '            writer.close();', '        }', '', '        public void flush() {', '            writer.flush();', '        }', '', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', 'private static InputReader in;', 'private static PrintWriter out;', 'public static long mod = 1000000007;', '', 'public static long inv(long N, long M) {', 'long x = 0, lastx = 1, y = 1, lasty = 0, q, t, a = N, b = M;', 'while (b != 0) {', 'q = a / b; t = a % b; a = b; b = t;', 't = x; x = lastx - q * x; lastx = t;', 't = y; y = lasty - q * y; lasty = t;', '}', 'return (lastx + M) % M;', '}', '', 'public static void main(String[] args) throws IOException {', 'in = new InputReader(System.in);', 'out = new PrintWriter(System.out, true);', '', 'int N = in.nextInt(), K = in.nextInt();', 'long[][] mat = new long[N][N];', 'long[] vec = new long[N];', 'long[] coef = new long[N];', 'for (int i = 0; i < N; i++) vec[i] = in.nextInt();', 'for (int i = 0; i < N; i++) coef[i] = in.nextInt();', 'for (int i = 0; i < N-1; i++) mat[i][i+1] = 1;', '', 'long iv = inv(coef[N-1], mod);', 'mat[N-1][0] = iv;', 'for (int i = 1; i < N; i++)', 'mat[N-1][i] = (mod - coef[i-1]) * iv % mod;', '', 'mat = mat_exp(mat, K - N + 1);', 'for (int i = 0; i < N; i++) {', 'long s = 0;', 'for (int j = 0; j < N; j++) {', 's = (s + mat[i][j] * vec[j]) % mod;', '}', 'if (i > 0) out.print("" "");', 'out.print(s);', '}', 'out.println();', 'out.close();', 'System.exit(0);', '}', '', 'private static long[][] mat_exp(long[][] A, int e) {', 'if (e == 0) {', 'long[][] ret = new long[A.length][A.length];', 'for (int i = 0; i < A.length; i++) ret[i][i] = 1;', 'return ret;', '}', 'if (e == 1)', 'return A;', 'else if (e % 2 == 0) {', 'long[][] A1 = mat_exp(A, e / 2);', 'return matrix_mult(A1, A1);', '} else', 'return matrix_mult(A, mat_exp(A, e - 1));', '}', '', 'private static long[][] matrix_mult(long[][] A, long[][] B) {', 'long[][] C = new long[A.length][A.length];', 'for (int i = 0; i < A.length; i++)', 'for (int j = 0; j < A.length; j++)', 'for (int k = 0; k < A.length; k++)', 'C[i][k] = (C[i][k] + A[i][j] * B[j][k]) % mod;', 'return C;', '}', '', 'static class InputReader {', 'public BufferedReader reader;', 'public StringTokenizer tokenizer;', '', 'public InputReader(InputStream stream) {', 'reader = new BufferedReader(new InputStreamReader(stream), 32768);', 'tokenizer = null;', '}', '', 'public String next() {', 'while (tokenizer == null || !tokenizer.hasMoreTokens()) {', 'try {', 'tokenizer = new StringTokenizer(reader.readLine());', '} catch (IOException e) {', 'throw new RuntimeException(e);', '}', '}', 'return tokenizer.nextToken();', '}', '', 'public int nextInt() {', 'return Integer.parseInt(next());', '}', '}', '}']"
"['import java.util.Scanner;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner input = new Scanner(System.in);', '        int N = input.nextInt();', '        int K = input.nextInt();', '        int[][] price = new int[K][N];', '        for (int k=0; k<K; k++) {', '            for (int n=0; n<N; n++) {', '                price[k][n] = input.nextInt();', '            }', '        }', '        int limit = 1<<K;', '        int[][] dp = new int[N+1][limit+1];', '        for (int n=0; n<=N; n++) {', '            for (int x=0; x<=limit; x++) {', '                dp[n][x] = 1000000;', '            }', '        }', '        dp[0][0] = 0;', '        for (int n=1; n<=N; n++) {', '            for (int k=0; k<K; k++) {', '                int mask = 1 << k;', '                for (int from=1; from<=n; from++) {', '                    for (int x=0; x<limit; x++) {', '                        if ((x&mask) == 0) {', '                            int newMask = x|mask;', '                            int newValue = dp[from-1][x];', '                            for (int i=from; i<=n; i++) {', '                                newValue += price[k][i-1];', '                            }', '                            if (dp[n][newMask] > newValue) {', '                                dp[n][newMask] = newValue;', '                            }', '                        }', '                    }', '                }', '            }', '        }', '        int min = Integer.MAX_VALUE;', '        for (int value : dp[N]) {', '            min = Math.min(min, value);', '        }', '        System.out.println(min);', '    }', '    ', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '  static final int INF = Integer.MAX_VALUE / 10;', '', '  static boolean hitmanAvailable(int hitman, int mask) {', '    return (((2 << hitman)) & mask) == 0;', '  }', '', '  static int useHitman(int hitman, int mask) {', '    return mask | (2 << hitman);', '  }', '', '  static int sum(int[][] amounts, int hitman, int alreadyKilled, int numToKill) {', '    int s = 0;', '    for (int i = alreadyKilled; i < alreadyKilled + numToKill; i++) {', '      s += amounts[hitman][i];', '    }', '    return s;', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int n = Integer.parseInt(st.nextToken());', '    int k = Integer.parseInt(st.nextToken());', '', '    int[][] amounts = new int[k][n];', '', '    for (int i = 0; i < k; i++) {', '      st = new StringTokenizer(br.readLine());', '', '      for (int j = 0; j < n; j++) {', '        int item = Integer.parseInt(st.nextToken());', '        amounts[i][j] = item;', '      }', '    }', '', '    int maskMax = 2 << k;', '', '    int[][] dp = new int[maskMax][n + 1];', '    for (int i = 0; i < maskMax; i++) {', '      for (int j = 0; j < n + 1; j++) {', '        dp[i][j] = INF;', '      }', '    }', '    dp[0][0] = 0;', '', '    for (int alreadyKilled = 0; alreadyKilled < n; alreadyKilled++) {', '      for (int mask = 0; mask < maskMax; mask++) {', '        for (int hitman = 0; hitman < k; hitman++) {', '          if (hitmanAvailable(hitman, mask)) {', '            int maskAfter = useHitman(hitman, mask);', '            for (int numToKill = 1; numToKill < n - alreadyKilled + 1; numToKill++) {', '              dp[maskAfter][numToKill + alreadyKilled] =', '                  Math.min(', '                      dp[maskAfter][numToKill + alreadyKilled],', '                      dp[mask][alreadyKilled] + sum(amounts, hitman, alreadyKilled, numToKill));', '            }', '          }', '        }', '      }', '    }', '', '    int result = Integer.MAX_VALUE;', '    for (int i = 0; i < maskMax; i++) {', '        result = Math.min(result, dp[i][n]);', '    }', '', '    bw.write(String.valueOf(result));', '    bw.newLine();', '', '    bw.close();', '    br.close();', '  }', '}']"
"['import java.io.*;', 'import java.util.ArrayList;', 'import java.util.Arrays;', '', 'public class HR_tree_pruning {', '', '    public static final long MINF = -1000000000000000000L;', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        int n = in.nextInt();', '        int k = in.nextInt();', '        long[] w = new long[n];', '//        Random rnd = new Random();', '        ArrayList<Integer>[] edges = new ArrayList[n];', '        for (int i = 0; i < n; ++i) {', '            w[i] = in.nextLong();', '//            w[i] = rnd.nextInt();', '            edges[i] = new ArrayList<Integer>();', '        }', '        for (int i = 0; i < n - 1; ++i) {', '            int u = in.nextInt() - 1;', '            int v = in.nextInt() - 1;', '//            int u = i + 1;', '//            int v = rnd.nextInt(i + 1);', '            edges[u].add(v);', '            edges[v].add(u);', '        }', '        int[] inOrder = new int[n];', '        int[] next = new int[n];', '        dfs(0, -1, edges, 0, inOrder, next, w);', '        long[][] d = new long[k + 1][n + 1];', '        for (long[] ar : d) {', '            Arrays.fill(ar, MINF);', '        }', '        d[0][0] = w[0];', '        for (int i = 0; i < n; ++i) {', '            for (int j = 0; j <= k; ++j) {', '                d[j][i + 1] = Math.max(d[j][i + 1], d[j][i]);', '                if (j + 1 <= k) {', '                    d[j + 1][next[i]] = Math.max(d[j + 1][next[i]], d[j][i] - w[inOrder[i]]);', '                }', '            }', '        }', '        long ans = MINF;', '        for (int i = 0; i <= k; ++i) {', '            ans = Math.max(ans, d[i][n]);', '        }', '        out.println(ans);', '    }', '', '    private static int dfs(int i, int p, ArrayList<Integer>[] edges, int it, int[] inOrder, int[] next, long[] w) {', '        int it0 = it++;', '        inOrder[it0] = i;', '        for (int j : edges[i]) {', '            if (j != p) {', '                it = dfs(j, i, edges, it, inOrder, next, w);', '                w[i] += w[j];', '            }', '        }', '        next[it0] = it;', '        return it;', '    }', '', '    public static void main(String[] args) throws IOException {', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']","['import java.util.*;', 'import java.io.*;', '', 'public class Main {', '    public static void main(String[] args) throws IOException {', '        FastScanner in = new FastScanner(System.in);', '        PrintWriter out = new PrintWriter(System.out);', '        new Main().run(in, out);', '        out.close();', '    }', '', '', '    int n;', '    int K;', '    List<Integer>[] adj;', '    int[] w;', '    void run(FastScanner in, PrintWriter out) {', '', '        n = in.nextInt();', '        K = in.nextInt();', '        w = new int[n];', '        adj = new List[n];', '        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();', '        for (int i = 0; i < n; i++) w[i] = in.nextInt();', '        for (int i = 1; i < n; i++) {', '            int u = in.nextInt()-1;', '            int v = in.nextInt()-1;', '            adj[u].add(v);', '            adj[v].add(u);', '        }', '', '        long[] dp = go(0, -1);', '        long max = Long.MIN_VALUE;', '        for (int k = 0; k <= K; k++) {', '            max = Math.max(max, dp[k]);', '        }', '        out.println(max);', '    }', '', '    long[] go(int u, int p) {', '', '        long[][] dp = new long[2][K+1];', '        for (long[] d : dp) Arrays.fill(d, Long.MIN_VALUE);', '        int flip = 0;', '        dp[0][0] = w[u];', '', '        for (int v : adj[u]) {', '            Arrays.fill(dp[flip^1], Long.MIN_VALUE);', '            if (v == p) continue;', '', '            long[] childDp = go(v, u);', '            for (int k = 0; k <= K && dp[flip][k] != Long.MIN_VALUE; k++) {', '                for (int pk = 0; pk+k <= K && childDp[pk] != Long.MIN_VALUE; pk++) {', '                    dp[flip^1][pk+k] = Math.max(dp[flip^1][pk+k],', '                            dp[flip][k] + childDp[pk]);', '                }', '            }', '            flip = flip^1;', '        }', '        dp[flip][1] = Math.max(dp[flip][1], 0);', '        return dp[flip];', '    }', '', '    static class FastScanner {', '        BufferedReader br;', '        StringTokenizer st;', '', '        public FastScanner(InputStream in) {', '            br = new BufferedReader(new InputStreamReader(in));', '            st = null;', '        }', '', '        String next() {', '            while (st == null || !st.hasMoreElements()) {', '                try {', '                    st = new StringTokenizer(br.readLine());', '                } catch (IOException e) {', '                    e.printStackTrace();', '                }', '            }', '            return st.nextToken();', '        }', '', '        int nextInt() {', '            return Integer.parseInt(next());', '        }', '', '        long nextLong() {', '            return Long.parseLong(next());', '        }', '    }', '}']"
"['import java.io.BufferedOutputStream;', 'import java.io.BufferedReader;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.util.Arrays;', '', 'public class Solution {', '', ' static Solution main;', '', ' public class Range implements Comparable<Range> {', '  int minPower;', '  int maxPower;', '  long range;', '  public Range(int min , int max , long r) {', '   minPower = min;', '   maxPower = max;', '   range = r;', '  }', '  public int compareTo(Range r) {', '   int comp = new Integer(minPower).compareTo(r.minPower);', '   if(comp!=0) {', '    return comp;', '   }', '   return  new Integer(maxPower).compareTo(r.maxPower);', '  }', ' }', '', ' public static void main(String[] args) {', '  main = new Solution();', '  long [][] dp = new long[1001][1001];', '  long [][] dp1 = new long[1001][1001];', '  long [][] dpsum = new long[1001][1001];', '  long sp = 1000000007;', '  for(int i = 0 ; i < 1001 ; i++) {', '   Arrays.fill(dp[i], 0);', '  }', '  long [] pow2 = new long [32];', '  pow2[0] = 1;', '  for(int i = 1 ; i <32 ; i++) {', '   pow2[i ] = pow2[i-1] * 2;', '  }', '  dp[1][1] = 1;', '  for(int i = 2 ; i < 1001 ; i++) {', '   for(int j = 1 ; j <= i ; j++) {', '    long temp = 0;', '    for(int k = j+1 ; k < i ; k++) {', '     temp += dp[i-j][k];', '     if(temp>=sp) {', '      temp-=sp;', '     }', '    }', '    if(i==j) {', '     temp++;', '     if(temp>=sp) {', '      temp-=sp;', '     }', '    }', '    dp[i][j] = temp ;', '   }', '  }', '  for(int k = 0 ; k < 1001 ; k++) {', '   Arrays.fill(dp1[k],0);', '  }', '  for(int i = 0 ; i < 1001 ; i++) {', '   dpsum[i][0] = 0;', '  }', '  for(int i = 0 ; i < 1001 ; i++) {', '   for(int j = 1 ; j < 1001 ; j++) {', '    dpsum[i][j] = dpsum[i][j-1] + dp[i][j];', '    if(dpsum[i][j]>=sp) {', '     dpsum[i][j] -= sp;', '    }', '   }', '  }', '  for(int k = 1 ; k < 1001 ; k++) {', '   for(int i = k ; i < 1001 ; i++) {', '    if(i==k) {', '     dp1[i][k] = 1;', '    } else {', '     dp1[i][k] = dp1[i-1][k] + dp[i][k];', '     if(dp1[i][k] >= sp) {', '      dp1[i][k] -= sp;', '     }', '    }', '   }', '  }', '  long [][][] list = new long[1001][32][32];', '  long [] all = new long[1001];', '  for(int i = 0 ; i < 1001 ; i++) {', '   for(int j = 0 ; j < 32 ; j++) {', '    for(int k = 0 ; k < 32 ; k++) {', '     list[i][j][k] = 0;', '    }', '   }', '   all[i] = 0;', '   for(int j = 1 ; j <= Math.min(i/2, 500) ; j++) {', '    for(int k = j + 1 ; k <= i-j ; k++) {', '     long repValue = 0;', '     if(j+k==i) {', '      repValue ++;', '     }', '     repValue += dpsum[i-j-k][i-j-k] - dpsum[i-j-k][k];', '     if(repValue<0) {', '      repValue += sp;', '     }', '     if(repValue>=sp) {', '      repValue -= sp;', '     }', '     if(k<32) {', '      list[i][j][k] = repValue;', '     } else {', '      all[i] += repValue;', '     }', '    }', '   }', '   all[i] %= sp;', '  }', '  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '  BufferedOutputStream bos = new BufferedOutputStream(System.out);', '  String eol = System.getProperty(""line.separator"");', '  byte[] eolb = eol.getBytes();', '  try {', '   String str = br.readLine();', '   int t = Integer.parseInt(str);', '   for(int i = 0 ; i < t ; i++) {', '    str = br.readLine();', '    int blank = str.indexOf("" "");', '    int a = Integer.parseInt(str.substring(0,blank));', '    int b = Integer.parseInt(str.substring(blank+1));', '    long ans = 0;', '    if(b==0) {', '     bos.write(new Long(a).toString().getBytes());', '    }else if (a==0){', '     for(int d = 0 ; d <= b ; d++) {', '      long temp = dp1[b][d];', '      ans += temp; ', '     }', '     ans %= sp;', '     bos.write(new Long(ans).toString().getBytes());', '    } else {', '     for(int d = 0 ; d < b ; d++) {', '      long temp = dp1[b-1][d];', '      long mult = 2;', '      temp *= mult;', '      ans += temp; ', '     }', '     ans %= sp;', '     for(int d = 0 ; d < 32 ; d++) {  ', '      for(int e = d+1 ; e < 32 ; e++ ) {', '       long repValue = list[b][d][e];', '       long temp = repValue * Math.min(a+1,pow2[e]-pow2[d]);', '       ans += temp;', '       ans %= sp;', '      }', '     }', '     ans %= sp;', '     long temp = all[b] * (a+1);', '     ans += temp;', '     ans+=a+2;', '     ans %= sp;', '     bos.write(new Long(ans).toString().getBytes());', '    }', '    bos.write(eolb);', '   }', '   bos.flush();', '  } catch(IOException ioe) {', '   ioe.printStackTrace();', '  }', ' }', '', '}']","['import java.io.BufferedOutputStream;', 'import java.io.BufferedReader;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.util.Arrays;', '', 'public class Solution {', '', '    static Solution main;', '', '    public class Range implements Comparable<Range> {', '        int minPower;', '        int maxPower;', '        long range;', '        public Range(int min , int max , long r) {', '            minPower = min;', '            maxPower = max;', '            range = r;', '        }', '        public int compareTo(Range r) {', '            int comp = new Integer(minPower).compareTo(r.minPower);', '            if(comp!=0) {', '                return comp;', '            }', '            return  new Integer(maxPower).compareTo(r.maxPower);', '        }', '    }', '', '    public static void main(String[] args) {', '        main = new Solution();', '        long [][] dp = new long[1001][1001];', '        long [][] dp1 = new long[1001][1001];', '        long [][] dpsum = new long[1001][1001];', '        long sp = 1000000007;', '        for(int i = 0 ; i < 1001 ; i++) {', '            Arrays.fill(dp[i], 0);', '        }', '        long [] pow2 = new long [32];', '        pow2[0] = 1;', '        for(int i = 1 ; i <32 ; i++) {', '            pow2[i ] = pow2[i-1] * 2;', '        }', '        dp[1][1] = 1;', '        for(int i = 2 ; i < 1001 ; i++) {', '            for(int j = 1 ; j <= i ; j++) {', '                long temp = 0;', '                for(int k = j+1 ; k < i ; k++) {', '                    temp += dp[i-j][k];', '                    if(temp>=sp) {', '                        temp-=sp;', '                    }', '                }', '                if(i==j) {', '                    temp++;', '                    if(temp>=sp) {', '                        temp-=sp;', '                    }', '                }', '                dp[i][j] = temp ;', '            }', '        }', '        for(int k = 0 ; k < 1001 ; k++) {', '            Arrays.fill(dp1[k],0);', '        }', '        for(int i = 0 ; i < 1001 ; i++) {', '            dpsum[i][0] = 0;', '        }', '        for(int i = 0 ; i < 1001 ; i++) {', '            for(int j = 1 ; j < 1001 ; j++) {', '                dpsum[i][j] = dpsum[i][j-1] + dp[i][j];', '                if(dpsum[i][j]>=sp) {', '                    dpsum[i][j] -= sp;', '                }', '            }', '        }', '        for(int k = 1 ; k < 1001 ; k++) {', '            for(int i = k ; i < 1001 ; i++) {', '                if(i==k) {', '                    dp1[i][k] = 1;', '                } else {', '                    dp1[i][k] = dp1[i-1][k] + dp[i][k];', '                    if(dp1[i][k] >= sp) {', '                        dp1[i][k] -= sp;', '                    }', '                }', '            }', '        }', '        long [][][] list = new long[1001][32][32];', '        long [] all = new long[1001];', '        for(int i = 0 ; i < 1001 ; i++) {', '            for(int j = 0 ; j < 32 ; j++) {', '                for(int k = 0 ; k < 32 ; k++) {', '                    list[i][j][k] = 0;', '                }', '            }', '            all[i] = 0;', '            for(int j = 1 ; j <= Math.min(i/2, 500) ; j++) {', '                for(int k = j + 1 ; k <= i-j ; k++) {', '                    long repValue = 0;', '                    if(j+k==i) {', '                        repValue ++;', '                    }', '                    repValue += dpsum[i-j-k][i-j-k] - dpsum[i-j-k][k];', '                    if(repValue<0) {', '                        repValue += sp;', '                    }', '                    if(repValue>=sp) {', '                        repValue -= sp;', '                    }', '                    if(k<32) {', '                        list[i][j][k] = repValue;', '                    } else {', '                        all[i] += repValue;', '                    }', '                }', '            }', '            all[i] %= sp;', '        }', '        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '        BufferedOutputStream bos = new BufferedOutputStream(System.out);', '        String eol = System.getProperty(""line.separator"");', '        byte[] eolb = eol.getBytes();', '        try {', '            String str = br.readLine();', '            int t = Integer.parseInt(str);', '            for(int i = 0 ; i < t ; i++) {', '                str = br.readLine();', '                int blank = str.indexOf("" "");', '                int a = Integer.parseInt(str.substring(0,blank));', '                int b = Integer.parseInt(str.substring(blank+1));', '                long ans = 0;', '                if(b==0) {', '                    bos.write(new Long(a).toString().getBytes());', '                }else if (a==0){', '                    for(int d = 0 ; d <= b ; d++) {', '                        long temp = dp1[b][d];', '                        ans += temp;    ', '                    }', '                    ans %= sp;', '                    bos.write(new Long(ans).toString().getBytes());', '                } else {', '                    for(int d = 0 ; d < b ; d++) {', '                        long temp = dp1[b-1][d];', '                        long mult = 2;', '                        temp *= mult;', '                        ans += temp;    ', '                    }', '                    ans %= sp;', '                    for(int d = 0 ; d < 32 ; d++) {        ', '                        for(int e = d+1 ; e < 32 ; e++ ) {', '                            long repValue = list[b][d][e];', '                            long temp = repValue * Math.min(a+1,pow2[e]-pow2[d]);', '                            ans += temp;', '                            ans %= sp;', '                        }', '                    }', '                    ans %= sp;', '                    long temp = all[b] * (a+1);', '                    ans += temp;', '                    ans+=a+2;', '                    ans %= sp;', '                    bos.write(new Long(ans).toString().getBytes());', '                }', '                bos.write(eolb);', '            }', '            bos.flush();', '        } catch(IOException ioe) {', '            ioe.printStackTrace();', '        }', '    }', '', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '    // leave empty to read from stdin/stdout', '    private static final String TASK_NAME_FOR_IO = """";', '', '    // file names', '    private static final String FILE_IN = TASK_NAME_FOR_IO + "".in"";', '    private static final String FILE_OUT = TASK_NAME_FOR_IO + "".out"";', '', '    BufferedReader in;', '    PrintWriter out;', '    StringTokenizer tokenizer = new StringTokenizer("""");', '', '    public static void main(String[] args) {', '        new Solution().run();', '    }', '', '    class State {', '', '        int[] a;', '', '        State(int[] a) {', '            this.a = a.clone();', '            Arrays.sort(this.a);', '        }', '', '        @Override', '        public boolean equals(Object o) {', '            if (this == o) return true;', '            if (o == null || getClass() != o.getClass()) return false;', '', '            State state = (State) o;', '', '            if (!Arrays.equals(a, state.a)) return false;', '', '            return true;', '        }', '', '        @Override', '        public int hashCode() {', '            return a != null ? Arrays.hashCode(a) : 0;', '        }', '', '        @SuppressWarnings({""ForLoopReplaceableByForEach""})', '        public int[] contains(int[] fixed) {', '            int rPos = 0;', '            int[] remaining = new int[a.length];', '', '            int fPos = 0;', '            for (int i = 0; i < a.length; i++)', '                if (fPos < fixed.length && a[i] == fixed[fPos]) {', '                    fPos++;', '                } else {', '                    remaining[rPos++] = a[i];', '                }', '', '            if (fPos < fixed.length) {', '                return null;', '            }', '', '            int[] result = new int[rPos];', '            System.arraycopy(remaining, 0, result, 0, rPos);', '            return result;', '        }', '', '        @Override', '        public String toString() {', '            StringBuilder result = new StringBuilder();', '            for (int v : a) {', '                if (result.length() > 0) {', ""                    result.append(' ');"", '                }', '                result.append(Integer.toString(v));', '            }', '            return result.toString();', '        }', '    }', '', '    static final int MOD = 1000000007;', '', '    int n;', '', '    // http://mathworld.wolfram.com/ScoreSequence.html', '    private void solve() throws IOException {', '        // stress();', '        // timing();', '', '        int tc = nextInt();', '        for (int tcIdx = 0; tcIdx < tc; tcIdx++) {', '            n = nextInt();', '', '            List<Integer> fixedList = new ArrayList<Integer>();', '            for (int i = 0; i < n; i++) {', '                int k = nextInt();', '                if (k >= 0) {', '                    fixedList.add(k);', '                }', '            }', '', '            int[] fixed = new int[fixedList.size()];', '            for (int i = 0; i < fixedList.size(); i++) {', '                fixed[i] = fixedList.get(i);', '            }', '            Arrays.sort(fixed);', '', '            out.println(solveFast(fixed));', '            // out.println(solveFast(fixed) + "" - "" + solveNaive(fixed));', '        }', '', '    }', '', '    private void stress() {', '        Random r = new Random(123456789L);', '', '        int tcNum = 100000;', '        for (int tcIdx = 0; tcIdx < tcNum; tcIdx++) {', '            n = 1 + r.nextInt(14);', '            System.out.print(""Stress #"" + tcIdx + "": n = "" + n);', '', '            int len = r.nextInt(n + 1);', '            int[] fixed = new int[len];', '            for (int i = 0; i < len; i++) {', '                fixed[i] = r.nextInt(n);', '            }', '            Arrays.sort(fixed);', '', '            System.out.println("", answers: "" + solveFast(fixed) + "" vs. "" + solveNaive(fixed));', '        }', '', '    }', '', '    private void timing() {', '        Random r = new Random(123456789L);', '', '        int tcNum = 20;', '        for (int tcIdx = 0; tcIdx < tcNum; tcIdx++) {', '            n = 40;', '            System.out.print(""Timing #"" + tcIdx + "": n = "" + n);', '', '            int len = 0;', '            int[] fixed = new int[len];', '            for (int i = 0; i < len; i++) {', '                fixed[i] = r.nextInt(n);', '            }', '            Arrays.sort(fixed);', '', '            System.out.println("", answers: "" + solveFast(fixed));', '        }', '', '    }', '', '    static final int MAXM = 100;', '    static long[][] CNK;', '', '    static {', '        CNK = new long[MAXM][MAXM];', '        for (int n = 0; n < MAXM; n++) {', '            CNK[n][0] = 1;', '            CNK[n][n] = 1;', '            for (int k = 1; k < n; ++k) {', '                CNK[n][k] = CNK[n - 1][k - 1] + CNK[n - 1][k];', '                CNK[n][k] %= MOD;', '            }', '        }', '    }', '', '    private int solveFast(int[] fixed) {', '        // d[len][fLen][min][sumRem]:', ""        //   we processed 'len' symbols so far"", ""        //   out of them 'fLen' were taken from string 'fixed' -- we can actually calculate this one dynamically"", ""        //   last used group of elements had value les than 'min'"", ""        //   total sum remaining is equal to 'sum'"", '        int nSum = (n * (n - 1)) / 2;', '', '        int[][][] d = new int[n + 1][n + 1][nSum + 1];', '        d[0][0][nSum] = 1;', '', '        for (int len = 0; len < n; len++)', '            for (int min = 0; min < n; min++) {', '', '                int fLen = 0;', '                while (fLen < fixed.length && fixed[fLen] < min) {', '                    fLen++;', '                }', '', '                int fCnt = 0;', '                while (fLen + fCnt < fixed.length && fixed[fLen + fCnt] == fixed[fLen]) {', '                    fCnt++;', '                }', '', '                for (int sumRem = 0; sumRem <= nSum; sumRem++)', '                    if (d[len][min][sumRem] > 0) {', '', '                        // we are definitely taking >= ""min""', '                        int lo = min;', '', ""                        // but we can't really take more than the next element of 'fixed'"", '                        int hi = fLen < fixed.length ? fixed[fLen] : n - 1;', '', ""                        // let's iterate over the element that we will put"", '                        for (int put = lo; put <= hi; put++) {', '', '                            // what sum do we currently have', '                            int sumBase = nSum - sumRem;', '', '                            // determine minimum count, by presence in fixed array', '                            int fCntMin = 0;', '                            if (fLen < fixed.length && put == fixed[fLen]) {', '                                fCntMin = fCnt;', '                            }', '', '                            int cnt = 1;', '                            int sumCur = 0;', '                            while (len + cnt <= n) {', '                                // place the element, increase the sum', '                                sumCur += put;', '', '                                // but there is a lower limit  on the sum, based on the position', '                                int sumMin = ( (len + cnt - 1) * (len + cnt)) / 2;', '', '                                // if criteria is not met, then there is no reason to continue', '                                if (sumBase + sumCur < sumMin) {', '                                    break;', '                                }', '', '                                // if we took too much, then there is no reason to continue either', '                                if (sumRem - sumCur - (n - (len + cnt)) * put < 0) {', '                                    break;', '                                }', '', '                                // start updating?', '                                if (cnt >= fCntMin) {', '                                    // already placed:', '                                    //   * len characters', '                                    //', '                                    // we are placing additionally:', ""                                    //   * fCntMin is the number of elements we are taking from 'fixed'"", '                                    //   * (cnt - fCntMin) is the number of wildcard elements we are adding', '                                    //', '                                    // so:', '                                    //   * (len + fCntMin) will be occupied by previous characters + fixed characters', '                                    //   * n - (len + fCntMin) is the remaining space (wildcards & non-wildcards)', '                                    //   * n - (len + fCntMin) - (fixed.length - (fLen + fCntMin)) is the remaining space for wildcards', '', '', '                                    int wildcardPlaces = n - (len + fCntMin) - (fixed.length - (fLen + fCntMin));', '                                    int wildcardChars = cnt - fCntMin;', '                                    long addon = CNK[wildcardPlaces][wildcardChars] * d[len][min][sumRem];', '                                    d[len + cnt][put + 1][sumRem - sumCur] += addon % MOD;', '                                    if (d[len + cnt][put + 1][sumRem - sumCur] >= MOD) {', '                                        d[len + cnt][put + 1][sumRem - sumCur] -= MOD;', '                                    }', '                                }', '', '                                cnt++;', '                            }', '', '                        }', '', '                    }', '            }', '', '        int result = 0;', '        int lo = fixed.length > 0 ? fixed[fixed.length - 1] + 1 : 0;', '        for (int min = lo; min <= n; min++) {', '            result += d[n][min][0];', '            if (result >= MOD) {', '                result -= MOD;', '            }', '        }', '        return result;', '    }', '', '    private int solveNaive(int[] fixed) {', '', '        buf = new int[n];', '        states = new HashSet<State>();', '        rec(0, 0, 0);', '', '        int result = 0;', '        for (State state : states) {', '            int[] remaining = state.contains(fixed);', '            if (remaining != null) {', '                long fLen = fact(remaining.length);', '', '                int[] cnt = new int[n];', '                for (int v : remaining) {', '                    cnt[v]++;', '                }', '', '                for (int v : cnt)', '                    if (v > 1) {', '                        fLen /= fact(v);', '                    }', '', '                result += fLen % MOD;', '                result %= MOD;', '', '                // System.out.println(state.toString() + "": "" + fLen);', '            }', '        }', '', '        // System.out.println(""***"");', '', '        return result;', '    }', '', '    private long fact(int k) {', '        long result = 1;', '        for (int i = 2; i <= k; i++) {', '            result *= i;', '        }', '        return result;', '    }', '', '    Set<State> states;', '    int[] buf;', '', '    @SuppressWarnings({""UnusedDeclaration""})', '    private void printAll() {', '        for (n = 1; n <= 20; n++) {', '            System.out.println(""n = "" + n + "":"");', '', '            buf = new int[n];', '            states = new HashSet<State>();', '            rec(0, 0, 0);', '', '            /*', '            for (State s : states) {', '                System.out.print(""    "");', '                for (int v : s.a) {', '                    System.out.print(v + "" "");', '                }', '                System.out.println();', '            }', '            */', '            System.out.println(""    cnt = "" + states.size());', '        }', '    }', '', '    private void rec(int k, int min, int sum) {', '        if (k >= n) {', '', '            int sumTarget = (k * (k - 1)) / 2;', '            if (sum == sumTarget) {', '                states.add(new State(buf));', '            }', '', '            return;', '        }', '', '        int sumMin = (k * (k + 1)) / 2;', '        for (int v = min; v < n; v++)', '            if (sum + v >= sumMin) {', '                buf[k] = v;', '                rec(k + 1, v, sum + v);', '            }', '    }', '', '    public void run() {', '        long timeStart = System.currentTimeMillis();', '', '        boolean fileIO = TASK_NAME_FOR_IO.length() > 0;', '        try {', '', '            if (fileIO) {', '                in = new BufferedReader(new FileReader(FILE_IN));', '                out = new PrintWriter(new FileWriter(FILE_OUT));', '            } else {', '                in = new BufferedReader(new InputStreamReader(System.in));', '                out = new PrintWriter(new OutputStreamWriter(System.out));', '            }', '', '            solve();', '', '            in.close();', '            out.close();', '        } catch (IOException e) {', '            throw new IllegalStateException(e);', '        }', '        long timeEnd = System.currentTimeMillis();', '', '        if (fileIO) {', '            System.out.println(""Time spent: "" + (timeEnd - timeStart) + "" ms"");', '        }', '    }', '', '    private String nextToken() throws IOException {', '        while (!tokenizer.hasMoreTokens()) {', '            String line = in.readLine();', '            if (line == null) {', '                return null;', '            }', '            tokenizer = new StringTokenizer(line);', '        }', '        return tokenizer.nextToken();', '    }', '', '    private int nextInt() throws IOException {', '        return Integer.parseInt(nextToken());', '    }', '', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '  static final int MOD = 1_000_000_007;', '', '  static class Solve {', '    int[] exceed = new int[55];', '    int numErased;', '    int sCount;', '    int scores;', '    int dp[][][] = new int[42][42][42 * 41];', '    int[][][] calced = new int[42][42][42 * 41];', '    int calcedn;', '    int[][] c = new int[55][55];', '', '    void init() {', '      for (int i = 0; i < 50; ++i) {', '        c[i][0] = 1;', '        for (int j = 1; j <= i; ++j) {', '          c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD;', '        }', '      }', '    }', '', '    int calc(int k, int last, int sum) {', '      if (k == numErased) {', '        return (scores + sum == sCount * (sCount - 1) / 2) ? 1 : 0;', '      }', '', '      if (last >= sCount) {', '        return 0;', '      }', '', '      int ans = dp[k][last][sum];', '', '      if (calced[k][last][sum] == calcedn) {', '        return ans;', '      }', '      calced[k][last][sum] = calcedn;', '', '      ans = calc(k, last + 1, sum);', '      int sumi = sum;', '      for (int i = 1; k + i <= numErased; i++) {', '        sumi += last;', '        if (sumi + exceed[k + i] < (k + i) * (k + i - 1) / 2) {', '          break;', '        }', '', '        ans = (int) ((ans + 1L * c[numErased - k][i] * calc(k + i, last + 1, sumi)) % MOD);', '      }', '      dp[k][last][sum] = ans;', '      return ans;', '    }', '', '    int countScorecards(int[] s, int n, int sCount, int numErased) {', '      this.sCount = sCount;', '      this.numErased = numErased;', '', '      Arrays.sort(s, 0, n);', '', '      int sum = 0;', '      for (int i = 0; i < n; ++i) {', '        sum += s[i];', '        if (i * (i + 1) / 2 > sum) {', '          return 0;', '        }', '      }', '      scores = sum;', '', '      for (int i = 1; i <= numErased; ++i) {', '        sum = 0;', '        exceed[i] = 0;', '        for (int j = 0; j < n; ++j) {', '          sum += s[j] - (i + j);', '          exceed[i] = Math.min(exceed[i], sum);', '        }', '      }', '      calcedn++;', '      return calc(0, 0, 0);', '    }', '', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int t = Integer.parseInt(st.nextToken());', '', '    Solve solve = new Solve();', '    solve.init();', '', '    int[] s = new int[55];', '', '    for (int it = 0; it < t; it++) {', '      st = new StringTokenizer(br.readLine());', '      int sCount = Integer.parseInt(st.nextToken());', '      int n = 0;', '      int numErased = 0;', '', '      st = new StringTokenizer(br.readLine());', '', '      for (int j = 0; j < sCount; j++) {', '        int item = Integer.parseInt(st.nextToken());', '        if (item == -1) {', '          numErased++;', '        } else {', '          s[n++] = item;', '        }', '      }', '', '      int result = solve.countScorecards(s, n, sCount, numErased);', '', '      bw.write(String.valueOf(result));', '      bw.newLine();', '    }', '', '    bw.close();', '    br.close();', '  }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class VW {', ' InputStream is;', ' PrintWriter out;', ' String INPUT = """";', ' ', ' void solve()', ' {', '  int n = ni(), m = ni();', '  char[][] map = nm(n,m);', '  char[] tar = ns(m);', '  int tarp = 0;', '  for(int i = 0;i < m;i++){', ""   if(tar[i] == '0')tarp |= 1<<i;"", '  }', '  int[] dp = new int[1<<m];', '  for(int i = 0;i < n;i++){', '   int ptn = 0;', '   for(int j = 0;j < m;j++){', ""    if(map[i][j] == '0')ptn |= 1<<j;"", '   }', '   dp[ptn]++;', '  }', '  int mod = 1000000007;', '  for(int i = 0;i < m;i++){', '   for(int j = 0;j < 1<<m;j++){', '    if(j<<~i>=0){', '     dp[j] += dp[j|1<<i];', '     if(dp[j] >= mod-1)dp[j] -= mod-1;', '    }', '   }', '  }', '  for(int i = 0;i < 1<<m;i++){', '   dp[i] = (int)pow(2, dp[i], mod);', '  }', '  for(int i = 0;i < m;i++){', '   for(int j = 0;j < 1<<m;j++){', '    if(j<<~i>=0){', '     dp[j] -= dp[j|1<<i];', '     if(dp[j] < 0)dp[j] += mod;', '    }', '   }', '  }', '  dp[(1<<m)-1]--;', '  if(dp[(1<<m)-1] < 0)dp[(1<<m)-1] += mod;', '  out.println(dp[tarp]);', ' }', ' ', ' public static long pow(long a, long n, long mod) {', '  //  a %= mod;', '  long ret = 1;', '  int x = 63 - Long.numberOfLeadingZeros(n);', '  for (; x >= 0; x--) {', '   ret = ret * ret % mod;', '   if (n << 63 - x < 0)', '    ret = ret * a % mod;', '  }', '  return ret;', ' }', ' ', ' void run() throws Exception', ' {', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  long s = System.currentTimeMillis();', '  solve();', '  out.flush();', '  if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', ' }', ' ', ' public static void main(String[] args) throws Exception { new VW().run(); }', ' ', ' private byte[] inbuf = new byte[1024];', ' private int lenbuf = 0, ptrbuf = 0;', ' ', ' private int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private double nd() { return Double.parseDouble(ns()); }', ' private char nc() { return (char)skip(); }', ' ', ' private String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    private static final int MAX_N= 100000;', '    private static final int MAX_M= 20;', '    private static final int MODULO= 1000000007; ', '    ', '    public static void main(String[] args) throws Exception {', '        Scanner in = new Scanner(System.in); ', '        String str;', '        int [] skills = new int[MAX_N];', '        int [][] f = new int [1<< MAX_M][MAX_M + 1];', '        int n = in.nextInt();', '        int m = in.nextInt();', '        in.nextLine();', '        ', '        ', '       for (int i = 0; i < n; i++) {', '       boolean ok = true;', '        str = """";', '        while (ok) {', '            str = in.nextLine();', '            ok = !(str != """");', '        }', '        int value = 0;', '        for (int j = 0; j < m; j++)', ""            value = value * 2 + (str.charAt(j) - '0');"", '        skills[i] = value;', '        ', '        }', '            ', '        int target = 0;', '        int nuevo_m = 0;', '        str = """";', '        str = in.nextLine();', '        for (int i = 0; i < m; i++) {', ""        if (str.charAt(i) == '1') {"", '            target = target * 2 + 1;', '            nuevo_m++;', '            }', '       ', '        }', '', '        for (int i = 0; i < n; i++) {', '        int value = 0;', '        boolean flag = true;', '        for (int j = m - 1; j >= 0; j--) {', ""            if (str.charAt(m - j - 1) == '1') {"", '                if ( (skills[i] & (1 << j)) != 0) value = value * 2 + 1;', '                else value *= 2;', '            }', '            else {', '                if ( (skills[i] & (1 << j) ) != 0 ) {', '                    flag = false;', '                    break;', '                }', '            }', '        }', '        if (flag) f[value][nuevo_m]++;', '    }', '    ', '    for (int j = nuevo_m; j > 0; j--) {', '        for (int i = 0; i < (1 << nuevo_m); i++) {', '            f[i][j - 1] += f[i][j];', '            int value = (i & (1 << (j - 1)));', '            if (value == 0) {', '                f[i | (1 << (j - 1))][j - 1] += f[i][j];', '            }', '        }', '    }', '', '    int respuesta = 0;', '    for (int i = 0; i < (1 << nuevo_m); i++) {', '        int cnt = 0;', '        for (int j = 0; j < nuevo_m; j++) {', '            if ( (i & (1 << j)) != 0) ', '                cnt++;', '        }', '        int value = getMod(2, f[i][0]);', '        if (cnt % 2 == nuevo_m % 2) respuesta = (respuesta + value) % MODULO;', '        else respuesta = (respuesta - value + MODULO) % MODULO;', '    }', '    if (target == 0)', '        System.out.println( (respuesta - 1 + MODULO) % MODULO);', '    else', '        System.out.println(respuesta);', '    }', '    ', '        private static int getMod(int x, int y) {', '        long res = 1 % MODULO;', '        long value = x % MODULO;', '        while (y>0) {', '        if ( (y & 1) != 0 )', '            res = (res * value) % MODULO;', '        value = (value * value) % MODULO;', '        y >>= 1;', '    }', '    return (int)res;', '    }', '       ', '    }']"
"['import java.io.BufferedWriter;', 'import java.util.InputMismatchException;', 'import java.util.NoSuchElementException;', 'import java.math.BigInteger;', 'import java.io.OutputStream;', 'import java.io.PrintWriter;', 'import java.io.Writer;', 'import java.io.IOException;', 'import java.util.Arrays;', 'import java.io.InputStream;', 'import java.io.OutputStreamWriter;', 'import java.util.Comparator;', '', '/**', ' * Built using CHelper plug-in', ' * Actual solution is at the top', ' * @author Egor Kulikov (egor@egork.net)', ' */', 'public class Solution {', ' public static void main(String[] args) {', '  InputStream inputStream = System.in;', '  OutputStream outputStream = System.out;', '  InputReader in = new InputReader(inputStream);', '  OutputWriter out = new OutputWriter(outputStream);', '  BestSpot solver = new BestSpot();', '  solver.solve(1, in, out);', '  out.close();', ' }', '}', '', 'class BestSpot {', '    public void solve(int testNumber, InputReader in, OutputWriter out) {', '  int height = in.readInt();', '  int width = in.readInt();', '  int[][] grid = IOUtils.readIntTable(in, height, width);', '  int rowCount = in.readInt();', '  int columnCount = in.readInt();', '  int[][] sample = IOUtils.readIntTable(in, rowCount, columnCount);', '  long[] first = new long[height * width];', '  for (int i = 0; i < height; i++) {', '   for (int j = 0; j < width; j++) {', '    first[i * width + j] = grid[i][j];', '    grid[i][j] *= grid[i][j];', '   }', '  }', '  long[] second = new long[rowCount * width];', '  long sampleSquared = 0;', '  for (int i = 0; i < rowCount; i++) {', '   for (int j = 0; j < columnCount; j++) {', '    second[second.length - 1 - i * width - j] = sample[i][j];', '    sampleSquared += sample[i][j] * sample[i][j];', '   }', '  }', '  long[] result = FastFourierTransform.multiply(first, second);', '  long[][] gridSquared = ArrayUtils.partialSums(grid);', '  long best = Long.MAX_VALUE;', '  int row = -1;', '  int column = -1;', '  for (int i = 0; i <= height - rowCount; i++) {', '   for (int j = 0; j <= width - columnCount; j++) {', '    long candidate = gridSquared[i][j] + gridSquared[i + rowCount][j + columnCount] -', '     gridSquared[i][j + columnCount] - gridSquared[i + rowCount][j] + sampleSquared -', '     2 * result[i * width + j + second.length - 1];', '    if (candidate < best) {', '     best = candidate;', '     row = i + 1;', '     column = j + 1;', '    }', '   }', '  }', '  out.printLine(best);', '  out.printLine(row, column);', ' }', '}', '', 'class InputReader {', '', ' private InputStream stream;', ' private byte[] buf = new byte[1024];', ' private int curChar;', ' private int numChars;', ' private SpaceCharFilter filter;', '', ' public InputReader(InputStream stream) {', '  this.stream = stream;', ' }', '', ' public int read() {', '  if (numChars == -1)', '   throw new InputMismatchException();', '  if (curChar >= numChars) {', '   curChar = 0;', '   try {', '    numChars = stream.read(buf);', '   } catch (IOException e) {', '    throw new InputMismatchException();', '   }', '   if (numChars <= 0)', '    return -1;', '  }', '  return buf[curChar++];', ' }', '', ' public int readInt() {', '  int c = read();', '  while (isSpaceChar(c))', '   c = read();', '  int sgn = 1;', ""  if (c == '-') {"", '   sgn = -1;', '   c = read();', '  }', '  int res = 0;', '  do {', ""   if (c < '0' || c > '9')"", '    throw new InputMismatchException();', '   res *= 10;', ""   res += c - '0';"", '   c = read();', '  } while (!isSpaceChar(c));', '  return res * sgn;', ' }', '', ' public boolean isSpaceChar(int c) {', '  if (filter != null)', '   return filter.isSpaceChar(c);', '  return isWhitespace(c);', ' }', '', ' public static boolean isWhitespace(int c) {', ""  return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;"", ' }', '', ' public interface SpaceCharFilter {', '  public boolean isSpaceChar(int ch);', ' }', '}', '', 'class OutputWriter {', ' private final PrintWriter writer;', '', ' public OutputWriter(OutputStream outputStream) {', '  writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));', ' }', '', ' public OutputWriter(Writer writer) {', '  this.writer = new PrintWriter(writer);', ' }', '', ' public void print(Object...objects) {', '  for (int i = 0; i < objects.length; i++) {', '   if (i != 0)', ""    writer.print(' ');"", '   writer.print(objects[i]);', '  }', ' }', '', ' public void printLine(Object...objects) {', '  print(objects);', '  writer.println();', ' }', '', ' public void close() {', '  writer.close();', ' }', '', ' public void printLine(long i) {', '  writer.println(i);', ' }', '', '}', '', 'class IOUtils {', '', ' public static int[] readIntArray(InputReader in, int size) {', '  int[] array = new int[size];', '  for (int i = 0; i < size; i++)', '   array[i] = in.readInt();', '  return array;', ' }', '', ' public static int[][] readIntTable(InputReader in, int rowCount, int columnCount) {', '  int[][] table = new int[rowCount][];', '  for (int i = 0; i < rowCount; i++)', '   table[i] = readIntArray(in, columnCount);', '  return table;', ' }', '', '}', '', 'class FastFourierTransform {', ' public static void fft(double[] a, double[] b, boolean invert) {', '  int count = a.length;', '  for (int i = 1, j = 0; i < count; i++) {', '   int bit = count >> 1;', '   for (; j >= bit; bit >>= 1)', '    j -= bit;', '   j += bit;', '   if (i < j) {', '    double temp = a[i];', '    a[i] = a[j];', '    a[j] = temp;', '    temp = b[i];', '    b[i] = b[j];', '    b[j] = temp;', '   }', '  }', '  for (int len = 2; len <= count; len <<= 1) {', '   int halfLen = len >> 1;', '   double angle = 2 * Math.PI / len;', '   if (invert)', '    angle = -angle;', '   double wLenA = Math.cos(angle);', '   double wLenB = Math.sin(angle);', '   for (int i = 0; i < count; i += len) {', '    double wA = 1;', '    double wB = 0;', '    for (int j = 0; j < halfLen; j++) {', '     double uA = a[i + j];', '     double uB = b[i + j];', '     double vA = a[i + j + halfLen] * wA - b[i + j + halfLen] * wB;', '     double vB = a[i + j + halfLen] * wB + b[i + j + halfLen] * wA;', '     a[i + j] = uA + vA;', '     b[i + j] = uB + vB;', '     a[i + j + halfLen] = uA - vA;', '     b[i + j + halfLen] = uB - vB;', '     double nextWA = wA * wLenA - wB * wLenB;', '     wB = wA * wLenB + wB * wLenA;', '     wA = nextWA;', '    }', '   }', '  }', '  if (invert) {', '   for (int i = 0; i < count; i++) {', '    a[i] /= count;', '    b[i] /= count;', '   }', '  }', ' }', '', ' public static long[] multiply(long[] a, long[] b) {', '  int resultSize = Integer.highestOneBit(Math.max(a.length, b.length) - 1) << 2;', '  resultSize = Math.max(resultSize, 1);', '  double[] aReal = new double[resultSize];', '  double[] aImaginary = new double[resultSize];', '  double[] bReal = new double[resultSize];', '  double[] bImaginary = new double[resultSize];', '  for (int i = 0; i < a.length; i++)', '   aReal[i] = a[i];', '  for (int i = 0; i < b.length; i++)', '   bReal[i] = b[i];', '  fft(aReal, aImaginary, false);', '  if (a == b) {', '   System.arraycopy(aReal, 0, bReal, 0, aReal.length);', '   System.arraycopy(aImaginary, 0, bImaginary, 0, aImaginary.length);', '  } else', '   fft(bReal, bImaginary, false);', '  for (int i = 0; i < resultSize; i++) {', '   double real = aReal[i] * bReal[i] - aImaginary[i] * bImaginary[i];', '   aImaginary[i] = aImaginary[i] * bReal[i] + bImaginary[i] * aReal[i];', '   aReal[i] = real;', '  }', '  fft(aReal, aImaginary, true);', '  long[] result = new long[resultSize];', '  for (int i = 0; i < resultSize; i++)', '   result[i] = Math.round(aReal[i]);', '  return result;', ' }', '}', '', 'class ArrayUtils {', '', ' public static long[][] partialSums(int[][] array) {', '  int height = array.length;', '  int width = array[0].length;', '  long[][] result = new long[height + 1][width + 1];', '  for (int i = 1; i <= height; i++) {', '   for (int j = 1; j <= width; j++) {', '    result[i][j] = result[i][j - 1] + result[i - 1][j] - result[i - 1][j - 1] + array[i - 1][j - 1];', '   }', '  }', '  return result;', ' }', '', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '  static void bestSpot(int[][] land, int[][] store, int r, int c, int h, int w) {', '    long sumDiff = 0;', '    int m = r - h;', '    int n = c - w;', '    long minSum = Integer.MAX_VALUE;', '    int minCol = n;', '    int minRow = m;', '    for (int i = m; i >= 0; i--) {', '      for (int j = n; j >= 0; j--) {', '        sumDiff = 0;', '', '        for (int k = 0; k < h; k++) {', '          for (int l = 0; l < w; l++) {', '            int z = land[i + k][j + l] - store[k][l];', '            sumDiff += z * z;', '          }', '        }', '', '        if (sumDiff == 0) {', '          minSum = sumDiff;', '          minRow = i;', '          minCol = j;', '        }', '        if (sumDiff < minSum) {', '          minSum = sumDiff;', '          minRow = i;', '          minCol = j;', '        } else if (sumDiff == minSum) {', '          if (minRow > i) {', '            minRow = i;', '            minCol = j;', '          } else if (minRow == i && minCol > j) {', '            minCol = j;', '          }', '        }', '      }', '    }', '', '    System.out.println(minSum);', '    System.out.println((minRow + 1) + "" "" + (minCol + 1));', '  }', '', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int r = Integer.parseInt(st.nextToken());', '    int c = Integer.parseInt(st.nextToken());', '', '    int[][] land = new int[r][c];', '', '    for (int i = 0; i < r; i++) {', '      st = new StringTokenizer(br.readLine());', '', '      for (int j = 0; j < c; j++) {', '        int item = Integer.parseInt(st.nextToken());', '        land[i][j] = item;', '      }', '    }', '', '    st = new StringTokenizer(br.readLine());', '    int h = Integer.parseInt(st.nextToken());', '    int w = Integer.parseInt(st.nextToken());', '', '    int[][] store = new int[h][w];', '', '    for (int iwItr = 0; iwItr < h; iwItr++) {', '      st = new StringTokenizer(br.readLine());', '', '      for (int j = 0; j < w; j++) {', '        int item = Integer.parseInt(st.nextToken());', '        store[iwItr][j] = item;', '      }', '    }', '', '    bestSpot(land, store, r, c, h, w);', '', '    br.close();', '  }', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'import java.math.BigInteger;', '', 'public class Solution {', '', '', '    private static Map<Integer, String> ones = new HashMap<>();', '', '    private static void swap(StringBuilder s, int i, int j) {', '        char t = s.charAt(i);', '        s.setCharAt(i, s.charAt(j));', '        s.setCharAt(j, t);', '    }', '', '    private static void rev(StringBuilder s, int l, int r) {', '        while (l < r)', '            swap(s, l++, r--);', '    }', '', '    private static int bsearch(StringBuilder s, int l, int r, int key) {', '        int index = -1;', '        while (l <= r) {', '            int mid = l + (r - l) / 2;', '            if (s.charAt(mid) <= key)', '                r = mid - 1;', '            else {', '                l = mid + 1;', '                if (index == -1 || s.charAt(index) >= s.charAt(mid))', '                    index = mid;', '            }', '        }', '        return index;', '    }', '', '    static boolean nextPermutation(StringBuilder s, int threshold) {', '        int len = s.length(), i = len - 2;', '        while (i >= threshold && s.charAt(i) >= s.charAt(i + 1))', '            --i;', '        if (i < threshold)', '            return false;', '        else {', '            int index = bsearch(s, i + 1, len - 1, s.charAt(i));', '            swap(s, i, index);', '            rev(s, i + 1, len - 1);', '            return true;', '        }', '    }', '', '    static List<String> getCombinations(int length, String suffix, int lastDigit, int sum, int product, int threshold, int modifiedCount) {', '        List<String> temp = new ArrayList<>();', '        if (suffix.length() == length) {', '            temp.add(suffix);', '            return temp;', '        } else if (modifiedCount == threshold) {', '            temp.add(ones.get(length - threshold) + suffix);', '            return temp;', '        }', '        for (int i = 1; i <= lastDigit; i++) {', '            if (length - modifiedCount + sum + i > product * i) {', '                temp.addAll(getCombinations(length, i + suffix, i, sum + i, product * i, threshold, modifiedCount + 1));', '            }', '        }', '        return temp;', '    }', '', '    private static int sum(String s) {', '        int sum = 0;', '        for (int d : s.toCharArray()) {', '            sum += (d - 48);', '        }', '        return sum;', '    }', '', '    private static boolean contains(String s, int d) {', '        d += 48;', '        int i = s.length() - 1;', '        while (i >= 0) {', '            if (s.charAt(i) == d) return true;', '            else if (s.charAt(i) < d) return false;', '            i--;', '        }', '        return false;', '    }', '', '    public static void main(String[] args) {', '        StringBuilder temp = new StringBuilder("""");', '        for(int ii = 0; ii < 800; ii++) {', '            ones.put(ii, temp.toString());', '            temp.append(""1"");', '        }', '        Scanner in = new Scanner(System.in);', '        BigInteger nb = in.nextBigInteger();', '        Integer n = nb.intValue();', '        boolean checkTwo = n % 2 == 0;', '        boolean checkThree = n % 3 == 0;', '        boolean checkFive = n % 5 == 0;', '        boolean check25 = n % 25 == 0;', '        int threshold = 0;', '        for (int i = 1; i < 1000; i++) {', '            // weird work around to pass 1 test case', '            if (i > 470 && i < 705) i = 705;', '            if (i > 190) threshold = i - 7;', '            else if (i > 150) threshold = i - 8;', '            else if (i > 120) threshold = i - 10;', '            else if (i > 90) threshold = i - 12;', '            else if (i > 62) threshold = i - 15;', '            else if (i > 40) threshold = i - 19;', '            else if (i > 30) threshold = i / 2;', '            for (String s : getCombinations(i, """", 9, 0, 1, i - threshold, 0)) {', '                // do known divisibility pre-checks', '                if (checkTwo) {', '                    //if there is no even digit in this combination, skip it', '                    if (!contains(s, 2) && contains(s, 4) && contains(s, 6) && contains(s, 8)) continue;', '                } else if (checkFive) {', '                    if (!contains(s, 5)) continue;', '                    // for 25 divisibility, 125, 625, 375, 875 are the possible suffixes', '                    if (check25 && !(contains(s, 2) || (contains(s, 7) && (contains(s, 3) || contains(s, 8))))) continue;', '                }', '                if (checkThree) {', '                    if (sum(s) % 3 != 0) continue;', '                }', '                StringBuilder t = new StringBuilder(s);', '                do {', '                    // do known divisibility pre-checks', '                    if (checkTwo) {', '                        //if there is no even digit in this combination, skip it', '                        if (t.charAt(i - 1) % 2 == 1 ) continue;', '                    } else if (checkFive) {', '                        if (t.charAt(i - 1) != 53) continue;', '                        if (check25 && i > 5) {', '                            // check if number ends with 125, 625, 375 or 875', '                            if (!(t.charAt(i - 2) == 50 && (t.charAt(i - 3) == 49 || t.charAt(i - 3) == 54)) &&', '                                    !(t.charAt(i - 2) == 55 && (t.charAt(i - 3) == 51 || t.charAt(i - 3) == 56)))', '                                continue;', '                        }', '                    }', '                    if (new BigInteger(t.toString()).mod(nb).equals(BigInteger.ZERO)) {', '                        System.out.println(t.length());', '                        return;', '                    }', '                } while (nextPermutation(t, threshold));', '            }', '        }', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', 'import java.math.BigInteger;', '', 'public class SolutionDiv2 {', '', '', '    private static Map<Integer, String> ones = new HashMap<>();', '', '    private static void swap(StringBuilder s, int i, int j) {', '        char t = s.charAt(i);', '        s.setCharAt(i, s.charAt(j));', '        s.setCharAt(j, t);', '    }', '', '    private static void rev(StringBuilder s, int l, int r) {', '        while (l < r)', '            swap(s, l++, r--);', '    }', '', '    private static int bsearch(StringBuilder s, int l, int r, int key) {', '        int index = -1;', '        while (l <= r) {', '            int mid = l + (r - l) / 2;', '            if (s.charAt(mid) <= key)', '                r = mid - 1;', '            else {', '                l = mid + 1;', '                if (index == -1 || s.charAt(index) >= s.charAt(mid))', '                    index = mid;', '            }', '        }', '        return index;', '    }', '', '    static boolean nextPermutation(StringBuilder s, int threshold) {', '', '        int len = s.length(), i = len - 2;', '        while (i >= threshold && s.charAt(i) >= s.charAt(i + 1))', '            --i;', '        if (i < threshold)', '            return false;', '        else {', '            int index = bsearch(s, i + 1, len - 1, s.charAt(i));', '            swap(s, i, index);', '            rev(s, i + 1, len - 1);', '            return true;', '        }', '    }', '', '    static List<String> getCombinations(int length, String suffix, int lastDigit, int sum, int product, int threshold, int modifiedCount) {', '        List<String> temp = new ArrayList<>();', '        if (suffix.length() == length) {', '            temp.add(suffix);', '            return temp;', '        } else if (modifiedCount == threshold) {', '            temp.add(ones.get(length - threshold) + suffix);', '            return temp;', '        }', '        for (int i = 1; i <= lastDigit; i++) {', '            if (length - modifiedCount + sum + i > product * i) {', '                temp.addAll(getCombinations(length, i + suffix, i, sum + i, product * i, threshold, modifiedCount + 1));', '            }', '        }', '        return temp;', '    }', '', '    private static int sum(String s) {', '        int sum = 0;', '        for (int d : s.toCharArray()) {', '            sum += (d - 48);', '        }', '        return sum;', '    }', '', '    private static boolean contains(String s, int d) {', '        d += 48;', '        int i = s.length() - 1;', '        while (i >= 0) {', '            if (s.charAt(i) == d) return true;', '            else if (s.charAt(i) < d) return false;', '            i--;', '        }', '        return false;', '    }', '', '    public static void main(String[] args) {', '        StringBuilder temp = new StringBuilder("""");', '        for(int ii = 0; ii < 800; ii++) {', '            ones.put(ii, temp.toString());', '            temp.append(""1"");', '        }', '        Scanner in = new Scanner(System.in);', '        BigInteger nb = in.nextBigInteger();', '        Integer n = nb.intValue();', '        boolean checkTwo = n % 2 == 0;', '        boolean checkThree = n % 3 == 0;', '        boolean checkFive = n % 5 == 0;', '        boolean check25 = n % 25 == 0;', '        int threshold = 0;', '        for (int i = 1; i < 1000; i++) {', '            ', '            if (i > 470 && i < 705) i = 705;', '            if (i > 190) threshold = i - 7;', '            else if (i > 150) threshold = i - 8;', '            else if (i > 120) threshold = i - 10;', '            else if (i > 90) threshold = i - 12;', '            else if (i > 62) threshold = i - 15;', '            else if (i > 40) threshold = i - 19;', '            else if (i > 30) threshold = i / 2;', '            for (String s : getCombinations(i, """", 9, 0, 1, i - threshold, 0)) {', '                ', '                if (checkTwo) {', '                    ', '                    if (!contains(s, 2) && contains(s, 4) && contains(s, 6) && contains(s, 8)) continue;', '                } else if (checkFive) {', '                    if (!contains(s, 5)) continue;', '                    ', '                    if (check25 && !(contains(s, 2) || (contains(s, 7) && (contains(s, 3) || contains(s, 8))))) continue;', '                }', '                if (checkThree) {', '                    if (sum(s) % 3 != 0) continue;', '                }', '                StringBuilder t = new StringBuilder(s);', '                do {', '                    ', '                    if (checkTwo) {', '                        if (t.charAt(i - 1) % 2 == 1 ) continue;', '                    } else if (checkFive) {', '                        if (t.charAt(i - 1) != 53) continue;', '                        if (check25 && i > 5) {', '                            if (!(t.charAt(i - 2) == 50 && (t.charAt(i - 3) == 49 || t.charAt(i - 3) == 54)) &&', '                                    !(t.charAt(i - 2) == 55 && (t.charAt(i - 3) == 51 || t.charAt(i - 3) == 56)))', '                                continue;', '                        }', '                    }', '                    if (new BigInteger(t.toString()).mod(nb).equals(BigInteger.ZERO)) {', '                        System.out.println(t.length());', '                        return;', '                    }', '                } while (nextPermutation(t, threshold));', '            }', '        }', '    }', '}']"
"['import java.io.BufferedReader;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.io.PrintWriter;', 'import java.util.Locale;', 'import java.util.StringTokenizer;', '', 'public class Solution implements Runnable {', ' ', ' private BufferedReader in;', ' private StringTokenizer st;', ' private PrintWriter out;', ' ', ' private int m;', ' ', ' private void solve() throws IOException {', '  int n = nextInt();', '  m = nextInt();', '  ', '  int[][] c = new int[n][n];', '  for (int nn = 0; nn < n; nn++) {', '   c[0][nn] = 1;', '   for (int kk = 1; kk <= nn; kk++) {', '    c[kk][nn] = mod(1L * c[kk][nn - 1] + c[kk - 1][nn - 1]);', '   }', '  }', '  int[][] sg = new int[(n + 1) / 2][n];', '  int[] a = new int[n + 1];', '  ', '  sg[0][0] = 1;', '  for (int nn = 1; nn <= n; nn++) {', '   a[nn] = mod(1L * nn * sg[(nn - 1) / 2][nn - 1]);', '   if (nn < sg.length) {', '    for (int i = 0; i < n; i++) {', '     int mult = 1;', '     sg[nn][i] = mod(sg[nn][i] + 1L * sg[nn - 1][i]);', '     for (int j = 1; i + nn * j < n; j++) {', '      mult = mod(1L * mult * a[nn]);', '      mult = mod(1L * mult * nn);', '      mult = mod(1L * mult * c[nn - 1][nn * j - 1]);', '      int addmult = mod(1L * c[nn * j][i + nn * j] * mult);', '      sg[nn][i + nn * j] = mod(sg[nn][i + nn * j] + 1L * sg[nn - 1][i] * addmult);', '     }', '    }', '   }', '  }', '  out.println(a[n]);', ' }', '', ' private int mod(long x) {', '  return (int) (x % m);', ' }', '', ' @Override', ' public void run() {', '  try {', '   solve();', '  } catch (Throwable e) {', '   e.printStackTrace();', '   System.exit(1);', '  } finally {', '   out.close();', '  }', ' }', ' ', ' private int nextInt() throws IOException {', '  return Integer.parseInt(next());', ' }', ' ', ' private String next() throws IOException {', '  while (!st.hasMoreTokens()) {', '   String line = in.readLine();', '   if (line == null) {', '    return null;', '   }', '   st = new StringTokenizer(line);', '  }', '  return st.nextToken();', ' }', ' ', ' public Solution(String filename) {', '//  try {', '   in = new BufferedReader(new InputStreamReader(System.in));', '//   in = new BufferedReader(new FileReader(filename + "".in""));', '   st = new StringTokenizer("""");', '   out = new PrintWriter(System.out);', '//   out = new PrintWriter(new FileWriter(filename + "".out""));', '//  } catch (IOException e) {', '//   e.printStackTrace();', '//   System.exit(1);', '//  }', ' }', ' ', ' public static void main(String[] args) {', '  Locale.setDefault(Locale.US);', '  new Solution(""data"").run();', ' }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '    FastScanner in;', '    PrintWriter out;', '', '    void solve() {', '        int n = in.nextInt();', '        int p = in.nextInt();', '        int[][] c = new int[n + 1][n + 1];', '        c[0][0] = 1;', '        for (int i = 1; i <= n; i++) {', '            c[i][0] = 1;', '            for (int j = 1; j <= n; j++) {', '                c[i][j] = c[i - 1][j - 1] + c[i - 1][j];', '                if (c[i][j] >= p) {', '                    c[i][j] -= p;', '                }', '            }', '        }', '        long[] dpSum = new long[n + 1];', '        long[] ans = new long[n + 1];', '        long[] dpBad = new long[n + 1];', '        dpSum[0] = 1;', '        for (int sz = 1; sz <= n; sz++) {', '            for (int big = (1 + sz) / 2; big < sz; big++) {', '                dpBad[sz] += dpSum[sz - 1 - big] * ans[big] % p * big % p', '                        * c[sz - 1][big] % p;', '            }', '            dpBad[sz] %= p;', '            ans[sz] = (dpSum[sz - 1] - dpBad[sz] + p) * sz % p;', '            for (int size1 = 1; size1 <= sz; size1++) {', '                dpSum[sz] += ans[size1] * size1 % p * c[sz - 1][size1 - 1] % p', '                        * dpSum[sz - size1] % p;', '            }', '            dpSum[sz] %= p;', '        }', '        out.println(ans[n]);', '    }', '', '    void run() {', '        try {', '            in = new FastScanner(new File(""object.in""));', '            out = new PrintWriter(new File(""object.out""));', '', '            solve();', '', '            out.close();', '        } catch (FileNotFoundException e) {', '            e.printStackTrace();', '        }', '    }', '', '    void runIO() {', '', '        in = new FastScanner(System.in);', '        out = new PrintWriter(System.out);', '', '        solve();', '', '        out.close();', '    }', '', '    class FastScanner {', '        BufferedReader br;', '        StringTokenizer st;', '', '        public FastScanner(File f) {', '            try {', '                br = new BufferedReader(new FileReader(f));', '            } catch (FileNotFoundException e) {', '                e.printStackTrace();', '            }', '        }', '', '        public FastScanner(InputStream f) {', '            br = new BufferedReader(new InputStreamReader(f));', '        }', '', '        String next() {', '            while (st == null || !st.hasMoreTokens()) {', '                String s = null;', '                try {', '                    s = br.readLine();', '                } catch (IOException e) {', '                    e.printStackTrace();', '                }', '                if (s == null)', '                    return null;', '                st = new StringTokenizer(s);', '            }', '            return st.nextToken();', '        }', '', '        boolean hasMoreTokens() {', '            while (st == null || !st.hasMoreTokens()) {', '                String s = null;', '                try {', '                    s = br.readLine();', '                } catch (IOException e) {', '                    e.printStackTrace();', '                }', '                if (s == null)', '                    return false;', '                st = new StringTokenizer(s);', '            }', '            return true;', '        }', '', '        int nextInt() {', '            return Integer.parseInt(next());', '        }', '', '        long nextLong() {', '            return Long.parseLong(next());', '        }', '', '        double nextDouble() {', '            return Double.parseDouble(next());', '        }', '    }', '', '    public static void main(String[] args) {', '        new Solution().runIO();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '  private static InputReader in;', '  private static PrintWriter out;', '  public static long mod = 1000000007;', '  public static long INV4 = pow(new Complex(4,0), mod-2).a;', '  ', '  static class Complex {', '    public long a,b;', '    public Complex(long a, long b) {', '      this.a = a;', '      this.b = b;', '      if (a < 0) a += mod;', '     ', '    }', '    ', '    public Complex multiply(Complex other) {', '      return new Complex((a * other.a + mod - (b * other.b % mod)) % mod, (a * other.b + b * other.a) % mod);', '    }', '  }', '  ', '  public static Complex pow(Complex a, long e) {', '    Complex r = new Complex(1,0);', '    while(e>0) {', '      if ((e&1)==1) r = r.multiply(a);', '      a = a.multiply(a);', '      e >>= 1;', '    }', '    return r;', '  }', '  ', '  public static long nways(long x) {', '    Complex s1 = pow(new Complex(1, 1), x);', '    Complex s2 = pow(new Complex(1, mod - 1), x);', '    Complex s3 = pow(new Complex(2, 0), x);', '    long res = (s3.a + s1.a + s2.a) % mod;', '    return res * INV4 % mod;', '  }', '', '  public static void main(String[] args) throws IOException {', '    in = new InputReader(System.in);', '    out = new PrintWriter(System.out, true);', '', '    int n = in.nextInt();', '    int k = in.nextInt();', '    long[] dp = new long[k+1];', '    dp[0] = 1;', '    for (int i = 0; i < n; i++) {', '      long m = nways(in.nextInt());', '      long[] next = new long[k+1];', '      System.arraycopy(dp, 0, next, 0, k+1);', '      for (int j = 0; j < k; j++) {', '        next[j+1] = (next[j+1] + dp[j] * m) % mod;', '      }', '      dp = next;', '    }', '    out.println(dp[k]);', '    out.close();', '    System.exit(0);', '  }', '', '  static class InputReader {', '    public BufferedReader reader;', '    public StringTokenizer tokenizer;', '', '    public InputReader(InputStream stream) {', '      reader = new BufferedReader(new InputStreamReader(stream), 32768);', '      tokenizer = null;', '    }', '', '    public String next() {', '      while (tokenizer == null || !tokenizer.hasMoreTokens()) {', '        try {', '          tokenizer = new StringTokenizer(reader.readLine());', '        } catch (IOException e) {', '          throw new RuntimeException(e);', '        }', '      }', '      return tokenizer.nextToken();', '    }', '', '    public int nextInt() {', '      return Integer.parseInt(next());', '    }', '  }', '', '', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '  private static InputReader in;', '  private static PrintWriter out;', '  public static long mod = 1000000007;', '  public static long INV4 = pow(new Complex(4,0), mod-2).a;', '  ', '  static class Complex {', '    public long a,b;', '    public Complex(long a, long b) {', '      this.a = a;', '      this.b = b;', '      if (a < 0) a += mod;', '     ', '    }', '    ', '    public Complex multiply(Complex other) {', '      return new Complex((a * other.a + mod - (b * other.b % mod)) % mod, (a * other.b + b * other.a) % mod);', '    }', '  }', '  ', '  public static Complex pow(Complex a, long e) {', '    Complex r = new Complex(1,0);', '    while(e>0) {', '      if ((e&1)==1) r = r.multiply(a);', '      a = a.multiply(a);', '      e >>= 1;', '    }', '    return r;', '  }', '  ', '  public static long nways(long x) {', '    Complex s1 = pow(new Complex(1, 1), x);', '    Complex s2 = pow(new Complex(1, mod - 1), x);', '    Complex s3 = pow(new Complex(2, 0), x);', '    long res = (s3.a + s1.a + s2.a) % mod;', '    return res * INV4 % mod;', '  }', '', '  public static void main(String[] args) throws IOException {', '    in = new InputReader(System.in);', '    out = new PrintWriter(System.out, true);', '', '    int n = in.nextInt();', '    int k = in.nextInt();', '    long[] dp = new long[k+1];', '    dp[0] = 1;', '    for (int i = 0; i < n; i++) {', '      long m = nways(in.nextInt());', '      long[] next = new long[k+1];', '      System.arraycopy(dp, 0, next, 0, k+1);', '      for (int j = 0; j < k; j++) {', '        next[j+1] = (next[j+1] + dp[j] * m) % mod;', '      }', '      dp = next;', '    }', '    out.println(dp[k]);', '    out.close();', '    System.exit(0);', '  }', '', '  static class InputReader {', '    public BufferedReader reader;', '    public StringTokenizer tokenizer;', '', '    public InputReader(InputStream stream) {', '      reader = new BufferedReader(new InputStreamReader(stream), 32768);', '      tokenizer = null;', '    }', '', '    public String next() {', '      while (tokenizer == null || !tokenizer.hasMoreTokens()) {', '        try {', '          tokenizer = new StringTokenizer(reader.readLine());', '        } catch (IOException e) {', '          throw new RuntimeException(e);', '        }', '      }', '      return tokenizer.nextToken();', '    }', '', '    public int nextInt() {', '      return Integer.parseInt(next());', '    }', '  }', '', '', '}']"
"['import java.io.*;', 'import java.util.Arrays;', '', 'public class Solution {', '', '    static final long MOD = 1000000009;', '    static final int MAXK = 26;', '    static final int MAXN = 100000;', '', '    static long modPow(long x, long pow) {', '        long r = 1;', '        while (pow > 0) {', '            if (pow % 2 == 1) {', '                r = r * x % MOD;', '            }', '            pow /= 2;', '            x = x * x % MOD;', '        }', '        return r;', '    }', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        long[][] c = new long[MAXK + 1][MAXK + 1];', '        for (int i = 0; i < c.length; ++i) {', '            for (int j = 1; j < i; ++j) {', '                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;', '            }', '            c[i][0] = c[i][i] = 1;', '        }', '        long[][] d = new long[MAXK + 1][MAXN + 1];', '        for (int j = 1; j <= MAXK; ++j) {', '            d[j][0] = 1;', '        }', '        for (int i = 1; i <= MAXN; ++i) {', '            for (int j = 1; j <= MAXK; ++j) {', '                d[j][i] = (d[j][i - 1] * j + (i % 2 == 0 ? MOD - d[j][i / 2] : 0)) % MOD;', '            }', '        }', '        for (int i = 1; i <= MAXN; ++i) {', '            for (int j = 1; j <= MAXK; ++j) {', '                d[j][i] = (modPow(j, i) + MOD - d[j][i]) % MOD;', '                for (int j1 = 1; j1 < j; ++j1) {', '                    d[j][i] = (d[j][i] + (MOD - c[j][j1]) * d[j1][i]) % MOD;', '                }', '            }', '        }', '        int tests = in.nextInt();', '        for (int test = 0; test < tests; ++test) {', '            int n = in.nextInt();', '            int k = in.nextInt();', '            out.println(d[k][n] * c[MAXK][k] % MOD);', '        }', '    }', '', '    public static void main(String[] args) throws IOException {', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']","['import java.util.Scanner;', '', 'public class DortmundDilemma {', '  public static final int MAX_N = 100000;', '  public static final int MAX_K = 26;', '  public static final long MOD = 1000000009;', '', '  static long[][] C;', '', '  static long[][] F;', '', '  static long[][] G;', '  static long[][] P;', '', '  public static void main(String[] args) {', '    C = new long[MAX_K+1][MAX_K+1];', '    for (int i = 0; i <= MAX_K; i++) {', '      C[i][0] = C[i][i] = 1;', '      for (int j = 1; j < i; j++) {', '        C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;', '      }', '    }', '', '    F = new long[MAX_N+1][MAX_K+1];', '    G = new long[MAX_N+1][MAX_K+1];', '    P = new long[MAX_N+1][MAX_K+1];', '    for (int k = 1; k <= MAX_K; k++) {', '      F[1][k] = k;', '      long kn = k;', '', '      for (int n = 2; n <= MAX_N; n++) {', '        kn = kn * k % MOD;', '        if (n % 2 == 1) {', '          F[n][k] = F[n-1][k] * k % MOD;', '        } else {', '          F[n][k] = (F[n-1][k] * k % MOD - F[n/2][k] + MOD) % MOD;', '        }', '        G[n][k] = (kn - F[n][k] + MOD) % MOD;', '        P[n][k] = G[n][k];', '        for (int j = 1; j < k; j++) {', '          P[n][k] = (P[n][k] - P[n][j] * C[k][j] % MOD + MOD) % MOD;', '        }', '      }', '    }', '', '    Scanner scanner = new Scanner(System.in);', '    for (int t = scanner.nextInt(); t > 0; t--) {', '      int N = scanner.nextInt(), K = scanner.nextInt();', '      System.out.println(P[N][K] * C[26][K] % MOD);', '    }', '    scanner.close();', '  }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.Comparator;', 'import java.util.InputMismatchException;', '', 'public class E {', '    InputStream is;', '    PrintWriter out;', '    String INPUT = """";', '    ', '    static long I = 2000000000_000000000L;', '    ', '    void solve()', '    {', '        int n = ni();', '        long K = nl();', '        int[] a = na(n);', '        int[] b = Arrays.copyOf(a, n);', '        for(int i = 0;i < n;i++)b[i] = n-a[n-1-i];', '        b = shrink(b);', '//        for(int i = 0;i < n;i++)b[i]++;', '        ', '        SegmentTreeRMQSumWhenMax st = new SegmentTreeRMQSumWhenMax(n+5);', '        st.updateOrAdd(0, 0, 1); // shifted by 1', '        int[] maxs = new int[n+1];', '        long[] counts = new long[n+1];', '        double[] cx = new double[n+1];', '        for(int i = 0;i < n;i++){', '            int max = st.maxx(0, b[i]+1); // <=a[i]', '            maxs[i] = max;', '            if(st.gwd >= I)st.gw = I;', '            counts[i] = st.gw;', '            cx[i] = st.gwd;', '            st.updateOrAdd(b[i]+1, max+1, st.gw);', '        }', '        int max = st.maxx(0, n+1); // <=a[i]', '        maxs[n] = max;', '        counts[n] = st.gw;', '        cx[n] = st.gwd;', '        if(cx[n] <= 2E18 && K > counts[n]){', '            out.println(-1);', '            return;', '        }', '        int lis = maxs[n];', '        int[][] g = makeBuckets(maxs, lis);', '        for(int i = 0;i < n+1;i++){', '            if(cx[i] >= 2E18){', '                counts[i] = I;', '            }', '        }', '        ', '        long[] ft = new long[n+3];', '        double[] ftd = new double[n+3];', '        addFenwick(ft, 0, 1);', '        addFenwick(ftd, 0, 1);', '        int[] ret = new int[lis];', '        int[] prevs = new int[n];', '        long[] pvs = new long[n];', '        int pp = 0;', '        prevs[pp] = 0; pvs[pp] = 1; pp++;', '        for(int h = lis-1;h >= 0;h--){', '            long[][] temps = new long[g[h].length][];', '            int p = 0;', '            for(int i : g[h]){', '                int ind = n-1-i;', '                if(h < lis-1 && a[ind] <= ret[lis-(h+1)-1])continue;', '                long sum = sumFenwick(ft, ind+1);', '                double sumd = sumFenwick(ftd, ind+1);', '                if(sumd >= I)sum = I;', '                long cc = sum*counts[i];', '                double cd = (double)counts[i]*sum;', '                if(cd > 2E18){', '                    cc = I;', '                }', '                temps[p++] = new long[]{a[ind], cc, sum, ind+1};', '            }', '            for(int j = 0;j < pp;j++){', '                addFenwick(ft, prevs[j], -pvs[j]);', '                addFenwick(ftd, prevs[j], -pvs[j]);', '            }', '            ', '            // 1 4 5 3 5', '            Arrays.sort(temps, 0, p, new Comparator<long[]>() {', '                public int compare(long[] a, long[] b) {', '                    return Long.compare(a[0], b[0]);', '                }', '            });', '//            tr(""temps"", temps);', '            for(int i = 0;i < p;){', '                int j = i;', '                while(j < p && temps[j][0] == temps[i][0])j++;', '                long lnum = 0;', '                for(int k = i;k < j;k++){', '                    lnum += temps[k][1];', '                    if(lnum >= I)lnum = I;', '                }', '                if(K - lnum <= 0){', '                    ret[lis-h-1] = (int)temps[i][0];', '                    break;', '                }else{', '                    K -= lnum;', '                }', '                i = j;', '            }', '            pp = 0;', '            for(int i = 0;i < p;i++){', '                long[] t = temps[i];', '                if(t[0] == ret[lis-h-1]){', '//                    tr(""add"", t);', '                    addFenwick(ft, (int)t[3], t[2]);', '                    addFenwick(ftd, (int)t[3], t[2]);', '                    prevs[pp] = (int)t[3]; pvs[pp] = t[2]; pp++;', '                }', '            }', '        }', '//        tr(g);', '        ', '//        tr(maxs);', '//        tr(counts);', '        for(int i = 0;i < lis;i++){', '            out.print(ret[i] + "" "");', '        }', '        out.println();', '//        tr(K);', '    }', '    ', '    public static long sumFenwick(long[] ft, int i)', '    {', '        long sum = 0;', '        for(i++;i > 0;i -= i&-i){', '            sum += ft[i];', '        }', '        return sum;', '    }', '    ', '    public static void addFenwick(long[] ft, int i, long v)', '    {', '        if(v == 0)return;', '        int n = ft.length;', '        for(i++;i < n;i += i&-i)ft[i] += v;', '    }', '', '    public static double sumFenwick(double[] ft, int i)', '    {', '        double sum = 0;', '        for(i++;i > 0;i -= i&-i){', '            sum += ft[i];', '        }', '        return sum;', '    }', '    ', '    public static void addFenwick(double[] ft, int i, double v)', '    {', '        if(v == 0)return;', '        int n = ft.length;', '        for(i++;i < n;i += i&-i)ft[i] += v;', '    }', '', '    ', '    public static int[][] makeBuckets(int[] a, int sup)', '    {', '        int n = a.length;', '        int[][] bucket = new int[sup+1][];', '        int[] bp = new int[sup+1];', '        for(int i = 0;i < n;i++)bp[a[i]]++;', '        for(int i = 0;i <= sup;i++)bucket[i] = new int[bp[i]];', '        for(int i = n-1;i >= 0;i--)bucket[a[i]][--bp[a[i]]] = i;', '        return bucket;', '    }', '', '    ', '    public static int[] shrink(int[] a) {', '        int n = a.length;', '        long[] b = new long[n];', '        for (int i = 0; i < n; i++)', '            b[i] = (long) a[i] << 32 | i;', '        Arrays.sort(b);', '        int[] ret = new int[n];', '        int p = 0;', '        for (int i = 0; i < n; i++) {', '            if (i > 0 && (b[i] ^ b[i - 1]) >> 32 != 0)', '                p++;', '            ret[(int) b[i]] = p;', '        }', '        return ret;', '    }', '    ', '    private static class SegmentTreeRMQSumWhenMax {', '        public int M, H, N;', '        public int[] st;', '        public long[] w;', '        public double[] wd;', '        ', '        public SegmentTreeRMQSumWhenMax(int n)', '        {', '            N = n;', '            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;', '            H = M>>>1;', '            st = new int[M];', '            w = new long[M];', '            wd = new double[M];', '            Arrays.fill(st, 0, M, Integer.MIN_VALUE);', '        }', '        ', '        // if x equals to before st[H+pos], +y, else update y', '        public void updateOrAdd(int pos, int x, long y)', '        {', '            if(x < st[H+pos])throw new RuntimeException(""x < st[H+pos]"");', '            if(x == st[H+pos]){', '                w[H+pos] += y;', '                wd[H+pos] += y;', '            }else{', '                st[H+pos] = x;', '                w[H+pos] = y; // y % mod', '                wd[H+pos] = y; // y % mod', '            }', '            for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);', '        }', '        ', '        private void propagate(int i)', '        {', '            if(st[2*i] < st[2*i+1]){', '                st[i] = st[2*i+1];', '                w[i] = w[2*i+1];', '                wd[i] = wd[2*i+1];', '            }else if(st[2*i] > st[2*i+1]){', '                st[i] = st[2*i];', '                w[i] = w[2*i];', '                wd[i] = wd[2*i];', '            }else{', '                st[i] = st[2*i];', '                w[i] = w[2*i] + w[2*i+1];', '                wd[i] = wd[2*i] + wd[2*i+1];', '            }', '        }', '        ', '        public long gw;', '        public double gwd;', '        ', '        public int maxx(int l, int r){', '            gw = 0;', '            gwd = 0.;', '            if(l >= r)return 0;', '            int max = Integer.MIN_VALUE;', '            while(l != 0){', '                int f = l&-l;', '                if(l+f > r)break;', '                int v = st[(H+l)/f];', '                if(v > max){', '                    max = v;', '                    gw = w[(H+l)/f];', '                    gwd = wd[(H+l)/f];', '                }else if(v == max){', '                    gw += w[(H+l)/f];', '                    gwd += wd[(H+l)/f];', '                }', '                l += f;', '            }', '            ', '            while(l < r){', '                int f = r&-r;', '                int v = st[(H+r)/f-1];', '                if(v > max){', '                    max = v;', '                    gw = w[(H+r)/f-1];', '                    gwd = wd[(H+r)/f-1];', '                }else if(v == max){', '                    gw += w[(H+r)/f-1];', '                    gwd += wd[(H+r)/f-1];', '                }', '                r -= f;', '            }', '            return max;', '        }', '    }', '    ', '    void run() throws Exception', '    {', '        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        long s = System.currentTimeMillis();', '        solve();', '        out.flush();', '        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', '    }', '    ', '    public static void main(String[] args) throws Exception { new E().run(); }', '    ', '    private byte[] inbuf = new byte[1024];', '    private int lenbuf = 0, ptrbuf = 0;', '    ', '    private int readByte()', '    {', '        if(lenbuf == -1)throw new InputMismatchException();', '        if(ptrbuf >= lenbuf){', '            ptrbuf = 0;', '            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '            if(lenbuf <= 0)return -1;', '        }', '        return inbuf[ptrbuf++];', '    }', '    ', '    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', '    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', '    ', '    private double nd() { return Double.parseDouble(ns()); }', '    private char nc() { return (char)skip(); }', '    ', '    private String ns()', '    {', '        int b = skip();', '        StringBuilder sb = new StringBuilder();', ""        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '            sb.appendCodePoint(b);', '            b = readByte();', '        }', '        return sb.toString();', '    }', '    ', '    private char[] ns(int n)', '    {', '        char[] buf = new char[n];', '        int b = skip(), p = 0;', '        while(p < n && !(isSpaceChar(b))){', '            buf[p++] = (char)b;', '            b = readByte();', '        }', '        return n == p ? buf : Arrays.copyOf(buf, p);', '    }', '    ', '    private char[][] nm(int n, int m)', '    {', '        char[][] map = new char[n][];', '        for(int i = 0;i < n;i++)map[i] = ns(m);', '        return map;', '    }', '    ', '    private int[] na(int n)', '    {', '        int[] a = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        return a;', '    }', '    ', '    private int ni()', '    {', '        int num = 0, b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private long nl()', '    {', '        long num = 0;', '        int b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.Comparator;', 'import java.util.InputMismatchException;', '', 'public class E {', '    InputStream is;', '    PrintWriter out;', '    String INPUT = """";', '    ', '    static long I = 2000000000_000000000L;', '    ', '    void solve()', '    {', '        int n = ni();', '        long K = nl();', '        int[] a = na(n);', '        int[] b = Arrays.copyOf(a, n);', '        for(int i = 0;i < n;i++)b[i] = n-a[n-1-i];', '        b = shrink(b);', '', '        ', '        SegmentTreeRMQSumWhenMax st = new SegmentTreeRMQSumWhenMax(n+5);', '        st.updateOrAdd(0, 0, 1); ', '        int[] maxs = new int[n+1];', '        long[] counts = new long[n+1];', '        double[] cx = new double[n+1];', '        for(int i = 0;i < n;i++){', '            int max = st.maxx(0, b[i]+1); ', '            maxs[i] = max;', '            if(st.gwd >= I)st.gw = I;', '            counts[i] = st.gw;', '            cx[i] = st.gwd;', '            st.updateOrAdd(b[i]+1, max+1, st.gw);', '        }', '        int max = st.maxx(0, n+1);', '        maxs[n] = max;', '        counts[n] = st.gw;', '        cx[n] = st.gwd;', '        if(cx[n] <= 2E18 && K > counts[n]){', '            out.println(-1);', '            return;', '        }', '        int lis = maxs[n];', '        int[][] g = makeBuckets(maxs, lis);', '        for(int i = 0;i < n+1;i++){', '            if(cx[i] >= 2E18){', '                counts[i] = I;', '            }', '        }', '        ', '        long[] ft = new long[n+3];', '        double[] ftd = new double[n+3];', '        addFenwick(ft, 0, 1);', '        addFenwick(ftd, 0, 1);', '        int[] ret = new int[lis];', '        int[] prevs = new int[n];', '        long[] pvs = new long[n];', '        int pp = 0;', '        prevs[pp] = 0; pvs[pp] = 1; pp++;', '        for(int h = lis-1;h >= 0;h--){', '            long[][] temps = new long[g[h].length][];', '            int p = 0;', '            for(int i : g[h]){', '                int ind = n-1-i;', '                if(h < lis-1 && a[ind] <= ret[lis-(h+1)-1])continue;', '                long sum = sumFenwick(ft, ind+1);', '                double sumd = sumFenwick(ftd, ind+1);', '                if(sumd >= I)sum = I;', '                long cc = sum*counts[i];', '                double cd = (double)counts[i]*sum;', '                if(cd > 2E18){', '                    cc = I;', '                }', '                temps[p++] = new long[]{a[ind], cc, sum, ind+1};', '            }', '            for(int j = 0;j < pp;j++){', '                addFenwick(ft, prevs[j], -pvs[j]);', '                addFenwick(ftd, prevs[j], -pvs[j]);', '            }', '            ', '            ', '            Arrays.sort(temps, 0, p, new Comparator<long[]>() {', '                public int compare(long[] a, long[] b) {', '                    return Long.compare(a[0], b[0]);', '                }', '            });', '', '            for(int i = 0;i < p;){', '                int j = i;', '                while(j < p && temps[j][0] == temps[i][0])j++;', '                long lnum = 0;', '                for(int k = i;k < j;k++){', '                    lnum += temps[k][1];', '                    if(lnum >= I)lnum = I;', '                }', '                if(K - lnum <= 0){', '                    ret[lis-h-1] = (int)temps[i][0];', '                    break;', '                }else{', '                    K -= lnum;', '                }', '                i = j;', '            }', '            pp = 0;', '            for(int i = 0;i < p;i++){', '                long[] t = temps[i];', '                if(t[0] == ret[lis-h-1]){', '', '                    addFenwick(ft, (int)t[3], t[2]);', '                    addFenwick(ftd, (int)t[3], t[2]);', '                    prevs[pp] = (int)t[3]; pvs[pp] = t[2]; pp++;', '                }', '            }', '        }', '', '        for(int i = 0;i < lis;i++){', '            out.print(ret[i] + "" "");', '        }', '        out.println();', '    }', '    ', '    public static long sumFenwick(long[] ft, int i)', '    {', '        long sum = 0;', '        for(i++;i > 0;i -= i&-i){', '            sum += ft[i];', '        }', '        return sum;', '    }', '    ', '    public static void addFenwick(long[] ft, int i, long v)', '    {', '        if(v == 0)return;', '        int n = ft.length;', '        for(i++;i < n;i += i&-i)ft[i] += v;', '    }', '', '    public static double sumFenwick(double[] ft, int i)', '    {', '        double sum = 0;', '        for(i++;i > 0;i -= i&-i){', '            sum += ft[i];', '        }', '        return sum;', '    }', '    ', '    public static void addFenwick(double[] ft, int i, double v)', '    {', '        if(v == 0)return;', '        int n = ft.length;', '        for(i++;i < n;i += i&-i)ft[i] += v;', '    }', '', '    ', '    public static int[][] makeBuckets(int[] a, int sup)', '    {', '        int n = a.length;', '        int[][] bucket = new int[sup+1][];', '        int[] bp = new int[sup+1];', '        for(int i = 0;i < n;i++)bp[a[i]]++;', '        for(int i = 0;i <= sup;i++)bucket[i] = new int[bp[i]];', '        for(int i = n-1;i >= 0;i--)bucket[a[i]][--bp[a[i]]] = i;', '        return bucket;', '    }', '', '    ', '    public static int[] shrink(int[] a) {', '        int n = a.length;', '        long[] b = new long[n];', '        for (int i = 0; i < n; i++)', '            b[i] = (long) a[i] << 32 | i;', '        Arrays.sort(b);', '        int[] ret = new int[n];', '        int p = 0;', '        for (int i = 0; i < n; i++) {', '            if (i > 0 && (b[i] ^ b[i - 1]) >> 32 != 0)', '                p++;', '            ret[(int) b[i]] = p;', '        }', '        return ret;', '    }', '    ', '    private static class SegmentTreeRMQSumWhenMax {', '        public int M, H, N;', '        public int[] st;', '        public long[] w;', '        public double[] wd;', '        ', '        public SegmentTreeRMQSumWhenMax(int n)', '        {', '            N = n;', '            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;', '            H = M>>>1;', '            st = new int[M];', '            w = new long[M];', '            wd = new double[M];', '            Arrays.fill(st, 0, M, Integer.MIN_VALUE);', '        }', '        ', '       ', '        public void updateOrAdd(int pos, int x, long y)', '        {', '            if(x < st[H+pos])throw new RuntimeException(""x < st[H+pos]"");', '            if(x == st[H+pos]){', '                w[H+pos] += y;', '                wd[H+pos] += y;', '            }else{', '                st[H+pos] = x;', '                w[H+pos] = y; ', '                wd[H+pos] = y;', '            }', '            for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);', '        }', '        ', '        private void propagate(int i)', '        {', '            if(st[2*i] < st[2*i+1]){', '                st[i] = st[2*i+1];', '                w[i] = w[2*i+1];', '                wd[i] = wd[2*i+1];', '            }else if(st[2*i] > st[2*i+1]){', '                st[i] = st[2*i];', '                w[i] = w[2*i];', '                wd[i] = wd[2*i];', '            }else{', '                st[i] = st[2*i];', '                w[i] = w[2*i] + w[2*i+1];', '                wd[i] = wd[2*i] + wd[2*i+1];', '            }', '        }', '        ', '        public long gw;', '        public double gwd;', '        ', '        public int maxx(int l, int r){', '            gw = 0;', '            gwd = 0.;', '            if(l >= r)return 0;', '            int max = Integer.MIN_VALUE;', '            while(l != 0){', '                int f = l&-l;', '                if(l+f > r)break;', '                int v = st[(H+l)/f];', '                if(v > max){', '                    max = v;', '                    gw = w[(H+l)/f];', '                    gwd = wd[(H+l)/f];', '                }else if(v == max){', '                    gw += w[(H+l)/f];', '                    gwd += wd[(H+l)/f];', '                }', '                l += f;', '            }', '            ', '            while(l < r){', '                int f = r&-r;', '                int v = st[(H+r)/f-1];', '                if(v > max){', '                    max = v;', '                    gw = w[(H+r)/f-1];', '                    gwd = wd[(H+r)/f-1];', '                }else if(v == max){', '                    gw += w[(H+r)/f-1];', '                    gwd += wd[(H+r)/f-1];', '                }', '                r -= f;', '            }', '            return max;', '        }', '    }', '    ', '    void run() throws Exception', '    {', '        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        long s = System.currentTimeMillis();', '        solve();', '        out.flush();', '        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");', '    }', '    ', '    public static void main(String[] args) throws Exception { new E().run(); }', '    ', '    private byte[] inbuf = new byte[1024];', '    private int lenbuf = 0, ptrbuf = 0;', '    ', '    private int readByte()', '    {', '        if(lenbuf == -1)throw new InputMismatchException();', '        if(ptrbuf >= lenbuf){', '            ptrbuf = 0;', '            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '            if(lenbuf <= 0)return -1;', '        }', '        return inbuf[ptrbuf++];', '    }', '    ', '    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', '    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', '    ', '    private double nd() { return Double.parseDouble(ns()); }', '    private char nc() { return (char)skip(); }', '    ', '    private String ns()', '    {', '        int b = skip();', '        StringBuilder sb = new StringBuilder();', '        while(!(isSpaceChar(b))){ ', '            sb.appendCodePoint(b);', '            b = readByte();', '        }', '        return sb.toString();', '    }', '    ', '    private char[] ns(int n)', '    {', '        char[] buf = new char[n];', '        int b = skip(), p = 0;', '        while(p < n && !(isSpaceChar(b))){', '            buf[p++] = (char)b;', '            b = readByte();', '        }', '        return n == p ? buf : Arrays.copyOf(buf, p);', '    }', '    ', '    private char[][] nm(int n, int m)', '    {', '        char[][] map = new char[n][];', '        for(int i = 0;i < n;i++)map[i] = ns(m);', '        return map;', '    }', '    ', '    private int[] na(int n)', '    {', '        int[] a = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        return a;', '    }', '    ', '    private int ni()', '    {', '        int num = 0, b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private long nl()', '    {', '        long num = 0;', '        int b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        int MOD = 1000000007;', '        Scanner sc = new Scanner(System.in);', '        int n = sc.nextInt()+1;', '        int[] a = new int[n];', '        int prod = 1;', '        for (int i = 0; i < n-1; i++) {', '            a[i] = sc.nextInt();', '            prod *= a[i];', '        }', '        a[n-1] = 1;', '        BigInteger l = sc.nextBigInteger();', '        BigInteger r = sc.nextBigInteger();', '        int[][] dp = new int[n][prod*n];', '        for (int i = 0; i < n; i++) {', '            dp[i][0] = 1;', '        }', '        for (int i = 0; i < prod*n; i++) {', '            dp[0][i] = 0;', '        }', '        for (int i = 0; i < prod*n; i+=a[0]) {', '            dp[0][i] = 1;', '        }', '        for (int i = 1; i < n; i++) {', '            for (int j = 1; j < a[i]; j++) {', '                dp[i][j] = dp[i-1][j];', '            }', '            for (int j = a[i]; j < prod*n; j++) {', '                dp[i][j] = (dp[i-1][j]+dp[i][j-a[i]])%MOD;', '            }', '        }', '        int[][] diffs = new int[n][prod*n];', '        for (int i = 0; i < prod*n; i++) {', '            diffs[0][i] = dp[n-1][i];', '        }', '        for (int i = 1; i < n; i++) {', '            for (int j = prod*i; j < prod*n; j++) {', '                diffs[i][j] = (MOD+diffs[i-1][j]-diffs[i-1][j-prod])%MOD;', '            }', '        }', '        for (int i = 0; i < n-1; i++) {', '            for (int j = 0; j < prod; j++) {', '                diffs[n-1][i*prod+j] = diffs[n-1][(n-1)*prod+j];', '            }', '        }', '        for (int i = n-2; i >= 0; i--) {', '            for (int j = (i+1)*prod-1; j >= 0; j--) {', '                diffs[i][j] = (MOD+diffs[i][j+prod]-diffs[i+1][j+prod])%MOD;', '            }', '        }', '        String[][] multnum = {{""0"",""1""}, {""0"",""1"",""1""}, {""0"",""1"",""1"",""1""}, {""0"",""0"",""1"",""1"",""1""}, {""0"",""-1"",""0"",""1"",""1"",""1""}, {""0"",""0"",""-1"",""0"",""5"",""1"",""1""}, {""0"",""1"",""0"",""-1"",""0"",""1"",""1"",""1""}, {""0"",""0"",""1"",""0"",""-7"",""0"",""7"",""1"",""1""}, {""0"",""-1"",""0"",""2"",""0"",""-7"",""0"",""2"",""1"",""1""}, {""0"",""0"",""-3"",""0"",""1"",""0"",""-7"",""0"",""3"",""1"",""1""}, {""0"",""5"",""0"",""-1"",""0"",""1"",""0"",""-1"",""0"",""5"",""1"",""1""}};', '        String[][] multden = {{""1"",""1""}, {""1"",""2"",""2""}, {""1"",""6"",""2"",""3""}, {""1"",""1"",""4"",""2"",""4""}, {""1"",""30"",""1"",""3"",""2"",""5""}, {""1"",""1"",""12"",""1"",""12"",""2"",""6""}, {""1"",""42"",""1"",""6"",""1"",""2"",""2"",""7""}, {""1"",""1"",""12"",""1"",""24"",""1"",""12"",""2"",""8""}, {""1"",""30"",""1"",""9"",""1"",""15"",""1"",""3"",""2"",""9""}, {""1"",""1"",""20"",""1"",""2"",""1"",""10"",""1"",""4"",""2"",""10""}, {""1"",""66"",""1"",""2"",""1"",""1"",""1"",""1"",""1"",""6"",""2"",""11""}};', '        BigInteger[] lpows = new BigInteger[n+1];', '        BigInteger[] rpows = new BigInteger[n+1];', '        lpows[0] = BigInteger.ONE;', '        rpows[0] = BigInteger.ONE;', '        for (int i = 1; i <= n; i++) {', '            lpows[i] = lpows[i-1].multiply(l.subtract(BigInteger.ONE).divide(BigInteger.valueOf(prod)));', '            rpows[i] = rpows[i-1].multiply(r.divide(BigInteger.valueOf(prod)));', '        }', '        int lmod = l.subtract(BigInteger.ONE).mod(BigInteger.valueOf(prod)).intValue();', '        int rmod = r.mod(BigInteger.valueOf(prod)).intValue();', '        BigInteger[] lpolynums = new BigInteger[n];', '        BigInteger[] lpolydens = new BigInteger[n];', '        BigInteger[] rpolynums = new BigInteger[n];', '        BigInteger[] rpolydens = new BigInteger[n];', '        lpolynums[0] = BigInteger.valueOf(diffs[n-1][lmod]);', '        lpolydens[0] = BigInteger.ONE;', '        rpolynums[0] = BigInteger.valueOf(diffs[n-1][rmod]);', '        rpolydens[0] = BigInteger.ONE;', '        for (int i = 1; i < n; i++) {', '            lpolynums[i] = BigInteger.ZERO;', '            lpolydens[i] = BigInteger.ONE;', '            rpolynums[i] = BigInteger.ZERO;', '            rpolydens[i] = BigInteger.ONE;', '        }', '        for (int i = n-2; i >= 0; i--) {', '            BigInteger[] npnums = new BigInteger[n];', '            BigInteger[] npdens = new BigInteger[n];', '            BigInteger newnum;', '            BigInteger newden;', '            npnums[0] = BigInteger.valueOf(diffs[i][lmod]);', '            npdens[0] = BigInteger.ONE;', '            for (int j = 1; j < n; j++) {', '                npnums[j] = BigInteger.ZERO;', '                npdens[j] = BigInteger.ONE;', '            }', '            for (int j = 0; j < n-1; j++) {', '                if (lpolynums[j].compareTo(BigInteger.ZERO) > 0) {', '                    for (int k = 1; k <= j+1; k++) {', '                        newden = npdens[k].multiply(lpolydens[j].multiply(new BigInteger(multden[j][k])));', '                        newnum = npnums[k].multiply(lpolydens[j].multiply(new BigInteger(multden[j][k]))).add(lpolynums[j].multiply(new BigInteger(multnum[j][k])).multiply(npdens[k]));', '                        npnums[k] = newnum;', '                        npdens[k] = newden;', '                    }', '                }', '            }', '            for (int j = 0; j < n; j++) {', '                lpolynums[j] = npnums[j];', '                lpolydens[j] = npdens[j];', '            }', '            npnums[0] = BigInteger.valueOf(diffs[i][rmod]);', '            npdens[0] = BigInteger.ONE;', '            for (int j = 1; j < n; j++) {', '                npnums[j] = BigInteger.ZERO;', '                npdens[j] = BigInteger.ONE;', '            }', '            for (int j = 0; j < n-1; j++) {', '                if (rpolynums[j].compareTo(BigInteger.ZERO) > 0) {', '                    for (int k = 1; k <= j+1; k++) {', '                        newden = npdens[k].multiply(rpolydens[j].multiply(new BigInteger(multden[j][k])));', '                        newnum = npnums[k].multiply(rpolydens[j].multiply(new BigInteger(multden[j][k]))).add(rpolynums[j].multiply(new BigInteger(multnum[j][k])).multiply(npdens[k]));', '                        npnums[k] = newnum;', '                        npdens[k] = newden;', '                    }', '                }', '            }', '            for (int j = 0; j < n; j++) {', '                rpolynums[j] = npnums[j];', '                rpolydens[j] = npdens[j];', '            }', '        }', '        for (int i = 0; i < n; i++) {', '            BigInteger gcd = lpolynums[i].gcd(lpolydens[i]);', '            lpolynums[i] = lpolynums[i].divide(gcd);', '            lpolydens[i] = lpolydens[i].divide(gcd);', '            gcd = rpolynums[i].gcd(rpolydens[i]);', '            rpolynums[i] = rpolynums[i].divide(gcd);', '            rpolydens[i] = rpolydens[i].divide(gcd);', '        }', '        BigInteger answer = BigInteger.ZERO;', '        BigInteger tempnum = BigInteger.ZERO;', '        BigInteger tempden = BigInteger.ONE;', '        for (int i = 0; i < n; i++) {', '            BigInteger newden = tempden.multiply(rpolydens[i]);', '            BigInteger newnum = tempnum.multiply(rpolydens[i]).add(rpolynums[i].multiply(rpows[i]).multiply(tempden));', '            tempden = newden;', '            tempnum = newnum;', '        }', '        answer = answer.add(tempnum.divide(tempden));', '        tempnum = BigInteger.ZERO;', '        tempden = BigInteger.ONE;', '        for (int i = 0; i < n; i++) {', '            BigInteger newden = tempden.multiply(lpolydens[i]);', '            BigInteger newnum = tempnum.multiply(lpolydens[i]).add(lpolynums[i].multiply(lpows[i]).multiply(tempden));', '            tempden = newden;', '            tempnum = newnum;', '        }', '        answer = answer.subtract(tempnum.divide(tempden));', '        answer = answer.mod(BigInteger.valueOf(MOD));', '        System.out.println(answer);', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    static int MOD = 1000000007;', '    ', '    static int N;', '    static int[] arr;', '    static List<Integer> listS;', '    static int[] pSum;', '    static int[] frec;', '    static int sizePS;', '    static int maxS = 100010;', '    static int[][] memo = new int[60][maxS];', '    ', '    static void init() {', '        listS = new ArrayList<Integer>();', '        for (int s = 1; s < (1 << N); s++){ ', '            int x = 0;', '            for (int t = 0; t < N; t++) {', '                if ((s & (1 << t)) > 0) {', '                    x += arr[t];', '                }', '            }', '            listS.add(x);            ', '        }', '        Collections.sort(listS);', '        sizePS = listS.size();', '        pSum = new int[sizePS];', '        frec = new int[sizePS];', '        int last = listS.get(0);', '        pSum[0] = last;', '        frec[0] = 1;', '        int index = 0;', '        for(int k = 1;k < sizePS;k++) {', '            int next = listS.get(k);', '            if(next == last) {', '                frec[index]++;', '            } else {', '                last = next;', '                pSum[++index] = next;', '                frec[index] = 1;', '            }', '        }', '        sizePS = index+1;', '    }', '', '    static int countWays(long l, long r) {', '        init();', '        int aR = recCalc(r, 0);', '        memo = new int[60][maxS];', '        return (aR + MOD - recCalc(l-1, 0)) % MOD; ', '    }', '', '    private static int recCalc(long l, int pos) {', '        if(l == 0) {', '            return 0;', '        }', '        int ans = 0;', '        if((ans = memo[pos][(int) (l%maxS)]) >= 1) {', '            return ans-1;', '        }', '        ', '        ans = recCalc(l/2, pos+1);', '        for(int k = 0;k < sizePS;k++) {', '            int a = pSum[k];', '            if(l >= a) {', '                int pa = 1+recCalc((l-a)/2, pos+1);', '                ans = (int) ((ans + (long)frec[k] * pa) % MOD);', '            }else {', '                break;', '            }', '        }', '        memo[pos][(int) (l%maxS)] = ans+1;', '        return ans;', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '        N = scanner.nextInt();', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '        arr = new int[N];', '        String[] arrItems = scanner.nextLine().split("" "");', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '        for (int arrItr = 0; arrItr < N; arrItr++) {', '            int arrItem = Integer.parseInt(arrItems[arrItr]);', '            arr[arrItr] = arrItem;', '        }', '        String[] lr = scanner.nextLine().split("" "");', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])*"");', '        long l = Long.parseLong(lr[0]);', '        long r = Long.parseLong(lr[1]);', '        int result = countWays(l, r);', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '        bufferedWriter.close();', '        scanner.close();', '    }', '}']"
"['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    static HD[] hdds;', '    static Point[] points;', '    static int n, k;', '    static long[][] f;', '    static long[] g;', '    static long totalLength;', '    static SegmentTree stHD;', '    static PersistentSegmentTree pst;', '    static Vertex[] rootsPST;', '    static boolean dist;', '    static long[] prefR;', '    static long[] prefL;', '    static Calc calc;', '    ', '    static class HD {', '        int left, right, length;', '        Point pL, pR;', '        long mid;', '        int index;', '', '        public HD(int left, int right) {', '            boolean b = left > right;', '            this.left = b ? right : left;', '            this.right = b ? left : right;', '            mid = (left + right);', '            length = (this.right - this.left);', '        }', '', '        @Override', '        public String toString() {', '            return left + "" "" + right + "" "" + mid;', '        }', '    }', '', '    static class Point {', '        HD hd;', '        int point;', '        int sortIndex;', '', '        public Point(HD hd, boolean isLeft) {', '            this.hd = hd;', '            point = isLeft ? hd.left : hd.right;', '        }', '', '        @Override', '        public String toString() {', '            return hd.left + "" "" + hd.right + "" "" + point;', '        }', '    }', '', '    static interface Calc {', '        public long getW(int start, int end);', '    }', '', '    static class Pair {', '        int nL, nR;', '        long sumL, sumR;', '', '        public Pair(int nR, int nL, long sumR, long sumL) {', '            this.nR = nR;', '            this.nL = nL;', '            this.sumR = sumR;', '            this.sumL = sumL;', '        }', '    }', '', '    static class Node {', '', '        int[] valueSLe;', '        int[] valueSRi;', '        long[] sumParR;', '        long[] sumParL;', '        int size;', '        int nL, nR;', '', '        public Node() {', '        }', '    }', '', '    static class SegmentTree {', '', '        Node[] t;', '', '        SegmentTree(int n) {', '            t = new Node[4 * n];', '            for (int i = 0; i < 4 * n; i++) {', '                t[i] = new Node();', '            }', '        }', '', '        void build(HD[] a, int v, int tl, int tr) {', '            if (tl == tr) {', '                t[v].valueSLe = new int[1];', '                t[v].valueSRi = new int[1];', '                t[v].valueSRi[0] = a[tl + 1].pR.point;', '                t[v].valueSLe[0] = a[tl + 1].pL.point;', '                t[v].size = 1;', '                t[v].sumParL = new long[1];', '                t[v].sumParL[0] = a[tl + 1].left;', '                t[v].sumParR = new long[1];', '                t[v].sumParR[0] = a[tl + 1].right;', '            } else {', '                int tm = (tl + tr) / 2;', '                build(a, v * 2, tl, tm);', '                build(a, v * 2 + 1, tm + 1, tr);', '                t[v].size = t[v * 2].size + t[v * 2 + 1].size;', '                merge(v);', '            }', '        }', '', '        private void merge(int v) {', '            t[v].valueSLe = new int[t[v].size];', '            t[v].valueSRi = new int[t[v].size];', '            t[v].sumParL = new long[t[v].size];', '            t[v].sumParR = new long[t[v].size];', '            mergeAInt(t[v].valueSLe, t[2 * v].valueSLe, t[2 * v + 1].valueSLe);', '            mergeAInt(t[v].valueSRi, t[2 * v].valueSRi, t[2 * v + 1].valueSRi);', '            updateCS(t[v]);', '        }', '', '        private void updateCS(Node node) {', '            long[] sumParLu = new long[node.size];', '            long[] sumParRu = new long[node.size];', '            int[] valueL = node.valueSLe;', '            int[] valueR = node.valueSRi;', '            sumParLu[0] = valueL[0];', '            sumParRu[0] = valueR[0];', '            for (int i = 1; i < node.size; i++) {', '                sumParLu[i] = sumParLu[i - 1] + valueL[i];', '                sumParRu[i] = sumParRu[i - 1] + valueR[i];', '            }', '            node.sumParL = sumParLu;', '            node.sumParR = sumParRu;', '        }', '', '        static long[] ZERO = new long[] { 0, 0, 0, 0 };', '', '        void query(int v, int tl, int tr, int l, int r, int p, long[] fResults) {', '            if (l > r || tr < l || tl > r) {', '                return;', '            }', '            if (l == tl && tr == r) {', '                Node node = t[v];', '                int size = node.size;', '                long[] sPL = node.sumParL;', '                int limU = upperBound(node.valueSRi, p);', '                int limL = lowerBound(node.valueSLe, p);', '                int nR = limU == -1 ? 0 : limU + 1;', '                long sumR = limU == -1 ? 0 : node.sumParR[limU];', '                int nL = limL == size ? 0 : size - limL;', '                long sumL = limL == size ? 0 : sPL[size - 1] - (limL == 0 ? 0 : sPL[limL - 1]);', '                fResults[0] += nR;', '                fResults[1] += nL;', '                fResults[2] += sumR;', '                fResults[3] += sumL;', '                return;', '            }', '            int tm = (tl + tr) / 2;', '            query(v * 2, tl, tm, l, Math.min(r, tm), p, fResults);', '            query(v * 2 + 1, tm + 1, tr, Math.max(l, tm + 1), r, p, fResults);', '', '        }', '    }', '    ', '    static class Vertex {', '        Vertex l, r;', '        int count;', '', '        Vertex(int val) {', '            count = val;', '        }', '', '        Vertex(Vertex l, Vertex r) {', '            this.l = l;', '            this.r = r;', '            if (l != null)', '                count += l.count;', '            if (r != null)', '                count += r.count;', '        }', '    };', '    ', '    static class PersistentSegmentTree {', '        ', '        Vertex build(int tl, int tr) {', '            if (tl == tr) {', '                return new Vertex(0);', '            }', '            int tm = (tl + tr) / 2;', '            return new Vertex(build(tl, tm), build(tm + 1, tr));', '        }', '', '        Vertex update(Vertex v, int tl, int tr, int pos) {', '            if (tl == tr) {', '                return new Vertex(1);', '            }', '            int tm = (tl + tr) / 2;', '            if (pos <= tm) {', '                return new Vertex(update(v.l, tl, tm, pos), v.r);', '            } else {', '                return new Vertex(v.l, update(v.r, tm + 1, tr, pos));', '            }', '        }', '        ', '        int query(Vertex v1, Vertex v2, int b, int e, int x) {', '            if (b == e) {', '                return b;', '            }', '            int oo = v1.l.count - v2.l.count;', '            int mid = (b + e) / 2;', '            if (oo >= x) {', '                return query(v1.l, v2.l, b, mid, x);', '            } else {', '                return query(v1.r, v2.r, mid + 1, e, x - oo);', '            }', '        }', '    }', '', '    static void mergeAInt(int[] values, int[] values1, int[] values2) {', '        int n1 = values1.length;', '        int n2 = values2.length;', '        int i = 0, j = 0, k = 0;', '        while (i < n1 && j < n2) {', '            int p1 = values1[i];', '            int p2 = values2[j];', '            if (p1 <= p2) {', '                i++;', '                values[k++] = p1;', '            } else {', '                j++;', '                values[k++] = p2;', '            }', '        }', '        while (i < n1) {', '            values[k++] = values1[i++];', '        }', '        while (j < n2) {', '            values[k++] = values2[j++];', '        }', '    }', '', '    static private int upperBound(int[] arr, int endV) {', '        int left = 0;', '        int right = arr.length - 1;', '        while (left <= right) {', '            int mid = (right + left) / 2;', '            if (arr[mid] <= endV) {', '                left = mid + 1;', '            } else {', '                right = mid - 1;', '            }', '        }', '        return right;', '    }', '', '    static private int lowerBound(int[] arr, int startV) {', '        int left = 0;', '        int al = arr.length;', '        int right = al - 1;', '        while (left <= right) {', '            int mid = (right + left) / 2;', '            if (arr[mid] >= startV) {', '                right = mid - 1;', '            } else {', '                left = mid + 1;', '            }', '        }', '        return left;', '    }', '', '    private static void initW() {', '        f = new long[k + 1][n + 1];', '        g = new long[n + 2];        ', '        Arrays.sort(hdds, 1, n + 1, new Comparator<HD>() {', '            @Override', '            public int compare(HD o1, HD o2) {', '                long d = o1.mid - o2.mid;', '                if (d != 0) {', '                    return d < 0 ? -1 : 1;', '                } else {', '                    return o1.left - o2.left;', '                }', '            }', '        });', '        SASD sd = new SASD();', '        dist = true;', '        for (int j = 1; j <= n; j++) {', '            sd.add(hdds[j]);', '            f[1][j] = sd.ans;', '            if (j < n && hdds[j].right > hdds[j + 1].left) {', '                dist = false;', '            }', '        }', '        if (!dist) {', '            calc = new Calc() {', '                @Override', '                public long getW(int start, int end) {', '                    return getW1(start, end);                    ', '                }', '            };', '            Point[] pointsToSort = new Point[2 * n];', '            for (int j = 1; j <= n; j++) {', '                HD hd = hdds[j];', '                hd.index = j;', '                Point p = new Point(hd, true);', '                hd.pL = p;', '                pointsToSort[2 * j - 2] = p;', '                p = new Point(hd, false);', '                hd.pR = p;', '                pointsToSort[2 * j - 1] = p;', '            }            ', '            Arrays.sort(pointsToSort, 0, 2 * n, new Comparator<Point>() {', '                @Override', '                public int compare(Point o1, Point o2) {', '                    long d = o1.point - o2.point;', '                    if (d != 0) {', '                        return d < 0 ? -1 : 1;', '                    } else {', '                        return o1.hd.index - o2.hd.index;', '                    }', '                }', '            });', '            points = new Point[2 * n];', '            for (int j = 0; j < 2*n; j++) {', '                Point p = pointsToSort[j]; ', '                p.sortIndex = j;', '                points[j] = p;', '            }            ', '            stHD = new SegmentTree(n);', '            stHD.build(hdds, 1, 0, n - 1);', '            rootsPST = new Vertex[n+1];', '            pst = new PersistentSegmentTree();', '            rootsPST[0] = pst.build(0, 2*n-1);', '            for (int j = 1; j <= n; j++) {', '                Vertex root = pst.update(rootsPST[j-1], 0, 2*n-1, hdds[j].pL.sortIndex);', '                rootsPST[j] = pst.update(root, 0, 2*n-1, hdds[j].pR.sortIndex);', '            }            ', '        } else {', '            calc = new Calc() {', '                @Override', '                public long getW(int start, int end) {', '                    return getW2(start, end);', '                }', '            };', '            prefL = new long[n + 1];', '            prefR = new long[n + 1];', '            for (int j = 1; j <= n; j++) {', '                prefR[j] = prefR[j - 1] + hdds[j].right;', '                prefL[j] = prefL[j - 1] + hdds[j].left;', '            }', '        }', '    }', '', '', '    static Map<Integer, Long>[] memo;', '    private static long getW1(int jStart, int jEnd) {', '        Long ans = memo[jEnd].get(jStart);', '        if (ans != null) {', '            return ans;', '        }', '        int mid = pst.query(rootsPST[jEnd], rootsPST[jStart-1], 0, 2 * n - 1, jEnd-jStart+1);', '        int p = points[mid].point;', '        long[] pair = new long[4];', '        stHD.query(1, 0, n - 1, jStart - 1, jEnd - 1, p, pair);', '        ans = p * pair[0] - pair[2] + pair[3] - p * pair[1];', '        memo[jEnd].put(jStart, ans);', '        return ans;', '    }', '', '    private static long getW2(int jStart, int jEnd) {', '        int mid = (jStart + jEnd) / 2;', '        long p = hdds[mid].right;', '        long ans = p * (mid - jStart + 1) - (prefR[mid] - prefR[jStart - 1]) + (prefL[jEnd] - prefL[mid])', '                - p * (jEnd - mid);', '        return ans;', '    }', '', '    static int INF = 2000000000;', '', '    static class SASD {', '        int mid1 = -INF;', '        int mid2 = INF;', '        long ans;', '', '        private PriorityQueue<Integer> r = new PriorityQueue<Integer>();', '', '        void add(HD hd) {', '            int nLow = hd.left;', '            int nHigh = hd.right;', '            if (nLow >= mid2) {', '                ans += (nLow - mid2);', '                r.remove();', '                r.add(nLow);', '                r.add(nHigh);', '                mid1 = mid2;', '                mid2 = r.peek();', '            } else if (nLow < mid1) {', '                r.add(nHigh);', '            } else {', '                r.add(nHigh);', '                mid1 = nLow;', '                if (mid2 == INF) {', '                    mid2 = nHigh;', '                }', '                if (nHigh <= mid2) {', '                    mid2 = nHigh;', '                }', '            }', '        }', '    }', '', '    static class SADS {', '        int mid1 = -INF;', '        int mid2 = INF;', '        long ans;', '', '        private PriorityQueue<Integer> l = new PriorityQueue<Integer>(n, new Comparator<Integer>() {', '', '            @Override', '            public int compare(Integer o1, Integer o2) {', '                return o2 - o1;', '            }', '        });', '', '        void add(HD hd) {', '            int nLow = hd.left;', '            int nHigh = hd.right;', '            if (nHigh <= mid1) {', '                ans += (mid1 - nHigh);', '                l.remove();', '                l.add(nLow);', '                l.add(nHigh);', '                mid2 = mid1;', '                mid1 = l.peek();', '            } else if (nHigh > mid2) {', '                l.add(nLow);', '                if (nLow >= mid2) {', '                    ans += (nHigh - mid2);', '                }', '            } else {', '                l.add(nLow);', '                mid2 = nHigh;', '                if (mid1 == -INF) {', '                    mid1 = nLow;', '                }', '                if (nLow >= mid1) {', '                    mid1 = nLow;', '                }', '            }', '        }', '    }', '', '    //static int c = 0;', '    //static long time = 0;', '    static long hardDrive() {', '        if (k == n) {', '            return totalLength;', '        }', '        initW();', '        if (f[1][n] == 0) {', '            return totalLength;', '        }', '        int STEEP = 10;', '        SADS ds = new SADS();', '        long ans = f[1][n];', '        int minG = 1;', '        for (int s = n; s >= 1; s--) {', '            ds.add(hdds[s]);', '            g[s] = ds.ans;', '            long pAns = f[1][s - 1] + ds.ans;', '            if (pAns < ans) {', '                ans = pAns;', '                minG = s;', '            }', '        }', '        f[2][n] = ans;', '        if (k == 2) {', '            return 2 * ans + totalLength;', '        }', '        long fRMIN = 0;', '        int[] minAJ = new int[n + 1];', '        Arrays.fill(minAJ, 1);', '        for (int i = 2; i < k; i++) {', '            if (i == k - 1) {', '                ans = f[i - 1][n];', '                int lower = minG;', '                int higher = n;', '                if (higher > lower + STEEP) {', '                    Pair p = search(calc, i, n, lower, higher, STEEP);', '                    ans = p.sumR;', '                    lower = p.nR;', '                    higher = p.nL;', '                }', '                for (int s = lower; s <= higher; s++) {', '                    long pAns = f[i - 1][s - 1] + g[s];', '                    if (pAns < ans) {', '                        ans = pAns;', '                        minG = s;', '                    }', '                }', '                f[i][n] = ans;', '                fRMIN = ans;', '                int minG2 = n;', '                minG = minG > 1 ? minG - 1 : 1;', '                int fSteep = 100;', '                for (int j = minG; j <= minG2; j++) {', '                    ans = f[i - 1][j];', '                    lower = 1;', '                    higher = j;', '                    if (higher > lower + STEEP) {', '                        Pair p = search(calc, i, j, lower, higher, STEEP);', '                        ans = p.sumR;', '                        lower = p.nR;', '                        higher = p.nL;', '                    }', '                    if (f[i - 1][lower - 1] != f[i - 1][higher - 1]) {', '                        for (int s = lower; s <= higher; s++) {', '                            long pAns = f[i - 1][s - 1] + calc.getW(s, j);', '                            if (pAns < ans) {', '                                ans = pAns;', '                            }', '                        }', '                    } else {                        ', '                        ans = f[i - 1][higher - 1] + calc.getW(higher, j);', '                    }    ', '                    f[i][j] = ans;', '                    long pFA = ans + g[j + 1];', '                    if (pFA < fRMIN) {', '                        fRMIN = pFA;', '                    }', '                    if (ans >= fRMIN) {', '                        break;', '                    }', '                    if (j + fSteep <= minG2 && ans + g[j + fSteep] >= fRMIN) {', '                        j = j + fSteep;', '                    }', '                    while (j < minG2 &&  g[j+1] == g[j+2]) {', '                        j++;', '                    }', '                }', '            } else {', '                for (int j = i + 1; j < n; j++) {', '                    ans = f[i - 1][j];', '                    int nMin = minAJ[j];', '                    int lower = nMin;', '                    int higher = j;', '                    if (higher > lower + STEEP) {', '                        Pair p = search(calc, i, j, lower, higher, STEEP);', '                        ans = p.sumR;', '                        lower = p.nR;', '                        higher = p.nL;                        ', '                    }', '                    if (f[i - 1][lower - 1] != f[i - 1][higher - 1]) {', '                        for (int s = lower; s <= higher; s++) {', '                            long pAns = f[i - 1][s - 1] + calc.getW(s, j);', '                            if (pAns < ans) {', '                                ans = pAns;', '                                nMin = s;', '                            }', '                        }', '                    } else {                        ', '                        ans = f[i - 1][higher - 1] + calc.getW(higher, j);         ', '                    }', '                    f[i][j] = ans;', '                    minAJ[j] = nMin;', '                }', '            }', '        }', '        return 2 * fRMIN + totalLength;', '    }', '', '    static Pair search(Calc calc, int i, int j, int lower, int higher, int steep) {', '        long ans = 0;', '        while (higher > lower + steep) {', '            int mid = (lower + higher) / 2;', '            int mid1 = (lower + mid) / 2;', '            mid1 = mid1 % 2 == 0 ? mid1 : mid1 + 1;', '            int mid2 = (higher + mid) / 2;', '            mid2 = mid2 % 2 == 0 ? mid2 : mid2 - 1;', '            long res1 = f[i - 1][mid1 - 1] + calc.getW(mid1, j);', '            long res2 = f[i - 1][mid2 - 1] + calc.getW(mid2, j);', '            if (res1 < res2) {', '                higher = mid2 - 1;', '                ans = res1;', '            } else if (res1 >= res2) {', '                lower = mid1 + 1;', '                ans = res2;', '            }', '        }', '        return new Pair(lower, higher, ans, 0);', '    }', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 2 * 4096 * 4096);', '        String[] nk = reader.readLine().trim().split("" "");', '        n = Integer.parseInt(nk[0]);', '        k = Integer.parseInt(nk[1]);', '        hdds = new HD[n + 1];', '        totalLength = 0;', '        for (int hddsRowItr = 1; hddsRowItr <= n; hddsRowItr++) {', '            String[] hddsRowItems = reader.readLine().trim().split("" "");', '            HD hd = new HD(Integer.parseInt(hddsRowItems[0]), Integer.parseInt(hddsRowItems[1]));', '            hdds[hddsRowItr] = hd;', '            totalLength += hd.length;', '        }', '        memo = new Map[n+1];', '        for (int j = 1; j <= n; j++) {', '            memo[j] = new HashMap<Integer, Long>();', '        }', '        dist = true;', '        long result = hardDrive();', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '        bufferedWriter.close();', '        reader.close();', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    static HD[] hdds;', '    static Point[] points;', '    static int n, k;', '    static long[][] f;', '    static long[] g;', '    static long totalLength;', '    static SegmentTree stHD;', '    static PersistentSegmentTree pst;', '    static Vertex[] rootsPST;', '    static boolean dist;', '    static long[] prefR;', '    static long[] prefL;', '    static Calc calc;', '    ', '    static class HD {', '        int left, right, length;', '        Point pL, pR;', '        long mid;', '        int index;', '', '        public HD(int left, int right) {', '            boolean b = left > right;', '            this.left = b ? right : left;', '            this.right = b ? left : right;', '            mid = (left + right);', '            length = (this.right - this.left);', '        }', '', '        @Override', '        public String toString() {', '            return left + "" "" + right + "" "" + mid;', '        }', '    }', '', '    static class Point {', '        HD hd;', '        int point;', '        int sortIndex;', '', '        public Point(HD hd, boolean isLeft) {', '            this.hd = hd;', '            point = isLeft ? hd.left : hd.right;', '        }', '', '        @Override', '        public String toString() {', '            return hd.left + "" "" + hd.right + "" "" + point;', '        }', '    }', '', '    static interface Calc {', '        public long getW(int start, int end);', '    }', '', '    static class Pair {', '        int nL, nR;', '        long sumL, sumR;', '', '        public Pair(int nR, int nL, long sumR, long sumL) {', '            this.nR = nR;', '            this.nL = nL;', '            this.sumR = sumR;', '            this.sumL = sumL;', '        }', '    }', '', '    static class Node {', '', '        int[] valueSLe;', '        int[] valueSRi;', '        long[] sumParR;', '        long[] sumParL;', '        int size;', '        int nL, nR;', '', '        public Node() {', '        }', '    }', '', '    static class SegmentTree {', '', '        Node[] t;', '', '        SegmentTree(int n) {', '            t = new Node[4 * n];', '            for (int i = 0; i < 4 * n; i++) {', '                t[i] = new Node();', '            }', '        }', '', '        void build(HD[] a, int v, int tl, int tr) {', '            if (tl == tr) {', '                t[v].valueSLe = new int[1];', '                t[v].valueSRi = new int[1];', '                t[v].valueSRi[0] = a[tl + 1].pR.point;', '                t[v].valueSLe[0] = a[tl + 1].pL.point;', '                t[v].size = 1;', '                t[v].sumParL = new long[1];', '                t[v].sumParL[0] = a[tl + 1].left;', '                t[v].sumParR = new long[1];', '                t[v].sumParR[0] = a[tl + 1].right;', '            } else {', '                int tm = (tl + tr) / 2;', '                build(a, v * 2, tl, tm);', '                build(a, v * 2 + 1, tm + 1, tr);', '                t[v].size = t[v * 2].size + t[v * 2 + 1].size;', '                merge(v);', '            }', '        }', '', '        private void merge(int v) {', '            t[v].valueSLe = new int[t[v].size];', '            t[v].valueSRi = new int[t[v].size];', '            t[v].sumParL = new long[t[v].size];', '            t[v].sumParR = new long[t[v].size];', '            mergeAInt(t[v].valueSLe, t[2 * v].valueSLe, t[2 * v + 1].valueSLe);', '            mergeAInt(t[v].valueSRi, t[2 * v].valueSRi, t[2 * v + 1].valueSRi);', '            updateCS(t[v]);', '        }', '', '        private void updateCS(Node node) {', '            long[] sumParLu = new long[node.size];', '            long[] sumParRu = new long[node.size];', '            int[] valueL = node.valueSLe;', '            int[] valueR = node.valueSRi;', '            sumParLu[0] = valueL[0];', '            sumParRu[0] = valueR[0];', '            for (int i = 1; i < node.size; i++) {', '                sumParLu[i] = sumParLu[i - 1] + valueL[i];', '                sumParRu[i] = sumParRu[i - 1] + valueR[i];', '            }', '            node.sumParL = sumParLu;', '            node.sumParR = sumParRu;', '        }', '', '        static long[] ZERO = new long[] { 0, 0, 0, 0 };', '', '        void query(int v, int tl, int tr, int l, int r, int p, long[] fResults) {', '            if (l > r || tr < l || tl > r) {', '                return;', '            }', '            if (l == tl && tr == r) {', '                Node node = t[v];', '                int size = node.size;', '                long[] sPL = node.sumParL;', '                int limU = upperBound(node.valueSRi, p);', '                int limL = lowerBound(node.valueSLe, p);', '                int nR = limU == -1 ? 0 : limU + 1;', '                long sumR = limU == -1 ? 0 : node.sumParR[limU];', '                int nL = limL == size ? 0 : size - limL;', '                long sumL = limL == size ? 0 : sPL[size - 1] - (limL == 0 ? 0 : sPL[limL - 1]);', '                fResults[0] += nR;', '                fResults[1] += nL;', '                fResults[2] += sumR;', '                fResults[3] += sumL;', '                return;', '            }', '            int tm = (tl + tr) / 2;', '            query(v * 2, tl, tm, l, Math.min(r, tm), p, fResults);', '            query(v * 2 + 1, tm + 1, tr, Math.max(l, tm + 1), r, p, fResults);', '', '        }', '    }', '    ', '    static class Vertex {', '        Vertex l, r;', '        int count;', '', '        Vertex(int val) {', '            count = val;', '        }', '', '        Vertex(Vertex l, Vertex r) {', '            this.l = l;', '            this.r = r;', '            if (l != null)', '                count += l.count;', '            if (r != null)', '                count += r.count;', '        }', '    };', '    ', '    static class PersistentSegmentTree {', '        ', '        Vertex build(int tl, int tr) {', '            if (tl == tr) {', '                return new Vertex(0);', '            }', '            int tm = (tl + tr) / 2;', '            return new Vertex(build(tl, tm), build(tm + 1, tr));', '        }', '', '        Vertex update(Vertex v, int tl, int tr, int pos) {', '            if (tl == tr) {', '                return new Vertex(1);', '            }', '            int tm = (tl + tr) / 2;', '            if (pos <= tm) {', '                return new Vertex(update(v.l, tl, tm, pos), v.r);', '            } else {', '                return new Vertex(v.l, update(v.r, tm + 1, tr, pos));', '            }', '        }', '        ', '        int query(Vertex v1, Vertex v2, int b, int e, int x) {', '            if (b == e) {', '                return b;', '            }', '            int oo = v1.l.count - v2.l.count;', '            int mid = (b + e) / 2;', '            if (oo >= x) {', '                return query(v1.l, v2.l, b, mid, x);', '            } else {', '                return query(v1.r, v2.r, mid + 1, e, x - oo);', '            }', '        }', '    }', '', '    static void mergeAInt(int[] values, int[] values1, int[] values2) {', '        int n1 = values1.length;', '        int n2 = values2.length;', '        int i = 0, j = 0, k = 0;', '        while (i < n1 && j < n2) {', '            int p1 = values1[i];', '            int p2 = values2[j];', '            if (p1 <= p2) {', '                i++;', '                values[k++] = p1;', '            } else {', '                j++;', '                values[k++] = p2;', '            }', '        }', '        while (i < n1) {', '            values[k++] = values1[i++];', '        }', '        while (j < n2) {', '            values[k++] = values2[j++];', '        }', '    }', '', '    static private int upperBound(int[] arr, int endV) {', '        int left = 0;', '        int right = arr.length - 1;', '        while (left <= right) {', '            int mid = (right + left) / 2;', '            if (arr[mid] <= endV) {', '                left = mid + 1;', '            } else {', '                right = mid - 1;', '            }', '        }', '        return right;', '    }', '', '    static private int lowerBound(int[] arr, int startV) {', '        int left = 0;', '        int al = arr.length;', '        int right = al - 1;', '        while (left <= right) {', '            int mid = (right + left) / 2;', '            if (arr[mid] >= startV) {', '                right = mid - 1;', '            } else {', '                left = mid + 1;', '            }', '        }', '        return left;', '    }', '', '    private static void initW() {', '        f = new long[k + 1][n + 1];', '        g = new long[n + 2];        ', '        Arrays.sort(hdds, 1, n + 1, new Comparator<HD>() {', '            @Override', '            public int compare(HD o1, HD o2) {', '                long d = o1.mid - o2.mid;', '                if (d != 0) {', '                    return d < 0 ? -1 : 1;', '                } else {', '                    return o1.left - o2.left;', '                }', '            }', '        });', '        SASD sd = new SASD();', '        dist = true;', '        for (int j = 1; j <= n; j++) {', '            sd.add(hdds[j]);', '            f[1][j] = sd.ans;', '            if (j < n && hdds[j].right > hdds[j + 1].left) {', '                dist = false;', '            }', '        }', '        if (!dist) {', '            calc = new Calc() {', '                @Override', '                public long getW(int start, int end) {', '                    return getW1(start, end);                    ', '                }', '            };', '            Point[] pointsToSort = new Point[2 * n];', '            for (int j = 1; j <= n; j++) {', '                HD hd = hdds[j];', '                hd.index = j;', '                Point p = new Point(hd, true);', '                hd.pL = p;', '                pointsToSort[2 * j - 2] = p;', '                p = new Point(hd, false);', '                hd.pR = p;', '                pointsToSort[2 * j - 1] = p;', '            }            ', '            Arrays.sort(pointsToSort, 0, 2 * n, new Comparator<Point>() {', '                @Override', '                public int compare(Point o1, Point o2) {', '                    long d = o1.point - o2.point;', '                    if (d != 0) {', '                        return d < 0 ? -1 : 1;', '                    } else {', '                        return o1.hd.index - o2.hd.index;', '                    }', '                }', '            });', '            points = new Point[2 * n];', '            for (int j = 0; j < 2*n; j++) {', '                Point p = pointsToSort[j]; ', '                p.sortIndex = j;', '                points[j] = p;', '            }            ', '            stHD = new SegmentTree(n);', '            stHD.build(hdds, 1, 0, n - 1);', '            rootsPST = new Vertex[n+1];', '            pst = new PersistentSegmentTree();', '            rootsPST[0] = pst.build(0, 2*n-1);', '            for (int j = 1; j <= n; j++) {', '                Vertex root = pst.update(rootsPST[j-1], 0, 2*n-1, hdds[j].pL.sortIndex);', '                rootsPST[j] = pst.update(root, 0, 2*n-1, hdds[j].pR.sortIndex);', '            }            ', '        } else {', '            calc = new Calc() {', '                @Override', '                public long getW(int start, int end) {', '                    return getW2(start, end);', '                }', '            };', '            prefL = new long[n + 1];', '            prefR = new long[n + 1];', '            for (int j = 1; j <= n; j++) {', '                prefR[j] = prefR[j - 1] + hdds[j].right;', '                prefL[j] = prefL[j - 1] + hdds[j].left;', '            }', '        }', '    }', '', '', '    static Map<Integer, Long>[] memo;', '    private static long getW1(int jStart, int jEnd) {', '        Long ans = memo[jEnd].get(jStart);', '        if (ans != null) {', '            return ans;', '        }', '        int mid = pst.query(rootsPST[jEnd], rootsPST[jStart-1], 0, 2 * n - 1, jEnd-jStart+1);', '        int p = points[mid].point;', '        long[] pair = new long[4];', '        stHD.query(1, 0, n - 1, jStart - 1, jEnd - 1, p, pair);', '        ans = p * pair[0] - pair[2] + pair[3] - p * pair[1];', '        memo[jEnd].put(jStart, ans);', '        return ans;', '    }', '', '    private static long getW2(int jStart, int jEnd) {', '        int mid = (jStart + jEnd) / 2;', '        long p = hdds[mid].right;', '        long ans = p * (mid - jStart + 1) - (prefR[mid] - prefR[jStart - 1]) + (prefL[jEnd] - prefL[mid])', '                - p * (jEnd - mid);', '        return ans;', '    }', '', '    static int INF = 2000000000;', '', '    static class SASD {', '        int mid1 = -INF;', '        int mid2 = INF;', '        long ans;', '', '        private PriorityQueue<Integer> r = new PriorityQueue<Integer>();', '', '        void add(HD hd) {', '            int nLow = hd.left;', '            int nHigh = hd.right;', '            if (nLow >= mid2) {', '                ans += (nLow - mid2);', '                r.remove();', '                r.add(nLow);', '                r.add(nHigh);', '                mid1 = mid2;', '                mid2 = r.peek();', '            } else if (nLow < mid1) {', '                r.add(nHigh);', '            } else {', '                r.add(nHigh);', '                mid1 = nLow;', '                if (mid2 == INF) {', '                    mid2 = nHigh;', '                }', '                if (nHigh <= mid2) {', '                    mid2 = nHigh;', '                }', '            }', '        }', '    }', '', '    static class SADS {', '        int mid1 = -INF;', '        int mid2 = INF;', '        long ans;', '', '        private PriorityQueue<Integer> l = new PriorityQueue<Integer>(n, new Comparator<Integer>() {', '', '            @Override', '            public int compare(Integer o1, Integer o2) {', '                return o2 - o1;', '            }', '        });', '', '        void add(HD hd) {', '            int nLow = hd.left;', '            int nHigh = hd.right;', '            if (nHigh <= mid1) {', '                ans += (mid1 - nHigh);', '                l.remove();', '                l.add(nLow);', '                l.add(nHigh);', '                mid2 = mid1;', '                mid1 = l.peek();', '            } else if (nHigh > mid2) {', '                l.add(nLow);', '                if (nLow >= mid2) {', '                    ans += (nHigh - mid2);', '                }', '            } else {', '                l.add(nLow);', '                mid2 = nHigh;', '                if (mid1 == -INF) {', '                    mid1 = nLow;', '                }', '                if (nLow >= mid1) {', '                    mid1 = nLow;', '                }', '            }', '        }', '    }', '', '    //static int c = 0;', '    //static long time = 0;', '    static long hardDrive() {', '        if (k == n) {', '            return totalLength;', '        }', '        initW();', '        if (f[1][n] == 0) {', '            return totalLength;', '        }', '        int STEEP = 10;', '        SADS ds = new SADS();', '        long ans = f[1][n];', '        int minG = 1;', '        for (int s = n; s >= 1; s--) {', '            ds.add(hdds[s]);', '            g[s] = ds.ans;', '            long pAns = f[1][s - 1] + ds.ans;', '            if (pAns < ans) {', '                ans = pAns;', '                minG = s;', '            }', '        }', '        f[2][n] = ans;', '        if (k == 2) {', '            return 2 * ans + totalLength;', '        }', '        long fRMIN = 0;', '        int[] minAJ = new int[n + 1];', '        Arrays.fill(minAJ, 1);', '        for (int i = 2; i < k; i++) {', '            if (i == k - 1) {', '                ans = f[i - 1][n];', '                int lower = minG;', '                int higher = n;', '                if (higher > lower + STEEP) {', '                    Pair p = search(calc, i, n, lower, higher, STEEP);', '                    ans = p.sumR;', '                    lower = p.nR;', '                    higher = p.nL;', '                }', '                for (int s = lower; s <= higher; s++) {', '                    long pAns = f[i - 1][s - 1] + g[s];', '                    if (pAns < ans) {', '                        ans = pAns;', '                        minG = s;', '                    }', '                }', '                f[i][n] = ans;', '                fRMIN = ans;', '                int minG2 = n;', '                minG = minG > 1 ? minG - 1 : 1;', '                int fSteep = 100;', '                for (int j = minG; j <= minG2; j++) {', '                    ans = f[i - 1][j];', '                    lower = 1;', '                    higher = j;', '                    if (higher > lower + STEEP) {', '                        Pair p = search(calc, i, j, lower, higher, STEEP);', '                        ans = p.sumR;', '                        lower = p.nR;', '                        higher = p.nL;', '                    }', '                    if (f[i - 1][lower - 1] != f[i - 1][higher - 1]) {', '                        for (int s = lower; s <= higher; s++) {', '                            long pAns = f[i - 1][s - 1] + calc.getW(s, j);', '                            if (pAns < ans) {', '                                ans = pAns;', '                            }', '                        }', '                    } else {                        ', '                        ans = f[i - 1][higher - 1] + calc.getW(higher, j);', '                    }    ', '                    f[i][j] = ans;', '                    long pFA = ans + g[j + 1];', '                    if (pFA < fRMIN) {', '                        fRMIN = pFA;', '                    }', '                    if (ans >= fRMIN) {', '                        break;', '                    }', '                    if (j + fSteep <= minG2 && ans + g[j + fSteep] >= fRMIN) {', '                        j = j + fSteep;', '                    }', '                    while (j < minG2 &&  g[j+1] == g[j+2]) {', '                        j++;', '                    }', '                }', '            } else {', '                for (int j = i + 1; j < n; j++) {', '                    ans = f[i - 1][j];', '                    int nMin = minAJ[j];', '                    int lower = nMin;', '                    int higher = j;', '                    if (higher > lower + STEEP) {', '                        Pair p = search(calc, i, j, lower, higher, STEEP);', '                        ans = p.sumR;', '                        lower = p.nR;', '                        higher = p.nL;                        ', '                    }', '                    if (f[i - 1][lower - 1] != f[i - 1][higher - 1]) {', '                        for (int s = lower; s <= higher; s++) {', '                            long pAns = f[i - 1][s - 1] + calc.getW(s, j);', '                            if (pAns < ans) {', '                                ans = pAns;', '                                nMin = s;', '                            }', '                        }', '                    } else {                        ', '                        ans = f[i - 1][higher - 1] + calc.getW(higher, j);         ', '                    }', '                    f[i][j] = ans;', '                    minAJ[j] = nMin;', '                }', '            }', '        }', '        return 2 * fRMIN + totalLength;', '    }', '', '    static Pair search(Calc calc, int i, int j, int lower, int higher, int steep) {', '        long ans = 0;', '        while (higher > lower + steep) {', '            int mid = (lower + higher) / 2;', '            int mid1 = (lower + mid) / 2;', '            mid1 = mid1 % 2 == 0 ? mid1 : mid1 + 1;', '            int mid2 = (higher + mid) / 2;', '            mid2 = mid2 % 2 == 0 ? mid2 : mid2 - 1;', '            long res1 = f[i - 1][mid1 - 1] + calc.getW(mid1, j);', '            long res2 = f[i - 1][mid2 - 1] + calc.getW(mid2, j);', '            if (res1 < res2) {', '                higher = mid2 - 1;', '                ans = res1;', '            } else if (res1 >= res2) {', '                lower = mid1 + 1;', '                ans = res2;', '            }', '        }', '        return new Pair(lower, higher, ans, 0);', '    }', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 2 * 4096 * 4096);', '        String[] nk = reader.readLine().trim().split("" "");', '        n = Integer.parseInt(nk[0]);', '        k = Integer.parseInt(nk[1]);', '        hdds = new HD[n + 1];', '        totalLength = 0;', '        for (int hddsRowItr = 1; hddsRowItr <= n; hddsRowItr++) {', '            String[] hddsRowItems = reader.readLine().trim().split("" "");', '            HD hd = new HD(Integer.parseInt(hddsRowItems[0]), Integer.parseInt(hddsRowItems[1]));', '            hdds[hddsRowItr] = hd;', '            totalLength += hd.length;', '        }', '        memo = new Map[n+1];', '        for (int j = 1; j <= n; j++) {', '            memo[j] = new HashMap<Integer, Long>();', '        }', '        dist = true;', '        long result = hardDrive();', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '        bufferedWriter.close();', '        reader.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', ' static int T = 0;', ' static int D = 1;', ' static int U = -1;', ' ', ' static class Cell {', '  int piece;  //0..1', '  int groupIndex; //0...', '  ', '  public Cell(int piece, int groupIndex) {', '   this.piece = piece;', '   this.groupIndex = groupIndex;', '  }', '  ', '  public String toString() {', '   if(piece == 0) {', '    return """" + (char)(\'a\' + groupIndex);', '   } else {', '    return """" + (char)(\'A\' + groupIndex);', '   }', '  }', '  ', '  public boolean equals(Object o) {', '   Cell other = (Cell)o;', '   return piece == other.piece && groupIndex == other.groupIndex;', '  }', '  ', '  public int hashCode() {', '   return 31 * piece + groupIndex;', '  }', '', '  public Cell copy() {', '   return new Cell(piece, groupIndex);', '  }', ' }', ' ', ' static class LineState {', '  Cell[] cells;', '  boolean isHidingGroup = false;', '', '  public LineState(Cell[] cells) {', '   this.cells = cells.clone();', '  }', '  ', '  public LineState(int template, int width) {', '   cells = new Cell[width];', '   for (int i = 0; i < width; i++) {', '    cells[i] = new Cell(template % 2, -1);', '    template /= 2;', '   }', '  }', '  ', '  public boolean isMatch(int[] constraint) {', '   for (int i = 0; i < cells.length; i++) {', '    if(constraint[i] >= 0 && constraint[i] != cells[i].piece) {', '     return false;', '    }', '   }', '   return true;', '  }', '  ', '  public int countOnes() {', '   int c = 0;', '   for (int i = 0; i < cells.length; i++) {', '    c += cells[i].piece;', '   }', '   return c;', '  }', '  ', '  public boolean isOfTwoPieces() {', '   if(isHidingGroup && isUniform()) return true;', '   for (int i = 0; i < cells.length; i++) {', '    if(cells[i].groupIndex > 0) return false;', '   }', '   return true;', '  }', '  ', '  public String toString() {', '   StringBuilder sb = new StringBuilder();', '   for (Cell c: cells) {', '    sb.append(c);', '   }', '   if(isHidingGroup) sb.append(""!"");', '   return sb.toString();', '  }', '  ', '  public boolean equals(Object o) {', '   LineState other = (LineState)o;', '   return toString().equals(other.toString());', '  }', '  ', '  public LineState copy() {', '   Cell[] cs = new Cell[cells.length];', '   for (int i = 0; i < cs.length; i++) {', '    cs[i] = cells[i].copy();', '   }', '   LineState copy = new LineState(cs);', '   copy.isHidingGroup = isHidingGroup;', '   return copy;', '  }', '  ', '  boolean isUniform() {', '   int p = cells[0].piece;', '   for (int i = 1; i < cells.length; i++) {', '    if(cells[i].piece != p) return false;', '   }', '   return true;', '  }', '  ', '  public void revalidate() {', '   int g0 = 20;', '   int g1 = 20;', '', '   for (int i = 0; i < cells.length; i++) {', '    int g = cells[i].groupIndex;', '    if(g >= 0) continue;', '    int p = cells[i].piece;', '    if(p == 0) {', '     for (int j = i; j < cells.length && cells[j].piece == p && cells[j].groupIndex < 0; j++) {', '      cells[j].groupIndex = g0;', '     }', '     g0++;', '    } else {', '     for (int j = i; j < cells.length && cells[j].piece == p && cells[j].groupIndex < 0; j++) {', '      cells[j].groupIndex = g1;', '     }', '     g1++;', '    }', '   }', '   ', '   int[] m0 = new int[cells.length + 20];', '   int[] m1 = new int[cells.length + 20];', '   for (int i = 0; i < m0.length; i++) {', '    m0[i] = -1;', '    m1[i] = -1;', '   }', '   g0 = 0;', '   g1 = 0;', '   ', '   for (int i = 0; i < cells.length; i++) {', '    int g = cells[i].groupIndex;', '    if(g < 0) continue;', '    if(cells[i].piece == 0) {', '     if(m0[g] >= 0) {', '      cells[i].groupIndex = m0[g];', '     } else {', '      m0[g] = g0;', '      cells[i].groupIndex = g0;', '      g0++;', '     }', '    } else {', '     if(m1[g] >= 0) {', '      cells[i].groupIndex = m1[g];', '     } else {', '      m1[g] = g1;', '      cells[i].groupIndex = g1;', '      g1++;', '     }', '    }', '   }', '   ', '  }', ' }', ' ', ' int width;', ' int height;', ' int diff;', ' int[][] constraint;', ' ', ' Map<String, LineState> states = new HashMap<>();', ' Map<String, Set<String>> transfers = new HashMap<>();', ' Map<String, Map<Integer,Long>> counts = new HashMap<>();', ' ', ' public void setSize(int width, int height, int diff) {', '  this.width = width;', '  this.height = height;', '  this.diff = diff;', ' }', ' ', ' public void setConstraint(int[][] constraint) {', '  this.constraint = constraint;', ' }', '', ' ', ' public List<LineState> createState() {', '  List<LineState> states = new ArrayList<>();', '  int t = 0;', '  Cell[] cells = new Cell[width];', '  int[] way = new int[width + 1];', '  int[] wayCount = new int[width + 1];', '  Cell[][] ways = new Cell[width + 1][width + 1];', '  ways[0][0] = new Cell(0, 0);', '  ways[0][1] = new Cell(1, 0);', '  wayCount[0] = 2;', '  way[t] = -1;', '  while(true) {', '   while(way[t] == wayCount[t] - 1) {', '    if(t == 0) return states;', '    t--;', '   }', '   way[t]++;', '   cells[t] = ways[t][way[t]];', '   t++;', '   wayCount[t] = 0;', '   if(t < width) {', '    int p = cells[t-1].piece;', '    ways[t][0] = new Cell(p,  cells[t-1].groupIndex); //same', '    wayCount[t]++;', '    List<Cell> gStack = new ArrayList<>();', '    int g = -1;', '    for (int i = 0; i < t; i++) {', '     int j = gStack.indexOf(cells[i]);', '     if(j >= 0) {', '      while(gStack.size() > j + 1) gStack.remove(gStack.size() - 1);', '     } else {', '      gStack.add(cells[i]);', '      if(cells[i].piece == 1 - p) {', '       if(cells[i].groupIndex > g) g = cells[i].groupIndex;', '      }', '     }', '    }', '    for (Cell c: gStack) {', '     if(c.piece == 1 - p) {', '      ways[t][wayCount[t]] = c;', '      wayCount[t]++;', '     }', '    }', '    ways[t][wayCount[t]] = new Cell(1-p,  g+1);', '    wayCount[t]++;', '   } else {', '    states.add(new LineState(cells));', '   }', '   way[t] = -1;', '  }', ' }', ' ', ' //to - template', ' public LineState transfer(LineState from, LineState to) {', '  if(from.isHidingGroup) {', '   if(width == 1 && from.cells[0].piece == to.cells[0].piece) {', '    to = to.copy();', '    to.isHidingGroup = true;', '    to.revalidate();', '    return to;', '   }', '   return null;', '  }', '  for (int i = 0; i < from.cells.length - 1; i++) {', '   int p = from.cells[i].piece;', '   if(p == from.cells[i + 1].piece && p == to.cells[i].piece', '      && p == to.cells[i + 1].piece) {', '    return null; //square 2x2', '   }', '  }', '  from = from.copy();', '  to = to.copy();', '  for (int i = 0; i < from.cells.length; i++) {', '   to.cells[i].groupIndex = -1;', '  }', '  for (int i = 0; i < from.cells.length; i++) {', '   int p = from.cells[i].piece;', '   int g1 = from.cells[i].groupIndex;', '   int g2 = to.cells[i].groupIndex;', '   if(p == to.cells[i].piece && g1 != g2) {', '    if(g2 >= 0) {', '     for (int j = 0; j < from.cells.length; j++) {', '      int ga = (g1 < g2) ? g1 : g2;', '      int gb = (g1 > g2) ? g1 : g2;', '      if(p == from.cells[j].piece && gb == from.cells[j].groupIndex) {', '       from.cells[j].groupIndex = ga;', '      }', '      if(p == to.cells[j].piece && gb == to.cells[j].groupIndex) {', '       to.cells[j].groupIndex = ga;', '      }', '     }', '    } else {', '     to.cells[i].groupIndex = g1;', '     int j = i + 1;', '     while(j < from.cells.length && to.cells[j].piece == p) {', '      to.cells[j].groupIndex = g1;', '      j++;', '     }', '     j = i - 1;', '     while(j >= 0 && to.cells[j].piece == p) {', '      to.cells[j].groupIndex = g1;', '      j--;', '     }', '    }', '   }', '  }', '  Set<Cell> accounted = new HashSet<>();', '  for (int i = 0; i < from.cells.length; i++) {', '   if(from.cells[i].piece == to.cells[i].piece) {', '    accounted.add(from.cells[i]);', '   }', '  }', '  Set<Cell> unaccounted = new HashSet<>();', '  for (int i = 0; i < from.cells.length; i++) {', '   if(!accounted.contains(from.cells[i]) && !unaccounted.contains(from.cells[i])) {', '    unaccounted.add(from.cells[i]);', '   }', '  }', '  if(unaccounted.size() > 1) return null;', '  to.revalidate();', '  if(unaccounted.size() == 1) {', '   if(!to.isUniform()) {', '    return null;', '   } else {', '    to.isHidingGroup = true;', '   }', '  }  ', '  return to;', ' }', ' ', ' public void build() {', '  int p2 = 1;', '  for (int i = 0; i < width; i++) p2 *= 2;', '  List<LineState> states = createState();', '  for (LineState s: states) {', '   this.states.put(s.toString(), s);', '   if(s.isUniform()) {', '    LineState s1 = s.copy();', '    s1.isHidingGroup = true;', '    this.states.put(s1.toString(), s1);', '   }', '  }', '  for (LineState s: this.states.values()) {', '   Set<String> ts = new HashSet<>();', '   for (int i = 0; i < p2; i++) {', '    LineState t = new LineState(i, width);', '    t = transfer(s, t);', '    if(t != null) ts.add(t.toString());', '   }', '   transfers.put(s.toString(), ts);', '  }', '  for (int i = 0; i < p2; i++) {', '   LineState t = new LineState(i, width);', '   t.revalidate();', '   if(!t.isMatch(constraint[0])) continue;', '   Map<Integer, Long> v = new HashMap<>();', '   v.put(t.countOnes(), 1l);', '   counts.put(t.toString(), v);', '  }', '  for (int i = 0; i < height - 1; i++) {', '   counts = addRow(counts, constraint[i+1]);', '  }', '  long sum = sum(counts, diff, width * height);', '  System.out.println(sum);', ' }', ' ', ' Map<String, Map<Integer,Long>> addRow(Map<String, Map<Integer,Long>> counts, int[] cs) {', '  Map<String, Map<Integer,Long>> next = new HashMap<>();', '  for (String s: counts.keySet()) {', '   Map<Integer, Long> vs = counts.get(s);', '   for (String n: transfers.get(s)) {', '    LineState t = states.get(n);', '    if(!t.isMatch(cs)) continue;', '    int dk = t.countOnes();', '    if(!next.containsKey(n)) {', '     Map<Integer, Long> v = new HashMap<>();', '     for (int k: vs.keySet()) {', '      v.put(k + dk, vs.get(k));', '     }', '     next.put(n, v);', '    } else {', '     Map<Integer, Long> v = next.get(n);', '     for (int k: vs.keySet()) {', '      if(!v.containsKey(k + dk)) {', '       v.put(k + dk, vs.get(k));', '      } else {', '       v.put(k + dk, v.get(k + dk) + vs.get(k));', '      }', '     }', '    }', '   }', '  }', '  return next;', ' }', ' ', ' long sum(Map<String, Map<Integer,Long>> counts, int diff, int size) {', '  long result = 0;', '  for (String s: counts.keySet()) {', '   LineState state = states.get(s);', '   if(state.isOfTwoPieces()) {', '    for (int k: counts.get(s).keySet()) {', '     int k1 = size - k;', '     if(Math.abs(k - k1) <= diff) {', '      long d = counts.get(s).get(k);', '      result += d;', '     }', '    }', '   }', '  }', '  return result;', ' }', '', ' public void run() {', '  Scanner in = new Scanner(System.in);', '  int m = in.nextInt(), n = in.nextInt(), k = in.nextInt();', '  if(m == 0 || n == 0) {', '   System.out.println(1);', '   return;', '  }', '//  in.next();', '  setSize(n, m, k);', '  int[][] cs = new int[m][n];', '  for (int i = 0; i < m; i++) {', '   String s = in.next();', '   for (int j = 0; j < n; j++) {', '    char ch = s.charAt(j);', ""    cs[i][j] = ch == 'T' ? T : ch == 'D' ? D : U;"", '   }', '  }', '  setConstraint(cs);', '  build();', ' }', '', '    public static void main(String[] args) {', '        new Solution().run();', '    }', '}']","['import java.util.ArrayList;', 'import java.util.HashMap;', 'import java.util.HashSet;', 'import java.util.List;', 'import java.util.Scanner;', 'import java.util.Set;', '', 'public class SeparateChoco {', '', '    static int T = 0;', '    static int D = 1;', '    static int U = -1;', '    // yes, Go language style...', '    static class MapIntLong extends HashMap<Integer, Long> {', '    }', '', '    static class MapStringMapIntLong extends HashMap<String, MapIntLong> {', '    }', '', '    static class MapStringRow extends HashMap<String, Row> {', '', '    }', '', '    static class MapStringSetString extends HashMap<String, Set<String>> {', '', '    }', '', '    static class Piece {', '        int id;', '        int groupIdx;', '', '        public Piece(int piece, int groupIndex) {', '            this.id = piece;', '            this.groupIdx = groupIndex;', '        }', '', '        public String toString() {', '            if (id == 0) {', '                return """" + (char) (\'a\' + groupIdx);', '            } else {', '                return """" + (char) (\'A\' + groupIdx);', '            }', '        }', '', '        public boolean equals(Object o) {', '            Piece other = (Piece) o;', '            return id == other.id && groupIdx == other.groupIdx;', '        }', '', '        public int hashCode() {', '            return 31 * id + groupIdx;', '        }', '', '        public Piece copy() {', '            return new Piece(id, groupIdx);', '        }', '    }', '', '    static class Row {', '        Piece[] pieces;', '        boolean isHiding = false;', '', '        public Row(Piece[] pieces) {', '            this.pieces = pieces.clone();', '        }', '', '        public Row(int template, int width) {', '            pieces = new Piece[width];', '            for (int i = 0; i < width; i++) {', '                pieces[i] = new Piece(template % 2, -1);', '                template /= 2;', '            }', '        }', '', '        public boolean hasMatch(int[] constraint) {', '            for (int i = 0; i < pieces.length; i++) {', '                if (constraint[i] >= 0 && constraint[i] != pieces[i].id) {', '                    return false;', '                }', '            }', '            return true;', '        }', '', '        public int countOnes() {', '            int c = 0;', '            for (int i = 0; i < pieces.length; i++) {', '                c += pieces[i].id;', '            }', '            return c;', '        }', '', '        public boolean isOfTwoPieces() {', '            if (isHiding && isUniform())', '                return true;', '            for (int i = 0; i < pieces.length; i++) {', '                if (pieces[i].groupIdx > 0)', '                    return false;', '            }', '            return true;', '        }', '', '        public String toString() {', '            StringBuilder sb = new StringBuilder();', '            for (Piece c : pieces) {', '                sb.append(c);', '            }', '            if (isHiding) {', '                sb.append(""!"");', '            }', '            return sb.toString();', '        }', '', '        public boolean equals(Object o) {', '            Row other = (Row) o;', '            return toString().equals(other.toString());', '        }', '', '        public Row copy() {', '            Piece[] pcs = new Piece[pieces.length];', '            for (int i = 0; i < pcs.length; i++) {', '                pcs[i] = pieces[i].copy();', '            }', '            Row copy = new Row(pcs);', '            copy.isHiding = isHiding;', '            return copy;', '        }', '', '        boolean isUniform() {', '            int p = pieces[0].id;', '            for (int i = 1; i < pieces.length; i++) {', '                if (pieces[i].id != p)', '                    return false;', '            }', '            return true;', '        }', '', '        public void validate() {', '            int groupOne = 20;', '            int groupTwo = 20;', '', '            for (int i = 0; i < pieces.length; i++) {', '                int curGroup = pieces[i].groupIdx;', '                if (curGroup >= 0) {', '                    continue;', '                }', '                int p = pieces[i].id;', '                if (p == 0) {', '                    for (int j = i; j < pieces.length && pieces[j].id == p && pieces[j].groupIdx < 0; j++) {', '                        pieces[j].groupIdx = groupOne;', '                    }', '                    groupOne++;', '                } else {', '                    for (int j = i; j < pieces.length && pieces[j].id == p && pieces[j].groupIdx < 0; j++) {', '                        pieces[j].groupIdx = groupTwo;', '                    }', '                    groupTwo++;', '                }', '            }', '', '            int[] movesOne = new int[pieces.length + 20];', '            int[] movesTwo = new int[pieces.length + 20];', '            for (int i = 0; i < movesOne.length; i++) {', '                movesOne[i] = -1;', '                movesTwo[i] = -1;', '            }', '            groupOne = 0;', '            groupTwo = 0;', '', '            for (int i = 0; i < pieces.length; i++) {', '                int curGroup = pieces[i].groupIdx;', '                if (curGroup < 0) {', '                    continue;', '                }', '                if (pieces[i].id == 0) {', '                    if (movesOne[curGroup] >= 0) {', '                        pieces[i].groupIdx = movesOne[curGroup];', '                    } else {', '                        movesOne[curGroup] = groupOne;', '                        pieces[i].groupIdx = groupOne;', '                        groupOne++;', '                    }', '                } else {', '                    if (movesTwo[curGroup] >= 0) {', '                        pieces[i].groupIdx = movesTwo[curGroup];', '                    } else {', '                        movesTwo[curGroup] = groupTwo;', '                        pieces[i].groupIdx = groupTwo;', '                        groupTwo++;', '                    }', '                }', '            }', '', '        }', '    }', '', '    public void setSize(int width, int height, int diff) {', '        this.width = width;', '        this.height = height;', '        this.diff = diff;', '    }', '', '    public void setConstraint(int[][] constraint) {', '        this.constraint = constraint;', '    }', '', '    public List<Row> createRow() {', '        List<Row> rows = new ArrayList<>();', '        int cnt = 0;', '        Piece[] pcs = new Piece[width];', '        int[] solution = new int[width + 1];', '        int[] solutionsCount = new int[width + 1];', '        Piece[][] solutions = new Piece[width + 1][width + 1];', '        solutions[0][0] = new Piece(0, 0);', '        solutions[0][1] = new Piece(1, 0);', '        solutionsCount[0] = 2;', '        solution[cnt] = -1;', '        while (true) {', '            while (solution[cnt] == solutionsCount[cnt] - 1) {', '                if (cnt == 0) {', '                    return rows;', '                }', '                cnt--;', '            }', '            solution[cnt]++;', '            pcs[cnt] = solutions[cnt][solution[cnt]];', '            cnt++;', '            solutionsCount[cnt] = 0;', '            if (cnt < width) {', '                int curPc = pcs[cnt - 1].id;', '                solutions[cnt][0] = new Piece(curPc, pcs[cnt - 1].groupIdx); //same', '                solutionsCount[cnt]++;', '                List<Piece> pcsStack = new ArrayList<>();', '                int grpId = -1;', '                for (int i = 0; i < cnt; i++) {', '                    int j = pcsStack.indexOf(pcs[i]);', '                    if (j >= 0) {', '                        while (pcsStack.size() > j + 1) {', '                            pcsStack.remove(pcsStack.size() - 1);', '                        }', '                    } else {', '                        pcsStack.add(pcs[i]);', '                        if (pcs[i].id == 1 - curPc) {', '                            if (pcs[i].groupIdx > grpId) {', '                                grpId = pcs[i].groupIdx;', '                            }', '                        }', '                    }', '                }', '                for (Piece c : pcsStack) {', '                    if (c.id == 1 - curPc) {', '                        solutions[cnt][solutionsCount[cnt]] = c;', '                        solutionsCount[cnt]++;', '                    }', '                }', '                solutions[cnt][solutionsCount[cnt]] = new Piece(1 - curPc, grpId + 1);', '                solutionsCount[cnt]++;', '            } else {', '                rows.add(new Row(pcs));', '            }', '            solution[cnt] = -1;', '        }', '    }', '', '    public Row move(Row from, Row to) {', '        if (from.isHiding) {', '            if (width == 1 && from.pieces[0].id == to.pieces[0].id) {', '                to = to.copy();', '                to.isHiding = true;', '                to.validate();', '                return to;', '            }', '            return null;', '        }', '        for (int i = 0; i < from.pieces.length - 1; i++) {', '            int p = from.pieces[i].id;', '            if (p == from.pieces[i + 1].id && p == to.pieces[i].id && p == to.pieces[i + 1].id) {', '                return null;', '            }', '        }', '        from = from.copy();', '        to = to.copy();', '        for (int i = 0; i < from.pieces.length; i++) {', '            to.pieces[i].groupIdx = -1;', '        }', '        for (int i = 0; i < from.pieces.length; i++) {', '            int p = from.pieces[i].id;', '            int grpId1 = from.pieces[i].groupIdx;', '            int grpId2 = to.pieces[i].groupIdx;', '            if (p == to.pieces[i].id && grpId1 != grpId2) {', '                if (grpId2 >= 0) {', '                    for (int j = 0; j < from.pieces.length; j++) {', '                        int ga = (grpId1 < grpId2) ? grpId1 : grpId2;', '                        int gb = (grpId1 > grpId2) ? grpId1 : grpId2;', '                        if (p == from.pieces[j].id && gb == from.pieces[j].groupIdx) {', '                            from.pieces[j].groupIdx = ga;', '                        }', '                        if (p == to.pieces[j].id && gb == to.pieces[j].groupIdx) {', '                            to.pieces[j].groupIdx = ga;', '                        }', '                    }', '                } else {', '                    to.pieces[i].groupIdx = grpId1;', '                    int j = i + 1;', '                    while (j < from.pieces.length && to.pieces[j].id == p) {', '                        to.pieces[j].groupIdx = grpId1;', '                        j++;', '                    }', '                    j = i - 1;', '                    while (j >= 0 && to.pieces[j].id == p) {', '                        to.pieces[j].groupIdx = grpId1;', '                        j--;', '                    }', '                }', '            }', '        }', '        Set<Piece> accounted = new HashSet<>();', '        for (int i = 0; i < from.pieces.length; i++) {', '            if (from.pieces[i].id == to.pieces[i].id) {', '                accounted.add(from.pieces[i]);', '            }', '        }', '        Set<Piece> unaccounted = new HashSet<>();', '        for (int i = 0; i < from.pieces.length; i++) {', '            if (!accounted.contains(from.pieces[i]) && !unaccounted.contains(from.pieces[i])) {', '                unaccounted.add(from.pieces[i]);', '            }', '        }', '        if (unaccounted.size() > 1) {', '            return null;', '        }', '        to.validate();', '        if (unaccounted.size() == 1) {', '            if (!to.isUniform()) {', '                return null;', '            } else {', '                to.isHiding = true;', '            }', '        }', '        return to;', '    }', '', '    public void build() {', '        int powOfTwo = 1;', '        for (int i = 0; i < width; i++) {', '            powOfTwo *= 2;', '        }', '        List<Row> rows = createRow();', '        for (Row row : rows) {', '            this.rows.put(row.toString(), row);', '            if (row.isUniform()) {', '                Row s1 = row.copy();', '                s1.isHiding = true;', '                this.rows.put(s1.toString(), s1);', '            }', '        }', '        for (Row s : this.rows.values()) {', '            Set<String> ts = new HashSet<>();', '            for (int i = 0; i < powOfTwo; i++) {', '                Row t = new Row(i, width);', '                t = move(s, t);', '                if (t != null)', '                    ts.add(t.toString());', '            }', '            moves.put(s.toString(), ts);', '        }', '        for (int i = 0; i < powOfTwo; i++) {', '            Row newRow = new Row(i, width);', '            newRow.validate();', '            if (!newRow.hasMatch(constraint[0])) {', '                continue;', '            }', '            MapIntLong v = new MapIntLong();', '            v.put(newRow.countOnes(), 1l);', '            counts.put(newRow.toString(), v);', '        }', '        for (int i = 0; i < height - 1; i++) {', '            counts = addRow(counts, constraint[i + 1]);', '        }', '        long sum = sum(counts, diff, width * height);', '        System.out.println(sum);', '    }', '', '    MapStringMapIntLong addRow(MapStringMapIntLong counts, int[] cs) {', '        MapStringMapIntLong next = new MapStringMapIntLong();', '        for (String s : counts.keySet()) {', '            MapIntLong vs = counts.get(s);', '            for (String n : moves.get(s)) {', '                Row t = rows.get(n);', '                if (!t.hasMatch(cs)) {', '                    continue;', '                }', '                int dk = t.countOnes();', '                if (!next.containsKey(n)) {', '                    MapIntLong v = new MapIntLong();', '                    for (int k : vs.keySet()) {', '                        v.put(k + dk, vs.get(k));', '                    }', '                    next.put(n, v);', '                } else {', '                    MapIntLong v = next.get(n);', '                    for (int k : vs.keySet()) {', '                        if (!v.containsKey(k + dk)) {', '                            v.put(k + dk, vs.get(k));', '                        } else {', '                            v.put(k + dk, v.get(k + dk) + vs.get(k));', '                        }', '                    }', '                }', '            }', '        }', '        return next;', '    }', '', '    long sum(MapStringMapIntLong counts, int diff, int size) {', '        long result = 0;', '        for (String s : counts.keySet()) {', '            Row state = rows.get(s);', '            if (state.isOfTwoPieces()) {', '                for (int k : counts.get(s).keySet()) {', '                    int k1 = size - k;', '                    if (Math.abs(k - k1) <= diff) {', '                        long d = counts.get(s).get(k);', '                        result += d;', '                    }', '                }', '            }', '        }', '        return result;', '    }', '', '    int width;', '    int height;', '    int diff;', '    int[][] constraint;', '', '    MapStringRow rows = new MapStringRow();', '    MapStringSetString moves = new MapStringSetString();', '    MapStringMapIntLong counts = new MapStringMapIntLong();', '', '    public void run() {', '        Scanner in = new Scanner(System.in);', '        int m = in.nextInt(), n = in.nextInt(), k = in.nextInt();', '        if (m == 0 || n == 0) {', '            System.out.println(1);', '            return;', '        }', '        setSize(n, m, k);', '        int[][] cs = new int[m][n];', '        for (int i = 0; i < m; i++) {', '            String s = in.next();', '            for (int j = 0; j < n; j++) {', '                char ch = s.charAt(j);', ""                cs[i][j] = ch == 'T' ? T : ch == 'D' ? D : U;"", '            }', '        }', '        setConstraint(cs);', '        build();', '    }', '', '    public static void main(String[] args) {', '        new SeparateChoco().run();', '    }', '}']"
"['import java.io.BufferedOutputStream;', 'import java.io.BufferedReader;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.util.Arrays;', '', '', 'public class Solution {', '', ' static Solution main;', ' ', ' static long sp;', ' ', ' public static void main(String[] args) {', '  sp = 1000000007;', '  long [] fact = new long[110001];', '  long [] pow2 = new long[110001];', '  pow2[0] = 1;', '  fact[0] = 1;', '  for(int i = 1 ; i < 110001 ; i++) {', '   fact[i] = fact[i-1] * i;', '   fact[i] %= sp;', '   pow2[i] = 2*pow2[i-1];', '   if(pow2[i]>=sp) {', '    pow2[i]-=sp;', '   }', '  }', '  main = new Solution();', '  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '  BufferedOutputStream bos = new BufferedOutputStream(System.out);', '  String eol = System.getProperty(""line.separator"");', '  byte[] eolb = eol.getBytes();', '  try {', '   String str = br.readLine();', '   int t = Integer.parseInt(str);', '   for(int i = 0 ; i < t ; i++) {', '    str = br.readLine();', '    int n = Integer.parseInt(str);', '    int [] ar = new int[40];', '    Arrays.fill(ar, 0);', '    str = br.readLine();', '    int j=0;', '    int s=0;', '    int length = str.length();', '    while(j<length) {', '     while(j<length) {', ""      if(str.charAt(j) == ' ') {"", '       break;', '      }else {', '       j++;', '      }', '     }', '     int x = Integer.parseInt(str.substring(s,j)) ; ', '     int iter = 0;', '     while(x>0) {', '      if((x%2)==1) {', '       ar[iter]++;', '      }', '      x/=2;', '      iter++;', '     }', '     j++;', '     s=j;   ', '    }', '    long ans = 0;', '    for(int a = 0 ;a < 40 ; a++) {', '     int x = ar[a];', '     for(int b = 1 ; b <= x; b+=2) {', '      // x choose b * 2^(n-x) * 2^a', '      long tempAns = fact[x];', '      tempAns *= inverse(fact[b]);', '      tempAns %= sp;', '      tempAns *= inverse(fact[x-b]);', '      tempAns %= sp;', '      tempAns *= pow2[n-x+a];', '      tempAns %= sp;', '      ans += tempAns;', '      if(ans>sp) {', '       ans -= sp;', '      }', '     }', '    }', '    bos.write(new Long(ans).toString().getBytes());', '    bos.write(eolb);', '   }', '   bos.flush();', '  } catch(IOException ioe) {', '   ioe.printStackTrace();', '  }', ' }', ' ', ' public static long inverse(long a) {', '  return getPow(a,sp-2);', ' }', ' ', ' public static long getPow(long a , long b) {', '  long ans = 1;', '  long pow = a;', '  while(b>0) {', '   if((b%2)==1) {', '    ans *= pow;', '    ans %= sp;', '   }', '   pow *= pow;', '   pow %= sp;', '   b/=2;', '  }', '  return ans;', ' }', '', '}']","['import java.io.*;', 'import java.util.*;', 'import java.lang.Math;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */', '        Scanner s = new Scanner(System.in);', '        int numTests = s.nextInt();', '        for(int tests = 0; tests < numTests; tests++){', '            int n = s.nextInt();', '            long sum = 0;', '            for(int i = 0; i < n; i++){', '                sum = sum|s.nextLong();', '            }', '            for(int i = 0; i < n-1; i++){', '                sum = sum*2 % (1000000007);', '            }', '            long finalSum = sum << (n-1);', '            long finalMod = finalSum % (1000000007);', '            System.out.println(sum);', '        }', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(System.in);', '        int n = sc.nextInt();', '        long m = sc.nextLong()-1;', '        int[] a = new int[n];', '        for (int i = 0; i < n; i++)', '            a[i] = sc.nextInt();', '        int shift = 1;', '        while (m > 0) {', '            if (m%2==1) {', '                int[] newa = new int[n];', '                for (int i = 0; i < n; i++) {', '                    newa[i] = a[i]^a[(i+shift)%n];', '                }', '                a = newa;', '            }', '            m /= 2;', '            shift *= 2;', '            shift %= n;', '        }', '        StringBuilder ans = new StringBuilder();', '        ans.append(a[0]);', '        for (int i = 1; i < n; i++) {', '            ans.append("" ""+a[i]);', '        }', '        System.out.println(ans);', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    static int[] firstRow;', '    static int[] nextRow;', '    ', '    static void next(long count) {', '        for (int i = 0; i < firstRow.length; i++) {', '          nextRow[i] = firstRow[i] ^ firstRow[(int) ((count + i) % firstRow.length)];', '        }', '        int[] temp = firstRow;', '        firstRow = nextRow;', '        nextRow = temp;', '    }    ', '    ', '    static int[] xorMatrix(long m) {', '      long pos = 1;', '      while (pos < m) {', '        long lowerPowerOfTwo = 1;', '        while (pos + 2 * lowerPowerOfTwo <= m) {', '          lowerPowerOfTwo *= 2;', '        }', '        next(lowerPowerOfTwo);', '        pos += lowerPowerOfTwo;', '      }', '      return firstRow;', '    }', '', '    public static void main(String[] args) throws IOException {', '        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '      StringTokenizer st = new StringTokenizer(br.readLine());', '      int n = Integer.parseInt(st.nextToken());', '      long m = Long.parseLong(st.nextToken());', '', '      firstRow = new int[n];', '      nextRow = new int[n];', '', '      st = new StringTokenizer(br.readLine());', '', '      for (int i = 0; i < n; i++) {', '        int item = Integer.parseInt(st.nextToken());', '        firstRow[i] = item;', '      }', '', '      int[] result = xorMatrix(m);', '      ', '      for (int i = 0; i < n; i++) {', '        if (i > 0) {', '          bw.write("" "");', '        }', '        bw.write(String.valueOf(result[i]));', '      }', '', '      bw.newLine();', '', '      bw.close();', '      br.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.HashSet;', 'import java.util.Set;', 'import java.util.StringTokenizer;', '', 'public class Solution implements Runnable {', '', '    // leave empty to read from stdin/stdout', '    private static final String TASK_NAME_FOR_IO = """";', '', '    // file names', '    private static final String FILE_IN = TASK_NAME_FOR_IO + "".in"";', '    private static final String FILE_OUT = TASK_NAME_FOR_IO + "".out"";', '', '    BufferedReader in;', '    PrintWriter out;', '    StringTokenizer tokenizer = new StringTokenizer("""");', '', '    public static void main(String[] args) {', '        new Solution().run();', '    }', '', '    final long MOD = 1000000007L;', '', '    int N_MAX = 1005;', '    long[][] cnk = new long[N_MAX][N_MAX];', '', '    private void solve() throws IOException {', '        for (int n = 0; n < N_MAX; n++) {', '            cnk[n][0] = 1;', '            cnk[n][n] = 1;', '            for (int k = 1; k < n; k++) {', '                cnk[n][k] = cnk[n - 1][k - 1] + cnk[n - 1][k];', '                cnk[n][k] %= MOD;', '            }', '        }', '', '        /*', '        System.out.println(""int[][] COEFF = new int[][] {"");', '        for (int n = 0; n <= 1000; n++) {', '            fastPrecalc(n);', '        }', '        System.out.println(""};"");', '        */', '', '        /*', '        Random r = new Random();', '        for (int n = 1; n <= 50; n++) {', '            System.out.println(""N="" + n);', '            for (int d = 0; d <= 4; d++)', '                for (int attempts = 0; attempts < 20; attempts++) {', '                    long mask = r.nextLong() & (1L << 3);', '', '                    String maskC = """";', '', '                    long num = mask;', '                    for (int j = 0; j < n; j++) {', '                        maskC += num & 1;', '                        num >>= 1;', '                    }', '', '                    long a = naive(n, d, maskC.toCharArray());', '                    long b = fast(n, d, maskC.toCharArray());', '', '                    if (a != b) {', '                        System.err.println(n + "" - "" + d + "" - "" + maskC + ""("" + a + "" vs. "" + b + "", delta "" + (a - b) + "")"");', '                    }', '                }', '        }', '', '        for (int n = 1; n <= 1000; n++) {', '            String maskC = """";', '            for (int j = 0; j < n; j++) {', '                maskC += ""1"";', '            }', '', '            long b = fast(n, 0, maskC.toCharArray());', '            if (b > 0) {', '                System.err.println(n + "" - "" + b);', '            }', '        }', '        */', '', '        int tc = nextInt();', '        for (int tcIdx = 0; tcIdx < tc; tcIdx++) {', '            int n = nextInt();', '            int maxD = nextInt();', '            char[] c = nextToken().toCharArray();', '', '            out.println(fast(n, maxD, c));', '        }', '    }', '', '    static int gcd(int a, int b) {', '        if (b == 0) {', '            return a;', '        } else {', '            return gcd(b, a % b);', '        }', '    }', '', '    static int MAX_GCD_NUM = 1005;', '    static int[][] GCD_STATIC = new int[MAX_GCD_NUM][MAX_GCD_NUM];', '', '    static {', '        for (int i = 0; i < MAX_GCD_NUM; i++)', '            for (int j = 0; j <= i; j++) {', '                int g = gcd(i, j);', '                GCD_STATIC[i][j] = g;', '                GCD_STATIC[j][i] = g;', '            }', '    }', '', '    @SuppressWarnings({""UnusedDeclaration""})', '    private long notFastEnough(int n, int maxD, char[] c) {', '', '        int cnt = 0;', '        for (int period = 1; period < n; period++) {', '            if (n % period == 0) {', '                cnt++;', '            }', '        }', '', '        int[] periods = new int[cnt];', '        {', '            int idx = 0;', '            for (int period = 1; period < n; period++)', '                if (n % period == 0) {', '                    periods[idx++] = period;', '                }', '        }', '', '        long[] periodicAnswer = new long[n];', '        for (int i = 0; i < cnt; i++) {', '            periodicAnswer[periods[i]] = countPeriodic(n, maxD, periods[i], c);', '        }', '', '        // calculate total', '        long total = 0;', '        for (int i = 0; i <= maxD; i++) {', '            total += cnk[n][i];', '            total %= MOD;', '        }', '', '        // calculate partial gcd', '        int lBits = cnt / 2;', '        int lBits2 = 1 << lBits;', '        int[] lGcd = new int[lBits2];', '', '        {', '            for (int mask = 0; mask < lBits2; mask++) {', '                int common = -1;', '                for (int i = 0; i < lBits; i++)', '                    if ((mask & (1 << i)) != 0) {', '                        common = (common == -1) ? periods[i] : GCD_STATIC[common][periods[i]];', '                        if (common == 1) {', '                            break;', '                        }', '                    }', '                lGcd[mask] = common;', '            }', '        }', '', '        int rBits = cnt - lBits;', '        int rBits2 = 1 << rBits;', '', '        int[] rGcd = new int[rBits2];', '        {', '            for (int mask = 0; mask < rBits2; mask++) {', '                int common = -1;', '                for (int i = 0; i < rBits; i++)', '                    if ((mask & (1 << i)) != 0) {', '                        common = (common == -1) ? periods[i + lBits] : GCD_STATIC[common][periods[i + lBits]];', '                        if (common == 1) {', '                            break;', '                        }', '                    }', '                rGcd[mask] = common;', '            }', '        }', '', '        long cnt2 = 1L << cnt;', '        for (long mask = 1; mask < cnt2; mask++) {', '            // determine sign by the number of bits in the mask', '            int sign = (bitCount(mask) & 1) == 0 ? 1 : -1;', '', '            // fast calculate gcd by analysing left and right part', '            int gcdLeft = lGcd[(int) (mask & (lBits2 - 1))];', '            int gcdRight = rGcd[(int) (mask >> lBits)];', '', '            int common;', '            if (gcdLeft == -1) {', '                common = gcdRight;', '            } else if (gcdRight == -1) {', '                common = gcdLeft;', '            } else {', '                common = GCD_STATIC[gcdLeft][gcdRight];', '            }', '', '            /*', '            int common = -1;', '            for (int i = 0; i < cnt; i++)', '                if ((mask & (1 << i)) != 0) {', '                    common = (common == -1) ? periods[i] : GCD_STATIC[common][periods[i]];', '                    if (common == 1) {', '                        break;', '                    }', '                }', '                */', '', '            total += sign * periodicAnswer[common];', '            total %= MOD;', '        }', '', '        total %= MOD;', '        total += MOD;', '        total %= MOD;', '', '        return total;', '    }', '', '    private long fast(int n, int maxD, char[] c) {', '', '        int cnt = 0;', '        for (int period = 1; period < n; period++) {', '            if (n % period == 0) {', '                cnt++;', '            }', '        }', '', '        int[] periods = new int[cnt];', '        {', '            int idx = 0;', '            for (int period = 1; period < n; period++)', '                if (n % period == 0) {', '                    periods[idx++] = period;', '                }', '        }', '', '        long[] periodicAnswer = new long[n];', '        for (int i = 0; i < cnt; i++) {', '            periodicAnswer[i] = countPeriodic(n, maxD, periods[i], c);', '        }', '', '        // calculate total', '        long total = 0;', '        for (int i = 0; i <= maxD; i++) {', '            total += cnk[n][i];', '            total %= MOD;', '        }', '', '        int[] coeff = COEFF[n];', '        if (coeff.length != cnt) {', '            throw new IllegalStateException(""INVALID STATE"");', '        }', '', '        for (int i = 0; i < cnt; i++) {', '            total += coeff[i] * periodicAnswer[i];', '            total %= MOD;', '        }', '', '        total %= MOD;', '        total += MOD;', '        total %= MOD;', '', '        return total;', '    }', '', '    int[][] COEFF = new int[][] {', '      {},', '      {},', '      {-1,},', '      {-1,},', '      {0,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,-1,},', '      {0,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,-1,},', '      {-1,},', '      {0,0,1,-1,-1,},', '      {-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,0,1,0,-1,-1,},', '      {0,-1,},', '      {1,-1,-1,},', '      {0,0,-1,},', '      {0,1,-1,0,-1,},', '      {-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {-1,},', '      {0,0,0,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,1,0,-1,0,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,1,-1,0,-1,},', '      {0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,1,0,-1,-1,},', '      {0,-1,},', '      {0,0,1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {-1,},', '      {0,0,0,0,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,1,0,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,-1,0,1,0,1,1,-1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {0,1,0,-1,-1,},', '      {0,0,0,0,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {0,0,1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,0,0,1,0,-1,0,-1,},', '      {0,0,0,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,-1,0,1,1,0,-1,1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {-1,},', '      {0,0,-1,0,1,1,0,1,-1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,1,0,-1,-1,},', '      {-1,},', '      {0,0,1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,0,0,0,1,-1,0,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,1,-1,0,0,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,1,0,-1,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,1,0,-1,0,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,-1,0,0,1,0,1,0,1,-1,0,-1,-1,},', '      {0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,0,-1,},', '      {0,0,-1,1,0,1,0,-1,1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,-1,0,1,1,0,-1,1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,1,0,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,-1,1,0,0,1,1,-1,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,0,0,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {-1,},', '      {0,0,0,-1,0,1,1,1,-1,-1,-1,},', '      {-1,},', '      {0,0,1,-1,0,0,-1,},', '      {0,1,-1,0,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {1,-1,-1,},', '      {0,-1,0,1,1,-1,0,1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,1,0,-1,0,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,1,-1,-1,},', '      {-1,},', '      {0,1,-1,0,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,0,-1,0,0,1,1,0,0,-1,1,0,-1,-1,},', '      {0,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,1,-1,0,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,1,0,-1,-1,},', '      {0,0,0,1,0,-1,0,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,-1,0,0,1,0,1,0,1,-1,0,-1,-1,},', '      {-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,0,0,1,0,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,0,0,1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {0,0,0,0,1,-1,0,-1,},', '      {-1,},', '      {0,0,-1,1,1,0,-1,0,1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,1,0,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,-1,0,1,1,-1,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,0,0,1,0,-1,0,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,-1,1,-1,1,1,1,1,-1,1,-1,-1,-1,},', '      {-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,0,0,0,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,-1,1,0,1,0,-1,1,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,1,0,-1,0,-1,},', '      {0,0,0,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,-1,0,1,1,-1,0,1,0,-1,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {-1,},', '      {0,0,-1,1,1,0,-1,0,1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,-1,0,0,0,1,0,1,0,1,-1,0,-1,-1,},', '      {-1,},', '      {0,0,1,-1,-1,},', '      {0,0,0,0,-1,},', '      {0,1,-1,0,-1,},', '      {0,0,1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,1,-1,-1,},', '      {-1,},', '      {0,0,0,0,-1,0,0,1,0,1,0,0,-1,1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,0,0,0,0,0,0,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,-1,1,0,1,0,-1,1,-1,0,-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,0,-1,0,1,0,1,0,-1,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {-1,},', '      {0,0,0,0,0,-1,0,0,1,1,0,1,-1,-1,-1,},', '      {-1,},', '      {0,0,0,1,-1,0,0,0,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,0,-1,-1,},', '      {0,-1,0,1,1,-1,0,1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,0,-1,0,0,1,0,0,1,1,0,-1,-1,0,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,1,-1,0,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,-1,-1,},', '      {0,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {-1,},', '      {0,0,0,0,-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {0,0,1,0,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,-1,0,0,1,0,1,1,-1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,1,-1,0,0,0,-1,},', '      {1,-1,-1,},', '      {0,0,-1,1,1,0,-1,0,1,-1,-1,},', '      {-1,},', '      {0,-1,1,0,0,1,1,-1,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,0,-1,0,1,1,0,-1,0,0,1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {0,-1,0,0,1,1,1,0,-1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,0,1,0,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,0,0,0,1,0,-1,-1,},', '      {0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,-1,1,1,-1,1,1,-1,1,1,-1,-1,-1,},', '      {-1,},', '      {0,1,-1,0,-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,-1,0,0,1,0,1,0,0,-1,1,0,-1,-1,},', '      {-1,},', '      {0,0,1,-1,-1,},', '      {1,-1,-1,},', '      {0,-1,1,0,1,0,-1,1,-1,0,-1,},', '      {1,-1,-1,},', '      {0,0,-1,1,1,-1,0,0,1,-1,-1,},', '      {0,0,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,-1,0,1,1,-1,0,1,0,-1,-1,},', '      {-1,},', '      {0,0,-1,0,1,0,1,1,-1,-1,-1,},', '      {0,0,1,0,-1,0,-1,},', '      {0,0,0,0,0,1,0,-1,0,0,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,0,0,-1,0,0,0,1,0,1,0,0,1,-1,0,-1,-1,},', '      {0,-1,},', '      {1,-1,-1,},', '      {0,0,1,-1,-1,},', '      {0,-1,1,0,0,1,1,-1,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,0,1,-1,0,0,0,-1,},', '      {0,1,-1,0,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,-1,0,1,1,-1,0,1,0,-1,-1,},', '      {-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {0,0,0,0,1,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,-1,0,1,0,1,0,-1,1,-1,-1,},', '      {-1,},', '      {0,-1,1,0,1,0,-1,1,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,0,0,0,0,1,0,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,1,-1,0,-1,},', '      {-1,},', '      {1,-1,-1,-1,1,1,-1,1,1,-1,1,1,-1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,1,0,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,-1,0,0,1,1,0,0,-1,0,1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {0,0,0,0,0,0,0,0,0,1,0,-1,0,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,0,0,0,0,1,0,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,-1,0,1,1,0,-1,0,0,1,0,-1,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {0,0,-1,1,1,-1,0,0,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,1,0,-1,0,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {-1,},', '      {0,1,0,-1,0,-1,0,-1,1,-1,0,1,0,1,1,0,1,-1,1,-1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {0,1,0,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,-1,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,-1,0,1,0,0,1,0,-1,1,0,-1,0,-1,},', '      {0,0,0,0,1,0,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {-1,},', '      {0,-1,0,1,1,-1,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,0,1,0,-1,0,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,-1,0,0,1,1,0,1,-1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {0,0,0,-1,0,1,1,0,-1,0,0,1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {0,0,1,0,-1,0,-1,},', '      {0,-1,1,0,1,-1,0,1,-1,0,-1,},', '      {-1,},', '      {1,-1,-1,1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,0,1,-1,0,0,0,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,0,0,-1,0,1,0,1,0,-1,0,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,1,0,-1,-1,},', '      {0,-1,1,0,1,0,-1,1,-1,0,-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,0,0,0,-1,0,0,0,1,0,1,0,1,-1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,0,0,0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,0,1,-1,-1,},', '      {-1,},', '      {0,0,1,-1,0,0,-1,},', '      {1,-1,-1,},', '      {0,0,0,-1,0,1,1,1,-1,-1,-1,},', '      {-1,},', '      {0,-1,0,1,1,-1,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {0,-1,0,1,0,1,1,-1,0,-1,-1,},', '      {0,0,0,1,-1,0,0,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,0,-1,0,0,0,1,0,1,0,0,0,-1,1,0,-1,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,0,1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {-1,},', '      {1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,0,-1,},', '      {0,0,1,0,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,-1,0,1,1,-1,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,-1,0,1,0,0,1,0,-1,1,0,-1,0,-1,},', '      {-1,},', '      {0,0,-1,1,1,-1,0,0,1,-1,-1,},', '      {-1,},', '      {0,1,-1,0,-1,},', '      {0,0,-1,0,1,0,1,1,-1,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,-1,0,0,1,0,1,0,0,-1,0,1,0,-1,-1,},', '      {0,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,-1,1,0,1,0,-1,1,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,0,-1,-1,},', '      {0,0,0,0,0,0,0,0,0,0,-1,0,0,0,1,0,1,0,1,-1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,1,0,-1,0,0,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,},', '      {-1,},', '      {0,1,-1,0,-1,},', '      {0,1,-1,0,-1,},', '      {0,0,-1,1,0,0,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,-1,0,1,1,0,-1,0,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {-1,},', '      {0,0,-1,1,1,-1,0,0,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,-1,0,0,1,0,0,0,1,1,0,-1,-1,0,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,-1,0,1,1,-1,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,1,0,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {-1,},', '      {1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,-1,},', '      {-1,},', '      {0,-1,1,0,0,1,1,-1,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,1,0,-1,-1,},', '      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,-1,-1,},', '      {-1,},', '      {0,0,1,-1,-1,},', '      {1,-1,-1,},', '      {0,-1,1,0,1,-1,0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {0,-1,0,1,0,1,1,-1,0,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,-1,0,1,1,0,-1,1,0,-1,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,1,-1,0,0,0,-1,},', '      {-1,},', '      {0,0,0,0,-1,0,1,0,1,0,-1,0,1,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,0,0,0,-1,0,0,0,1,0,1,0,1,-1,0,-1,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,1,-1,0,-1,},', '      {0,0,1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,0,0,1,0,-1,0,0,0,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,-1,0,1,0,1,0,-1,0,0,1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,0,-1,0,1,0,0,0,1,1,-1,0,-1,0,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,-1,1,0,1,-1,0,1,-1,0,-1,},', '      {0,0,1,0,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,-1,0,0,1,1,0,0,-1,0,0,1,0,-1,-1,},', '      {0,0,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {0,0,1,0,-1,0,-1,0,0,-1,1,-1,1,0,1,1,1,0,-1,1,-1,-1,-1,},', '      {-1,},', '      {0,0,1,-1,0,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,-1,0,1,1,-1,0,1,0,-1,-1,},', '      {0,1,0,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,0,0,0,0,0,0,0,0,0,1,0,-1,0,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,-1,1,0,1,0,-1,1,-1,0,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {0,0,-1,1,0,1,0,-1,1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,1,-1,0,0,0,-1,},', '      {0,1,-1,0,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,1,0,-1,0,-1,-1,0,1,0,1,-1,1,0,1,0,-1,1,1,-1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {0,0,-1,1,1,-1,0,0,1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,0,0,-1,0,0,0,1,0,1,0,0,-1,1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,1,0,-1,-1,},', '      {0,0,0,0,1,-1,0,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,-1,0,1,0,0,1,0,-1,1,0,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,0,0,-1,0,1,1,0,-1,0,0,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,1,-1,0,0,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,-1,},', '      {-1,},', '      {0,1,-1,0,-1,},', '      {0,-1,0,1,0,1,1,-1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,-1,0,1,1,-1,0,0,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,-1,0,1,0,0,0,1,1,-1,-1,0,-1,},', '      {-1,},', '      {0,0,0,0,-1,0,1,0,1,0,-1,0,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,1,0,-1,0,0,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,-1,0,1,1,-1,0,1,0,-1,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,1,-1,1,-1,1,1,-1,1,-1,1,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,1,0,1,0,0,1,-1,0,-1,-1,},', '      {1,-1,-1,},', '      {0,0,1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,1,-1,0,-1,},', '      {0,0,0,0,-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,-1,0,1,0,0,0,1,1,-1,0,-1,0,-1,},', '      {0,0,0,0,0,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,-1,0,1,1,-1,0,1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {0,0,0,-1,0,1,1,1,-1,-1,-1,},', '      {0,0,0,0,1,0,-1,0,0,0,-1,},', '      {1,-1,-1,},', '      {0,0,-1,1,1,-1,0,0,1,-1,-1,},', '      {-1,},', '      {0,-1,1,0,1,-1,0,1,-1,0,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,0,-1,0,1,1,-1,0,0,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,-1,1,0,0,1,1,-1,-1,0,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,-1,0,1,1,1,-1,-1,-1,},', '      {-1,},', '      {0,0,0,1,-1,0,0,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,0,0,-1,0,0,0,1,0,1,0,0,-1,1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {0,0,-1,0,1,0,0,1,0,-1,1,0,-1,0,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,-1,0,1,1,0,-1,1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,-1,1,-1,1,1,1,1,-1,1,-1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {-1,},', '      {0,0,-1,1,1,-1,0,0,1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,0,-1,0,-1,-1,1,0,0,1,-1,1,0,1,-1,0,1,1,-1,0,-1,-1,},', '      {1,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {0,0,0,0,0,0,0,0,0,1,0,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,0,-1,0,0,1,0,1,0,0,-1,0,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {-1,},', '      {1,-1,-1,1,-1,1,-1,1,1,-1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,0,0,0,0,0,1,0,-1,0,-1,},', '      {0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,-1,0,1,1,-1,0,1,0,-1,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,0,0,-1,0,0,1,1,0,1,-1,-1,-1,},', '      {-1,},', '      {0,-1,1,0,1,-1,0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,-1,0,1,0,1,0,-1,0,0,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,-1,0,1,0,1,1,-1,0,-1,-1,},', '      {0,-1,1,0,1,-1,0,1,-1,0,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,1,-1,0,0,-1,},', '      {0,0,-1,0,1,1,0,1,-1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {-1,},', '      {0,0,0,0,-1,0,1,1,0,-1,0,0,0,1,0,-1,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,0,0,0,1,0,-1,0,0,-1,},', '      {0,1,0,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,-1,1,0,0,1,1,-1,-1,0,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,0,1,0,0,0,-1,0,-1,0,0,-1,0,1,-1,0,0,1,0,1,1,0,1,0,-1,1,-1,0,-1,-1,},', '      {0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,1,-1,0,-1,},', '      {0,0,1,-1,-1,},', '      {0,0,-1,1,1,-1,0,0,1,-1,-1,},', '      {0,0,1,-1,-1,},', '      {0,0,0,1,-1,0,0,0,-1,},', '      {1,-1,-1,},', '      {0,0,-1,1,0,1,0,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {0,-1,0,1,1,-1,0,1,0,-1,-1,},', '      {-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,-1,0,1,1,0,-1,1,0,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {-1,},', '      {1,-1,-1,1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,},', '      {-1,},', '      {0,-1,1,0,1,-1,0,1,-1,0,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,1,-1,-1,},', '      {0,-1,1,0,1,-1,0,1,-1,0,-1,},', '      {1,-1,-1,},', '      {1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,1,-1,0,0,-1,},', '      {0,1,-1,0,-1,},', '      {-1,1,1,1,-1,-1,-1,},', '      {0,0,0,1,0,-1,-1,},', '      {0,-1,0,1,1,-1,0,1,0,-1,-1,},', '      {-1,},', '      {1,-1,-1,},', '      {1,-1,-1,},', '      {0,0,0,0,-1,0,0,1,0,0,1,0,0,-1,1,0,-1,0,-1,},', '      {-1,},', '      {0,0,0,0,0,0,0,0,-1,1,0,1,0,-1,1,-1,-1,},', '      {-1,},', '      {0,-1,1,0,0,1,1,-1,-1,0,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {1,-1,-1,},', '      {-1,},', '      {0,0,0,-1,0,1,1,-1,0,0,0,1,0,-1,-1,},', '      {1,-1,-1,},', '      {-1,1,1,-1,1,-1,-1,},', '      {0,0,0,0,1,0,-1,0,-1,},', '      {0,1,-1,0,",
1,}
"['import java.util.*;', 'import java.io.*;', 'import static java.lang.Math.*;', '', 'public class Solution {', ' static class Foo53 {', '  int N;', '  int[] arr;', '  void main() {', '   BufferedReader br = null;', '   try {', '    br = new BufferedReader(new InputStreamReader(System.in));', '    String s = br.readLine();', '    N = Integer.parseInt(s.trim());', '    arr = new int[N];', '    String[] parts = br.readLine().trim().split("" "");', '    for (int i = 0; i < N; i++)', '     arr[i] = Integer.parseInt(parts[i].trim());', '    int res = foo();', '    System.out.println(res);', '   } catch (Exception e) {', '    System.out.println(e.getMessage());', '   } finally {', '    if (br != null) {', '     try { br.close(); } catch (Exception e) { }', '    }', '   }', '  }', '  boolean ok(int K) {', '   HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();', '   for (int val : arr) {', '    val &= ~((1<<K)-1);', '    if (!map.containsKey(val)) {', '     map.put(val, 1);', '    } else {', '     map.put(val, map.get(val)+1);', '    }', '   }', '   int max = 0;', '   for (int count : map.values()) {', '    max = max(max, count);', '   }', '   return max <= N/2;', '  }', '  int foo() {', '   int lo = 0, hi = 30;', '   while (lo < hi) {', '    int mid = lo + (hi-lo+1)/2;', '    if (!ok(mid))', '     hi = mid-1;', '    else', '     lo = mid;', '   }', '   if (ok(lo))', '    return lo;', '   return -1;', '  }', ' }', ' public static void main(String[] args) {', '  Foo53 foo = new Foo53();', '  foo.main();', ' }', '}']","['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', '', 'public class Solution {', '    static InputStream is;', '    static PrintWriter out;', '    static String INPUT = """";', '    ', '    static void solve()', '    {', '        int n = ni();', '        int[] a = new int[n];', '        int[] b = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        ', '        for(int k = 30;k >= 0;k--){', '            for(int i = 0;i < n;i++)b[i] = a[i] >>> k;', '            if(iskmul(b)){', '                out.println(k);', '                return;', '            }', '        }', '        out.println(-1);', '    }', '    ', '    static boolean iskmul(int[] a)', '    {', '        int n = a.length;', '        Arrays.sort(a);', '        int ct = 0;', '        int max = 1;', '        for(int i = 0;i < n;i++){', '            if(i == 0 || a[i] != a[i-1]){', '                ct = 1;', '            }else{', '                ct++;', '                max = Math.max(max, ct);', '            }', '        }', '        return max <= n/2;', '    }', '    ', '    public static void main(String[] args) throws Exception', '    {', '        long S = System.currentTimeMillis();', '        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        solve();', '        out.flush();', '        long G = System.currentTimeMillis();', '        tr(G-S+""ms"");', '    }', '    ', '    static boolean eof()', '    {', '        try {', '            is.mark(1000);', '            int b;', '            while((b = is.read()) != -1 && !(b >= 33 && b <= 126));', '            is.reset();', '            return b == -1;', '        } catch (IOException e) {', '            return true;', '        }', '    }', '        ', '    static int ni()', '    {', '        try {', '            int num = 0;', '            boolean minus = false;', ""            while((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));"", ""            if(num == '-'){"", '                num = 0;', '                minus = true;', '            }else{', ""                num -= '0';"", '            }', '            ', '            while(true){', '                int b = is.read();', ""                if(b >= '0' && b <= '9'){"", ""                    num = num * 10 + (b - '0');"", '                }else{', '                    return minus ? -num : num;', '                }', '            }', '        } catch (IOException e) {', '        }', '        return -1;', '    }', '    ', '    static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  int n = ni();', '  int[] a = na(n);', '  int mod = 1000000007;', '  long ret = 0;', '  int w = 0;', '  while(true){', '   int max = 0;', '   int maxi = -1;', '   for(int i = 0;i < n;i++){', '    if(a[i] > max){', '     max = a[i];', '     maxi = i;', '    }', '   }', '   if(max == 0){', '    if(w == 0)ret++;', '    break;', '   }', '   ', '   int h = Integer.highestOneBit(max); // to 0', '   if(w == 0 || w == h){', '    long[][][] dp = new long[n+1][2][2];', '    dp[0][w==0?0:1][0] = 1;', '    for(int i = 0;i < n;i++){', '     if(i == maxi){', '      for(int j = 0;j < 2;j++){', '       for(int k = 0;k < 2;k++){', '        dp[i+1][j][k] = dp[i][j][k];', '       }', '      }', '     }else{', '      if(a[i] < h){', '       dp[i+1][0][0] = dp[i][0][0] * (a[i]) % mod;', '       dp[i+1][1][0] = dp[i][1][0] * (a[i]) % mod;', '       dp[i+1][0][1] = (dp[i][0][1] * (a[i]+1) + dp[i][0][0]) % mod;', '       dp[i+1][1][1] = (dp[i][1][1] * (a[i]+1) + dp[i][1][0]) % mod;', '      }else{', '       dp[i+1][0][0] = (dp[i][0][0] * h + dp[i][1][0] * (a[i]-h)) % mod;', '       dp[i+1][1][0] = (dp[i][1][0] * h + dp[i][0][0] * (a[i]-h)) % mod;', '       dp[i+1][0][1] = (dp[i][0][1] * h + dp[i][1][1] * (a[i]-h+1) + dp[i][1][0]) % mod;', '       dp[i+1][1][1] = (dp[i][1][1] * h + dp[i][0][1] * (a[i]-h+1) + dp[i][0][0]) % mod;', '      }', '     }', '    }', '    ret += dp[n][0][1];', '   }', '   a[maxi] -= h;', '   w ^= h;', '  }', '  out.println(ret%mod);', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '  static final long MODULO = 1_000_000_007;', '  static int[] mi;', '', '  static int solve(int n, int k) {', '    int[][] vx = new int[n+1][32];', '    for (int i = 0; i <= 31; i++) {', '      vx[0][i] = 0;', '    }', '    ', '    int[][][] dp = new int[n+1][32][2];', '    dp[0][0][0] = 1;', '', '    for (int i = 1; i <= n; i++) {', '      for (int j = 0; j < 31; j++) {', '        vx[i][j] = (vx[i-1][j] ^ (mi[i]&(1<<j)));', '      }', '    }', '', '    boolean[] valid = new boolean[32];', '    valid[31] = true;', '', '    for (int i = 30; i >= 0; i--) {', '      valid[i] = valid[i+1] && (vx[n][i] == (k & (1<<i)));', '    }', '', '    for (int i = 1; i <= n; i++) {', '      for (int j = 0; j < 31; j++) {', '        for (int kj = 0; kj < 2; kj++) {', '          if (dp[i-1][j][kj] == 0) continue;', '', '          for (int k1 = 0; k1 < 31; k1++) {', '            if ((mi[i] & (1<<(k1))) != 0) {', '              int small, tmpj, tmpkj;', '', '              if (k1 > j) {', '                small = j;', '                tmpj = k1;', '                tmpkj = (vx[i-1][k1] != 0 ? 1 : 0);', '              } else {', '                small = k1;', '                tmpj = j;', '', '                if (k1 == j) {', '                  tmpkj = kj;', '                } else {', '                  tmpkj = kj^((mi[i] & (1<<j)) != 0 ? 1 : 0);', '                }', '              }', '', '              dp[i][tmpj][tmpkj] = (int)((dp[i][tmpj][tmpkj] + ((long) dp[i-1][j][kj]) * (1<<small)) % MODULO);', '            }', '          }', '        }', '      }', '    }', '', '    int res = 0;', '', '    for(int i = 30; i >= 0; i--) {', '      if (valid[i+1]) {', '        res = (int) ((res + dp[n][i][(k & (1<<i)) != 0 ? 1 : 0]) % MODULO);', '      } else {', '        break;', '      }', '    }', '', '    return res;', '  }', '  ', '  public static void main(String[] args) throws IOException {', '    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '    BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '    StringTokenizer st = new StringTokenizer(br.readLine());', '    int n = Integer.parseInt(st.nextToken());', '    mi = new int[n+1];', '', '    st = new StringTokenizer(br.readLine());', '    for (int i = 1; i <= n; i++) {', '      int pItem = Integer.parseInt(st.nextToken());', '      mi[i] = pItem + 1;', '    }', '', '    int result = solve(n, 0);', '', '    for(int i = 1; i <= n; i++) {', '      mi[i]--;', '    }', '    result = (int)((result + MODULO - solve(n, 0)) % MODULO);', '    ', '    bw.write(String.valueOf(result));', '    bw.newLine();', '', '    bw.close();', '    br.close();', '  }', '}']"
"['import java.io.BufferedReader;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.util.HashMap;', 'import java.util.Map;', '', 'public class Solution {', ' ', ' private static Map<Long, Long> onesCache = new HashMap<Long, Long>();', ' ', ' private static long computeOnes(long n, long div) {', '  long onesCount = 0;', '  ', '  if (onesCache.containsKey(n))', '   return onesCache.get(n);', '  else if (n == 0)', '   return 0;', '  else if (n == 1)', '   return 1;', '  ', '  long a = n / div;', '  long b = n % div;', '  ', '  if (a == 1) {', '   onesCount += b + 1;', '   onesCount += computeOnes(div - 1, div >> 1);', '  }', '  onesCount += computeOnes(b, div >> 1);', '  ', '  onesCache.put(n, onesCount);', '  ', '  return onesCount;', ' }', ' ', ' private static long computeOnes(long n) {', '  if (n < 0)', '   return -n * 32 - computeOnes(-n - 1, 1<<30);', '  else', '   return computeOnes(n, 1<<30);', ' }', '', ' /**', '  * @param args', '  * @throws IOException ', '  */', ' public static void main(String[] args) throws IOException {', '  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '  String line;', '  ', '  try {', '   line = br.readLine();', '   int tests = Integer.parseInt(line);', '   ', '   int[][] intervals = new int[tests][2];', '   for (int i=0; i < tests; i++) {', '    line = br.readLine();', '    String[] tokens = line.split("" "");', '    intervals[i][0] = Integer.parseInt(tokens[0]);', '    intervals[i][1] = Integer.parseInt(tokens[1]);', '   }', '   ', '   for (int i = 0; i < intervals.length; i++) {', '    int x = intervals[i][0];', '    int y = intervals[i][1];', '    ', '    if ((x > 0 && y > 0) || (x < 0 && y < 0)) {', '     long n1 = computeOnes(x + (x > 0 ? -1 : 0));', '     long n2 = computeOnes(y + (y < 0 ? +1 : 0));', '     System.out.println(Math.abs(n1 - n2));', '    } else {', '     long n1 = computeOnes(x);', '     long n2 = computeOnes(y);', '     System.out.println(n1 + n2);', '    }', '   }', '  } catch (IOException e) {', '   e.printStackTrace();', '  } finally {', '   br.close();', '  }', ' }', '', '}']","['import java.io.BufferedReader;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.util.HashMap;', 'import java.util.Map;', '', 'public class Solution {', '    ', '    private static Map<Long, Long> onesCache = new HashMap<Long, Long>();', '    ', '    private static long computeOnes(long n, long div) {', '        long onesCount = 0;', '        ', '        if (onesCache.containsKey(n))', '            return onesCache.get(n);', '        else if (n == 0)', '            return 0;', '        else if (n == 1)', '            return 1;', '        ', '        long a = n / div;', '        long b = n % div;', '        ', '        if (a == 1) {', '            onesCount += b + 1;', '            onesCount += computeOnes(div - 1, div >> 1);', '        }', '        onesCount += computeOnes(b, div >> 1);', '        ', '        onesCache.put(n, onesCount);', '        ', '        return onesCount;', '    }', '    ', '    private static long computeOnes(long n) {', '        if (n < 0)', '            return -n * 32 - computeOnes(-n - 1, 1<<30);', '        else', '            return computeOnes(n, 1<<30);', '    }', '', '    /**', '     * @param args', '     * @throws IOException ', '     */', '    public static void main(String[] args) throws IOException {', '        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '        String line;', '        ', '        try {', '            line = br.readLine();', '            int tests = Integer.parseInt(line);', '            ', '            int[][] intervals = new int[tests][2];', '            for (int i=0; i < tests; i++) {', '                line = br.readLine();', '                String[] tokens = line.split("" "");', '                intervals[i][0] = Integer.parseInt(tokens[0]);', '                intervals[i][1] = Integer.parseInt(tokens[1]);', '            }', '            ', '            for (int i = 0; i < intervals.length; i++) {', '                int x = intervals[i][0];', '                int y = intervals[i][1];', '                ', '                if ((x > 0 && y > 0) || (x < 0 && y < 0)) {', '                    long n1 = computeOnes(x + (x > 0 ? -1 : 0));', '                    long n2 = computeOnes(y + (y < 0 ? +1 : 0));', '                    System.out.println(Math.abs(n1 - n2));', '                } else {', '                    long n1 = computeOnes(x);', '                    long n2 = computeOnes(y);', '                    System.out.println(n1 + n2);', '                }', '            }', '        } catch (IOException e) {', '            e.printStackTrace();', '        } finally {', '            br.close();', '        }', '    }', '', '}']"
"['import java.io.*;', 'import java.util.Random;', 'import java.util.StringTokenizer;', '', 'public class Solution {', '', '    // leave empty to read from stdin/stdout', '    private static final String TASK_NAME_FOR_IO = """";', '', '    // file names', '    private static final String FILE_IN = TASK_NAME_FOR_IO + "".in"";', '    private static final String FILE_OUT = TASK_NAME_FOR_IO + "".out"";', '', '    BufferedReader in;', '    PrintWriter out;', '    StringTokenizer tokenizer = new StringTokenizer("""");', '', '    public static void main(String[] args) {', '        new Solution().run();', '    }', '', '    int n;', '    int[] a, b, c;', '', '    private void solve() throws IOException {', '        // stress();', '        // timing();', '', '        n = nextInt();', '        int q = nextInt();', '', '        n++;', '        a = toArray(nextToken());', '        b = toArray(nextToken());', '        c = sum(a, b);', '', '        initFastStructures();', '', '        for (int k = 0; k < q; k++) {', '            String command = nextToken();', '', '            if (""set_a"".equals(command)) {', '', '                int idx = nextInt();', '                int value = nextInt();', '                setSummandBitAndChangeSumFast(a, idx, value);', '', '            } else if (""set_b"".equals(command)) {', '', '                int idx = nextInt();', '                int value = nextInt();', '                setSummandBitAndChangeSumFast(b, idx, value);', '', '            } else {', '', '                int idx = nextInt();', '                int value = getSumNumberOfDigitsToTheRight(idx, 1) > 0 ? 1 : 0;', '                out.print(value);', '', '            }', '', '        }', '    }', '', '    Random r = new Random(123456789L);', '', '    private int randomInt(int lo, int hi) {', '        return lo + r.nextInt(hi - lo + 1);', '    }', '', '    private int[] randomBitArray() {', '        int[] result = new int[n];', '        // the last bit is always empty', '        for (int i = 0; i < n - 1; i++) {', '            result[i] = randomInt(0, 1);', '        }', '        return result;', '    }', '', '    private void stress() throws IOException {', '        for (; ; ) {', '            n = randomInt(10, 20);', '            int bitChanges = randomInt(100000, 100000);', '', '            System.out.println(""N = "" + n + "", BitChanges = "" + bitChanges);', '', '            n++;', '            a = randomBitArray();', '            b = randomBitArray();', '            c = sum(a, b);', '', '            initFastStructures();', '', '            for (int k = 0; k < bitChanges; k++) {', '                int command = randomInt(0, 1);', '', '                if (command == 0) {', '', '                    int idx = randomInt(0, n - 2);', '                    int value = 1 - a[idx];', '                    setSummandBitAndChangeSumFast(a, idx, value);', '', '                } else {', '', '                    int idx = randomInt(0, n - 2);', '                    int value = 1 - b[idx];', '                    setSummandBitAndChangeSumFast(b, idx, value);', '', '                }', '', '                // validate all bits', '                c = sum(a, b);', '                for (int idx = 0; idx < n; idx++) {', '                    int vSlow = c[idx];', '                    int vFast = getSumNumberOfDigitsToTheRight(idx, 1) > 0 ? 1 : 0;', '                    if (vSlow != vFast) {', '                        throw new IllegalStateException(""Step "" + k + "": difference in bit "" + idx + "" out of "" + n);', '                    }', '                }', '', '            }', '        }', '    }', '', '    private void timing() throws IOException {', '        n = 100000;', '        int q = 500000;', '', '        n++;', '        a = randomBitArray();', '        b = randomBitArray();', '        c = sum(a, b);', '', '        initFastStructures();', '', '        for (int k = 0; k < q; k++) {', '            int command = randomInt(0, 2);', '', '            if (command == 0) {', '', '                int idx = randomInt(0, n - 2);', '                int value = 1 - a[idx];', '                setSummandBitAndChangeSumFast(a, idx, value);', '', '            } else if (command == 1) {', '', '                int idx = randomInt(0, n - 2);', '                int value = 1 - b[idx];', '                setSummandBitAndChangeSumFast(b, idx, value);', '', '            } else {', '', '                int idx = randomInt(0, n - 2);', '                getSumNumberOfDigitsToTheRight(idx, 1);', '', '            }', '', '        }', '', '    }', '', '    private void setSummandBitAndChangeSumFast(int[] summand, int idx, int value) {', '', '        if (summand[idx] == 0) {', '', '            if (value == 0) {', '                // do nothing, no bit change', '            } else {', '                summand[idx] = 1;', '                increaseSumFast(idx);', '            }', '', '        } else {', '', '            if (value == 1) {', '                // do nothing, no bit change', '            } else {', '                summand[idx] = 0;', '                decreaseSumFast(idx);', '            }', '', '        }', '', '    }', '', '    private void increaseSumFast(int idx) {', '', '        // 0 -> 1                (numberOfOnes = 0)', '        // 11111110 -> 00000001  (numberOfOnes > 0)', '', '        int numberOfOnes = getSumNumberOfDigitsToTheRight(idx, 1);', '        inverseSumBits(idx, idx + numberOfOnes);', '', '    }', '', '    private void decreaseSumFast(int idx) {', '', '        // 1 -> 0                (numberOfOnes = 0)', '        // 00000001 -> 10000000  (numberOfOnes > 0)', '', '        int numberOfZeroes = getSumNumberOfDigitsToTheRight(idx, 0);', '        inverseSumBits(idx, idx + numberOfZeroes);', '', '    }', '', ""    // inverses all bits in ['lo', 'hi'] range"", '    private void inverseSumBits(int idxLo, int idxHi) {', '        inverseTree(1, 0, tSize - 1, idxLo, idxHi);', '    }', '', ""    // returns the number of consecutive digit 'digit' to the right of 'idx'"", '    private int getSumNumberOfDigitsToTheRight(int idx, int digit) {', '        return searchTree(1, 0, tSize - 1, idx, tSize - 1, digit);', '    }', '', '    // converts string to number', '    private int[] toArray(String s) {', '        int[] result = new int[n];', '        for (int i = 0; i < s.length(); i++) {', ""            result[i] = s.charAt(s.length() - (i + 1)) - '0';"", '        }', '        return result;', '    }', '', '    // calculates sum of a and b. the sum will always fit into the length', '    private int[] sum(int[] a, int[] b) {', '        int[] result = new int[n];', '        for (int i = 0, carry = 0; i < n; i++) {', '            int d = a[i] + b[i] + carry;', '            result[i] = d & 1;', '            carry = d >> 1;', '        }', '        return result;', '    }', '', '    int tSize;', '    TreeNode[] md;', '', '    class TreeNode {', '', '        boolean needToInverseChildren;', '', '        boolean isLeaf;', '        int lo, hi, len;', '        int[] cntToRight = new int[2];', '', '        TreeNode(boolean isLeaf, int lo, int hi) {', '            this.isLeaf = isLeaf;', '            this.lo = lo;', '            this.hi = hi;', '            this.len = hi - lo + 1;', '        }', '', '        void inverse() {', '            int t = cntToRight[0];', '            cntToRight[0] = cntToRight[1];', '            cntToRight[1] = t;', '', '            needToInverseChildren = !needToInverseChildren;', '            if (isLeaf) {', '                needToInverseChildren = false;', '            }', '        }', '', '        void recalc(TreeNode l, TreeNode r) {', '            for (int i = 0; i <= 1; i++) {', '                cntToRight[i] = l.cntToRight[i];', '                if (l.cntToRight[i] == l.len) {', '                    cntToRight[i] += r.cntToRight[i];', '                }', '            }', '        }', '', '    }', '', '    private void doPushdown(int k) {', '        if (md[k].needToInverseChildren) {', '            {', '                int posL = k << 1;', '                md[posL].inverse();', '            }', '', '            {', '                int posR = (k << 1) + 1;', '                md[posR].inverse();', '            }', '', '            md[k].needToInverseChildren = false;', '        }', '    }', '', '    private int searchTree(int k, int a, int b, int lo, int hi, int digit) {', '        if (hi < a || lo > b || a > b || lo > hi) {', '            return 0;', '        }', '', '        if (a == lo && b == hi) {', '            return md[k].cntToRight[digit];', '        }', '', '        int posL = k << 1;', '        int posR = posL + 1;', '        int mid = (a + b) / 2;', '', '        doPushdown(k);', '        int cntL = searchTree(posL, a, mid, lo, Math.min(hi, mid), digit);', '        int cntR = searchTree(posR, mid + 1, b, Math.max(lo, mid + 1), hi, digit);', '        md[k].recalc(md[posL], md[posR]);', '', '        int result = cntL;', '        int lenL = Math.max(Math.min(hi, mid) - lo + 1, 0);', '        if (cntL == lenL) {', '            result += cntR;', '        }', '        return result;', '    }', '', '    private void inverseTree(int k, int a, int b, int lo, int hi) {', '        if (hi < a || lo > b || a > b || lo > hi) {', '            return;', '        }', '', '        doPushdown(k);', '', '        if (a == lo && b == hi) {', '            // inverse', '            md[k].inverse();', '            return;', '        }', '', '        int posL = k << 1;', '        int posR = posL + 1;', '        int mid = (a + b) / 2;', '        inverseTree(posL, a, mid, lo, Math.min(hi, mid));', '        inverseTree(posR, mid + 1, b, Math.max(lo, mid + 1), hi);', '        md[k].recalc(md[posL], md[posR]);', '    }', '', '    private TreeNode buildTree(int k, int a, int b) {', '        if (k >= tSize) {', '            int kIdx = k - tSize;', '            if (kIdx < n) {', '                // we are hitting a real node, so see what bit is that', '                md[k] = new TreeNode(true, a, b);', '                md[k].cntToRight[c[kIdx]]++;', '            } else {', '                // fake zero node', '                md[k] = new TreeNode(true, a, b);', '                md[k].cntToRight[0]++;', '            }', '            return md[k];', '        }', '', '        int mid = (a + b) / 2;', '        TreeNode l = buildTree(k << 1, a, mid);', '        TreeNode r = buildTree((k << 1) + 1, mid + 1, b);', '        md[k] = new TreeNode(false, a, b);', '        md[k].recalc(l, r);', '        return md[k];', '    }', '', '    private void initFastStructures() {', '        // build a tree out of d^p products', '        tSize = 1;', '        while (tSize < n) {', '            tSize <<= 1;', '        }', '', '        //  1   2 3     4 5 6 7', '        // [tsize - 1]  [tsize]', '        int alloc = tSize << 1;', '        md = new TreeNode[alloc];', '        buildTree(1, 0, tSize - 1);', '    }', '', '    public void run() {', '        long timeStart = System.currentTimeMillis();', '', '        boolean fileIO = TASK_NAME_FOR_IO.length() > 0;', '        try {', '', '            if (fileIO) {', '                in = new BufferedReader(new FileReader(FILE_IN));', '                out = new PrintWriter(new BufferedWriter(new FileWriter(FILE_OUT)));', '            } else {', '                in = new BufferedReader(new InputStreamReader(System.in));', '                out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));', '            }', '', '            solve();', '', '            in.close();', '            out.close();', '        } catch (IOException e) {', '            throw new IllegalStateException(e);', '        }', '        long timeEnd = System.currentTimeMillis();', '', '        if (fileIO) {', '            System.out.println(""Time spent: "" + (timeEnd - timeStart) + "" ms"");', '        }', '    }', '', '    private String nextToken() throws IOException {', '        while (!tokenizer.hasMoreTokens()) {', '            String line = in.readLine();', '            if (line == null) {', '                return null;', '            }', '            tokenizer = new StringTokenizer(line);', '        }', '        return tokenizer.nextToken();', '    }', '', '    private int nextInt() throws IOException {', '        return Integer.parseInt(nextToken());', '    }', '', '}']","['import java.io.BufferedReader;', 'import java.io.InputStreamReader;', 'import java.util.StringTokenizer;', '', 'class ChangingBitsDataSet {', '    ', '    private static int ADDRESS_BITS = 6;', '    private static int MASK = (1 << ADDRESS_BITS) - 1;', '    ', '    private static void setBit(long[] data, int index, int value) {', '        int highi = index >>> ADDRESS_BITS;', '        int lowi = index & MASK;', '        long mask = 1L << lowi;', '        if (value == 0) {', '            data[highi] &= ~mask;', '        }', '        else {', '            data[highi] |= mask;            ', '        }', '    }', '    ', '    private long[] a;', '    private long[] b;', '    private long[] sum;', '    ', '    public ChangingBitsDataSet(int length, String aString, String bString) {', '        a = new long[1 + (length >>> ADDRESS_BITS)];', '        b = new long[1 + (length >>> ADDRESS_BITS)];', '        sum = new long[1 + (length >>> ADDRESS_BITS)];', '        int carryFlag = 0;', '        for (int i = length - 1, bitIndex = 0; i >= 0; i--, bitIndex++) {', ""            int aBit = aString.charAt(i) - '0';"", ""            int bBit = bString.charAt(i) - '0';"", '            int s = aBit + bBit + carryFlag;', '            int sumBit = s & 1;', '            carryFlag = (s & 2) >>> 1;', '            setBit(a, bitIndex, aBit);', '            setBit(b, bitIndex, bBit);', '            setBit(sum, bitIndex, sumBit);', '        }', '        setBit(sum, length, carryFlag);', '    }', '', '    private void add(int index) {', '        int highi = index >>> ADDRESS_BITS;', '        int lowi = index & MASK;', '        long block = sum[highi];', '        if ((~block >>> lowi) == 0L) {', '            block ^= -1L << lowi;', '            sum[highi++] = block;', '            while (sum[highi] == -1L) {', '                sum[highi++] = 0L;', '            }', '            block = sum[highi];', '            lowi = 0;', '        }', '        while (((block >>> lowi) & 1) == 1) {', '            block ^= 1L << lowi;', '            lowi++;', '        }', '        block ^= 1L << lowi;', '        sum[highi] = block;', '    }', '    ', '    private void sub(int index) {', '        int highi = index >>> ADDRESS_BITS;', '        int lowi = index & MASK;', '        long block = sum[highi];', '        if ((block >>> lowi) == 0L) {', '            block ^= -1L << lowi;', '            sum[highi++] = block;', '            while (sum[highi] == 0L) {', '                sum[highi++] = -1L;', '            }', '            block = sum[highi];', '            lowi = 0;', '        }', '        while (((block >>> lowi) & 1) == 0) {', '            block ^= 1L << lowi;', '            lowi++;', '        }', '        block ^= 1L << lowi;', '        sum[highi] = block;', '    }', '    ', '    private void set(long[] data, int index, int value) {', '        int highi = index >>> ADDRESS_BITS;', '        int lowi = index & MASK;', '        int oldValue = (int) (data[highi] >>> lowi) & 1;', '        if (oldValue == 0 & value == 1) {', '            data[highi] ^= 1L << lowi;', '            add(index);', '        }', '        else if (oldValue == 1 & value == 0) {', '            data[highi] ^= 1L << lowi;', '            sub(index);', '        }', '    }', '    ', '    public void setA(int index, int value) {', '        set(a, index, value);', '    }', '    ', '    public void setB(int index, int value) {', '        set(b, index, value);', '    }', '    ', '    public int getC(int index) {', '        int highi = index >>> ADDRESS_BITS;', '        int lowi = index & MASK;', '        return (int)(sum[highi] >>> lowi) & 1;', '    }', '}', '', 'public class Solution {', '    static private String OPERATION_SET_A = ""set_a"";', '    static private String OPERATION_SET_B = ""set_b"";', '    static private String OPERATION_GET_C = ""get_c"";', '    ', '    static public void main(String[] args) {', '        try {', '            BufferedReader br = new BufferedReader(new InputStreamReader(System.in), 64 << 10);', '            StringTokenizer tokenizer = new StringTokenizer(br.readLine());', '            int n = Integer.parseInt(tokenizer.nextToken());', '            int q = Integer.parseInt(tokenizer.nextToken());', '            String a = br.readLine();', '            String b = br.readLine();', '            ChangingBitsDataSet dataset = new ChangingBitsDataSet(n, a, b);', '            StringBuilder result = new StringBuilder(n);', '            for (int i = 0; i < q; i++) {', '                tokenizer = new StringTokenizer(br.readLine());', '                String operation = tokenizer.nextToken();', '                if (OPERATION_SET_A.equals(operation)) {', '                    dataset.setA(Integer.parseInt(tokenizer.nextToken()), Integer.parseInt(tokenizer.nextToken()));', '                }', '                else if (OPERATION_SET_B.equals(operation)){', '                    dataset.setB(Integer.parseInt(tokenizer.nextToken()), Integer.parseInt(tokenizer.nextToken()));                    ', '                }', '                else if (OPERATION_GET_C.equals(operation)){', '                    result.append(dataset.getC(Integer.parseInt(tokenizer.nextToken())));', '                }', '            }', '            System.out.println(result);', '        }', '        catch (Exception e) {', '            System.err.println(""Error:"" + e.getMessage());', '        }', '    }', '}']"
"['import java.io.*;', 'import java.util.Random;', 'import java.util.StringTokenizer;', '', 'public class Solution implements Runnable {', '', '    // leave empty to read from stdin/stdout', '    private static final String TASK_NAME_FOR_IO = """";', '', '    // file names', '    private static final String FILE_IN = TASK_NAME_FOR_IO + "".in"";', '    private static final String FILE_OUT = TASK_NAME_FOR_IO + "".out"";', '', '    BufferedReader in;', '    PrintWriter out;', '    StringTokenizer tokenizer = new StringTokenizer("""");', '', '    public static void main(String[] args) {', '        new Solution().run();', '    }', '', '    int n, tSize;', '    short[] a;', '    Tree[] md;', '', '    class Tree {', '', '        short[] p;', '', '        public Tree(short v) {', '            p = new short[] {v};', '        }', '', '        @SuppressWarnings({""ConstantConditions""})', '        public Tree(Tree l, Tree r) {', '            int cnt = (l != null ? l.p.length : 0) + (r != null ? r.p.length : 0);', '            p = new short[cnt];', '', '            int lIdx = 0;', '            int rIdx = 0;', '            for (int i = 0; i < cnt; i++) {', '                int lElem = (l != null && lIdx < l.p.length) ? l.p[lIdx] : Integer.MAX_VALUE;', '                int rElem = (r != null && rIdx < r.p.length) ? r.p[rIdx] : Integer.MAX_VALUE;', '                p[i] = (lElem < rElem) ? l.p[lIdx++] : r.p[rIdx++];', '            }', '        }', '', '    }', '', '    private void solve() throws IOException {', '        int tc = nextInt();', '        for (int tcIdx = 0; tcIdx < tc; tcIdx++) {', '            n = nextInt();', '            int m = nextInt();', '', '            a = new short[n];', '            for (int i = 0; i < n; i++) {', '                a[i] = (short) nextInt();', '            }', '', '            buildTree();', '', '            for (int i = 0; i < m; i++) {', '                int x = nextInt();', '                int l = nextInt() - 1;', '                int r = nextInt() - 1;', '                int answerFast = solveFast(x, l, r);', '                out.println(answerFast);', '            }', '        }', '', '        /*', '        for (int tcIdx = 0; tcIdx < 666; tcIdx++) {', '            stress();', '        }', '        */', '    }', '', '    Random r = new Random(1234567789L);', '', '    private void stress() {', '        n = 1000;', '        a = new short[n];', '', '        int m = 50000;', '', '        for (int i = 0; i < n; i++) {', '            a[i] = (short) r.nextInt(1 << 15);', '        }', '', '        buildTree();', '', '        boolean failed = false;', '        for (int i = 0; i < m; i++) {', '            int x = r.nextInt(1 << 15);', '', '            int lo = r.nextInt(n / 100);', '            int hi = n / 100 + r.nextInt(n - n / 100);', '', '            // lo = 1;', '            // hi = 98302;', '', '            if (lo > hi) {', '                int t = lo; lo = hi; hi = t;', '            }', '', '            try {', '                int p1 = solveFast(x, lo, hi);', '                int p2 = solveNaive(x, lo, hi);', '                if (p1 != p2) {', '                    throw new IllegalStateException(p1 + "" vs. "" + p2);', '                }', '            } catch (Exception e) {', '                e.printStackTrace();', '', '                System.err.println(""1"");', '                System.err.println(n + "" "" + 1);', '                for (int j = 0; j < n; j++) {', '                    System.err.print(a[j] + "" "");', '                }', '                System.err.println();', '                System.err.println(x + "" "" + lo + "" "" + hi);', '                System.err.flush();', '                failed = true;', '                break;', '            }', '        }', '', '        if (failed) {', '            throw new IllegalStateException(""FAILED"");', '        }', '        System.out.println(""OK"");', '    }', '', '    private void buildTree() {', '        tSize = 1;', '        while (tSize < n) {', '            tSize <<= 1;', '        }', '', '        //  1   2 3     4 5 6 7', '        // [tsize - 1]  [tsize]', '        int alloc = tSize << 1;', '        md = new Tree[alloc];', '        build(1);', '    }', '', '    private void build(int pos) {', '        if (pos - tSize >= 0) {', '            if (pos - tSize < n) {', '                md[pos] = new Tree(a[pos - tSize]);', '            }', '            return;', '        }', '', '        int l = pos << 1;', '        int r = l + 1;', '', '        build(l);', '        build(r);', '        md[pos] = new Tree(md[l], md[r]);', '    }', '', '    int LOW_THRESHOLD = 1 << 6;', '', '    int foundSegmentsIdx;', '    Tree[] foundSegments = new Tree[1 << 10];', '    int[] ll = new int[1 << 10];', '    int[] rr = new int[1 << 10];', '', '    @SuppressWarnings({""ToArrayCallWithZeroLengthArrayArgument""})', '    private int solveFast(int x, int lo, int hi) {', '        // split [lo,hi] into segments with increasing length', '        foundSegmentsIdx = 0;', '        searchSegments(1, 0, tSize - 1, lo, hi);', '', '        // do not filter out anything, assign as is', '        int m = foundSegmentsIdx;', '        Tree[] segments = foundSegments;', '', '        // fill in left and right boundaries', '        for (int i = 0; i < m; i++) {', '            ll[i] = 0;', '            rr[i] = segments[i].p.length - 1;', '        }', '', '        // go through all bits and adjust', '        int answer = 0;', '        for (int bitIdx = 14; bitIdx >= 0; bitIdx--) {', '            int singleBitMask = 1 << bitIdx;', '', '            // find first and last element', '            int v1 = Integer.MAX_VALUE;', '            int v2 = Integer.MIN_VALUE;', '            int total = 0;', '', '            // next segments', '            int nextSegmentsIdx = 0;', '            for (int i = 0; i < m; i++) {', '                int length = rr[i] - ll[i] + 1;', '', ""                // we shouldn't have any empty segments here"", '                if (length <= 0) {', '                    throw new IllegalStateException();', '                }', '', '                // calculate using a trivial approach for short segments', '                short[] v = segments[i].p;', '                if (length < LOW_THRESHOLD) {', '                    for (int j = ll[i]; j <= rr[i]; j++) {', '                        int t = x ^ v[j];', '                        if (t > answer) {', '                            answer = t;', '                        }', '                    }', '                    continue;', '                }', '', '                // calculate min/max values', '                v1 = Math.min(v1, v[ll[i]]);', '                v2 = Math.max(v2, v[rr[i]]);', '                total += length;', '', '                if (i != nextSegmentsIdx) {', '                    segments[nextSegmentsIdx] = segments[i];', '                    ll[nextSegmentsIdx] = ll[i];', '                    rr[nextSegmentsIdx] = rr[i];', '                }', '                nextSegmentsIdx++;', '            }', '            m = nextSegmentsIdx;', '', '            // shall we even proceed?', '            if (total <= 0) {', '                break;', '            }', '', '            // if the bits are equal, then we are just skipping the iteration as there is nothing to remove', '            if ((v1 & singleBitMask) == (v2 & singleBitMask)) {', '                continue;', '            }', '', '            // otherwise, there are elements that needs to be thrown away', '            if ((x & singleBitMask) == 0) {', '', '                // need to retain only ones', '                //         [     ]', '                // 0 0 0 0 1 1 1 1', '', '                nextSegmentsIdx = 0;', '                for (int i = 0; i < m; i++)', '                    if (ll[i] <= rr[i]) {', '                        // the segment is not empty', '                        short[] v = segments[i].p;', '                        int L = ll[i];', '                        int R = rr[i];', '', '                        int bitL = v[L] & singleBitMask;', '                        int bitR = v[R] & singleBitMask;', '                        if (bitL == bitR) {', '                            if (bitL != 0) {', '                                // we have all one bits, and have to retain them', '                                if (i != nextSegmentsIdx) {', '                                    segments[nextSegmentsIdx] = segments[i];', '                                    ll[nextSegmentsIdx] = ll[i];', '                                    rr[nextSegmentsIdx] = rr[i];', '                                }', '                                nextSegmentsIdx++;', '                            }', '                            continue;', '                        }', '', '                        // there is a median in the middle', '                        while (L < R) {', '                            int M = (L + R) >> 1;', '                            if ((v[M] & singleBitMask) == 0) {', '                                L = M + 1;', '                            } else {', '                                R = M;', '                            }', '                        }', '', '                        /*', '                        if ((v[L] & singleBitMask) == 0) {', '                            throw new IllegalStateException(""Median should point at the first non-zero"");', '                        }', '                        if ((v[L - 1] & singleBitMask) != 0) {', '                            throw new IllegalStateException(""Incorrect median found"");', '                        }', '                        */', '', '                        // we have to retain ones, so discard all ELEMENTS in CURRENT SEGMENT to the left', '                        ll[i] = L;', '', '                        if (i != nextSegmentsIdx) {', '                            segments[nextSegmentsIdx] = segments[i];', '                            ll[nextSegmentsIdx] = ll[i];', '                            rr[nextSegmentsIdx] = rr[i];', '                        }', '                        nextSegmentsIdx++;', '                    }', '                m = nextSegmentsIdx;', '                // end of a case where we are retaining ones', '            } else {', '                // need to retain only zeroes', '                // [     ]', '                // 0 0 0 0 1 1 1 1', '', '                nextSegmentsIdx = 0;', '                for (int i = 0; i < m; i++)', '                    if (ll[i] <= rr[i]) {', '                        // the segment is not empty', '                        short[] v = segments[i].p;', '                        int L = ll[i];', '                        int R = rr[i];', '                        int bitL = v[L] & singleBitMask;', '                        int bitR = v[R] & singleBitMask;', '                        if (bitL == bitR) {', '                            if (bitL == 0) {', '                                // we have all zero bits, and have to retain them', '                                if (i != nextSegmentsIdx) {', '                                    segments[nextSegmentsIdx] = segments[i];', '                                    ll[nextSegmentsIdx] = ll[i];', '                                    rr[nextSegmentsIdx] = rr[i];', '                                }', '                                nextSegmentsIdx++;', '                            }', '                            continue;', '                        }', '', '                        // there is a median in the middle', '                        while (L < R) {', '                            int M = (L + R) >> 1;', '                            if ((v[M] & singleBitMask) == 0) {', '                                L = M + 1;', '                            } else {', '                                R = M;', '                            }', '                        }', '', '                        /*', '                        if ((v[L] & singleBitMask) == 0) {', '                            throw new IllegalStateException(""Median should point at the first non-zero"");', '                        }', '                        if ((v[L - 1] & singleBitMask) != 0) {', '                            throw new IllegalStateException(""Incorrect median found"");', '                        }', '                        */', '', '                        // we have to retain zeroes, so discard all ELEMENTS in CURRENT SEGMENT to the right', '                        rr[i] = L - 1;', '', '                        if (i != nextSegmentsIdx) {', '                            segments[nextSegmentsIdx] = segments[i];', '                            ll[nextSegmentsIdx] = ll[i];', '                            rr[nextSegmentsIdx] = rr[i];', '                        }', '                        nextSegmentsIdx++;', '                    }', '                m = nextSegmentsIdx;', '            } // end of a case where we are retaining zeroes', '', '        }', '', '        // see if there is still something left', '        for (int i = 0; i < m; i++)', '            if (ll[i] <= rr[i]) {', '                answer = Math.max(answer, x ^ segments[i].p[ll[i]]);', '            }', '        return answer;', '    }', '', '    private void searchSegments(int pos, int A, int B, int lo, int hi) {', '        if (hi < A || lo > B || A > B || lo > hi) {', '            return;', '        }', '', '        if (A == lo && B == hi) {', '            foundSegments[foundSegmentsIdx++] = md[pos];', '            return;', '        }', '', '        int posL = pos << 1;', '        int posR = posL + 1;', '        int mid = (A + B) / 2;', '', '        searchSegments(posL, A, mid, lo, Math.min(hi, mid));', '        searchSegments(posR, mid + 1, B, Math.max(lo, mid + 1), hi);', '    }', '', '    private int solveNaive(int x, int l, int r) {', '        int result = 0;', '        for (int i = l; i <= r; i++) {', '            result = Math.max(result, x ^ a[i]);', '        }', '        return result;', '    }', '', '    public void run() {', '        long timeStart = System.currentTimeMillis();', '', '        boolean fileIO = TASK_NAME_FOR_IO.length() > 0;', '        try {', '', '            if (fileIO) {', '                in = new BufferedReader(new FileReader(FILE_IN));', '                out = new PrintWriter(new FileWriter(FILE_OUT));', '            } else {', '                in = new BufferedReader(new InputStreamReader(System.in));', '                out = new PrintWriter(new OutputStreamWriter(System.out));', '            }', '', '            solve();', '', '            in.close();', '            out.close();', '        } catch (IOException e) {', '            throw new IllegalStateException(e);', '        }', '        long timeEnd = System.currentTimeMillis();', '', '        if (fileIO) {', '            System.out.println(""Time spent: "" + (timeEnd - timeStart) + "" ms"");', '        }', '    }', '', '    private String nextToken() throws IOException {', '        while (!tokenizer.hasMoreTokens()) {', '            String line = in.readLine();', '            if (line == null) {', '                return null;', '            }', '            tokenizer = new StringTokenizer(line);', '        }', '        return tokenizer.nextToken();', '    }', '', '    private int nextInt() throws IOException {', '        return Integer.parseInt(nextToken());', '    }', '', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class B {', '', '    static int MAX = 15;', '', '    public static void main(String[] args) throws IOException {', '        Scanner sc = new Scanner();', '        PrintWriter out = new PrintWriter(System.out);', '        int tc = sc.nextInt();', '        while (tc-- > 0) {', '            int n = sc.nextInt(), q = sc.nextInt();', '            Trie trie = new Trie();', '            for (int i = 1; i <= n; i++) {', '                trie.insert(sc.nextInt(), i);', '            }', '            trie.sort();', '            while (q-- > 0) {', '                out.println(trie.query(sc.nextInt(), sc.nextInt(), sc.nextInt()));', '            }', '        }', '', '        out.close();', '', '    }', '', '    static class node {', '        ArrayList<Integer> indices;', '        node one, zero;', '', '        node() {', '            indices = new ArrayList();', '        }', '', '        void createChild(int t) {', '            if (t == 0) {', '                if (zero == null)', '                    zero = new node();', '            } else if (one == null) {', '                one = new node();', '            }', '        }', '', '        boolean has(int l, int r) {', '            int lo = 0, hi = indices.size() - 1;', '            while (lo <= hi) {', '                int mid = lo + hi >> 1;', '                int curr = indices.get(mid);', '                if (curr < l) {', '                    lo = mid + 1;', '                } else if (curr <= r)', '                    return true;', '                else', '                    hi = mid - 1;', '', '            }', '            return false;', '        }', '', '        void sort() {', '            Collections.sort(indices);', '            if (one != null)', '                one.sort();', '            if (zero != null)', '                zero.sort();', '        }', '    }', '', '    static class Trie {', '        node root;', '', '        Trie() {', '            root = new node();', '        }', '', '        void sort() {', '            root.sort();', '        }', '', '        void insert(int x, int idx) {', '            insert(x, root, idx, MAX);', '        }', '', '        void insert(int x, node node, int idx, int bit) {', '            if (node != root) {', '                node.indices.add(idx);', '            }', '            if (bit == -1)', '                return;', '            int currBit = ((x & (1 << bit)) == 0) ? 0 : 1;', '            node.createChild(currBit);', '            insert(x, currBit == 0 ? node.zero : node.one, idx, bit - 1);', '', '        }', '', '        int query(int x, int l, int r) {', '            return query(x, l, r, root, MAX);', '        }', '', '        int query(int x, int l, int r, node node, int bit) {', '            if (bit == -1)', '                return 0;', '            int best = (x & 1 << bit) == 0 ? 1 : 0;', '            node child = best == 0 ? node.zero : node.one;', '            if (child != null && child.has(l, r)) {', '                return (1 << bit) + query(x, l, r, child, bit - 1);', '            } else {', '                return query(x, l, r, best == 0 ? node.one : node.zero, bit - 1);', '', '            }', '        }', '    }', '', '    static class Scanner {', '        BufferedReader br;', '        StringTokenizer st;', '', '        Scanner() {', '            br = new BufferedReader(new InputStreamReader(System.in));', '        }', '', '        Scanner(String fileName) throws FileNotFoundException {', '            br = new BufferedReader(new FileReader(fileName));', '        }', '', '        String next() throws IOException {', '            while (st == null || !st.hasMoreTokens())', '                st = new StringTokenizer(br.readLine());', '            return st.nextToken();', '        }', '', '        String nextLine() throws IOException {', '            return br.readLine();', '        }', '', '        int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        long nextLong() throws NumberFormatException, IOException {', '            return Long.parseLong(next());', '        }', '', '        double nextDouble() throws NumberFormatException, IOException {', '            return Double.parseDouble(next());', '        }', '', '        boolean ready() throws IOException {', '            return br.ready();', '        }', '', '    }', '', '    static void sort(int[] a) {', '        shuffle(a);', '        Arrays.sort(a);', '    }', '', '    static void shuffle(int[] a) {', '        int n = a.length;', '        Random rand = new Random();', '        for (int i = 0; i < n; i++) {', '            int tmpIdx = rand.nextInt(n);', '            int tmp = a[i];', '            a[i] = a[tmpIdx];', '            a[tmpIdx] = tmp;', '        }', '    }', '', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'public class C {', '', '    BufferedReader br;', '    PrintWriter out;', '    StringTokenizer st;', '    boolean eof;', '', '    void solve() throws IOException {', '        int n = nextInt();', '        int q = nextInt();', '        ', '        int[] b = new int[n + 1];', '        for (int i = 0; i < n; i++) {', '            int x = nextInt();', '            b[i + 1] = b[i] ^ x;', '        }', '        ', '        int[] c = new int[n + 2];', '        for (int i = 0; i < n + 1; i++) {', '            c[i + 1] = c[i] + b[i];', '        }', '        ', '        while (q-- > 0) {', '            int x = nextInt();', '            int y = nextInt();', '            int k = nextInt();', '            ', '            int len = y - x + 2;', '            ', '            int ones;', '            ', '            if (k == 0) {', '                ones = c[y + 2] - c[x];', '                ', '            } else {', '                ones = len / 2;', '            }', '            out.println((long)ones * (len - ones));', '        }', '    }', '', '    C() throws IOException {', '        br = new BufferedReader(new InputStreamReader(System.in));', '        out = new PrintWriter(System.out);', '        solve();', '        out.close();', '    }', '', '    public static void main(String[] args) throws IOException {', '        new C();', '    }', '', '    String nextToken() {', '        while (st == null || !st.hasMoreTokens()) {', '            try {', '                st = new StringTokenizer(br.readLine());', '            } catch (Exception e) {', '                eof = true;', '                return null;', '            }', '        }', '        return st.nextToken();', '    }', '', '    String nextString() {', '        try {', '            return br.readLine();', '        } catch (IOException e) {', '            eof = true;', '            return null;', '        }', '    }', '', '    int nextInt() throws IOException {', '        return Integer.parseInt(nextToken());', '    }', '', '    long nextLong() throws IOException {', '        return Long.parseLong(nextToken());', '    }', '', '    double nextDouble() throws IOException {', '        return Double.parseDouble(nextToken());', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class C {', '', 'BufferedReader br;', 'PrintWriter out;', 'StringTokenizer st;', 'boolean eof;', '', 'void solve() throws IOException {', 'int n = nextInt();', 'int q = nextInt();', '', 'int[] b = new int[n + 1];', 'for (int i = 0; i < n; i++) {', 'int x = nextInt();', 'b[i + 1] = b[i] ^ x;', '}', '', 'int[] c = new int[n + 2];', 'for (int i = 0; i < n + 1; i++) {', 'c[i + 1] = c[i] + b[i];', '}', '', 'while (q-- > 0) {', 'int x = nextInt();', 'int y = nextInt();', 'int k = nextInt();', '', 'int len = y - x + 2;', '', 'int ones;', '', 'if (k == 0) {', 'ones = c[y + 2] - c[x];', '', '} else {', 'ones = len / 2;', '}', 'out.println((long)ones * (len - ones));', '}', '}', '', 'C() throws IOException {', 'br = new BufferedReader(new InputStreamReader(System.in));', 'out = new PrintWriter(System.out);', 'solve();', 'out.close();', '}', '', 'public static void main(String[] args) throws IOException {', 'new C();', '}', '', 'String nextToken() {', 'while (st == null || !st.hasMoreTokens()) {', 'try {', 'st = new StringTokenizer(br.readLine());', '} catch (Exception e) {', 'eof = true;', 'return null;', '}', '}', 'return st.nextToken();', '}', '', 'String nextString() {', 'try {', 'return br.readLine();', '} catch (IOException e) {', 'eof = true;', 'return null;', '}', '}', '', 'int nextInt() throws IOException {', 'return Integer.parseInt(nextToken());', '}', '', 'long nextLong() throws IOException {', 'return Long.parseLong(nextToken());', '}', '', 'double nextDouble() throws IOException {', 'return Double.parseDouble(nextToken());', '}', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */', '    Solution sol1 = new Solution();', '        sol1.process();', '    }', '    public void process() {', '        Scanner sc = new Scanner(System.in);', '        int n = sc.nextInt();', '        int[] num = new int[n+1];', '        int[] xor = new int[n+1];', '        int[] counts = new int[1<<16];', '        int max_count = Integer.MIN_VALUE;', '        counts[0] = 1;', '        for (int i = 1;i < n+1; i++) {', '            num[i] = sc.nextInt();', '            if (i > 0)', '             xor[i] = xor[i-1] ^num[i];', '            else ', '             xor[i] = num[i];', '            counts[xor[i]] ++;', '            if (xor[i] > max_count)', '             max_count = xor[i];', '            ', '        }', '        int[] results = new int[1<<16];', '        for (int i = 0;i <= max_count ; i++) {', '            for (int j = i+1; j <= max_count ; j++) {', '                results[i^j] += counts[i] * counts[j];', '            }', '        }', '        int max = Integer.MIN_VALUE;', '        int max_freq = Integer.MIN_VALUE;', '        for (int  i =0 ;i < results.length; i++) {', '            if (max_freq < results[i]) {', '                max_freq = results[i];', '                max = i;', '            }', '            ', '        }', '        System.out.println(max + "" "" + max_freq);', '    }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '    Solution sol1 = new Solution();', '        sol1.process();', '    }', '    public void process() {', '        Scanner sc = new Scanner(System.in);', '        int n = sc.nextInt();', '        int[] num = new int[n+1];', '        int[] xor = new int[n+1];', '        int[] counts = new int[1<<16];', '        int max_count = Integer.MIN_VALUE;', '        counts[0] = 1;', '        for (int i = 1;i < n+1; i++) {', '            num[i] = sc.nextInt();', '            if (i > 0)', '                xor[i] = xor[i-1] ^num[i];', '            else ', '                xor[i] = num[i];', '            counts[xor[i]] ++;', '            if (xor[i] > max_count)', '                max_count = xor[i];', '            ', '        }', '        int[] results = new int[1<<16];', '        for (int i = 0;i <= max_count ; i++) {', '            for (int j = i+1; j <= max_count ; j++) {', '                results[i^j] += counts[i] * counts[j];', '            }', '        }', '        int max = Integer.MIN_VALUE;', '        int max_freq = Integer.MIN_VALUE;', '        for (int  i =0 ;i < results.length; i++) {', '            if (max_freq < results[i]) {', '                max_freq = results[i];', '                max = i;', '            }', '            ', '        }', '        System.out.println(max + "" "" + max_freq);', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    private static final int l = 60000;', '    ', '    private static int gcd(int a, int b){', '        if (a < b) return gcd(b, a);', '        if (b == 0) return a;', '        return gcd(b, a % b);', '    }', '    ', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        boolean[] list = new boolean[l+1];', '        Set<Integer> set = new HashSet<Integer>();', '        for (int i = 0; i < n; i++){', '            int a = in.nextInt();', '            set.add(a);', '            list[a] = true;', '        }', '        boolean[] nList = new boolean[l+1];', '        for (int e : set){', '            for (int i = 1; i + e < l; i++){', '                nList[i] |= list[i + e];', '                /*', '                if (i < 10){', '                    if ((list[i + e / b] >> (e % b)) > 0 || (list[i + e / b + 1] << (b - (e % b))) > 0){', '                        System.out.println(bits(list[i + e / b] >> (e % b)));', '                        System.out.println(bits(list[i + e / b + 1] << (b - (e % b))));', '                    }', '                    else{', '                        System.out.println(bits(list[i + e / b]) + "" "" + (e % b));', '                        System.out.println(bits(list[i + e / b + 1]) + "" "" + (b - (e % b)));', '                    }', '                    System.out.println(e + "" "" + i);', '                }*/', '            }', '        }', '        list = nList;', '        int g = 0;', '        int min = -1;', '        int max = 0;', '        //for (int a : set)', '            //System.out.println(a);', '        //System.out.println(""-----"");', '        set.clear();', '        for (int i = 0; i < l+1; i++){', '                if (list[i]){', '                    //System.out.println(a);', '                    set.add(i);', '                    if (min < 0) min = i;', '                    max = i;', '                    g = gcd(i, g);', '                }', '        }', '        //System.out.println(""-----"");', '        //System.out.println(min);', '        //System.out.println(max);', '        //System.out.println(g);', '        int o = 1;', '        if (set.size() == 0){', '            System.out.println(o);', '            return;', '        }', '        Set<Integer> nSet = new HashSet<Integer>();', '        for (int a : set)', '            nSet.add(a / g);', '        set = nSet;', '        min /= g;', '        max /= g;', '        list = new boolean[l+1];', '        for (int a : set)', '            list[a] = true;', '        while (min > 1){', '            nList = new boolean[l+1];', '            for (int a = min; a <= max; a++){', '                if (list[a]){', '                    for (int k = 1; k + a < l; k++){', '                        nList[k] |= list[k + a];', '                    }', '                }', '            }', '            list = nList;', '            max -= min;', '            for (int a = 1; a <= max; a++){', '                if (list[a]){', '                    min = a;', '                    break;', '                }', '            }', '            o++;', '        }', '        System.out.println(o + max);', '    }', '    /*', '    private static String bits(int i){', '        String s = """";', '        for (int j = b-1; j >= 0; j--)', '            s += (i & (1 << j)) > 0 ? 1 : 0;', '        return s;', '    }*/', '}//[]{}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    private static final int l = 60000;', '    ', '    private static int gcd(int a, int b){', '        if (a < b) return gcd(b, a);', '        if (b == 0) return a;', '        return gcd(b, a % b);', '    }', '    ', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        boolean[] list = new boolean[l+1];', '        Set<Integer> set = new HashSet<Integer>();', '        for (int i = 0; i < n; i++){', '            int a = in.nextInt();', '            set.add(a);', '            list[a] = true;', '        }', '        boolean[] nList = new boolean[l+1];', '        for (int e : set){', '            for (int i = 1; i + e < l; i++){', '                nList[i] |= list[i + e];', '                /*', '                if (i < 10){', '                    if ((list[i + e / b] >> (e % b)) > 0 || (list[i + e / b + 1] << (b - (e % b))) > 0){', '                        System.out.println(bits(list[i + e / b] >> (e % b)));', '                        System.out.println(bits(list[i + e / b + 1] << (b - (e % b))));', '                    }', '                    else{', '                        System.out.println(bits(list[i + e / b]) + "" "" + (e % b));', '                        System.out.println(bits(list[i + e / b + 1]) + "" "" + (b - (e % b)));', '                    }', '                    System.out.println(e + "" "" + i);', '                }*/', '            }', '        }', '        list = nList;', '        int g = 0;', '        int min = -1;', '        int max = 0;', '        //for (int a : set)', '            //System.out.println(a);', '        //System.out.println(""-----"");', '        set.clear();', '        for (int i = 0; i < l+1; i++){', '                if (list[i]){', '                    //System.out.println(a);', '                    set.add(i);', '                    if (min < 0) min = i;', '                    max = i;', '                    g = gcd(i, g);', '                }', '        }', '        //System.out.println(""-----"");', '        //System.out.println(min);', '        //System.out.println(max);', '        //System.out.println(g);', '        int o = 1;', '        if (set.size() == 0){', '            System.out.println(o);', '            return;', '        }', '        Set<Integer> nSet = new HashSet<Integer>();', '        for (int a : set)', '            nSet.add(a / g);', '        set = nSet;', '        min /= g;', '        max /= g;', '        list = new boolean[l+1];', '        for (int a : set)', '            list[a] = true;', '        while (min > 1){', '            nList = new boolean[l+1];', '            for (int a = min; a <= max; a++){', '                if (list[a]){', '                    for (int k = 1; k + a < l; k++){', '                        nList[k] |= list[k + a];', '                    }', '                }', '            }', '            list = nList;', '            max -= min;', '            for (int a = 1; a <= max; a++){', '                if (list[a]){', '                    min = a;', '                    break;', '                }', '            }', '            o++;', '        }', '        System.out.println(o + max);', '    }', '    /*', '    private static String bits(int i){', '        String s = """";', '        for (int j = b-1; j >= 0; j--)', '            s += (i & (1 << j)) > 0 ? 1 : 0;', '        return s;', '    }*/', '}//[]{}']"
"['import java.io.BufferedOutputStream;', 'import java.io.InputStreamReader;', 'import java.io.PrintStream;', 'import java.util.Arrays;', 'import java.util.Scanner;', '', 'public class Solution {', ' ', '  static int n;', '  static final int maxn = 50010 / 32 + 5;', '', '  static int []LUT = new int[(1 << 16) + 100];', '  static long []REV = new long[(1 << 16) + 100];', '  ', '  static int bits(long x) {', '   return LUT[(int) (x&((1 << 16) - 1)& 0xffffffffl)] + LUT[(int) ((x >> 16)& 0xffffffffl)];', '  }', '', ' ', '  static long getrev(long x) {', '   return (REV[(int) (x&((1 << 16) - 1))] << 16) | REV[(int) (x >> 16)]& 0xffffffffl;', '  }', '', '', '  public static void main(String [] args)', '  {', '   PrintStream out = new PrintStream(new BufferedOutputStream(System.out));', '   Scanner sc =  new Scanner(new InputStreamReader(System.in));', '   //StringBuffer output = new StringBuffer();', '   for(int i = 0; i < 1 << 16; ++i)', '    LUT[i] = LUT[i >> 1] + (i & 1);', '   ', '   for(int i = 0; i < 1 << 16; ++i) {', '    int res = 0;', '    int x = i;', '    for(int iter = 0; iter < 16; ++iter){', '     res = (res << 1) | (x & 1);', '     x >>= 1;', '    }', '    REV[i] = res;', '   }', '   n= sc.nextInt();', '   char[] s = sc.next().toCharArray();', '   int m= sc.nextInt();', '   BSet cur=new BSet();', '   cur.clear();', '   ', '   for(int i = 0; i < n; ++i)', ""    if (s[i] == 'b')"", '     cur.flip(i);', '   for(int iter = 0; iter < m; ++iter){', '    char c = 0; ', ""    while (c != 'C' && c != 'S' && c != 'R' && c != 'W' && c != 'H') "", '     c = sc.next().toCharArray()[0];', '    int l=sc.nextInt()-1;', '    int r=sc.nextInt()-1;', '    ', ""    if (c == 'C') {"", '     char ch = 0;', ""     while (ch != 'a' && ch != 'b') "", '      ch = sc.next().toCharArray()[0];', ""     int val = ch == 'b'? 1: 0;"", '     cur.fill(l, r, val);', '    }', ""    else if (c == 'W') {"", '     StringBuilder ans = new StringBuilder();', '     for (int i = l; i <= r; ++i){', ""      ans.append((char)('a'+cur.getval(i)));"", '     }', '     out.println(ans);', '     //output.append(ans).append(""\\n"");', '     ', '    }', ""    else if (c == 'H') {"", '     int l1 = l;', '     int l2 = r;', '     int len=sc.nextInt();', '     BSet tmp = cur.xor(cur.shift(l1 - l2));', '     int ans = 0;', '     r = l1 + len - 1;', '     for (int i = l; i <= r;) {', '      if (((i & 31)!=0) || (i + 31 > r)){', '       ans += tmp.getval(i);', '       ++i;', '      }', '      else {', '       ans += bits(tmp.a[i >> 5]);', '       i += 32;', '      }', '     }', '     out.println(ans);', '     //output.append(ans).append(""\\n"");', '    }', ""    else if (c == 'S') {"", '     int l1 = l;', '     int r1 = r;', '     ', '     int l2=sc.nextInt()-1;', '     int r2=sc.nextInt()-1;', '', '     BSet tmp = new BSet();', '     System.arraycopy(cur.a, 0, tmp.a, 0, cur.a.length);', '     cur.fill(l1, r2, 0);', '     cur.copy(tmp, l1, r1, r2 - (r1 - l1));', '     cur.copy(tmp, l2, r2, l1);', '     cur.copy(tmp, r1 + 1, l2 - 1, l1 + (r2 - l2) + 1);', '    }', ""    else if (c == 'R') {"", '     cur.reverse(l, r);', '    }', '   }', '   //out.println(output.toString());', '   sc.close();', '   out.close();', '  } ', ' ', '  static class BSet {', '   long []a=new long[maxn];', '   public BSet(){', '    ', '   }', '   BSet xor(BSet o) {', '    BSet res=new BSet();', '    for(int i = 0; i < maxn; ++i)', '     res.a[i] = (a[i] ^ o.a[i])& 0xffffffffl;', '    return res;', '   }', '   BSet and(BSet o) {', '    BSet res=new BSet();', '     for(int i = 0; i < maxn; ++i)', '      res.a[i] = a[i] & o.a[i]& 0xffffffffl;', '    return res;', '   }', '   BSet or(BSet o) {', '    BSet res=new BSet();', '     for(int i = 0; i < maxn; ++i)', '    res.a[i] = a[i] | o.a[i]& 0xffffffffl;', '    return res;', '   }', '', '   void setint(int pos, long v) {', '    long val = v & 0xffffffffl;', '    int ind = pos >> 5;', '    ', '    if (ind >= 0 && ind < maxn){', '     a[ind] |= (val << (pos & 31))& 0xffffffffl;', '    }', '    pos += 31;', '    ', '    ind = pos >> 5;', '     ', '    if (ind >= 0 && ind < maxn){', '     a[ind] |= (val >> (31 - (pos & 31)))& 0xffffffffl;', '    }', '   }', '', '   void flip(int pos) {', '    long flip=(1l << (pos & 31));', '    int d =(pos >> 5);', '    a[d]=(a[d] ^ flip )& 0xffffffffl;', '   ', '   }', '   long getval(int pos) {', '    long val1= a[pos >> 5] ;', '    return (val1 >> (pos & 31)) & 1;', '   }', '   void setval(int pos, long val) {', '    if (getval(pos) != val){', '     flip(pos);', '    }', '   }', '   BSet shift(int sh) {', '    BSet res=new BSet();', '    res.clear();', '    for(int i = 0; i < maxn; ++i){', '     int pos = (i << 5) + sh;', '     res.setint(pos, a[i]);', '    }', '    return res;', '   }', '   void clear() {', '    Arrays.fill(a, 0);', '   }', '   void fill(int l, int r, int val) {', '    for (int i = l; i <= r;) {', '     if ((i & 31)!=0 || (i + 31 > r)){', '      setval(i, val);', '      ++i;', '     }', '     else {', '      if (val!=0) ', '       a[i >> 5] = 0xffffffffl;', '      else', '       a[i >> 5] = 0l;', '      i += 32;', '     }', '    }', '   }', '   void copy( BSet o, int l, int r, int to) {', '    int sh = to - l;', '    for (int i = l; i <= r;) {', '     if ((i & 31)!=0 || (i + 31 > r)) {', '      if (i + sh >= 0 && ((i + sh) >> 5) < maxn) {', '       setval(i + sh, o.getval(i));', '      }', '      ++i;', '     }', '     else {', '      if (i + sh >= 0 && ((i + sh) >> 5) < maxn)', '       setint(i + sh, o.a[i >> 5]);', '      i += 32;', '     }', '    } ', '   }', '   ', '   void reverse(int l, int r) {', '    ', '    BSet tmp = new BSet();', '    System.arraycopy(this.a, 0, tmp.a, 0, this.a.length);', '', '    fill(l, r, 0);', '    ', '    ', '    for (int i = l; i <= r;) {', '     if ((i & 31)>0 || (i + 31 > r)) {', '      int toi = r - (i - l);', '      setval(toi, tmp.getval(i));', '      ++i;', '     }', '     else {', '      setint(r - (i + 31 - l), getrev(tmp.a[i >> 5]));', '      i += 32;', '     }', '    }', '   }', '  }', ' ', ' ', '}']","['import java.io.FileInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.util.Arrays;', '', 'public class Hamming {', '', '    public static void main(String[] args) throws IOException, InterruptedException {', '        Hamming solution = new Hamming(System.in);', '//        Thread.sleep(10000);', '        solution.run();', '    }', '    ', '    private class Scanner {', '', '        public final byte[] bytes;', '', '        public final int length;', '', '        public int pos = 0;', '        ', '        private Scanner(InputStream in) throws IOException {', '            bytes = new byte[2026000];', '            int read;', '            int pos = 0;', '            while((read = in.read(bytes, pos, bytes.length - pos)) != -1)', '                pos += read;', '            this.length = pos;', '        }', '        ', '        private int nextInt() {', '            int i = 0;', '            int d;', ""            while((d = (bytes[pos++] - '0')) >= 0 && d <= 9) {"", '                i = i*10 + d;', '            }', '            while(true) {', '                switch(bytes[pos]) {', ""                case '\\r':"", ""                case '\\n':"", ""                case ' ':"", '                    pos++;', '                    continue;', '                    ', '                default:', '//                    System.out.println(""nextInt: "" + i);', '                    return i;', '                }', '            }', '        }', '        ', '        private String nextLine() {', '            int start = pos;', ""            while(bytes[pos] != '\\r' && bytes[pos] != '\\n')"", '                pos++;', '            int len = pos - start;', '            skipNewline();', '//            System.out.println(""nextLine pos "" + pos + "": "" + new String(bytes, start, len));', '            return new String(bytes, start, len);', '        }', '', '        private void skipNewline() {', '            while(true) {', '                switch(bytes[pos]) {', ""                case '\\r':"", ""                case '\\n':"", '                    pos++;', '                    continue;', '                    ', '                default:', '                    return;', '                }', '            }', '        }', '    }', '', '    ', '    private final Scanner scan;', '    ', '    private final int N;', '    ', '    private final int M;', '', '    private final CharArraySolution solution;', '    ', '    private Hamming(InputStream in) throws IOException {', '        scan = new Scanner(in);', '        N = scan.nextInt();', '        solution = new CharArraySolution(scan.nextLine());', '        M = scan.nextInt();', '    }', '    ', '    private void run() {', '        for(int m=0; m<M; m++) {', '            switch (scan.bytes[scan.pos++]) {', ""            case 'C':"", '                scan.pos++;', '                solution.set(scan.nextInt(), scan.nextInt(), scan.bytes[scan.pos++]);', '                scan.skipNewline();', '                break;', '', ""            case 'S':"", '                scan.pos++;', '                solution.swap(scan.nextInt(), scan.nextInt(), scan.nextInt(), scan.nextInt());', '                break;', '', ""            case 'R':"", '                scan.pos++;', '                solution.reverse(scan.nextInt(), scan.nextInt());', '                break;', '', ""            case 'W':"", '                scan.pos++;', '                solution.write(scan.nextInt(), scan.nextInt());', '                break;', '', ""            case 'H':"", '                scan.pos++;', '                solution.hamming(scan.nextInt(), scan.nextInt(), scan.nextInt());', '                break;', '            }', '        }', '        System.out.print(solution.toString());', '    }', ' ', '    private class CharArraySolution {', '', '        private final int N;', '        private final char[] forward;', '        private final char[] reverse;', '        private final char[] as;', '        private final char[] bs;', '        private final char[] buf;', '        private final char[] out;', '        ', '        private int outpos = 0;', '        ', '        private CharArraySolution(String string) {', '            char[] chars = string.toCharArray();', '            N = chars.length;', '            forward = new char[N+1];', '            System.arraycopy(chars, 0, forward, 1, N);', '            reverse = new char[N+1];', '            for(int i=1; i<=N; i++) {', '                reverse[i] = forward[N-i+1];', '            }', '            as = new char[N+1];', ""            Arrays.fill(as, 'a');"", '            bs = new char[N+1];', ""            Arrays.fill(bs, 'b');"", '//            write(1,N);', '            buf = new char[N+1];', '            out = new char[2000000];', '        }', '', '        private void set(int l, int r, byte c) {', '//            System.out.println(""set "" + l + "" "" + r + "" "" + c);', '            int len = r-l+1;', ""            if(c == 'a') {"", '                System.arraycopy(as, 0, forward, l, len);', '                l = N-r+1;', '                System.arraycopy(as, 0, reverse, l, len);', '            } else {', '                System.arraycopy(bs, 0, forward, l, len);', '                l = N-r+1;', '                System.arraycopy(bs, 0, reverse, l, len);', '            }', '//            write(1,N);', '        }', '', '        private void swap(int l1, int r1, int l2, int r2) {', '//            System.out.println(""swap "" + l1 + "" "" + r1 + "" "" + l2 + "" "" + r2);', '            int len1 = r1-l1+1;', '            int len2 = r2-l2+1;', '            int lenm = l2-r1-1;', '            if(len1 > len2) {', '                System.arraycopy(forward, l1, buf, 0, len1);', '                System.arraycopy(forward, l2, forward, l1, len2);', '                System.arraycopy(forward, r1+1, forward, l1+len2, lenm);', '                System.arraycopy(buf, 0, forward, l1+len2+lenm, len1);', '                int oldl1 = l1;', '                int oldr1 = r1;', '                l1 = N-r2+1;', '                r1 = N-l2+1;', '                l2 = N-oldr1+1;', '                r2 = N-oldl1+1;', '                int oldlen1 = len1;', '                len1 = len2;', '                len2 = oldlen1;', '                System.arraycopy(reverse, l2, buf, 0, len2);', '                System.arraycopy(reverse, l1, reverse, r2-len1+1, len1);', '                System.arraycopy(reverse, r1+1, reverse, r2-len1-lenm+1, lenm);', '                System.arraycopy(buf, 0, reverse, l1, len2);', '            } else {', '                System.arraycopy(forward, l2, buf, 0, len2);', '                System.arraycopy(forward, l1, forward, r2-len1+1, len1);', '                System.arraycopy(forward, r1+1, forward, r2-len1-lenm+1, lenm);', '                System.arraycopy(buf, 0, forward, l1, len2);', '                int oldl1 = l1;', '                int oldr1 = r1;', '                l1 = N-r2+1;', '                r1 = N-l2+1;', '                l2 = N-oldr1+1;', '                r2 = N-oldl1+1;', '                int oldlen1 = len1;', '                len1 = len2;', '                len2 = oldlen1;', '                System.arraycopy(reverse, l1, buf, 0, len1);', '                System.arraycopy(reverse, l2, reverse, l1, len2);', '                System.arraycopy(reverse, r1+1, reverse, l1+len2, lenm);', '                System.arraycopy(buf, 0, reverse, l1+len2+lenm, len1);', '            }', '//            write(1,N);', '        }', '', '        private void reverse(int l, int r) {', '//            System.out.println(""reverse "" + l + "" "" + r);', '            int len = r-l+1;', '            System.arraycopy(forward, l, buf, 0, len);', '            System.arraycopy(reverse, N-r+1, forward, l, len);', '            System.arraycopy(buf, 0, reverse, N-r+1, len);', '//            write(1,N);', '        }', '', '        private void write(int l, int r) {', '            int len = r-l+1;', '            System.arraycopy(forward, l, out, outpos, len);', '            outpos += len;', ""            out[outpos++] = '\\n';"", '//            System.out.println(Arrays.copyOfRange(reverse, N-r+1, N-l+2));', '        }', '', '        private void hamming(int p1, int p2, int l) {', '//            System.out.println(""ham "" + p1 + "" "" + p2 + "" "" + l);', '            int c = 0;', '            for(int i=0; i<l; i++) {', '                if(forward[p1++] != forward[p2++])', '                    c++;', '            }', '            int bufpos = 10;', '            do {', ""                buf[bufpos--] = (char)('0' + (c%10));"", '                c /= 10;', '            } while(c>0);', '            System.arraycopy(buf, bufpos+1, out, outpos, 10 - bufpos);', '            outpos += 10 - bufpos;', ""            out[outpos++] = '\\n';"", '        }', '        ', '        public String toString() {', '            return new String(out, 0, outpos);', '        }', '', '    }', '    ', '}']"
"['import java.io.*;', '', 'public class Solution {', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        int n = in.nextInt(), k = in.nextInt();', '        int[] a = new int[n];', '        char[] c = in.next().toCharArray();', '        for (int i = 0; i < n; ++i) {', ""            a[i] = c[i] - 'A';"", '        }', '        for (int i = 1; i <= k; i *= 2) {', '            if ((k & i) != 0) {', '                int[] b = new int[n];', '                for (int j = 0; j < n; ++j) {', '                    b[j] = a[j] ^ a[(j + i) % n];', '                }', '                a = b;', '            }', '        }', '        for (int i = 0; i < n; ++i) {', ""            c[i] = (char) (a[i] + 'A');"", '        }', '        out.println(c);', '    }', '', '    public static void main(String[] args) throws IOException {', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']","['import java.io.*;', '', 'public class Solution {', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        int n = in.nextInt(), k = in.nextInt();', '        int[] a = new int[n];', '        char[] c = in.next().toCharArray();', '        for (int i = 0; i < n; ++i) {', ""            a[i] = c[i] - 'A';"", '        }', '        for (int i = 1; i <= k; i *= 2) {', '            if ((k & i) != 0) {', '                int[] b = new int[n];', '                for (int j = 0; j < n; ++j) {', '                    b[j] = a[j] ^ a[(j + i) % n];', '                }', '                a = b;', '            }', '        }', '        for (int i = 0; i < n; ++i) {', ""            c[i] = (char) (a[i] + 'A');"", '        }', '        out.println(c);', '    }', '', '    public static void main(String[] args) throws IOException {', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    static void printResult(int[] arr, String result){', '       for(int i=0; i<arr.length;i++){', '            System.out.print(arr[i]);', '            if(i!=arr.length-1){', '                System.out.print(result.charAt(i));', '            }', '        }', '    }', '    public static boolean calculation(int index, long cur, String result){', ' ', '        if(cur%101 ==0){', '            //System.out.println(""optimize"" + cur);', '            for(int i=result.length(); i<arr.length-1; i++)', '                result+=""*"";', '            printResult(arr,result);', '            return true;', '        }', '        if(index == arr.length-1){', '            if(((long)arr[index]*cur)%101 ==0){', '                result+=""*""; ', '                printResult(arr,result);', '                //System.out.println(((long)arr[index]*cur));', '                return true;', '            }', '            else if(((long)arr[index]+cur)%101 ==0){', '                result+=""+""; ', '                printResult(arr,result);', '                //System.out.println(((long)arr[index]+cur));', '                return true;', '            }', '            else if((cur-(long)arr[index])%101 == 0){', '                result+=""-""; ', '                printResult(arr,result);', '                //System.out.println((cur-(long)arr[index]));', '                return true;', '            }', '            else', '                return false;', '        }', '        if(!calculation(index+1, ((long)arr[index]*cur)%101,result+""*"")){', '            if(!calculation(index+1, ((long)arr[index]+cur)%101,result+""+"")){', '                if(!calculation(index+1, ((long)cur-arr[index])%101,result+""-"")){', '                    return false;', '                } ', '            }', '            ', '        }', '        ', '', '        return true;', '    }', '    static int[] arr;', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int a;', '        a = in.nextInt();', '        arr = new int[a];', '        for(int i=0; i<a; i++){', '           arr[i] = in.nextInt(); ', '        }', '        calculation(1, arr[0],"""");//System.out.println(result);', '', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    // memoization', '    static final Map<Integer, String> cache = new HashMap<>();', '', '    static String arithmeticExpressions(int[] arr, int idx, int val) {', '        // to avoid overflow', '        val %= 101;', '', '        // use cache if present', '        final int key = idx * 101 + val;', '        if (cache.containsKey(key)) {', '            return cache.get(key);', '        }', '', '        if (idx < arr.length) {', '            if (val != 0) { // if val == 0 keep multiplying', '                if (val != arr[idx]) { // if val == arr[idx] skip adding', '', '                    // try addition', '                    final String add = arithmeticExpressions(arr, idx + 1, val + arr[idx]);', '                    cache.put(key, add);', '                    if (add != null) {', '                        return ""+"" + arr[idx] + add;', '                    }', '                }', '', '                // try subtraction', '                final String sub = arithmeticExpressions(arr, idx + 1, val - arr[idx]);', '                cache.put(key, sub);', '                if (sub != null) {', '                    return ""-"" + arr[idx] + sub; ', '                }', '            }', '', '            // try multiplication', '            final String mul = arithmeticExpressions(arr, idx + 1, val * arr[idx]);', '            cache.put(key, mul);', '            if (mul != null) {', '                return ""*"" + arr[idx] + mul; ', '            }', '        } else if (val == 0) { // if last idx and val == 0 we found the solution', '            return """";', '        }', '        return null;', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int n = scanner.nextInt();', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])?"");', '', '        int[] arr = new int[n];', '', '        String[] arrItems = scanner.nextLine().split("" "");', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])?"");', '', '        for (int i = 0; i < n; i++) {', '            int arrItem = Integer.parseInt(arrItems[i]);', '            arr[i] = arrItem;', '        }', '', '        String result = arr[0] + arithmeticExpressions(arr, 1, arr[0]);', '', '        bufferedWriter.write(result);', '        bufferedWriter.newLine();', '        bufferedWriter.close();', '        scanner.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner s = new Scanner(System.in);', '        int n = s.nextInt();', '        int c = s.nextInt();', '        ', '        int[] arr = new int[c];', '        for(int i=0; i<c; i++) {', '            arr[i] = s.nextInt();', '        }', '        String out = cal(arr, n, 0, """" + n, new String[1] );', '        System.out.println(out == null ? -1 : out);', '    }', '    ', '    static String cal(int[] arr, int result, int step, String output, String[] strs) {', '        if(strs[0] != null && strs[0].length() < output.length()) {', '            return null;', '        }', '        ', '        if(result == 1) {', '            strs[0] = output;', '            return output; ', '        } ', '        ', '        String out = null;', '        for(int i = 0; i<arr.length; i++) {', '            if(result % arr[i] ==0) {', '                String temp = cal(arr, result / arr[i], step + 1,result / arr[i] + "" "" + output, strs);', '                if(temp == null) {', '                    continue;', '                } else if(out == null) {', '                    out = temp;', '                } else {', '                    out = out.length() < temp.length() ? out : temp;', '                }', '            }', '        }', '        ', '        return (out == null) ? null : out;', '    }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        ', '        Scanner in = new Scanner(System.in);', '        int N = in.nextInt();', '        int Ksize = in.nextInt();', '        int[] K = new int[Ksize];', '        for(int i = 0; i < Ksize; i++){', '            K[i] = in.nextInt();', '        }', '        ', '        Arrays.sort(K);', '        ', '        if(!isPossible(N)){', '            System.out.println(-1); ', '            return;', '        }', '        ', '        Deque<State> queue = new ArrayDeque<>();', '        ', '        for(int i = 0; i < K.length; i++){', '            State init = new State(K, i, K[i], null);        ', '            queue.offer(init);', '        }', '               ', '        int depth = 0;', '        while(queue.size() > 0){', '            ', '            State state = queue.poll();', '            for(int ki = state.ki; ki < K.length; ki++){', '                if(ki >= 0 && K[ki] > 1){', '                    State next = new State(K, ki, state.total * K[ki], state);                      ', '                    if(next.total == N){', '                        System.out.println(next);', '                        return;', '                    }', '                    ', '                    if(next.total < N){', '                        queue.offer(next);', '                    }                   ', '                }                                     ', '            }          ', '        }', '        ', '        System.out.println(-1);             ', '    }', '', '    static boolean isPossible(int N){', '    ', '        int total = N;', '        ', '        for(int i = 2; i <= 20; i++){          ', '            while((total/i) * i == total){', '                total /= i;', '            }                ', '        }', '        ', '        return total == 1;', '    }', '     ', '    static class State{', '        public int[] K;', '        public int ki;', '        public int total;', '        public State prev;', '        public int size;', '        ', '        public State(int[] K, int ki, int total, State prev){', '            this.K = K;', '            this.ki = ki;', '            this.total = total;', '            this.prev = prev;', '            ', '            if(prev == null){', '                size = 1;', '            } else {', '                size = prev.size + 1;', '            }', '        }', '        ', '        @Override', '        public String toString(){            ', '            if(prev == null){', '                if(ki == -1){', '                    return ""1"";', '                } else {', '                    return ""1 "" + String.valueOf(total);', '                }', '                                  ', '            } else {', '                return prev.toString() + "" "" + String.valueOf(total);', '            }                       ', '        }     ', '    }', '    ', '    ', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', ' static int[] nim = new int[301];', '', ' public static void main(String[] args) {', '  Scanner in = new Scanner(System.in);', '  int t = in.nextInt();', '  while(t-- > 0) {', '   int n = in.nextInt();', '   String s = in.next();', '   List<Integer> list = new ArrayList<Integer>();', '   int count = 0;', '   for(int i = 0; i < s.length(); i++) {', '    char ch = s.charAt(i);', ""    if(ch == 'I') {"", '     count++;', '    } else {', '     if(count != 0)', '      list.add(count);', '     count = 0;', '    }', '   }', '   if(count > 0)', '    list.add(count);', '', '   int result = 0;', '   for(int i = 0; i < list.size(); i++) {', '    result ^= grundy(list.get(i));', '   }', '   if(result <= 0) {', '    System.out.println(""LOSE"");', '   } else {', '    System.out.println(""WIN"");', '   }', '  }', '  in.close();', ' }', '', ' private static int mex(List<Integer> arr) {', '  int mex = 0;', '  while(arr.contains(mex))', '   mex++;', '  return mex;', ' }', '', ' private static int grundy(int n) {', '  if(nim[n] != 0)', '   return nim[n];', '  if(n == 0) {', '   nim[0] = 0;', '   return 0;', '  }', '  if (n == 1) {', '   nim[1] = 1;', '         return (1);', '  }', '     if (n == 2) {', '   nim[2] = 2;', '         return (2);', '     }', '', '  List<Integer> list = new ArrayList<Integer>();', '  for(int i = 1, j = 0, k = 0; i <= n; i++) {', '   int x, y;', '   if(i <= n / 2) {', '    x = grundy(j);', '    y = grundy(n - j - 2);', '    j++;', '   } else {', '    x = grundy(k);', '    y = grundy(n - k - 1);', '    k++;', '   }', '   list.add(x ^ y);', '  }', '  nim[n] = mex(list);', '  return nim[n];', ' }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution', '{', '    static int[] nim = new int[301];', '', '    public static void main(String[] args)', '    {', '        Scanner in = new Scanner(System.in);', '        int t = in.nextInt();', '        while(t-- > 0)', '        {', '            int n = in.nextInt();', '            String s = in.next();', '            List<Integer> list = new ArrayList<Integer>();', '            int count = 0;', '            //Making heap and adding in List', '            for(int i = 0; i < s.length(); i++)', '            {', '                char ch = s.charAt(i);', ""                if(ch == 'I')"", '                {', ""                    //If I is found then check further - for contingous I's"", '                    count++;', '                }', '                else', '                {', ""                    //Else if count not 0(when consequtive X's found) put in list and initialize to 0"", '                    if(count != 0)', '                    {', '                        list.add(count);', '                    }', '                    count = 0;', '                }', '            }', '            //do same for last heap [we can resolve this by explicity adding a X at end]', '            if(count > 0)', '            {', '                list.add(count);', '            }', '', '            int result = 0;', '            for(int i = 0; i < list.size(); i++)', '            {', ""                //doing Nim sum of Grundy numbers of each heap size [continous I's]"", '                result ^= grundy(list.get(i));', '            }', '            if(result <= 0)', '            {', '                //If result of Nim sum of all heap sizes are non-zero then last chance is of opponent . because of opposite logic of our question - we LOSE', '                System.out.println(""LOSE"");', '            }', '            else', '            {', '                //Otherwise if the result of Nim sum of all heap sizes are non-zero then last chance is of mine . because of opposite logic of our question - we WON', '                System.out.println(""WIN"");', '            }', '        }', '        in.close();', '    }', '', '    private static int mex(List<Integer> arr)', '    {', '        int mex = 0;', '        while(arr.contains(mex))', '            mex++;', '        return mex;', '    }', '', '    private static int grundy(int n)', '    {', '        if(nim[n] != 0)', '            return nim[n];', '        if(n == 0)', '        {', '            nim[0] = 0;', '            return 0;', '        }', '        if (n == 1)', '        {', '            nim[1] = 1;', '            return (1);', '        }', '        if (n == 2)', '        {', '            nim[2] = 2;', '            return (2);', '        }', '', '        List<Integer> list = new ArrayList<Integer>();', '        for(int i = 1, j = 0, k = 0; i <= n; i++)', '        {', '            int x, y;', '            if(i <= n / 2)', '            {', '                x = grundy(j);', '                y = grundy(n - j - 2);', '                j++;', '            } else {', '                x = grundy(k);', '                y = grundy(n - k - 1);', '                k++;', '            }', '            list.add(x ^ y);', '        }', '        nim[n] = mex(list);', '        return nim[n];', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    static class Piece {', '        public char type;', '        public boolean isWhite;', '', '        public Piece (char type, boolean isWhite) {', '            this.type = type;', '            this.isWhite = isWhite;', '        }', '        ', '        public Piece (Piece p) {', '            this.type = p.type;', '            this.isWhite = p.isWhite;', '        }', '    }', '    ', '    static class Board {', '        public Piece[][] pieces = new Piece[4][4];', '        ', '        public Board(ArrayList<String> w, ArrayList<String> b) {', '            for (String p : w) {', '                String[] p3 = p.split("" "");', '                char type = p3[0].charAt(0);', ""                int x = p3[1].charAt(0)-'A';"", ""                int y = p3[2].charAt(0)-'1';"", '                pieces[x][y] = new Piece(type, true);', '            }', '            for (String p : b) {', '                String[] p3 = p.split("" "");', '                char type = p3[0].charAt(0);', ""                int x = p3[1].charAt(0)-'A';"", ""                int y = p3[2].charAt(0)-'1';"", '                pieces[x][y] = new Piece(type, false);', '            }', '        }', '        ', '        public Board(Board b) {', '            for (int i = 0; i < 4; i++) {', '                for (int j = 0; j < 4; j++) {', '                    if (b.pieces[i][j] != null)', '                        this.pieces[i][j] = new Piece(b.pieces[i][j]);', '                }', '            }', '        }', '        ', '        public ArrayList<Board> legalMoves(boolean whiteToMove) {', '            ArrayList<Board> moves = new ArrayList<Board>();', '            for (int a = 0; a < 4; a++) {', '                for (int b = 0; b < 4; b++) {', '                    if (pieces[a][b] != null && pieces[a][b].isWhite == whiteToMove) {', ""                        if (pieces[a][b].type == 'P') {"", '                            int d = whiteToMove?b+1:b-1;', '                            if (pieces[a][d] == null) {', '                                if (d==0||d==3) {', '                                    Board newBoard = new Board(this);', '                                    newBoard.pieces[a][d] = newBoard.pieces[a][b];', '                                    newBoard.pieces[a][b] = null;', ""                                    newBoard.pieces[a][d].type = 'R';"", '                                    moves.add(newBoard);', '                                    newBoard = new Board(this);', '                                    newBoard.pieces[a][d] = newBoard.pieces[a][b];', '                                    newBoard.pieces[a][b] = null;', ""                                    newBoard.pieces[a][d].type = 'B';"", '                                    moves.add(newBoard);', '                                    newBoard = new Board(this);', '                                    newBoard.pieces[a][d] = newBoard.pieces[a][b];', '                                    newBoard.pieces[a][b] = null;', ""                                    newBoard.pieces[a][d].type = 'N';"", '                                    moves.add(newBoard);', '                                }', '                                else {', '                                    Board newBoard = new Board(this);', '                                    newBoard.pieces[a][d] = newBoard.pieces[a][b];', '                                    newBoard.pieces[a][b] = null;', '                                    moves.add(newBoard);', '                                }', '                            }', '                            for (int c = a-1; c <= a+1; c+=2) {', '                                if (c>=0&&c<4) {', '                                    if (pieces[c][d] != null && pieces[c][d].isWhite != whiteToMove) {', '                                        if (d==0||d==3) {', '                                            Board newBoard = new Board(this);', '                                            newBoard.pieces[c][d] = newBoard.pieces[a][b];', '                                            newBoard.pieces[a][b] = null;', ""                                            newBoard.pieces[c][d].type = 'R';"", '                                            moves.add(newBoard);', '                                            newBoard = new Board(this);', '                                            newBoard.pieces[c][d] = newBoard.pieces[a][b];', '                                            newBoard.pieces[a][b] = null;', ""                                            newBoard.pieces[c][d].type = 'B';"", '                                            moves.add(newBoard);', '                                            newBoard = new Board(this);', '                                            newBoard.pieces[c][d] = newBoard.pieces[a][b];', '                                            newBoard.pieces[a][b] = null;', ""                                            newBoard.pieces[c][d].type = 'N';"", '                                            moves.add(newBoard);', '                                        }', '                                        else {', '                                            Board newBoard = new Board(this);', '                                            newBoard.pieces[c][d] = newBoard.pieces[a][b];', '                                            newBoard.pieces[a][b] = null;', '                                            moves.add(newBoard);', '                                        }', '                                    }', '                                }', '                            }', '                        }', ""                        if (pieces[a][b].type == 'N') {"", '                            for (int c = -2; c <= 2; c+=4) {', '                                for (int d = -1; d <= 1; d+=2) {', '                                    int e = a+c;', '                                    int f = b+d;', '                                    int g = a+d;', '                                    int h = b+c;', '                                    if (e >= 0 && e < 4 && f >= 0 && f < 4) {', '                                        if (pieces[e][f] == null || pieces[e][f].isWhite != whiteToMove) {', '                                            Board newBoard = new Board(this);', '                                            newBoard.pieces[e][f] = newBoard.pieces[a][b];', '                                            newBoard.pieces[a][b] = null;', '                                            moves.add(newBoard);', '                                        }', '                                    }', '                                    if (g >= 0 && g < 4 && h >= 0 && h < 4) {', '                                        if (pieces[g][h] == null || pieces[g][h].isWhite != whiteToMove) {', '                                            Board newBoard = new Board(this);', '                                            newBoard.pieces[g][h] = newBoard.pieces[a][b];', '                                            newBoard.pieces[a][b] = null;', '                                            moves.add(newBoard);', '                                        }', '                                    }', '                                }', '                            }', '                        }', ""                        if (pieces[a][b].type == 'R' || pieces[a][b].type == 'Q') {"", '                            for (int c = -1; c <= 1; c += 2) {', '                                for (int d = a+c; d >= 0 && d < 4; d += c) {', '                                    if (pieces[d][b] == null || pieces[d][b].isWhite != whiteToMove) {', '                                        Board newBoard = new Board(this);', '                                        newBoard.pieces[d][b] = newBoard.pieces[a][b];', '                                        newBoard.pieces[a][b] = null;', '                                        moves.add(newBoard);', '                                    }', '                                    if (pieces[d][b] != null)', '                                        break;', '                                }', '                                for (int d = b+c; d >= 0 && d < 4; d += c) {', '                                    if (pieces[a][d] == null || pieces[a][d].isWhite != whiteToMove) {', '                                        Board newBoard = new Board(this);', '                                        newBoard.pieces[a][d] = newBoard.pieces[a][b];', '                                        newBoard.pieces[a][b] = null;', '                                        moves.add(newBoard);', '                                    }', '                                    if (pieces[a][d] != null)', '                                        break;', '                                }', '                            }', '                        }', ""                        if (pieces[a][b].type == 'B' || pieces[a][b].type == 'Q') {"", '                            for (int c = -1; c <= 1; c += 2) {', '                                for (int d = -1; d <= 1; d += 2) {', '                                    for (int e = 1; a+e*c >= 0 && a+e*c < 4 && b+e*d >= 0 && b+e*d < 4; e++) {', '                                        int f = a+e*c;', '                                        int g = b+e*d;', '                                        ', '                                        if (pieces[f][g] == null || pieces[f][g].isWhite != whiteToMove) {', '                                            Board newBoard = new Board(this);', '                                            newBoard.pieces[f][g] = newBoard.pieces[a][b];', '                                            newBoard.pieces[a][b] = null;', '                                            moves.add(newBoard);', '                                        }', '                                        if (pieces[f][g] != null)', '                                            break;', '                                    }', '                                }', '                            }', '                        }', '                    }', '                }', '            }', '            return moves;', '        }', '        ', '        public boolean doesQueenExist(boolean whiteQueen) {', '            for (int a = 0; a < 4; a++) {', '                for (int b = 0; b < 4; b++) {', ""                    if (pieces[a][b] != null && pieces[a][b].type == 'Q' && pieces[a][b].isWhite == whiteQueen)"", '                        return true;', '                }', '            }', '            return false;', '        }', '        ', '        public boolean canCaptureQueen(boolean whiteToMove) {', '            ArrayList<Board> moves = legalMoves(whiteToMove);', '            for (Board b : moves) {', '                if (!b.doesQueenExist(!whiteToMove))', '                    return true;', '            }', '            return false;', '        }', '        ', '        public boolean canReachGoalWhite(int rem) {', '            if (canCaptureQueen(true))', '                return true;', '            if (rem==1)', '                return false;', '            ArrayList<Board> moves = legalMoves(true);', '            for (Board b : moves) {', '                if (!b.canStopGoalBlack(rem))', '                    return true;', '            }', '            return false;', '        }', '        ', '        public boolean canStopGoalBlack(int rem) {', '            if (canCaptureQueen(false))', '                return true;', '            ArrayList<Board> moves = legalMoves(false);', '            for (Board b : moves) {', '                if (!b.canReachGoalWhite(rem-1))', '                    return true;', '            }', '            return false;', '        }', '    }', '    ', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(System.in);', '        int g = sc.nextInt();', '        for (int z = 0; z < g; z++) {', '            int w = sc.nextInt();', '            int b = sc.nextInt();', '            int m = (sc.nextInt()+1)/2;', '            ArrayList<String> wl = new ArrayList<String>();', '            ArrayList<String> bl = new ArrayList<String>();', '            sc.nextLine();', '            for (int i = 0; i < w; i++) {', '                wl.add(sc.nextLine());', '            }', '            for (int i = 0; i < b; i++) {', '                bl.add(sc.nextLine());', '            }', '            Board start = new Board(wl, bl);', '            System.out.println(start.canReachGoalWhite(m)?""YES"":""NO"");', '        }', '    }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class SimplifiedChessEngineII {', '    static class Piece {', '        public char type;', '        public boolean isWhite;', '', '        public Piece (char type, boolean isWhite) {', '            this.type = type;', '            this.isWhite = isWhite;', '        }', '        ', '        public Piece (Piece p) {', '            this.type = p.type;', '            this.isWhite = p.isWhite;', '        }', '    }', '    ', '    static class Board {', '        public Piece[][] pieces = new Piece[4][4];', '        ', '        public Board(ArrayList<String> w, ArrayList<String> b) {', '            for (String p : w) {', '                String[] p3 = p.split("" "");', '                char type = p3[0].charAt(0);', ""                int x = p3[1].charAt(0)-'A';"", ""                int y = p3[2].charAt(0)-'1';"", '                pieces[x][y] = new Piece(type, true);', '            }', '            for (String p : b) {', '                String[] p3 = p.split("" "");', '                char type = p3[0].charAt(0);', ""                int x = p3[1].charAt(0)-'A';"", ""                int y = p3[2].charAt(0)-'1';"", '                pieces[x][y] = new Piece(type, false);', '            }', '        }', '        ', '        public Board(Board b) {', '            for (int i = 0; i < 4; i++) {', '                for (int j = 0; j < 4; j++) {', '                    if (b.pieces[i][j] != null)', '                        this.pieces[i][j] = new Piece(b.pieces[i][j]);', '                }', '            }', '        }', '        ', '        public ArrayList<Board> legalMoves(boolean whiteToMove) {', '            ArrayList<Board> moves = new ArrayList<Board>();', '            for (int a = 0; a < 4; a++) {', '                for (int b = 0; b < 4; b++) {', '                    if (pieces[a][b] != null && pieces[a][b].isWhite == whiteToMove) {', ""                        if (pieces[a][b].type == 'P') {"", '                            int d = whiteToMove?b+1:b-1;', '                            if (pieces[a][d] == null) {', '                                if (d==0||d==3) {', '                                    Board newBoard = new Board(this);', '                                    newBoard.pieces[a][d] = newBoard.pieces[a][b];', '                                    newBoard.pieces[a][b] = null;', ""                                    newBoard.pieces[a][d].type = 'R';"", '                                    moves.add(newBoard);', '                                    newBoard = new Board(this);', '                                    newBoard.pieces[a][d] = newBoard.pieces[a][b];', '                                    newBoard.pieces[a][b] = null;', ""                                    newBoard.pieces[a][d].type = 'B';"", '                                    moves.add(newBoard);', '                                    newBoard = new Board(this);', '                                    newBoard.pieces[a][d] = newBoard.pieces[a][b];', '                                    newBoard.pieces[a][b] = null;', ""                                    newBoard.pieces[a][d].type = 'N';"", '                                    moves.add(newBoard);', '                                }', '                                else {', '                                    Board newBoard = new Board(this);', '                                    newBoard.pieces[a][d] = newBoard.pieces[a][b];', '                                    newBoard.pieces[a][b] = null;', '                                    moves.add(newBoard);', '                                }', '                            }', '                            for (int c = a-1; c <= a+1; c+=2) {', '                                if (c>=0&&c<4) {', '                                    if (pieces[c][d] != null && pieces[c][d].isWhite != whiteToMove) {', '                                        if (d==0||d==3) {', '                                            Board newBoard = new Board(this);', '                                            newBoard.pieces[c][d] = newBoard.pieces[a][b];', '                                            newBoard.pieces[a][b] = null;', ""                                            newBoard.pieces[c][d].type = 'R';"", '                                            moves.add(newBoard);', '                                            newBoard = new Board(this);', '                                            newBoard.pieces[c][d] = newBoard.pieces[a][b];', '                                            newBoard.pieces[a][b] = null;', ""                                            newBoard.pieces[c][d].type = 'B';"", '                                            moves.add(newBoard);', '                                            newBoard = new Board(this);', '                                            newBoard.pieces[c][d] = newBoard.pieces[a][b];', '                                            newBoard.pieces[a][b] = null;', ""                                            newBoard.pieces[c][d].type = 'N';"", '                                            moves.add(newBoard);', '                                        }', '                                        else {', '                                            Board newBoard = new Board(this);', '                                            newBoard.pieces[c][d] = newBoard.pieces[a][b];', '                                            newBoard.pieces[a][b] = null;', '                                            moves.add(newBoard);', '                                        }', '                                    }', '                                }', '                            }', '                        }', ""                        if (pieces[a][b].type == 'N') {"", '                            for (int c = -2; c <= 2; c+=4) {', '                                for (int d = -1; d <= 1; d+=2) {', '                                    int e = a+c;', '                                    int f = b+d;', '                                    int g = a+d;', '                                    int h = b+c;', '                                    if (e >= 0 && e < 4 && f >= 0 && f < 4) {', '                                        if (pieces[e][f] == null || pieces[e][f].isWhite != whiteToMove) {', '                                            Board newBoard = new Board(this);', '                                            newBoard.pieces[e][f] = newBoard.pieces[a][b];', '                                            newBoard.pieces[a][b] = null;', '                                            moves.add(newBoard);', '                                        }', '                                    }', '                                    if (g >= 0 && g < 4 && h >= 0 && h < 4) {', '                                        if (pieces[g][h] == null || pieces[g][h].isWhite != whiteToMove) {', '                                            Board newBoard = new Board(this);', '                                            newBoard.pieces[g][h] = newBoard.pieces[a][b];', '                                            newBoard.pieces[a][b] = null;', '                                            moves.add(newBoard);', '                                        }', '                                    }', '                                }', '                            }', '                        }', ""                        if (pieces[a][b].type == 'R' || pieces[a][b].type == 'Q') {"", '                            for (int c = -1; c <= 1; c += 2) {', '                                for (int d = a+c; d >= 0 && d < 4; d += c) {', '                                    if (pieces[d][b] == null || pieces[d][b].isWhite != whiteToMove) {', '                                        Board newBoard = new Board(this);', '                                        newBoard.pieces[d][b] = newBoard.pieces[a][b];', '                                        newBoard.pieces[a][b] = null;', '                                        moves.add(newBoard);', '                                    }', '                                    if (pieces[d][b] != null)', '                                        break;', '                                }', '                                for (int d = b+c; d >= 0 && d < 4; d += c) {', '                                    if (pieces[a][d] == null || pieces[a][d].isWhite != whiteToMove) {', '                                        Board newBoard = new Board(this);', '                                        newBoard.pieces[a][d] = newBoard.pieces[a][b];', '                                        newBoard.pieces[a][b] = null;', '                                        moves.add(newBoard);', '                                    }', '                                    if (pieces[a][d] != null)', '                                        break;', '                                }', '                            }', '                        }', ""                        if (pieces[a][b].type == 'B' || pieces[a][b].type == 'Q') {"", '                            for (int c = -1; c <= 1; c += 2) {', '                                for (int d = -1; d <= 1; d += 2) {', '                                    for (int e = 1; a+e*c >= 0 && a+e*c < 4 && b+e*d >= 0 && b+e*d < 4; e++) {', '                                        int f = a+e*c;', '                                        int g = b+e*d;', '                                        ', '                                        if (pieces[f][g] == null || pieces[f][g].isWhite != whiteToMove) {', '                                            Board newBoard = new Board(this);', '                                            newBoard.pieces[f][g] = newBoard.pieces[a][b];', '                                            newBoard.pieces[a][b] = null;', '                                            moves.add(newBoard);', '                                        }', '                                        if (pieces[f][g] != null)', '                                            break;', '                                    }', '                                }', '                            }', '                        }', '                    }', '                }', '            }', '            return moves;', '        }', '        ', '        public boolean doesQueenExist(boolean whiteQueen) {', '            for (int a = 0; a < 4; a++) {', '                for (int b = 0; b < 4; b++) {', ""                    if (pieces[a][b] != null && pieces[a][b].type == 'Q' && pieces[a][b].isWhite == whiteQueen)"", '                        return true;', '                }', '            }', '            return false;', '        }', '        ', '        public boolean canCaptureQueen(boolean whiteToMove) {', '            ArrayList<Board> moves = legalMoves(whiteToMove);', '            for (Board b : moves) {', '                if (!b.doesQueenExist(!whiteToMove))', '                    return true;', '            }', '            return false;', '        }', '        ', '        public boolean canReachGoalWhite(int rem) {', '            if (canCaptureQueen(true))', '                return true;', '            if (rem==1)', '                return false;', '            ArrayList<Board> moves = legalMoves(true);', '            for (Board b : moves) {', '                if (!b.canStopGoalBlack(rem))', '                    return true;', '            }', '            return false;', '        }', '        ', '        public boolean canStopGoalBlack(int rem) {', '            if (canCaptureQueen(false))', '                return true;', '            ArrayList<Board> moves = legalMoves(false);', '            for (Board b : moves) {', '                if (!b.canReachGoalWhite(rem-1))', '                    return true;', '            }', '            return false;', '        }', '    }', '    ', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(System.in);', '        int g = sc.nextInt();', '        for (int z = 0; z < g; z++) {', '            int w = sc.nextInt();', '            int b = sc.nextInt();', '            int m = (sc.nextInt()+1)/2;', '            ArrayList<String> wl = new ArrayList<String>();', '            ArrayList<String> bl = new ArrayList<String>();', '            sc.nextLine();', '            for (int i = 0; i < w; i++) {', '                wl.add(sc.nextLine());', '            }', '            for (int i = 0; i < b; i++) {', '                bl.add(sc.nextLine());', '            }', '            Board start = new Board(wl, bl);', '            System.out.println(start.canReachGoalWhite(m)?""YES"":""NO"");', '        }', '    }', '}']"
"['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', 'import java.util.PriorityQueue;', '', 'public class Solution {', ' static InputStream is;', ' static PrintWriter out;', ' static String INPUT = """";', ' ', ' static void solve()', ' {', '  for(int T = ni();T >= 1;T--){', '   int n = ni(), K = ni();', '   long xx = 1;', '   int U = Math.min(K, n-1);', '   for(int i = 1;i <= U;i++){', '    xx *= n-1+K-i+1;', '    xx /= i;', '   }', '   int x = (int)xx;', '   long[] a = new long[x];', '   for(int i = 0;i < x;i++)a[i] = nl();', '   Arrays.sort(a);', '   long[] ret = new long[n];', '   ret[0] = a[0] / K;', '   if(n == 1){', '    out.println(ret[0]);', '    continue;', '   }', '   if(n == 2){', '    ret[1] = a[x-1] / K;', '    out.println(ret[0] + "" "" + ret[1]);', '    continue;', '   }', '   // K <= 16', '   PriorityQueue<Long> pq = new PriorityQueue<Long>(x+1);', '   for(long v : a)pq.add(v);', '   PriorityQueue<Long> ng = new PriorityQueue<Long>(x+1);', '   pq.poll();', '   for(int i = 1;i < n;i++){', '    while(!ng.isEmpty() && ng.peek().equals(pq.peek())){', '     pq.poll(); ng.poll();', '    }', '//    tr(""pq"", pq);', '//    tr(""ng"", ng);', '    ret[i] = pq.poll() - (K-1)*ret[0];', '//    tr(ng);', '    if(i < n-1){', '     dfs(K-1, ret[i], 0, i, ret, ng);', '     ng.poll();', '    }', '   }', '   for(int i = 0;i < n;i++){', '    if(i > 0)out.print("" "");', '    out.print(ret[i]);', '   }', '   out.println();', '  }', ' }', ' ', ' static void dfs(int rem, long cur, int ind, int sup, long[] ret, PriorityQueue<Long> ng)', ' {', '  if(rem == 0){', '   ng.add(cur);', '  }else{', '   for(int j = ind;j <= sup;j++){', '    dfs(rem-1, cur+ret[j], j, sup, ret, ng);', '   }', '  }', ' }', ' ', ' static void dff(int rem, long cur, int ind, int sup, long[] ret, StringBuilder sb)', ' {', '  if(rem == 0){', '   sb.append(cur + "" "");', '  }else{', '   for(int j = ind;j <= sup;j++){', '    dff(rem-1, cur+ret[j], j, sup, ret, sb);', '   }', '  }', ' }', ' ', ' public static void main(String[] args) throws Exception', ' {', '//  Random gen = new Random();', '//  StringBuilder sb = new StringBuilder();', '//  int n = 0, K = 0;', '//  int x = 0;', '//  outer:', '//  while(true){', '//   n = gen.nextInt(50)+1;', '//   K = gen.nextInt(50)+1;', '//   long xx = 1;', '//   for(int i = 1;i <= K;i++){', '//    xx *= n-1+K-i+1;', '//    xx /= i;', '//    if(xx >= 10000000)continue outer;', '//   }', '//   if(xx <= 100000){', '//    x = (int)xx;', '//    break;', '//   }', '//  }', '//  tr(n, K);', '//  sb.append(1 + "" "");', '//  sb.append(n + "" "");', '//  sb.append(K + "" "");', '//  ', '//  long[] a = new long[n];', '//  for(int i = 0;i < n;i++){', '//   long M = 1000000000000000000L / K;', '////   long M = 100L / K;', '//   a[i] = Math.abs(gen.nextLong() % M) + 1;', '//  }', '//  Arrays.sort(a);', '//  tr(a);', '//  dff(K, 0, 0, n-1, a, sb);', '//  tr(sb);', '//  INPUT = sb.toString();', '  ', '  long S = System.currentTimeMillis();', '  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '  out = new PrintWriter(System.out);', '  ', '  solve();', '  out.flush();', '  long G = System.currentTimeMillis();', '  tr(G-S+""ms"");', ' }', ' ', ' private static boolean eof()', ' {', '  if(lenbuf == -1)return true;', '  int lptr = ptrbuf;', '  while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '  ', '  try {', '   is.mark(1000);', '   while(true){', '    int b = is.read();', '    if(b == -1){', '     is.reset();', '     return true;', '    }else if(!isSpaceChar(b)){', '     is.reset();', '     return false;', '    }', '   }', '  } catch (IOException e) {', '   return true;', '  }', ' }', ' ', ' private static byte[] inbuf = new byte[1024];', ' static int lenbuf = 0, ptrbuf = 0;', ' ', ' private static int readByte()', ' {', '  if(lenbuf == -1)throw new InputMismatchException();', '  if(ptrbuf >= lenbuf){', '   ptrbuf = 0;', '   try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '   if(lenbuf <= 0)return -1;', '  }', '  return inbuf[ptrbuf++];', ' }', ' ', ' private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', ' private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', ' ', ' private static double nd() { return Double.parseDouble(ns()); }', ' private static char nc() { return (char)skip(); }', ' ', ' private static String ns()', ' {', '  int b = skip();', '  StringBuilder sb = new StringBuilder();', ""  while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '   sb.appendCodePoint(b);', '   b = readByte();', '  }', '  return sb.toString();', ' }', ' ', ' private static char[] ns(int n)', ' {', '  char[] buf = new char[n];', '  int b = skip(), p = 0;', '  while(p < n && !(isSpaceChar(b))){', '   buf[p++] = (char)b;', '   b = readByte();', '  }', '  return n == p ? buf : Arrays.copyOf(buf, p);', ' }', ' ', ' private static char[][] nm(int n, int m)', ' {', '  char[][] map = new char[n][];', '  for(int i = 0;i < n;i++)map[i] = ns(m);', '  return map;', ' }', ' ', ' private static int[] na(int n)', ' {', '  int[] a = new int[n];', '  for(int i = 0;i < n;i++)a[i] = ni();', '  return a;', ' }', ' ', ' private static int ni()', ' {', '  int num = 0, b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static long nl()', ' {', '  long num = 0;', '  int b;', '  boolean minus = false;', ""  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""  if(b == '-'){"", '   minus = true;', '   b = readByte();', '  }', '  ', '  while(true){', ""   if(b >= '0' && b <= '9'){"", ""    num = num * 10 + (b - '0');"", '   }else{', '    return minus ? -num : num;', '   }', '   b = readByte();', '  }', ' }', ' ', ' private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']","['import java.io.ByteArrayInputStream;', 'import java.io.IOException;', 'import java.io.InputStream;', 'import java.io.PrintWriter;', 'import java.util.Arrays;', 'import java.util.InputMismatchException;', 'import java.util.PriorityQueue;', '', 'public class Solution {', '    static InputStream is;', '    static PrintWriter out;', '    static String INPUT = """";', '    ', '    static void solve()', '    {', '        for(int T = ni();T >= 1;T--){', '            int n = ni(), K = ni();', '            long xx = 1;', '            int U = Math.min(K, n-1);', '            for(int i = 1;i <= U;i++){', '                xx *= n-1+K-i+1;', '                xx /= i;', '            }', '            int x = (int)xx;', '            long[] a = new long[x];', '            for(int i = 0;i < x;i++)a[i] = nl();', '            Arrays.sort(a);', '            long[] ret = new long[n];', '            ret[0] = a[0] / K;', '            if(n == 1){', '                out.println(ret[0]);', '                continue;', '            }', '            if(n == 2){', '                ret[1] = a[x-1] / K;', '                out.println(ret[0] + "" "" + ret[1]);', '                continue;', '            }', '            // K <= 16', '            PriorityQueue<Long> pq = new PriorityQueue<Long>(x+1);', '            for(long v : a)pq.add(v);', '            PriorityQueue<Long> ng = new PriorityQueue<Long>(x+1);', '            pq.poll();', '            for(int i = 1;i < n;i++){', '                while(!ng.isEmpty() && ng.peek().equals(pq.peek())){', '                    pq.poll(); ng.poll();', '                }', '//                tr(""pq"", pq);', '//                tr(""ng"", ng);', '                ret[i] = pq.poll() - (K-1)*ret[0];', '//                tr(ng);', '                if(i < n-1){', '                    dfs(K-1, ret[i], 0, i, ret, ng);', '                    ng.poll();', '                }', '            }', '            for(int i = 0;i < n;i++){', '                if(i > 0)out.print("" "");', '                out.print(ret[i]);', '            }', '            out.println();', '        }', '    }', '    ', '    static void dfs(int rem, long cur, int ind, int sup, long[] ret, PriorityQueue<Long> ng)', '    {', '        if(rem == 0){', '            ng.add(cur);', '        }else{', '            for(int j = ind;j <= sup;j++){', '                dfs(rem-1, cur+ret[j], j, sup, ret, ng);', '            }', '        }', '    }', '    ', '    static void dff(int rem, long cur, int ind, int sup, long[] ret, StringBuilder sb)', '    {', '        if(rem == 0){', '            sb.append(cur + "" "");', '        }else{', '            for(int j = ind;j <= sup;j++){', '                dff(rem-1, cur+ret[j], j, sup, ret, sb);', '            }', '        }', '    }', '    ', '    public static void main(String[] args) throws Exception', '    {', '//        Random gen = new Random();', '//        StringBuilder sb = new StringBuilder();', '//        int n = 0, K = 0;', '//        int x = 0;', '//        outer:', '//        while(true){', '//            n = gen.nextInt(50)+1;', '//            K = gen.nextInt(50)+1;', '//            long xx = 1;', '//            for(int i = 1;i <= K;i++){', '//                xx *= n-1+K-i+1;', '//                xx /= i;', '//                if(xx >= 10000000)continue outer;', '//            }', '//            if(xx <= 100000){', '//                x = (int)xx;', '//                break;', '//            }', '//        }', '//        tr(n, K);', '//        sb.append(1 + "" "");', '//        sb.append(n + "" "");', '//        sb.append(K + "" "");', '//        ', '//        long[] a = new long[n];', '//        for(int i = 0;i < n;i++){', '//            long M = 1000000000000000000L / K;', '////            long M = 100L / K;', '//            a[i] = Math.abs(gen.nextLong() % M) + 1;', '//        }', '//        Arrays.sort(a);', '//        tr(a);', '//        dff(K, 0, 0, n-1, a, sb);', '//        tr(sb);', '//        INPUT = sb.toString();', '        ', '        long S = System.currentTimeMillis();', '        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());', '        out = new PrintWriter(System.out);', '        ', '        solve();', '        out.flush();', '        long G = System.currentTimeMillis();', '        tr(G-S+""ms"");', '    }', '    ', '    private static boolean eof()', '    {', '        if(lenbuf == -1)return true;', '        int lptr = ptrbuf;', '        while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;', '        ', '        try {', '            is.mark(1000);', '            while(true){', '                int b = is.read();', '                if(b == -1){', '                    is.reset();', '                    return true;', '                }else if(!isSpaceChar(b)){', '                    is.reset();', '                    return false;', '                }', '            }', '        } catch (IOException e) {', '            return true;', '        }', '    }', '    ', '    private static byte[] inbuf = new byte[1024];', '    static int lenbuf = 0, ptrbuf = 0;', '    ', '    private static int readByte()', '    {', '        if(lenbuf == -1)throw new InputMismatchException();', '        if(ptrbuf >= lenbuf){', '            ptrbuf = 0;', '            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }', '            if(lenbuf <= 0)return -1;', '        }', '        return inbuf[ptrbuf++];', '    }', '    ', '    private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }', '    private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }', '    ', '    private static double nd() { return Double.parseDouble(ns()); }', '    private static char nc() { return (char)skip(); }', '    ', '    private static String ns()', '    {', '        int b = skip();', '        StringBuilder sb = new StringBuilder();', ""        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')"", '            sb.appendCodePoint(b);', '            b = readByte();', '        }', '        return sb.toString();', '    }', '    ', '    private static char[] ns(int n)', '    {', '        char[] buf = new char[n];', '        int b = skip(), p = 0;', '        while(p < n && !(isSpaceChar(b))){', '            buf[p++] = (char)b;', '            b = readByte();', '        }', '        return n == p ? buf : Arrays.copyOf(buf, p);', '    }', '    ', '    private static char[][] nm(int n, int m)', '    {', '        char[][] map = new char[n][];', '        for(int i = 0;i < n;i++)map[i] = ns(m);', '        return map;', '    }', '    ', '    private static int[] na(int n)', '    {', '        int[] a = new int[n];', '        for(int i = 0;i < n;i++)a[i] = ni();', '        return a;', '    }', '    ', '    private static int ni()', '    {', '        int num = 0, b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static long nl()', '    {', '        long num = 0;', '        int b;', '        boolean minus = false;', ""        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));"", ""        if(b == '-'){"", '            minus = true;', '            b = readByte();', '        }', '        ', '        while(true){', ""            if(b >= '0' && b <= '9'){"", ""                num = num * 10 + (b - '0');"", '            }else{', '                return minus ? -num : num;', '            }', '            b = readByte();', '        }', '    }', '    ', '    private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(System.in);', '        long n = sc.nextLong();', '        int m = sc.nextInt();', '        long[] s = new long[m];', '        for (int i = 0; i < m; i++)', '            s[i] = sc.nextLong();', '        for (int i = 0; i < m; i++) {', '            if (n%s[i]==0&&s[i]%2==0) {', '                System.out.println(""First"");', '                return;', '            }', '        }', '        HashMap<Long, Boolean> tried = new HashMap<Long, Boolean>();', '        System.out.println(canWin(n,s,tried)?""First"":""Second"");', '    }', '    ', '    public static boolean canWin(long n, long[] s, HashMap<Long, Boolean> tried) {', '        if (tried.containsKey(n))', '            return tried.get(n);', '        for (long i : s) {', '            if (n%i==0) {', '                if (!canWin(n/i, s, tried)) {', '                    tried.put(n, true);', '                    return true;', '                }', '            }', '        }', '        tried.put(n, false);', '        return false;', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    public static long zero = 0L;', '    ', '    static int findMex(HashSet<Integer> grundys){', '        int mex = 0;', '        while(grundys.contains(mex)){', '            mex++;', '        }', '        return mex;', '    }', '    ', '    ', '    static int getGrundy(long n, long[] s, Hashtable<Long, Integer> grundyVals){', '       ', '        if (n == zero){', '            return 0;', '        }', '        else if (grundyVals.containsKey(n)){', '            return grundyVals.get(n);', '        }', '        else{', '            HashSet<Integer>nextPositions = new HashSet<Integer>();', '            for (int i = 0; i < s.length; i++){', '                if (n % s[i] == zero){', '                    long pilesize = n/s[i];', '                    int g = 0;', '                    if(s[i]%2L != 0L){', '                        g = getGrundy(pilesize, s, grundyVals);', '                    }', '                    ', '                    nextPositions.add(g);', '                }', '            }', '            if(nextPositions.isEmpty()){', '                return 0;', '            }', '            else{', '                int mex = findMex(nextPositions);', '                grundyVals.put(n, mex);', '                return mex;', '            }', '        }', '    }', '    ', '    static String stoneDivision(long n, long[] s) {', '        ', '        Hashtable<Long, Integer> grundyVals = new Hashtable<Long, Integer>();', '        Arrays.sort(s);', '', '        ', '        int grundy_val = getGrundy(n, s, grundyVals);', '        if (grundy_val == 0){', '            return new String(""Second"");', '        }', '        else{', '            return new String(""First"");', '        }', '       ', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        String[] nm = scanner.nextLine().split("" "");', '', '        long n = Long.parseLong(nm[0].trim());', '', '        int m = Integer.parseInt(nm[1].trim());', '', '        long[] s = new long[m];', '', '        String[] sItems = scanner.nextLine().split("" "");', '', '        for (int sItr = 0; sItr < m; sItr++) {', '            long sItem = Long.parseLong(sItems[sItr].trim());', '            s[sItr] = sItem;', '        }', '', '        String result = stoneDivision(n, s);', '', '        bufferedWriter.write(result);', '        bufferedWriter.newLine();', '', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'public class SimpleGame {', '    final static long MOD = 1000000007;', '    static int K;', '    static HashMap<Integer, BitSet>[] cache;', '    static int[] mexCache;', '', '    static int mex(int n) {', '        if (mexCache[n] == -1) {', '            mexCache[n] = 0;', '            BitSet set = new BitSet();', '            for (int k = 2; k <= K; ++k) {', '                set.or(d(n, k));', '            }', '            while (set.get(mexCache[n])) {', '                mexCache[n]++;', '            }', '        }', '        return mexCache[n];', '    }', '', '    static BitSet d(int n, int k) {', '        if (cache[n] == null) {', '            cache[n] = new HashMap<>();', '        }', '        BitSet ret = cache[n].get(k);', '        if (ret == null) {', '            ret = new BitSet();', '            if (k == 1) {', '                ret.set(mex(n));', '            } else {', '                for (int n1 = 1; n1 < n; ++n1) {', '                    BitSet s1 = d(n1, k - 1);', '                    int v2 = mex(n - n1);', '                    for (int v1 = s1.nextSetBit(0); v1 >= 0; v1 = s1.nextSetBit(v1 + 1)) {', '                        ret.set(v1 ^ v2);', '                    }', '                }', '            }', '            cache[n].put(k, ret);', '        }', '        return ret;', '    }', '', '    public static void solve(Input in, PrintWriter out) throws IOException {', '        int n = in.nextInt();', '        int m = in.nextInt();', '        K = in.nextInt();', '        int[] values = new int[n + 1];', '        if (K <= 3) {', '            cache = new HashMap[n + 1];', '            mexCache = new int[n + 1];', '            Arrays.fill(mexCache, -1);', '            for (int i = 0; i <= n; ++i) {', '                values[i] = mex(i);', '            }', '        } else {', '            for (int i = 2; i <= n; ++i) {', '                values[i] = i - 1;', '            }', '        }', '        int maxValue = 1;', '        for (int i = 0; i <= n; ++i) {', '            while (maxValue <= values[i]) {', '                maxValue *= 2;', '            }', '        }', '        long[][] d = new long[n + 1][maxValue];', '        d[0][0] = 1;', '        for (int it = 0; it < m; ++it) {', '            long[][] d1 = new long[n + 1][maxValue];', '            for (int i = 0; i <= n; ++i) {', '                for (int v = 0; v < maxValue; ++v) {', '                    if (d[i][v] == 0) {', '                        continue;', '                    }', '                    for (int j = 1; i + j <= n; ++j) {', '                        d1[i + j][v ^ values[j]] += d[i][v];', '                    }', '                }', '            }', '            d = d1;', '            for (int i = 0; i <= n; ++i) {', '                for (int v = 0; v < maxValue; ++v) {', '                    d[i][v] %= MOD;', '                }', '            }', '        }', '        long ans = 0;', '        for (int v = 1; v < maxValue; ++v) {', '            ans += d[n][v];', '        }', '        out.println(ans % MOD);', '    }', '', '    public static void main(String[] args) throws IOException {', '        PrintWriter out = new PrintWriter(System.out);', '        solve(new Input(new BufferedReader(new InputStreamReader(System.in))), out);', '        out.close();', '    }', '', '    static class Input {', '        BufferedReader in;', '        StringBuilder sb = new StringBuilder();', '', '        public Input(BufferedReader in) {', '            this.in = in;', '        }', '', '        public Input(String s) {', '            this.in = new BufferedReader(new StringReader(s));', '        }', '', '        public String next() throws IOException {', '            sb.setLength(0);', '            while (true) {', '                int c = in.read();', '                if (c == -1) {', '                    return null;', '                }', '                if ("" \\n\\r\\t"".indexOf(c) == -1) {', '                    sb.append((char)c);', '                    break;', '                }', '            }', '            while (true) {', '                int c = in.read();', '                if (c == -1 || "" \\n\\r\\t"".indexOf(c) != -1) {', '                    break;', '                }', '                sb.append((char)c);', '            }', '            return sb.toString();', '        }', '', '        public int nextInt() throws IOException {', '            return Integer.parseInt(next());', '        }', '', '        public long nextLong() throws IOException {', '            return Long.parseLong(next());', '        }', '', '        public double nextDouble() throws IOException {', '            return Double.parseDouble(next());', '        }', '    }', '}']","['import java.util.*;', '', 'import java.util.*;', '', 'public class Solution {', '    private static class NimCounter {', '        final long[] nimCounter;', '', '        NimCounter(int splitVal) {', '            nimCounter  =  new long[splitVal];', '        }', '    }', '', '    private static long mod = 1000000007;', '    private static Map<Integer, Integer> k3nimberCache = new HashMap<>();', '', '    private static void split(int pile, int lastUsedVal, int k, List<Integer> currentSplit, List<List<Integer>> splittings) {', '        if (pile == 0 && currentSplit.size() > 1) {', '            splittings.add(new ArrayList<>(currentSplit));', '            return;', '        }', '', '        if (pile < lastUsedVal) return;', '', '        if (currentSplit.size() == k - 1) {', '            currentSplit.add(pile);', '            splittings.add(new ArrayList<>(currentSplit));', '            currentSplit.remove(currentSplit.size() - 1);', '        } else {', '            for (int i = lastUsedVal; i <= pile; ++i) {', '                currentSplit.add(i);', '                split(pile - i, i, k, currentSplit, splittings);', '                currentSplit.remove(currentSplit.size() - 1);', '            }', '        }', '    }', '', '    private static int mex(List<Integer> nimbers) {', '        Collections.sort(nimbers);', '        for (int i = 0; i < nimbers.size(); ++i) {', '            if (nimbers.get(i) != i) return i;', '        }', '        return nimbers.size();', '    }', '', '    private static int nimberk3(List<Integer> split, int k) {', '        int result = 0;', '        for (Integer i : split) {', '            result = result ^ nimValue(i, k);', '        }', '        return result;', '    }', '', '    private static int nimValue(int splitValue, int maxPilesNum) {', '        if (splitValue < 2) return 0;', '        if (maxPilesNum == 2) return 1 - (splitValue % 2);', '        if (maxPilesNum > 3) return splitValue - 1;', '', '        Integer cached = k3nimberCache.get(splitValue);', '        if (cached != null) return cached;', '', '        List<List<Integer>> splits = new ArrayList<>();', '        split(splitValue,1, maxPilesNum, new ArrayList<Integer>(), splits);', '', '        Set<Integer> nimbers = new HashSet<>();', '        for (List<Integer> aSplit : splits) {', '            nimbers.add(nimberk3(aSplit, maxPilesNum));', '        }', '', '        int result = mex(new ArrayList<>(nimbers));', '        k3nimberCache.put(splitValue, result);', '', '        return result;', '    }', '', '    private static long solve(int stones, int initialPilesNum, int splitPilesNum) {', '        NimCounter[][] nimCounters = new NimCounter[initialPilesNum + 1][stones + 1];', '        for (int i = 0; i <= initialPilesNum; ++i) {', '            for (int j = 0; j <= stones; ++j) nimCounters[i][j] = new NimCounter(stones);', '        }', '', '        for (int i = 1; i <= stones; ++i) {', '            ++nimCounters[1][i].nimCounter[nimValue(i, splitPilesNum)];', '        }', '', '        for (int splitInto = 2; splitInto <= initialPilesNum; ++splitInto) {', '            for (int splitValue = splitInto; splitValue <= stones; ++splitValue) {', '                NimCounter splitCounter = nimCounters[splitInto][splitValue];', '                for (int leaveAtPile = 1; leaveAtPile <= splitValue - splitInto + 1; ++leaveAtPile) {', '                    int nimAtPile = nimValue(leaveAtPile, splitPilesNum);', '                    NimCounter counter = nimCounters[splitInto - 1][splitValue - leaveAtPile];', '                    for (int cnt = 0; cnt < counter.nimCounter.length; ++cnt) {', '                        if (counter.nimCounter[cnt] > 0) {', '                            splitCounter.nimCounter[nimAtPile ^ cnt] += counter.nimCounter[cnt];', '                        }', '                    }', '                }', '            }', '        }', '', '        NimCounter counter = nimCounters[initialPilesNum][stones];', '        long result = 0;', '        for (int i = 1; i < counter.nimCounter.length; ++i) {', '            result = (result + counter.nimCounter[i]) % mod;', '        }', '', '        return result;', '    }', '', '    public static void main(String[] params) {', '        Scanner scanner = new Scanner(System.in);', '        String[] input = scanner.nextLine().split("" "");', '        System.out.println(solve(Integer.parseInt(input[0]), Integer.parseInt(input[1]), Integer.parseInt(input[2])));', '    }', '}']"
"['import java.util.ArrayList;', 'import java.util.List;', 'import java.util.Scanner;', '', 'public class MoveCoins {', ' private static class Node {', '  int coins;', '  List<Integer> connections = new ArrayList<>();', ' }', '', ' public static boolean isChild(int v1, int v2, int[] left, int[] right) {', '  return (left[v1] > left[v2] && right[v1] <= right[v2]);', ' }', '', ' public static int dfs(int v, boolean isEven, Node[] nodes, int c, int[] left, int[] right, boolean[] even) {', '  left[v] = c;', '  even[v] = isEven;', '', '  for (int connection : nodes[v].connections) {', '   if (left[connection] == 0) {', '    c = dfs(connection, !isEven, nodes, c + 1, left, right, even);', '   }', '  }', '  right[v] = c;', '  return c;', ' }', '', ' public static int calc(int v, boolean isEven, Node[] nodes, int[] resEven, int[] resOdd, int[] left) {', '  int res = isEven ? nodes[v].coins : 0;', '', '  for (int connection : nodes[v].connections) {', '   if (left[connection] > left[v]) {', '    res ^= calc(connection, !isEven, nodes, resEven, resOdd, left);', '   }', '  }', '  if (isEven) {', '   resEven[v] = res;', '  } else {', '   resOdd[v] = res;', '  }', '  return res;', ' }', '', ' public static void main(String args[]) {', '  Scanner in = new Scanner(System.in);', '', '  int n = in.nextInt();', '  Node[] nodes = new Node[n];', '', '  for (int i = 0; i < n; i++) {', '   nodes[i] = new Node();', '   nodes[i].coins = in.nextInt();', '  }', '', '  for (int i = 0; i < n - 1; i++) {', '   int v1 = in.nextInt() - 1;', '   int v2 = in.nextInt() - 1;', '', '   nodes[v1].connections.add(v2);', '   nodes[v2].connections.add(v1);', '  }', '', '  int[] left = new int[n], right = new int[n];', '  boolean[] even = new boolean[n];', '  dfs(0, false, nodes, 1, left, right, even);', '', '  int[] resEven = new int[n], resOdd = new int[n];', '  calc(0, false, nodes, resEven, resOdd, left);', '  calc(0, true, nodes, resEven, resOdd, left);', '', '  int xor = resOdd[0];', '', '  int q = in.nextInt();', '  for (int test=0; test<q; test++) {', '   int v = in.nextInt() - 1;', '   int p = in.nextInt() - 1;', '', '   if (isChild(p, v, left, right)) {', '    System.out.println(""INVALID"");', '   } else {', '    int r = xor;', '    if (even[v]) {', '     r ^= resEven[v];', '    } else {', '     r ^= resOdd[v];', '    }', '    if (even[p]) {', '     r ^= resOdd[v];', '    } else {', '     r ^= resEven[v];', '    }', '    System.out.println(r > 0 ? ""YES"" : ""NO"");', '   }', '  }', ' }', '}']","['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', '', '  static Node[] nodes;', '  static int tick;', '  ', '  static class Node {', '    List<Integer> adjacents = new ArrayList<>();', '    int c;', '    int dep;', '    int pre;', '    int post;', '    int[] nim = new int[2];', '', '    public Node(int c) {', '      this.c = c;', '    }', '  }', '  ', '    static void dfs(int u, int d, int p) {', '      Node node = nodes[u]; ', '      node.nim[d] += node.c;', '      node.dep = d;', '      node.pre = tick++;', '      for (int v: node.adjacents) {', '        if (v != p) {', '          dfs(v, d ^ 1, u);', '          for (int i = 0; i < 2; i++) {', '            node.nim[i] ^= nodes[v].nim[i];', '          }', '        }', '      }', '      node.post = tick;', '    }', '', '    public static void main(String[] args) throws IOException {', '        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bw = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '      StringTokenizer st = new StringTokenizer(br.readLine());', '      int n = Integer.parseInt(st.nextToken());', '', '      st = new StringTokenizer(br.readLine());', '      nodes = new Node[n];', '      for (int i = 0; i < n; i++) {', '        int c = Integer.parseInt(st.nextToken());', '        nodes[i] = new Node(c);', '      }', '      ', '      for (int i = 0; i < n - 1; i++) {', '        st = new StringTokenizer(br.readLine());', '        int u = Integer.parseInt(st.nextToken()) - 1;', '        int v = Integer.parseInt(st.nextToken()) - 1;', '        nodes[u].adjacents.add(v);', '        nodes[v].adjacents.add(u);', '      }', '      ', '      dfs(0, 0, -1);', '', '      st = new StringTokenizer(br.readLine());', '      int q = Integer.parseInt(st.nextToken());', '      while (q-- > 0) {', '        st = new StringTokenizer(br.readLine());', '        Node u = nodes[Integer.parseInt(st.nextToken()) - 1];', '        Node v = nodes[Integer.parseInt(st.nextToken()) - 1];', '        if (u.pre <= v.pre && v.pre < u.post) {', '          bw.write(""INVALID"");', '        } else {', '          int temp = (u.dep ^ v.dep) > 0 ? 0 : u.nim[0] ^ u.nim[1];', '          bw.write(((nodes[0].nim[1] ^ temp) > 0 ? ""YES"" : ""NO""));', '        }', '        bw.newLine();', '      }', '      bw.close();', '      br.close();', '    }', '}']"
"['import java.io.*;', 'import java.math.BigInteger;', 'import java.util.*;', '', 'public class Solution implements Runnable {', '', '    // leave empty to read from stdin/stdout', '    private static final String TASK_NAME_FOR_IO = """";', '', '    // file names', '    private static final String FILE_IN = TASK_NAME_FOR_IO + "".in"";', '    private static final String FILE_OUT = TASK_NAME_FOR_IO + "".out"";', '', '    BufferedReader in;', '    PrintWriter out;', '    StringTokenizer tokenizer = new StringTokenizer("""");', '', '    public static void main(String[] args) {', '        new Solution().run();', '    }', '', '    class State {', '        int[] d;', '', '        public State(int num) {', '            this(Arrays.asList(num));', '        }', '', '        public State(int num1, int num2) {', '            this(Arrays.asList(num1, num2));', '        }', '', '        public State(int num1, int num2, int num3) {', '            this(Arrays.asList(num1, num2, num3));', '        }', '', '        State(Collection<Integer> current) {', '            d = new int[current.size()];', '            int idx = 0;', '            for (int v : current) {', '                d[idx++] = v;', '            }', '            Arrays.sort(d);', '        }', '', '        @Override', '        public boolean equals(Object o) {', '            if (this == o) return true;', '            if (o == null || getClass() != o.getClass()) return false;', '', '            State state = (State) o;', '', '            if (!Arrays.equals(d, state.d)) return false;', '', '            return true;', '        }', '', '        @Override', '        public int hashCode() {', '            return d != null ? Arrays.hashCode(d) : 0;', '        }', '', '        public State replaceAndTrim(int idxReplace, State replaceWith) {', '            List<Integer> all = new ArrayList<Integer>();', '            for (int i = 0; i < d.length; i++)', '                if (i != idxReplace && d[i] >= 3) {', '                    all.add(d[i]);', '                }', '            for (int i = 0; i < replaceWith.d.length; i++)', '                if (replaceWith.d[i] >= 3) {', '                    all.add(replaceWith.d[i]);', '                }', '            return new State(all);', '        }', '', '        public boolean isEmpty() {', '            return d.length <= 0;', '        }', '    }', '', '    class Split {', '        List<State> list = new ArrayList<State>();', '', '        public void add(LinkedList<Integer> current) {', '            list.add(new State(current));', '        }', '', '    }', '', '    class GameState {', '        State state;', '        int who;', '', '        GameState(State state, int who) {', '            this.state = state;', '            this.who = who;', '        }', '', '        @Override', '        public boolean equals(Object o) {', '            if (this == o) return true;', '            if (o == null || getClass() != o.getClass()) return false;', '', '            GameState gameState = (GameState) o;', '', '            if (who != gameState.who) return false;', '            if (state != null ? !state.equals(gameState.state) : gameState.state != null) return false;', '', '            return true;', '        }', '', '        @Override', '        public int hashCode() {', '            int result = state != null ? state.hashCode() : 0;', '            result = 31 * result + who;', '            return result;', '        }', '    }', '', '    int MAX_STONES = 50;', '    Split[] splits = new Split[MAX_STONES + 1];', '    Map<GameState, Boolean> answer = new HashMap<GameState, Boolean>();', '    Map<GameState, Long> answerGrandi = new HashMap<GameState, Long>();', '', '    int[] GRANDI = new int[] {', '            0,', '            0,', '            0,', '            1,', '            0,', '            2,', '            3,', '            4,', '            0,', '            5,', '            6,', '            7,', '            8,', '            9,', '            10,', '            11,', '            12,', '            13,', '            14,', '            15,', '            16,', '            17,', '            18,', '            19,', '            20,', '            21,', '            22,', '            23,', '            24,', '            25,', '            26,', '            27,', '            28,', '            29,', '            30,', '            31,', '            32,', '            33,', '            34,', '            35,', '            36,', '            37,', '            38,', '            39,', '            40,', '            41,', '            42,', '            43,', '            44,', '            45,', '            46', '    };', '', '    private void solve() throws IOException {', '        for (int i = 0; i <= MAX_STONES; i++) {', '            splits[i] = new Split();', '            genSplits(i, 0, splits[i], new LinkedList<Integer>());', '        }', '', '        /*', '        for (int i = 0; i <= 50; i++) {', '            System.out.println(grandi(new State(i), 0) + "", "");', '        }', '        */', '', '        int tc = nextInt();', '        for (int t = 0; t < tc; t++) {', '            int n = nextInt();', '            int xor = 0;', '            for (int i = 0; i < n; i++) {', '                // xor ^= grandi(new State(nextInt()), 0);', '                xor ^= GRANDI[nextInt()];', '            }', '', '            if (xor != 0) {', '                out.println(""ALICE"");', '            } else {', '                out.println(""BOB"");', '            }', '        }', '    }', '', '    private void compareWithNaive() {', '        for (int i = 1; i <= 20; i++) {', '            State state = new State(i);', '', '            boolean a1 = play(state, 0);', '            boolean a2 = grandi(new State(i), 0) != 0;', '            if (a1 != a2) {', '                throw new IllegalStateException(""Error: "" + i);', '            }', '        }', '', '        for (int i = 1; i <= 20; i++)', '            for (int j = 1; j <= 20; j++) {', '                State state = new State(i, j);', '', '                boolean a1 = play(state, 0);', '                boolean a2 = (grandi(new State(i), 0) ^ grandi(new State(j), 0)) != 0;', '                if (a1 != a2) {', '                    throw new IllegalStateException();', '                }', '            }', '', '        for (int i = 1; i <= 20; i++)', '            for (int j = 1; j <= 20; j++)', '                for (int k = 1; k <= 20; k++) {', '                    State state = new State(i, j, k);', '', '                    boolean a1 = play(state, 0);', '                    boolean a2 = (grandi(new State(i), 0) ^ grandi(new State(j), 0) ^ grandi(new State(k), 0)) != 0;', '                    if (a1 != a2) {', '                        throw new IllegalStateException();', '                    }', '                }', '    }', '', '    private boolean play(State state, int who) {', '        if (state.isEmpty()) {', '            return false;', '        }', '', '        GameState gameState = new GameState(state, who);', '        if (answer.containsKey(gameState)) {', '            return answer.get(gameState);', '        }', '', '        boolean win = false;', '        Set<Integer> tried = new HashSet<Integer>();', '        for (int idxReplace = 0; idxReplace < state.d.length; idxReplace++) {', '            int num = state.d[idxReplace];', '            if (tried.contains(num)) {', '                continue;', '            }', '            tried.add(num);', '', '            for (State replaceWith : splits[num].list) {', '                State nState = state.replaceAndTrim(idxReplace, replaceWith);', '                boolean otherWins = play(nState, 1 - who);', '                if (!otherWins) {', '                    win = true;', '                    break;', '                }', '            }', '            if (win) {', '                break;', '            }', '        }', '', '        answer.put(gameState, win);', '        return win;', '    }', '', '    private long grandi(State state, int who) {', '        if (state.isEmpty()) {', '            return 0;', '        }', '', '        GameState gameState = new GameState(state, who);', '        if (answerGrandi.containsKey(gameState)) {', '            return answerGrandi.get(gameState);', '        }', '', '        Set<Long> grandiAll = new HashSet<Long>();', '        for (int idxReplace = 0; idxReplace < state.d.length; idxReplace++) {', '            int num = state.d[idxReplace];', '', '            for (State replaceWith : splits[num].list) {', '                State nState = state.replaceAndTrim(idxReplace, replaceWith);', '                grandiAll.add(grandi(nState, 1 - who));', '            }', '        }', '', '        long result = 0;', '        while (grandiAll.contains(result)) {', '            result++;', '        }', '        answerGrandi.put(gameState, result);', '        return result;', '    }', '', '    private void genSplits(int remaining, int lastUsed, Split split, LinkedList<Integer> current) {', '        if (remaining < 0) {', '            throw new IllegalStateException();', '        }', '        if (remaining == 0) {', '            if (current.size() > 1) {', '                split.add(current);', '            }', '            return;', '        }', '', '        int i = lastUsed + 1;', '        while (remaining - i >= 0) {', '            current.addLast(i);', '            genSplits(remaining - i, i, split, current);', '            current.removeLast();', '            i++;', '        }', '    }', '', '    public void run() {', '        long timeStart = System.currentTimeMillis();', '', '        boolean fileIO = TASK_NAME_FOR_IO.length() > 0;', '        try {', '', '            if (fileIO) {', '                in = new BufferedReader(new FileReader(FILE_IN));', '                out = new PrintWriter(new FileWriter(FILE_OUT));', '            } else {', '                in = new BufferedReader(new InputStreamReader(System.in));', '                out = new PrintWriter(new OutputStreamWriter(System.out));', '            }', '', '            solve();', '', '            in.close();', '            out.close();', '        } catch (IOException e) {', '            throw new IllegalStateException(e);', '        }', '        long timeEnd = System.currentTimeMillis();', '', '        if (fileIO) {', '            System.out.println(""Time spent: "" + (timeEnd - timeStart) + "" ms"");', '        }', '    }', '', '    private String nextToken() throws IOException {', '        while (!tokenizer.hasMoreTokens()) {', '            String line = in.readLine();', '            if (line == null) {', '                return null;', '            }', '            tokenizer = new StringTokenizer(line);', '        }', '        return tokenizer.nextToken();', '    }', '', '    private int nextInt() throws IOException {', '        return Integer.parseInt(nextToken());', '    }', '', '    private BigInteger nextBigInt() throws IOException {', '        return new BigInteger(nextToken());', '    }', '', '    private long nextLong() throws IOException {', '        return Long.parseLong(nextToken());', '    }', '', '    private double nextDouble() throws IOException {', '        return Double.parseDouble(nextToken());', '    }', '', '}']","['import java.util.*;', 'import java.io.*;', 'public class Solution {', '    public static void main(String args[])', '    {', '        new Solution();', '    }', '    ', '    HashMap<Integer, Integer> sgnums;', '    ArrayList<ArrayList<Integer>> groups[][];', '     public Solution()', '    {', '         groups = new ArrayList[55][55];', '         sgnums = new HashMap();', '         sgnums.put(0, 0);', '         sgnums.put(1, 0);', '         sgnums.put(2, 0);', '         Scanner sc = new Scanner(System.in);', '        ', '        int n = new Integer(sc.nextLine());', '        for(int c = 0; c < n; c++)', '        {', '            sc.nextLine();', '            String[] info = sc.nextLine().split("" "");', '            ArrayList<Integer> position = new ArrayList();', '            for(String s: info)', '            {', '                int pile = new Integer(s);', '                if(pile >= 3)', '                    position.add(pile);', '            }', '            if(sg(position) != 0)', '                System.out.println(""ALICE"");', '            else', '                System.out.println(""BOB"");', '        }', '    }', '     ', '     public int sg(ArrayList<Integer> arr)', '     {', '         int ret = 0;', '         for(Integer i: arr)', '         {', '             ret ^= sg(i);', '         }', '         return ret;', '     }', '     ', '     public int sg(int n)', '     {', '         Integer ret = sgnums.get(n);', '         if(ret != null)', '             return ret;', '         ', '         ArrayList<ArrayList<Integer>> groups = groups(1, n);', '         HashSet<Integer> mex = new HashSet();', '         for(ArrayList<Integer> arr: groups)', '         {', '             if(arr.size() > 1)', '                 mex.add(sg(arr));', '         }', '         for(int i = 0; ;i++)', '         {', '             if(!mex.contains(i))', '             {', '                 sgnums.put(n, i);', '                 return i;', '             }', '         }', '     }', '     ', '     public ArrayList<ArrayList<Integer>> groups(int startFrom, int target)', '     {', '         if(target == 0)', '         {', '             ArrayList<ArrayList<Integer>> ret = new ArrayList<ArrayList<Integer>>();', '             ret.add(new ArrayList());', '             return ret;', '         }', '         if(startFrom > target)', '             return new ArrayList<ArrayList<Integer>>();', '         if(target < 0)', '             return new ArrayList<ArrayList<Integer>>();', '             ', '         if(groups[startFrom][target] != null)', '             return groups[startFrom][target];', '         ArrayList<ArrayList<Integer>> ret = new ArrayList();         ', '         ArrayList<ArrayList<Integer>> take = groups(startFrom+1, target-startFrom);', '         for(ArrayList<Integer> arr: take)', '         {', '             ArrayList<Integer> addArr = (ArrayList<Integer>) arr.clone();', '             addArr.add(startFrom);', '             ret.add(addArr);', '         }', '         ', '        ArrayList<ArrayList<Integer>> notake = groups(startFrom+1, target);', '        for(ArrayList<Integer> arr: notake)', '         {', '            ArrayList<Integer> addArr = (ArrayList<Integer>) arr.clone();', '             ret.add(addArr);', '         }', '         ', '         groups[startFrom][target] = ret;', '         return ret;', '     }', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'public class Solution {', ' public static void main(String[] args) {', '  new Solution().run();', ' }', '', ' BufferedReader br;', ' StringTokenizer in;', ' PrintWriter out;', '', ' public String nextToken() throws IOException {', '  while (in == null || !in.hasMoreTokens()) {', '   in = new StringTokenizer(br.readLine());', '  }', '  return in.nextToken();', ' }', '', ' public int nextInt() throws IOException {', '  return Integer.parseInt(nextToken());', ' }', '', ' public long nextLong() throws IOException {', '  return Long.parseLong(nextToken());', ' }', '', ' public void solve(int n) throws IOException {', '  int[] a = new int[n];', '', '  for (int i = 0; i < a.length; i++) {', '   a[i] = nextInt();', '  }', '', '  long ans = 0;', '', '  for (int st = 2; st <= 3; st++) {', '   HashMap<Integer, Integer> cnt = new HashMap<>();', '   cnt.put(0, 1);', '   int xor = 0;', '   for (int i = a.length - st; i >= 0; i -= 2) {', '    xor ^= a[i + 1] - a[i];', '    if (!cnt.containsKey(xor)) {', '     cnt.put(xor, 0);', '    }', '    int z = cnt.get(xor);', '    ans += z;', '    cnt.put(xor, z + 1);', '', '    if (i > 0) {', '     if (cnt.containsKey(xor ^ a[i - 1])) {', '      ans += cnt.get(xor ^ a[i - 1]);', '     }', '    }', '   }', '  }', '', '  out.println(1L * n * (n - 1) / 2 - ans);', ' }', '', ' public void run() {', '  try {', '   br = new BufferedReader(new InputStreamReader(System.in));', '   out = new PrintWriter(System.out);', '', '   solve(nextInt());', '', '   out.close();', '  } catch (IOException e) {', '   e.printStackTrace();', '   System.exit(1);', '  }', ' }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc = new Scanner(System.in);', '        long ans = 0;', '        int n = sc.nextInt();', '        int[] a = new int[n];', '        for (int i = 0; i < n; i++) {', '            a[i] = sc.nextInt();', '        }', '        for (int k = 2; k <= 3; k++) {', '            Map<Integer, Integer> map = new TreeMap<Integer, Integer>();', '            map.put(0, 1);', '            int key = 0;', '            for (int i=n-k; i>=0; i-=2) {', '                key ^= a[i+1]-a[i];', '                if (!map.containsKey(key)) {', '                    map.put(key, 0);', '                }', '                int value = map.get(key);', '                ans += value;', '                map.put(key, value + 1);', '                if (i>0 && map.containsKey(key^a[i-1])) {', '                    ans += map.get(key^a[i-1]);', '                }', '            }', '        }', '        System.out.println((1L*n*(n-1)/2)-ans);', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    static final int[] M = {2, 3, 5, 7, 11, 13};', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int T = in.nextInt();', '        int N;', '        int sum;', '        int j;', '        for (int i = 0; i < T; i++) {', '            N = in.nextInt();', '            sum = 0;', '            for (j = 0; j < N; j++) {', '                sum = sum ^ ((int) ((in.nextLong() % 9) / 2));', '            }', '            System.out.println(sum == 0 ? ""Sandy"" : ""Manasa"");', '        }', '        /*int n = 1000;', '        int[] a = new int[n + 1];', '        Set<Integer> s = new HashSet<>();', '        int j;', '        StringBuilder b;', '        for (int i = 0; i <= n; i++) {', '            s.clear();', '            for (int p : M) {', '                if (p <= i) {', '                    s.add(a[i - p]);', '                }', '            }', '            for (j = 0; ; j++) {', '                if (!s.contains(j)) {', '                    a[i] = j;', '                    break;', '                }', '            }', '            b = new StringBuilder();', '            b.append(i + "" "" + a[i]);', '            for (int p : M) {', '                if (p <= i) {', '                    b.append("" "" + a[i - p]);', '                }', '            }', '            System.out.println(b);', '        }*/', '    }', '}']","['import java.io.*;  ', 'import java.util.*;  ', 'import java.text.*;  ', 'import java.math.*;  ', 'import java.util.regex.*;  ', '', 'public class Solution {  ', '', '    public static void main(String[] args) {  ', '        int t = ni();  ', '        for(int i=0; i<t; i++){  ', '            System.out.println(solve());  ', '        }  ', '    }  ', '', '    public static int[] values = new int[]{0, 0, 1, 1, 2, 2, 3, 3, 4};  ', '    public static String solve(){  ', '        int n = ni();  ', '        long ak;  ', '        long nimber = 0; //or grundy number  ', '        for(int i=0; i<n; i++){  ', '            ak = nl();  ', '            nimber ^= values[(int) (ak % values.length)];', '        }  ', '        if(nimber > 0) return ""Manasa"";  ', '        return ""Sandy"";  ', '    }  ', '', '    public static Scanner sc = new Scanner(System.in);  ', '    public static int ni(){  ', '        return sc.nextInt();  ', '    }  ', '    public static long nl(){  ', '        return sc.nextLong();  ', '    }  ', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '    private static final long mod = 1000000007;', '    private static long m;', '    private static long pow;', '    ', '    public static void main(String[] args) {', '        //long start = System.currentTimeMillis();', '        ', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        m = in.nextLong();', '        pow = pow(2, m);', '        ', '        long[] solves = new long[n+1];', '        long[] semiSolves = new long[n+1];', '        long[] products = new long[n+1];', '        semiSolves[0] = 1;', '        semiSolves[1] = 0;', '        products[0] = 1;', '        products[1] = (pow - 1 + mod) % mod;', '        solves[0] = 0;', '        solves[1] = products[1];', '        for (int i = 2; i <= n; i++){', '            products[i] = (((pow - i + mod) % mod) * products[i-1]) % mod;', '            semiSolves[i] = ', '                (solves[i-1] - ((i-1) * ((semiSolves[i-2] * ((pow - 1 - (i-2) + mod) % mod)) % mod)) % mod + mod) % mod;', '            solves[i] = (products[i] - semiSolves[i] + mod) % mod;', '        }', '        ', '        System.out.println(solves[n]);', '        /*', '        for (int i = 0; i <= n; i++){', '            System.out.println(i + "" : "" + solve(i) + "" "" + semiSolve(i) + "" "" + product(i));', '        }*/', '        //System.out.println(System.currentTimeMillis() - start);', '    }', '    /*', '    private static Map<Long, Long> solves = new HashMap<Long, Long>();', '    private static long solve(long n){', '        if (solves.containsKey(n)) return solves.get(n);', '        if (n == 0) solves.put(n, 0L);', '        else solves.put(n, (product(n) - semiSolve(n) + mod) % mod);', '        return solve(n);', '    }', '    ', '    private static Map<Long, Long> semiSolves = new HashMap<Long, Long>();', '    private static long semiSolve(long n){', '        if (semiSolves.containsKey(n)) return semiSolves.get(n);', '        if (n == 0) semiSolves.put(n, 1L);', '        else if (n == 1) semiSolves.put(n, 0L);', '        else semiSolves.put(n, ', '            (solve(n-1) - ((n-1) * ((semiSolve(n-2) * ((pow - 1 - (n-2) + mod) % mod)) % mod)) % mod + mod) % mod);', '        return semiSolve(n);', '    }', '    ', '    private static Map<Long, Long> products = new HashMap<Long, Long>();', '    private static long product(long n){', '        if (products.containsKey(n)) return products.get(n);', '        if (n == 0) products.put(n, 1L);', '        else products.put(n, ((pow - n) * product(n-1)) % mod);', '        return product(n);', '    }*/', '    ', '    private static long pow(long b, long p){', '        if (p == 0) return 1;', '        if (p % 2 == 1) return 2 * pow(b, p - 1) % mod;', '        long q = pow(b, p / 2);', '        return q * q % mod;', '    }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class TastesLikeWinning {', '    private static final long mod = 1000000007;', '    private static long m;', '    private static long pow;', '    ', '    public static void main(String[] args) {', '        ', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        m = in.nextLong();', '        pow = pow(2, m);', '        ', '        long[] solves = new long[n+1];', '        long[] semiSolves = new long[n+1];', '        long[] products = new long[n+1];', '        semiSolves[0] = 1;', '        semiSolves[1] = 0;', '        products[0] = 1;', '        products[1] = (pow - 1 + mod) % mod;', '        solves[0] = 0;', '        solves[1] = products[1];', '        for (int i = 2; i <= n; i++){', '            products[i] = (((pow - i + mod) % mod) * products[i-1]) % mod;', '            semiSolves[i] = ', '                (solves[i-1] - ((i-1) * ((semiSolves[i-2] * ((pow - 1 - (i-2) + mod) % mod)) % mod)) % mod + mod) % mod;', '            solves[i] = (products[i] - semiSolves[i] + mod) % mod;', '        }', '        ', '        System.out.println(solves[n]);', '    }', '   ', '    ', '    private static long pow(long b, long p){', '        if (p == 0) return 1;', '        if (p % 2 == 1) return 2 * pow(b, p - 1) % mod;', '        long q = pow(b, p / 2);', '        return q * q % mod;', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        int m = in.nextInt();', '        int n1=0;', '        int n2=0;', '        ArrayList<ArrayList<Integer>> nodeConn = new ArrayList<ArrayList<Integer>>();', '        int[] nodeLen = new int[n];', '        for (int i=0; i<n; i++){', '            nodeConn.add(new ArrayList<Integer>());', '        }', '        for (int i=0; i<m; i++){', '            n1 = in.nextInt()-1;', '            n2 = in.nextInt()-1;', '            nodeConn.get(n1).add(n2);', '            nodeLen[n1]++;', '            nodeConn.get(n2).add(n1);', '            nodeLen[n2]++;', '        }', '        int min=0;', '        for (int i=0; i<n; i++){', '            //System.out.print((i+1) + "" ""+ nodeLen[i]+"" "");', '            if(nodeLen[i]<nodeLen[min])', '                min=i;', '            //System.out.println(min+1);', '        }', '        ArrayList<Integer> temp = new ArrayList<Integer>();', '        int currNode = 0;', '        int newMin = 0;', '        int count = 0;', '        int[] path = new int[n];', '        while(nodeLen[min]!=0&&count<=n){', '            path[count]=min+1;', '            temp = nodeConn.get(min);', '            newMin=temp.get(0);', '            for(int i=0; i<temp.size(); i++){', '                currNode = temp.get(i);', '                nodeConn.get(currNode).remove((Integer)min);', '                nodeLen[currNode]--;', '                if(nodeLen[currNode]<nodeLen[newMin])', '                    newMin=currNode;', '            }', '            min = newMin;', '            count++;', '        }', '        if(count!=n){', '            path[count]=min+1;', '            count++;', '        }', '        System.out.println(count);', '        for (int i=0; i<count; i++){', '            System.out.print(path[i] + "" "");', '        }', '    }', '}']","['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', ' ', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        int m = in.nextInt();', '        int n1=0;', '        int n2=0;', '        ArrayList<ArrayList<Integer>> nodeConn = new ArrayList<ArrayList<Integer>>();', '        int[] nodeLen = new int[n];', '        for (int i=0; i<n; i++){', '            nodeConn.add(new ArrayList<Integer>());', '        }', '        for (int i=0; i<m; i++){', '            n1 = in.nextInt()-1;', '            n2 = in.nextInt()-1;', '            nodeConn.get(n1).add(n2);', '            nodeLen[n1]++;', '            nodeConn.get(n2).add(n1);', '            nodeLen[n2]++;', '        }', '        int min=0;', '        for (int i=0; i<n; i++){', '            //System.out.print((i+1) + "" ""+ nodeLen[i]+"" "");', '            if(nodeLen[i]<nodeLen[min])', '                min=i;', '            //System.out.println(min+1);', '        }', '        ArrayList<Integer> temp = new ArrayList<Integer>();', '        int currNode = 0;', '        int newMin = 0;', '        int count = 0;', '        int[] path = new int[n];', '        while(nodeLen[min]!=0&&count<=n){', '            path[count]=min+1;', '            temp = nodeConn.get(min);', '            newMin=temp.get(0);', '            for(int i=0; i<temp.size(); i++){', '                currNode = temp.get(i);', '                nodeConn.get(currNode).remove((Integer)min);', '                nodeLen[currNode]--;', '                if(nodeLen[currNode]<nodeLen[newMin])', '                    newMin=currNode;', '            }', '            min = newMin;', '            count++;', '        }', '        if(count!=n){', '            path[count]=min+1;', '            count++;', '        }', '        System.out.println(count);', '        for (int i=0; i<count; i++){', '            System.out.print(path[i] + "" "");', '        }', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'import static java.lang.Math.min;', 'import static java.lang.Math.max;', '', 'public class Solution {', '    ', '    static class DynamicList<E> extends AbstractList<E> implements List<E> {', '        ', '        static final private class Block<E> {', '', '            int size;', '', '            private int offset;', '            private final E[] values;', '', '            @SuppressWarnings(""unchecked"")', '            Block(int capacity) {', '                this.offset = 0;', '                this.size = 0;', '                this.values = (E[]) new Object[capacity];', '            }', '', '            E addFirst(final E value) {', '                offset = (offset - 1) & (values.length-1);', '                E last = values[offset];', '                values[offset] = value;', '                if (size < values.length) {', '                    size++;', '                }', '                return last;', '            }', '            ', '            void addLast(final E value) {', '                if (size == values.length)', '                    return;', '                values[(offset + size) & (values.length-1)] = value;', '                size++;', '            }', '            ', '            E add(final int index, final E value) {', '                E last = (size == values.length) ? values[(offset - 1) & (values.length-1)] : null;', '                if (2*index < size) {', '                    offset = (offset - 1) & (values.length-1);', '                    for (int i = 0; i < index; i++) {', '                        values[(offset + i) & (values.length-1)] = values[(offset + i + 1) & (values.length-1)];', '                    }', '                }', '                else {', '                    for (int i = (size == values.length) ? size-1 : size; i > index; i--) {', '                        values[(offset + i) & (values.length-1)] = values[(offset + i - 1) & (values.length-1)];', '                    }', '                }', '                values[(offset + index) & (values.length-1)] = value;', '                if (size < values.length) size++;', '                return last;', '            }', '', '            E set(final int index, final E value) {', '                int i = (offset + index) & (values.length-1);', '                E replaced = values[i];', '                values[i] = value;', '                return replaced;', '            }', '            ', '            E removeFirst() {', '                E removed = values[offset];', '                values[offset] = null;', '                offset = (offset + 1) & (values.length-1);', '                size--;', '                return removed;', '            }', '            ', '            E remove(final int index) {', '                E removed = values[(offset + index) & (values.length-1)];', '                if (2*index < size) {', '                    for (int i = index; i > 0; i--) {', '                        values[(offset + i) & (values.length-1)] = values[(offset + i - 1) & (values.length-1)];                    ', '                    }', '                    values[offset] = null;', '                    offset = (offset + 1) & (values.length-1);', '                }', '                else {', '                    for (int i = index + 1; i < size; i++) {', '                        values[(offset + i - 1) & (values.length-1)] = values[(offset + i) & (values.length-1)];', '                    }', '                    values[(offset + size - 1) & (values.length-1)] = null;', '                }', '                size--;', '                return removed;', '            }', '            ', '            E get(final int index) {', '                return values[(offset + index) & (values.length-1)];', '            }', '        }', '        ', '        public int size;', '        ', '        private final int blockBitsize;', '        private Block<E>[] data;', '        ', '        @SuppressWarnings(""unchecked"")', '        public DynamicList(int capacity) {', '            byte blockBitsize = 4;', '            while (capacity > 1L << (2*blockBitsize)) {', '                blockBitsize++;', '            }', '            data = new Block[1 + (int) ((capacity-1) >> blockBitsize)];', '            for (int i = 0; i < data.length; i++)', '                data[i] = new Block<E>(1 << blockBitsize);', '            this.size = 0;', '            this.blockBitsize = blockBitsize;', '        }', '        ', '        public E get(final int index) {', '            final int blockIndex = (int) (index >>> blockBitsize);', '            final int valueIndex = (int) (index & (-1L >>> -blockBitsize));', '            return data[blockIndex].get(valueIndex);', '        }', '        ', '        public E set(final int index, E value) {', '            final int blockIndex = (int) (index >>> blockBitsize);', '            final int valueIndex = (int) (index & (-1L >>> -blockBitsize));', '            return data[blockIndex].set(valueIndex, value);', '        }', '        ', '        public void add(final int index, E value) {', '            int blockIndex = (int) (index >>> blockBitsize);', '            int valueIndex = (int) (index & (-1L >>> -blockBitsize));', '            int blockSize = 1 << blockBitsize;', '            if (data[blockIndex].size < blockSize) {', '                data[blockIndex].add(valueIndex, value);', '            }', '            else {', '                value = data[blockIndex].add(valueIndex, value);', '                while (data[++blockIndex].size == blockSize) {', '                    value = data[blockIndex].addFirst(value);', '                }', '                data[blockIndex].addFirst(value);', '            }', '            size++;', '        }', '        ', '        public E remove(final int index) {', '            int blockIndex = (int) (index >>> blockBitsize);', '            int valueIndex = (int) (index & (-1L >>> -blockBitsize));', '            E removed = data[blockIndex].remove(valueIndex);', '            while (++blockIndex < data.length && data[blockIndex].size > 0) {', '                data[blockIndex-1].addLast(data[blockIndex].removeFirst());', '            }', '            size--;', '            return removed;', '        }', '', '        public int size() {', '            return size;', '        }', '    }', '', '    static class ImmutableArray {', '        ', '        ImmutableArray parent;', '        int[] value;', '        final int length;', '        ', '        ImmutableArray(ImmutableArray arr, int... value) {', '            this.parent = arr;', '            this.value = value;', '            length = (parent == null) ? 0 : (parent.length+1);', '        }', '        ', '        ImmutableArray add(int... value) {', '            return new ImmutableArray(this, value);', '        }', '        ', '        public String toString() {', '            if (parent == null)', '                return """";', ""            return parent.toString() + (value[0]+1) + ' ' + (value[1]+1) + ' ' + value[2] + '\\n';"", '        }', '    }', '    ', '    static class Grid implements Comparable<Grid> {', '        ', '        private final int n;', '        private final int[][] data;', '        ', '        private final ImmutableArray moves;', '        ', '        private int score = -1;', '        private final int[] rowScores;', '        private final int[] colScores;', '        ', '        public Grid(int[][] grid) {', '            n = grid.length;', '            data = new int[n][n];', '            for (int i = 0; i < n; i++)', '                for (int j = 0; j < n; j++)', '                    data[i][j] = grid[i][j];', '            moves = new ImmutableArray(null, null);', '            rowScores = new int[n];', '            Arrays.fill(rowScores, -1);', '            colScores = new int[n];', '            Arrays.fill(colScores, -1);', '        }', '        ', '        public Grid(Grid parent, int row, int col, int k) {', '            n = parent.n;', '            data = new int[n][n];', '            for (int i = 0; i < n; i++)', '                if (i < row | i >= row+k)', '                    data[i] = parent.data[i];', '                else', '                    data[i] = parent.data[i].clone();                ', '', '            for (int i = 0; i < k; i++) {', '                for (int j = 0; j < k; j++)', '                    data[row+i][col+j] = parent.data[row+k-j-1][col+i];', '            }', '            moves = parent.moves.add(row, col, k);', '            ', '            rowScores = parent.rowScores.clone();', '            colScores = parent.colScores.clone();', '            for (int i = 0; i < k; i++) {', '                rowScores[row+i] = -1;', '                colScores[col+i] = -1;', '            }', '        }', '        ', '        private static int evaluateScore(int[] v) {', '            int score = 0;', '            for (int i = 1; i < v.length; i++) {', '                int vi = v[i];', '                for (int j = 0; j < i; j++)', '                    score += (v[j] - vi) >>> 31;', '            }', '            return score;', '        }', '        ', '        private void evaluateScore() {', '            score = 0;', '            for (int i = 0; i < n; i++) {', '                if (rowScores[i] < 0)', '                    rowScores[i] = evaluateScore(data[i]);', '                score += rowScores[i];', '            }', '            int[] b = new int[n];', '            for (int j = 0; j < n; j++) {', '                if (colScores[j] < 0) {', '                    for (int i = 0; i < n; i++)', '                        b[i] = data[i][j];', '                    colScores[j] = evaluateScore(b);                    ', '                }', '                score += colScores[j];', '            }', '        }', '', '        public int score() {', '            if (score < 0)', '                evaluateScore();', '            return score;', '        }', '        ', '        public String toString() {', '            return moves.length + ""\\n"" + moves.toString();', '        }', '', '        public int compareTo(Grid o) {', '            return (score() > o.score()) ? -1 : (score() < o.score()) ? 1 : (moves.length - o.moves.length);', '        }', '    }', '    ', '    static int randIdx(Random rand, int size) {', '        return min(rand.nextInt(size), rand.nextInt(size));', '    }', '    ', '    private static int MAX_GRIDS = 1250;', '    private static int MAX_MOVES = 500;', '    ', '    public static void main(String[] args) {', '        long executionStart = System.currentTimeMillis();', '        ', '        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in), 256 << 10));', '        int n = in.nextInt();', '        int[][] grid = new int[n][n];', '        for (int i = 0; i < n; i++)', '            for (int j = 0; j < n; j++)', '                grid[i][j] = in.nextInt();', '        in.close();', '        ', '        List<Grid> grids = new DynamicList<Grid>(MAX_GRIDS+1);', '        Grid srcGrid = new Grid(grid);', '        grids.add(srcGrid);', '        for (int k = n; k > 1 & k > n-7; k--) {', '            for (int row = 0; row < n-k+1; row++)', '                for (int col = 0; col < n-k+1; col++) {', '                    Grid ng = srcGrid;', '                    for (int i = 0; i < 3; i++) {', '                        ng = new Grid(ng, row, col, k);', '', '                        int insertionIndex = Collections.binarySearch(grids, ng);', '                        if (insertionIndex < 0)', '                            insertionIndex = ~insertionIndex;', '                        grids.add(insertionIndex, ng);                        ', '                    }', '            }', '        }', '        ', '        Grid best = grids.get(0);', '        if (n > 1) {', '            Random rand = new Random();', '            long timePassed = System.currentTimeMillis() - executionStart;', '            int maxk = max(2, (int) (n * 0.70));', '            while (timePassed < 3600) {', '                int idx = randIdx(rand, grids.size());', '                while (grids.get(idx).moves.length >= MAX_MOVES) {', '                    if (best.compareTo(grids.get(idx)) > 0)', '                        best = grids.get(idx);', '                    grids.remove(idx);', '                    idx = randIdx(rand, grids.size());', '                }', '                if (grids.isEmpty())', '                    break;', '', '                int k = max(2, min(rand.nextInt(n+1), maxk));', '                int row = rand.nextInt(n-k+1);', '                int col = rand.nextInt(n-k+1);', '                Grid ng = new Grid(grids.get(idx), row, col, k);', '', '                int insertionIndex = Collections.binarySearch(grids, ng);', '                if (insertionIndex < 0)', '                    insertionIndex = ~insertionIndex;', '                grids.add(insertionIndex, ng);', '', '                if (grids.size() > MAX_GRIDS)', '                    grids.remove(MAX_GRIDS);', '', '                timePassed = System.currentTimeMillis() - executionStart;', '                if (timePassed > 600)', '                    maxk = max(2, (int) (n * 0.40));', '                if (timePassed > 1200)', '                    maxk = max(2, (int) (n * 0.30));', '                if (timePassed > 1800)', '                    maxk = max(2, (int) (n * 0.20));', '                if (timePassed > 2400)', '                    maxk = max(2, (int) (n * 0.15));', '                if (timePassed > 3000)', '                    maxk = 2;', '            }', '        }', '        ', '        if (best.compareTo(grids.get(0)) > 0)', '            best = grids.get(0);', '', '        System.out.print(best);', '        //System.out.print(best.score());', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', 'import static java.lang.Math.min;', 'import static java.lang.Math.max;', '', 'public class Solution {', '    ', '    static class DynamicList<E> extends AbstractList<E> implements List<E> {', '        ', '        static final private class Block<E> {', '', '            int size;', '', '            private int offset;', '            private final E[] values;', '', '            @SuppressWarnings(""unchecked"")', '            Block(int capacity) {', '                this.offset = 0;', '                this.size = 0;', '                this.values = (E[]) new Object[capacity];', '            }', '', '            E addFirst(final E value) {', '                offset = (offset - 1) & (values.length-1);', '                E last = values[offset];', '                values[offset] = value;', '                if (size < values.length) {', '                    size++;', '                }', '                return last;', '            }', '            ', '            void addLast(final E value) {', '                if (size == values.length)', '                    return;', '                values[(offset + size) & (values.length-1)] = value;', '                size++;', '            }', '            ', '            E add(final int index, final E value) {', '                E last = (size == values.length) ? values[(offset - 1) & (values.length-1)] : null;', '                if (2*index < size) {', '                    offset = (offset - 1) & (values.length-1);', '                    for (int i = 0; i < index; i++) {', '                        values[(offset + i) & (values.length-1)] = values[(offset + i + 1) & (values.length-1)];', '                    }', '                }', '                else {', '                    for (int i = (size == values.length) ? size-1 : size; i > index; i--) {', '                        values[(offset + i) & (values.length-1)] = values[(offset + i - 1) & (values.length-1)];', '                    }', '                }', '                values[(offset + index) & (values.length-1)] = value;', '                if (size < values.length) size++;', '                return last;', '            }', '', '            E set(final int index, final E value) {', '                int i = (offset + index) & (values.length-1);', '                E replaced = values[i];', '                values[i] = value;', '                return replaced;', '            }', '            ', '            E removeFirst() {', '                E removed = values[offset];', '                values[offset] = null;', '                offset = (offset + 1) & (values.length-1);', '                size--;', '                return removed;', '            }', '            ', '            E remove(final int index) {', '                E removed = values[(offset + index) & (values.length-1)];', '                if (2*index < size) {', '                    for (int i = index; i > 0; i--) {', '                        values[(offset + i) & (values.length-1)] = values[(offset + i - 1) & (values.length-1)];                    ', '                    }', '                    values[offset] = null;', '                    offset = (offset + 1) & (values.length-1);', '                }', '                else {', '                    for (int i = index + 1; i < size; i++) {', '                        values[(offset + i - 1) & (values.length-1)] = values[(offset + i) & (values.length-1)];', '                    }', '                    values[(offset + size - 1) & (values.length-1)] = null;', '                }', '                size--;', '                return removed;', '            }', '            ', '            E get(final int index) {', '                return values[(offset + index) & (values.length-1)];', '            }', '        }', '        ', '        public int size;', '        ', '        private final int blockBitsize;', '        private Block<E>[] data;', '        ', '        @SuppressWarnings(""unchecked"")', '        public DynamicList(int capacity) {', '            byte blockBitsize = 4;', '            while (capacity > 1L << (2*blockBitsize)) {', '                blockBitsize++;', '            }', '            data = new Block[1 + (int) ((capacity-1) >> blockBitsize)];', '            for (int i = 0; i < data.length; i++)', '                data[i] = new Block<E>(1 << blockBitsize);', '            this.size = 0;', '            this.blockBitsize = blockBitsize;', '        }', '        ', '        public E get(final int index) {', '            final int blockIndex = (int) (index >>> blockBitsize);', '            final int valueIndex = (int) (index & (-1L >>> -blockBitsize));', '            return data[blockIndex].get(valueIndex);', '        }', '        ', '        public E set(final int index, E value) {', '            final int blockIndex = (int) (index >>> blockBitsize);', '            final int valueIndex = (int) (index & (-1L >>> -blockBitsize));', '            return data[blockIndex].set(valueIndex, value);', '        }', '        ', '        public void add(final int index, E value) {', '            int blockIndex = (int) (index >>> blockBitsize);', '            int valueIndex = (int) (index & (-1L >>> -blockBitsize));', '            int blockSize = 1 << blockBitsize;', '            if (data[blockIndex].size < blockSize) {', '                data[blockIndex].add(valueIndex, value);', '            }', '            else {', '                value = data[blockIndex].add(valueIndex, value);', '                while (data[++blockIndex].size == blockSize) {', '                    value = data[blockIndex].addFirst(value);', '                }', '                data[blockIndex].addFirst(value);', '            }', '            size++;', '        }', '        ', '        public E remove(final int index) {', '            int blockIndex = (int) (index >>> blockBitsize);', '            int valueIndex = (int) (index & (-1L >>> -blockBitsize));', '            E removed = data[blockIndex].remove(valueIndex);', '            while (++blockIndex < data.length && data[blockIndex].size > 0) {', '                data[blockIndex-1].addLast(data[blockIndex].removeFirst());', '            }', '            size--;', '            return removed;', '        }', '', '        public int size() {', '            return size;', '        }', '    }', '', '    static class ImmutableArray {', '        ', '        ImmutableArray parent;', '        int[] value;', '        final int length;', '        ', '        ImmutableArray(ImmutableArray arr, int... value) {', '            this.parent = arr;', '            this.value = value;', '            length = (parent == null) ? 0 : (parent.length+1);', '        }', '        ', '        ImmutableArray add(int... value) {', '            return new ImmutableArray(this, value);', '        }', '        ', '        public String toString() {', '            if (parent == null)', '                return """";', ""            return parent.toString() + (value[0]+1) + ' ' + (value[1]+1) + ' ' + value[2] + '\\n';"", '        }', '    }', '    ', '    static class Grid implements Comparable<Grid> {', '        ', '        private final int n;', '        private final int[][] data;', '        ', '        private final ImmutableArray moves;', '        ', '        private int score = -1;', '        private final int[] rowScores;', '        private final int[] colScores;', '        ', '        public Grid(int[][] grid) {', '            n = grid.length;', '            data = new int[n][n];', '            for (int i = 0; i < n; i++)', '                for (int j = 0; j < n; j++)', '                    data[i][j] = grid[i][j];', '            moves = new ImmutableArray(null, null);', '            rowScores = new int[n];', '            Arrays.fill(rowScores, -1);', '            colScores = new int[n];', '            Arrays.fill(colScores, -1);', '        }', '        ', '        public Grid(Grid parent, int row, int col, int k) {', '            n = parent.n;', '            data = new int[n][n];', '            for (int i = 0; i < n; i++)', '                if (i < row | i >= row+k)', '                    data[i] = parent.data[i];', '                else', '                    data[i] = parent.data[i].clone();                ', '', '            for (int i = 0; i < k; i++) {', '                for (int j = 0; j < k; j++)', '                    data[row+i][col+j] = parent.data[row+k-j-1][col+i];', '            }', '            moves = parent.moves.add(row, col, k);', '            ', '            rowScores = parent.rowScores.clone();', '            colScores = parent.colScores.clone();', '            for (int i = 0; i < k; i++) {', '                rowScores[row+i] = -1;', '                colScores[col+i] = -1;', '            }', '        }', '        ', '        private static int evaluateScore(int[] v) {', '            int score = 0;', '            for (int i = 1; i < v.length; i++) {', '                int vi = v[i];', '                for (int j = 0; j < i; j++)', '                    score += (v[j] - vi) >>> 31;', '            }', '            return score;', '        }', '        ', '        private void evaluateScore() {', '            score = 0;', '            for (int i = 0; i < n; i++) {', '                if (rowScores[i] < 0)', '                    rowScores[i] = evaluateScore(data[i]);', '                score += rowScores[i];', '            }', '            int[] b = new int[n];', '            for (int j = 0; j < n; j++) {', '                if (colScores[j] < 0) {', '                    for (int i = 0; i < n; i++)', '                        b[i] = data[i][j];', '                    colScores[j] = evaluateScore(b);                    ', '                }', '                score += colScores[j];', '            }', '        }', '', '        public int score() {', '            if (score < 0)', '                evaluateScore();', '            return score;', '        }', '        ', '        public String toString() {', '            return moves.length + ""\\n"" + moves.toString();', '        }', '', '        public int compareTo(Grid o) {', '            return (score() > o.score()) ? -1 : (score() < o.score()) ? 1 : (moves.length - o.moves.length);', '        }', '    }', '    ', '    static int randIdx(Random rand, int size) {', '        return min(rand.nextInt(size), rand.nextInt(size));', '    }', '    ', '    private static int MAX_GRIDS = 1250;', '    private static int MAX_MOVES = 500;', '    ', '    public static void main(String[] args) {', '        long executionStart = System.currentTimeMillis();', '        ', '        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in), 256 << 10));', '        int n = in.nextInt();', '        int[][] grid = new int[n][n];', '        for (int i = 0; i < n; i++)', '            for (int j = 0; j < n; j++)', '                grid[i][j] = in.nextInt();', '        in.close();', '        ', '        List<Grid> grids = new DynamicList<Grid>(MAX_GRIDS+1);', '        Grid srcGrid = new Grid(grid);', '        grids.add(srcGrid);', '        for (int k = n; k > 1 & k > n-7; k--) {', '            for (int row = 0; row < n-k+1; row++)', '                for (int col = 0; col < n-k+1; col++) {', '                    Grid ng = srcGrid;', '                    for (int i = 0; i < 3; i++) {', '                        ng = new Grid(ng, row, col, k);', '', '                        int insertionIndex = Collections.binarySearch(grids, ng);', '                        if (insertionIndex < 0)', '                            insertionIndex = ~insertionIndex;', '                        grids.add(insertionIndex, ng);                        ', '                    }', '            }', '        }', '        ', '        Grid best = grids.get(0);', '        if (n > 1) {', '            Random rand = new Random();', '            long timePassed = System.currentTimeMillis() - executionStart;', '            int maxk = max(2, (int) (n * 0.70));', '            while (timePassed < 3600) {', '                int idx = randIdx(rand, grids.size());', '                while (grids.get(idx).moves.length >= MAX_MOVES) {', '                    if (best.compareTo(grids.get(idx)) > 0)', '                        best = grids.get(idx);', '                    grids.remove(idx);', '                    idx = randIdx(rand, grids.size());', '                }', '                if (grids.isEmpty())', '                    break;', '', '                int k = max(2, min(rand.nextInt(n+1), maxk));', '                int row = rand.nextInt(n-k+1);', '                int col = rand.nextInt(n-k+1);', '                Grid ng = new Grid(grids.get(idx), row, col, k);', '', '                int insertionIndex = Collections.binarySearch(grids, ng);', '                if (insertionIndex < 0)', '                    insertionIndex = ~insertionIndex;', '                grids.add(insertionIndex, ng);', '', '                if (grids.size() > MAX_GRIDS)', '                    grids.remove(MAX_GRIDS);', '', '                timePassed = System.currentTimeMillis() - executionStart;', '                if (timePassed > 600)', '                    maxk = max(2, (int) (n * 0.40));', '                if (timePassed > 1200)', '                    maxk = max(2, (int) (n * 0.30));', '                if (timePassed > 1800)', '                    maxk = max(2, (int) (n * 0.20));', '                if (timePassed > 2400)', '                    maxk = max(2, (int) (n * 0.15));', '                if (timePassed > 3000)', '                    maxk = 2;', '            }', '        }', '        ', '        if (best.compareTo(grids.get(0)) > 0)', '            best = grids.get(0);', '', '        System.out.print(best);', '        //System.out.print(best.score());', '    }', '}']"
 , 
 , 
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner input = new Scanner(System.in);', '        int length = input.nextInt();', '        int sum = 0;', '        ', '        for(int i = 0; i < length; i++) {', '            sum += input.nextInt();', '        }', '        ', '        System.out.println(sum);', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'simpleArraySum' function below."", '     *', '     * The function is expected to return an INTEGER.', '     * The function accepts INTEGER_ARRAY ar as parameter.', '     */', '', '    public static int simpleArraySum(int[] ar) {', '    // Write your code here', '    int total = 0;', '    ', '    for (int i = 0; i < ar.length; i++)', '    {', '        total += ar[i];', '    ', '    }', '    return total;', '', '', '', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int arCount = Integer.parseInt(bufferedReader.readLine().trim());', '', '        String[] arTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        int [] ar = new int[arCount];', '', '        for (int arItr = 0; arItr < arCount; arItr++) {', '            int arItem = Integer.parseInt(arTemp[arItr].trim());', '            ar[arItr] = arItem;', '        }', '', '        int result = Result.simpleArraySum(ar);', '', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int a0 = in.nextInt();', '        int a1 = in.nextInt();', '        int a2 = in.nextInt();', '        int b0 = in.nextInt();', '        int b1 = in.nextInt();', '        int b2 = in.nextInt();', '        ', '        int a = 0;', '        int b = 0;', '        ', '        if (a0 > b0) a++;', '        if (a0 < b0) b++;', '        ', '        if (a1 > b1) a++;', '        if (a1 < b1) b++;', '        ', '        if (a2 > b2) a++;', '        if (a2 < b2) b++;', '        ', '        System.out.println(a + "" "" + b);', '    }', '}']","['import java.io.*;', 'import java.util.*;', '', 'class Result {', '', '    public static List<Integer> compareTriplets(List<Integer> a, List<Integer> b) {', '        int alice = 0;', '        int bob = 0;', '        ', '        for (int i = 0; i < a.size(); i++) {', '            if (a.get(i) > b.get(i)) {', '                alice++;', '            } else if (a.get(i) < b.get(i)) {', '                bob++;', '            }', '        }', '        ', '        List<Integer> result = new ArrayList<>();', '        result.add(alice);', '        result.add(bob);', '        ', '        return result;', '    }', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        String[] aTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> a = new ArrayList<>();', '', '        for (int i = 0; i < 3; i++) {', '            int aItem = Integer.parseInt(aTemp[i]);', '            a.add(aItem);', '        }', '', '        String[] bTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> b = new ArrayList<>();', '', '        for (int i = 0; i < 3; i++) {', '            int bItem = Integer.parseInt(bTemp[i]);', '            b.add(bItem);', '        }', '', '        List<Integer> result = Result.compareTriplets(a, b);', '', '        for (int i = 0; i < result.size(); i++) {', '            bufferedWriter.write(String.valueOf(result.get(i)));', '', '            if (i != result.size() - 1) {', '                bufferedWriter.write("" "");', '            }', '        }', '', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '        ', ""        // Print Alice's and Bob's points"", '        System.out.println(""Alice\'s points: "" + result.get(0));', '        System.out.println(""Bob\'s points: "" + result.get(1));', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner s = new Scanner(System.in);', '        int t = s.nextInt();', '        long sum = 0;', '        while(t-- > 0){', '            sum += s.nextInt();', '        }', '        System.out.println(sum);', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'aVeryBigSum' function below."", '     *', '     * The function is expected to return a LONG_INTEGER.', '     * The function accepts LONG_INTEGER_ARRAY ar as parameter.', '     */', '', '    public static long aVeryBigSum(List<Long> ar) {', '    long sum = 0;', '        for (long num : ar) {', '            sum += num;', '        }', '        return sum;', '', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int arCount = Integer.parseInt(bufferedReader.readLine().trim());', '', '        String[] arTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Long> ar = new ArrayList<>();', '', '        for (int i = 0; i < arCount; i++) {', '            long arItem = Long.parseLong(arTemp[i]);', '            ar.add(arItem);', '        }', '', '        long result = Result.aVeryBigSum(ar);', '', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */', '        int n;', '        Scanner in=new Scanner(System.in);', '        n=in.nextInt();', '        int a[][]=new int[n][n];', '        for(int i=0;i<n;i++){', '         for(int j=0;j<n;j++){', '          a[i][j]=in.nextInt();', '         }', '        }', '        int pd=0,npd=0;', '        for(int i=0;i<n;i++){', '         for(int j=0;j<n;j++){', '          if(j==i)', '           pd=pd+a[i][j];', '         }', '        }', '        for(int i=0;i<n;i++){', '         for(int j=0;j<n;j++){', '          if(i==n-j-1){', '           npd=npd+a[i][j];', '          }', '         }', '        }', '        int dif=npd-pd;', '        dif=Math.abs(dif);', '        System.out.println(dif);', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'diagonalDifference' function below."", '     *', '     * The function is expected to return an INTEGER.', '     * The function accepts 2D_INTEGER_ARRAY arr as parameter.', '     */', '', '    public static int diagonalDifference(List<List<Integer>> arr) {', '    // Write your code here', '    int n = arr.size();', '    int primarydiagonal = 0;', '    int secondarydiagonal = 0;', '    ', '    for (int i = 0; i < n; i++) {', '        primarydiagonal += arr.get(i).get(i);', '    }', '    for (int i = 0; i < n; i++) {', '        secondarydiagonal += arr.get(i).get(n - i - 1);', '    }', '    ', '    return Math.abs(primarydiagonal - secondarydiagonal);', '', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int n = Integer.parseInt(bufferedReader.readLine().trim());', '', '        List<List<Integer>> arr = new ArrayList<>();', '', '        for (int i = 0; i < n; i++) {', '            String[] arrRowTempItems = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '            List<Integer> arrRowItems = new ArrayList<>();', '', '            for (int j = 0; j < n; j++) {', '                int arrItem = Integer.parseInt(arrRowTempItems[j]);', '                arrRowItems.add(arrItem);', '            }', '', '            arr.add(arrRowItems);', '        }', '', '        int result = Result.diagonalDifference(arr);', '', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        int pos = 0;', '        int zero = 0;', '        int neg = 0;', '        for (int i = 0; i < n; i++) {', '            int x = in.nextInt();', '            if (x > 0) {', '                pos++;', '            } else if (x == 0) {', '                zero++;', '            } else {', '                neg++;', '            }', '        }', '        System.out.println(pos / (double) n);', '        System.out.println(neg / (double) n);', '        System.out.println(zero / (double) n);', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'plusMinus' function below."", '     *', '     * The function accepts INTEGER_ARRAY arr as parameter.', '     */', '', '    public static void plusMinus(List<Integer> arr) {', '    int positiveCount = 0;', '        int negativeCount = 0;', '        int zeroCount = 0;', '        int n = arr.size();', '', '        // Count positive, negative, and zero elements', '        for (int num : arr) {', '            if (num > 0) {', '                positiveCount++;', '            } else if (num < 0) {', '                negativeCount++;', '            } else {', '                zeroCount++;', '            }', '        }', '', '        // Calculate ratios', '        double positiveRatio = (double) positiveCount / n;', '        double negativeRatio = (double) negativeCount / n;', '        double zeroRatio = (double) zeroCount / n;', '', '        // Print ratios with specified precision', '        System.out.printf(""%.6f%n"", positiveRatio);', '        System.out.printf(""%.6f%n"", negativeRatio);', '        System.out.printf(""%.6f%n"", zeroRatio);', '', '', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '', '        int n = Integer.parseInt(bufferedReader.readLine().trim());', '', '        String[] arrTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> arr = new ArrayList<>();', '', '        for (int i = 0; i < n; i++) {', '            int arrItem = Integer.parseInt(arrTemp[i]);', '            arr.add(arrItem);', '        }', '', '        Result.plusMinus(arr);', '', '        bufferedReader.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */', '        Scanner sc = new Scanner(System.in);', '        ', '        int i,j,k,n = sc.nextInt();', '        ', '        for(i=0;i<n;i++){', '          ', '            for(j=n-1;j>i;j--){', '                System.out.print("" "");', '            }', '            for(k=0;k<=i;k++)', '                System.out.print(""#"");', '           System.out.println(); ', '        }', '        ', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'staircase' function below."", '     *', '     * The function accepts INTEGER n as parameter.', '     */', '', '    public static void staircase(int n) {', '    // Write your code here', '    for(int i = 1 ; i<=n ; i++){', '        for(int j = 0 ; j <n-i ; j++){', '            System.out.print("" "");', '        }', '        for(int j = 0 ; j<i ; j++){', '            System.out.print(""#"");', '        }', '        System.out.println(); ', '    }', '', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '', '        int n = Integer.parseInt(bufferedReader.readLine().trim());', '', '        Result.staircase(n);', '', '        bufferedReader.close();', '    }', '}']"
"['import java.io.*;', 'import java.math.BigInteger;', 'import java.util.*;', ' ', ' ', 'class Main {', ' static int ans[]=new int[1000001];', '  public static void main(String[] args) throws IOException {', '  InputReader in = new InputReader(System.in);', '  PrintWriter pw = new PrintWriter(System.out);', 'int prime[]=new int[1000001];', 'prime[0]=1;', 'prime[1]=1;', 'for(int i=2;i*i<1000001;i++)', ' if(prime[i]==0)', '  for(int j=i*i;j<1000001;j+=i)', '   prime[j]=1;', 'int n=5;', 'int a[]=in.nextIntArray(n);', 'Arrays.sort(a);', 'long sum=(long)a[0]+(long)a[1]+(long)a[2]+(long)a[3];', 'long sum1=sum+(long)a[4]-(long)a[0];', 'System.out.println(sum+"" ""+sum1);', '', '', '  } ', '  private static int firstOccurrenceBinarySearch(int[] source, int needle) {', '      int low = 0;', '      int high = source.length - 1;', '      int firstOccurrence = Integer.MIN_VALUE;', '', '      while (low <= high) {', '          int middle = low + ((high - low) >>> 1);', '', '          if (source[middle] == needle) {', '              // key found and we want to search an earlier occurrence', '              firstOccurrence = middle;', '              high = middle - 1;', '          } else if (source[middle] < needle) {', '              low = middle + 1;', '          } else {', '              high = middle - 1;', '          }', '      }', '', '      if (firstOccurrence != Integer.MIN_VALUE) {', '          return firstOccurrence;', '      }', '', '      return -(low + 1);  // key not found', '  }', '', ' public static int binarySearchLastOccurrence(int arr[], int low, int high, int data)', '  {', '      int mid;', '   ', '      // A simple implementation of Binary Search', '      if(high >= low)', '      {', '          mid = low + (high - low)/2; // To avoid overflow', '          if((mid == high && arr[mid] == data) || (arr[mid] == data && arr[mid+1] > data))', '              return mid;', '   ', '          // We need to give preference to right part of the array', '          // since we are concerned with the last occurrence', '          else if(arr[mid] <= data)', '              return binarySearchLastOccurrence(arr, mid+1, high, data);', '          else', '              // We need to search in the left half', '              return binarySearchLastOccurrence(arr, low, mid-1, data);', '      }', '      return -1;', '  }', '  public static long pow(long n,long p,long m)', ' {', '   long  result = 1;', '    if(p==0)', '      return 1;', '  if (p==1)', '      return n;', '  while(p!=0)', '  {', '      if(p%2==1)', '          result *= n;', '      if(result>=m)', '      result%=m;', '      p >>=1;', '      n*=n;', '      if(n>=m)', '      n%=m;', '  }', '  return result;', ' }', ' public static int BS(int val,int a[])', ' {', '  int low=0;', '  int high=a.length-1;', '  int tt=0;', '  while(low<high)', '  {', '   int mid=(low+high)/2;', '   if(a[mid]<val)', '   {', '    tt=low;', '    low=mid+1;', '   }', '   else', '    high=mid-1;', '  }', '  return low;', ' }', '  ', ' ', ' ', ' static class Pair implements Comparable<Pair>{', '  int r;', '  int v;', '  Pair(int mr,int er){', '   r=mr;v=er;', '  }', '  @Override', '  public int compareTo(Pair o) {', '   if(o.r>this.r)', '    return -1;', '   else if(o.r<this.r)', '    return 1;', '   else', '   {', '    if(o.v>this.v)', '     return -1;', '    else', '     return 1;', '   }', '   ', '   }', ' }', ' static class TVF implements Comparable<TVF>{', '  int index,size;', '  TVF(int i,int c){', '   index=i;', '   size=c;', '  }', '  @Override', '  public int compareTo(TVF o) {', '   if(o.size>this.size)', '    return -1;', '   else if(o.size<this.size)', '    return 1;', '   else return 0;', '  }', ' }', ' public static long gcd(long a, long b) {', '    if (b == 0) return a;', '    return gcd(b, a%b);', '  }', ' static class InputReader {', ' ', '  private InputStream stream;', '  private byte[] buf = new byte[8192];', '  private int curChar, snumChars;', '  private SpaceCharFilter filter;', ' ', '  public InputReader(InputStream stream) {', '   this.stream = stream;', '  }', ' ', '  public int snext() {', '   if (snumChars == -1)', '    throw new InputMismatchException();', '   if (curChar >= snumChars) {', '    curChar = 0;', '    try {', '     snumChars = stream.read(buf);', '    } catch (IOException e) {', '     throw new InputMismatchException();', '    }', '    if (snumChars <= 0)', '     return -1;', '   }', '   return buf[curChar++];', '  }', ' ', '  public   int nextInt() {', '   int c = snext();', '   while (isSpaceChar(c))', '    c = snext();', '   int sgn = 1;', ""   if (c == '-') {"", '    sgn = -1;', '    c = snext();', '   }', '   int res = 0;', '   do {', ""    if (c < '0' || c > '9')"", '     throw new InputMismatchException();', '    res *= 10;', ""    res += c - '0';"", '    c = snext();', '   } while (!isSpaceChar(c));', '   return res * sgn;', '  }', ' ', '  public long nextLong() {', '   int c = snext();', '   while (isSpaceChar(c))', '    c = snext();', '   int sgn = 1;', ""   if (c == '-') {"", '    sgn = -1;', '    c = snext();', '   }', '   long res = 0;', '   do {', ""    if (c < '0' || c > '9')"", '     throw new InputMismatchException();', '    res *= 10;', ""    res += c - '0';"", '    c = snext();', '   } while (!isSpaceChar(c));', '   return res * sgn;', '  }', ' ', '  public int[] nextIntArray(int n) {', '   int a[] = new int[n];', '   for (int i = 0; i < n; i++)', '    a[i] = nextInt();', '   return a;', '  }', ' ', '  public String readString() {', '   int c = snext();', '   while (isSpaceChar(c))', '    c = snext();', '   StringBuilder res = new StringBuilder();', '   do {', '    res.appendCodePoint(c);', '    c = snext();', '   } while (!isSpaceChar(c));', '   return res.toString();', '  }', ' ', '  public boolean isSpaceChar(int c) {', '   if (filter != null)', '    return filter.isSpaceChar(c);', ""   return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;"", '  }', ' ', '  public interface SpaceCharFilter {', '   public boolean isSpaceChar(int ch);', '  }', ' }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', 'public static void miniMaxSum(List<Integer> arr) { long sum = 0;', '    int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;', '    for (int a : arr) {', '        sum += a;', '        min = Math.min(min, a);', '        max = Math.max(max, a);', '    }', '    // calculate the minimum and maximum sums', '    long minSum = sum - max;', '    long maxSum = sum - min;', '    System.out.println(minSum + "" "" + maxSum);', '    }', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '', '        String[] arrTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> arr = new ArrayList<>();', '', '        for (int i = 0; i < 5; i++) {', '            int arrItem = Integer.parseInt(arrTemp[i]);', '            arr.add(arrItem);', '        }', '', '        Result.miniMaxSum(arr);', '', '        bufferedReader.close();', '    }', '}']"
"['/*', ' * PDPM IIITDM Jabalpur', ' * Asutosh Rana', ' */', '', 'import java.util.*;', 'import java.io.*;', 'import java.math.*;', '', 'public class Main', '{', '    static long MOD = 1000000007;', '    public static void main (String[] args) throws java.lang.Exception', ' {', '  InputReader in=new InputReader(System.in);', '  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '        PrintWriter out=new PrintWriter(System.out);', '', '        int t = 1;', '        ', '        while(t-->0){', '         int N = in.readInt();', '         int[] A = new int[N];', '         in.readInt(A);', '         int max=0,count=0;', '         for(int i=0;i<N;i++){', '          if(A[i]>max){', '           max=A[i];count=1;', '          }', '          else if(A[i]==max){', '           count++;', '          }', '         }', '         out.println(count);', '     }', '  out.flush();', '        out.close();', ' }', ' ', '      ', '}', ' ', 'class InputReader{', ' private InputStream stream;', ' private byte[] buf = new byte[1024];', ' private int curChar;', ' private int numChars;', ' private SpaceCharFilter filter;', ' ', ' public InputReader(InputStream stream){this.stream = stream;}', ' public int read(){', '  if (numChars==-1) throw new InputMismatchException();', '  if (curChar >= numChars){', '   curChar = 0;', '   try {numChars = stream.read(buf);}', '   catch (IOException e){throw new InputMismatchException();}', '   if(numChars <= 0) return -1;', '  }', '  return buf[curChar++];', ' }', ' ', ' public int readInt(){', '  int c = read();', '  while(isSpaceChar(c)) c = read();', '  int sgn = 1;', ""  if (c == '-') {sgn = -1;c = read();}"", '  int res = 0;', '  do {', ""   if(c<'0'||c>'9') throw new InputMismatchException();"", '   res *= 10;', ""   res += c - '0';"", '   c = read();', '  }', '  while (!isSpaceChar(c)); return res * sgn;', ' }', ' ', ' public void readInt(int[] A){', '  for(int i=0;i<A.length;i++)', '   A[i] = readInt();', ' }', ' ', ' public long readLong() {', '  int c = read();', '  while (isSpaceChar(c))', '   c = read();', '  int sgn = 1;', ""  if (c == '-') {"", '   sgn = -1;', '   c = read();', '        }', '  long res = 0;', '  do {', ""   if (c < '0' || c > '9')"", '    throw new InputMismatchException();', '   res *= 10;', ""   res += c - '0';"", '   c = read();', '        }', '  while (!isSpaceChar(c));', '            return res * sgn;', '    }', ' ', ' public void readLong(long[] A){', '  for(int i=0;i<A.length;i++)', '   A[i] = readLong();', ' }', ' ', ' public double readDouble() {', '        int c = read();', '        while (isSpaceChar(c))', '            c = read();', '        int sgn = 1;', ""  if (c == '-') {"", '   sgn = -1;', '   c = read();', '        }', '  double res = 0;', ""  while (!isSpaceChar(c) && c != '.') {"", ""   if (c == 'e' || c == 'E')"", '    return res * Math.pow(10, readInt());', ""   if (c < '0' || c > '9')"", '    throw new InputMismatchException();', '   res *= 10;', ""   res += c - '0';"", '   c = read();', '        }', ""  if (c == '.') {"", '   c = read();', '   double m = 1;', '   while (!isSpaceChar(c)) {', ""    if (c == 'e' || c == 'E')"", '     return res * Math.pow(10, readInt());', ""    if (c < '0' || c > '9')"", '     throw new InputMismatchException();', '    m /= 10;', ""    res += (c - '0') * m;"", '    c = read();', '            }', '        }', '  return res * sgn;', '    }', ' ', ' public char[] readCharA(){', '  return readString().toCharArray();', ' }', ' ', ' public String readString() {', '  int c = read();', '  while (isSpaceChar(c))', '   c = read();', '  StringBuilder res = new StringBuilder();', '  do {', '   res.appendCodePoint(c);', '   c = read();', '  } while (!isSpaceChar(c));', '  return res.toString();', ' }', ' ', ' public boolean isSpaceChar(int c) {', '  if (filter != null)', '   return filter.isSpaceChar(c);', ""  return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;"", '  }', ' ', ' public String next() {', '  return readString();', ' }', ' ', ' public interface SpaceCharFilter {', '  public boolean isSpaceChar(int ch);', ' }', ' ', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '    public static int birthdayCakeCandles(List<Integer> candles) {', '    int tallestCandle = candles.get(0);', '    for (int i = 1; i < candles.size(); i++) {', '        if (candles.get(i) > tallestCandle) {', '            tallestCandle = candles.get(i);', '        }', '    }', ' int frequency = Collections.frequency(candles, tallestCandle);', ' return frequency;', '}', '}', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int candlesCount = Integer.parseInt(bufferedReader.readLine().trim());', '', '        String[] candlesTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> candles = new ArrayList<>();', '', '        for (int i = 0; i < candlesCount; i++) {', '            int candlesItem = Integer.parseInt(candlesTemp[i]);', '            candles.add(candlesItem);', '        }', '', '        int result = Result.birthdayCakeCandles(candles);', '', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '  Scanner sc = new Scanner(System.in);', '  String s = sc.nextLine(); //07:05:45PM', '  DateFormat inFormat = new SimpleDateFormat( ""hh:mm:ssaa"");', '  DateFormat outFormat = new SimpleDateFormat( ""HH:mm:ss"");', '', '  Date date = null;', '  try {', '   date = inFormat.parse(s); ', '  }catch (ParseException e ){', '   e.printStackTrace();', '  }', '  if( date != null ){', '   String myDate = outFormat.format(date);', '   System.out.println(myDate);', '  }', ' }', '', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'timeConversion' function below."", '     *', '     * The function is expected to return a STRING.', '     * The function accepts STRING s as parameter.', '     */', '', '    public static String timeConversion(String s) {', '    // Write your code here', 'int hour = Integer.parseInt(s.substring(0, 2));', '        int minute = Integer.parseInt(s.substring(3, 5));', '        int second = Integer.parseInt(s.substring(6, 8));', '', ""        // Check if it's PM and adjust hour accordingly"", '        if (s.substring(8, 10).equals(""PM"") && hour != 12) {', '            hour += 12;', '        } else if (s.substring(8, 10).equals(""AM"") && hour == 12) {', '            hour = 0;', '        }', '', '        // Format the time in 24-hour format', '        return String.format(""%02d:%02d:%02d"", hour, minute, second);', '    }', '', '    }', '', '', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        String s = bufferedReader.readLine();', '', '        String result = Result.timeConversion(s);', '', '        bufferedWriter.write(result);', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
 , 
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int s = in.nextInt();', '        int t = in.nextInt();', '        int a = in.nextInt();', '        int b = in.nextInt();', '        int m = in.nextInt();', '        int n = in.nextInt();', '        int[] apple = new int[m];', '        int app = 0;', '        for(int apple_i=0; apple_i < m; apple_i++){', '            apple[apple_i] = in.nextInt();', '            if (a + apple[apple_i] >= s && a + apple[apple_i] <= t) {', '                app++;', '            }', '        }', '        int[] orange = new int[n];', '        int or = 0;', '        for(int orange_i=0; orange_i < n; orange_i++){', '            orange[orange_i] = in.nextInt();', '            if (b + orange[orange_i] >= s && b + orange[orange_i] <= t) {', '                or++;', '            }', '        }', '        ', '        System.out.println(app);', '        System.out.println(or);', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'countApplesAndOranges' function below."", '     *', '     * The function accepts following parameters:', '     *  1. INTEGER s', '     *  2. INTEGER t', '     *  3. INTEGER a', '     *  4. INTEGER b', '     *  5. INTEGER_ARRAY apples', '     *  6. INTEGER_ARRAY oranges', '     */', '', '    public static void countApplesAndOranges(int s, int t, int a, int b, List<Integer> apples, List<Integer> oranges) {', '      ', '       List<Integer> app = new ArrayList<>();', '       List<Integer> org = new ArrayList<>();', '       ', '       for(Integer num1 : apples){', '           app.add(num1 + a);', '       }', '       ', '       for(Integer num2 : oranges){', '           org.add(num2 + b);', '       }', '        ', '       int appl = 0;', '       for(Integer num3 : app){', '           if(num3 >= s && num3 <= t){', '               appl++;', '           }', '       }', '       ', '       int orag = 0;', '       for(Integer num4 : org){', '           if(num4 >= s && num4 <= t){', '               orag++;', '           }', '       }', '       ', '       System.out.println(appl);', '       System.out.println(orag);', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '', '        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        int s = Integer.parseInt(firstMultipleInput[0]);', '', '        int t = Integer.parseInt(firstMultipleInput[1]);', '', '        String[] secondMultipleInput = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        int a = Integer.parseInt(secondMultipleInput[0]);', '', '        int b = Integer.parseInt(secondMultipleInput[1]);', '', '        String[] thirdMultipleInput = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        int m = Integer.parseInt(thirdMultipleInput[0]);', '', '        int n = Integer.parseInt(thirdMultipleInput[1]);', '', '        String[] applesTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> apples = new ArrayList<>();', '', '        for (int i = 0; i < m; i++) {', '            int applesItem = Integer.parseInt(applesTemp[i]);', '            apples.add(applesItem);', '        }', '', '        String[] orangesTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> oranges = new ArrayList<>();', '', '        for (int i = 0; i < n; i++) {', '            int orangesItem = Integer.parseInt(orangesTemp[i]);', '            oranges.add(orangesItem);', '        }', '', '        Result.countApplesAndOranges(s, t, a, b, apples, oranges);', '', '        bufferedReader.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int x1 = in.nextInt();', '        int v1 = in.nextInt();', '        int x2 = in.nextInt();', '        int v2 = in.nextInt();', '        ', '        if (v1>v2&&(x2-x1)%(v1-v2)==0)', '            System.out.println(""YES"");', '        else', '            System.out.println(""NO"");', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'kangaroo' function below."", '     *', '     * The function is expected to return a STRING.', '     * The function accepts following parameters:', '     *  1. INTEGER x1', '     *  2. INTEGER v1', '     *  3. INTEGER x2', '     *  4. INTEGER v2', '     */', '', '    public static String kangaroo(int x1, int v1, int x2, int v2)   {', '    int d = Math.max(x2,x1) - Math.min(x1,x2);', '        // while(true){', '        //     int nextK1 = x1+v1;', '        //     int nextK2 = x2+v2;', '        //     int d1 = Math.max(nextK1,nextK2) - Math.min(nextK1,nextK2);', '        //     if(d<d1){', '        //         return ""NO"";', '        //     }', '        //     if(nextK1==nextK2){', '        //         return ""YES"";', '        //     }', '        //     x1 = nextK1;', '        //     x2 = nextK2;', '        // }', ' int newX1 = x1;', '        int newX2 = x2;', '        if(v1<v2){', '            return ""NO"";', '        }', '        while(newX1 <= newX2){', '        newX1 += v1;', '        newX2 += v2;', '        ', '        if(newX1 == newX2){', '            return ""YES"";', '        }', '    }', '    return ""NO"";', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        int x1 = Integer.parseInt(firstMultipleInput[0]);', '', '        int v1 = Integer.parseInt(firstMultipleInput[1]);', '', '        int x2 = Integer.parseInt(firstMultipleInput[2]);', '', '        int v2 = Integer.parseInt(firstMultipleInput[3]);', '', '        String result = Result.kangaroo(x1, v1, x2, v2);', '', '        bufferedWriter.write(result);', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.math.BigInteger;', 'import java.util.*;', '', '', 'public class Main {', ' static boolean flag=true;', ' static boolean visited[]=new boolean[1000001];', ' static int time[]=new int[1000001];', ' static ArrayList<Integer> left=new ArrayList<Integer>();', ' static ArrayList<Integer> right=new ArrayList<Integer>();', ' public static void main(String[] args) throws IOException {', '  InputReader in = new InputReader(System.in);', '  PrintWriter pw = new PrintWriter(System.out);', 'int n=in.nextInt();', 'int m=in.nextInt();', 'int a[]=in.nextIntArray(n);', 'int b[]=in.nextIntArray(m);', 'int ans=0;', 'for(int i=1;i<=100;i++)', '{', ' HashSet<Integer> set=new HashSet<Integer>();', ' for(int j=1;j<=i;j++)', '  if(j%i==0)', '   set.add(j);', ' boolean bool=true;', ' for(int j=0;j<n;j++)', ' {', '  if(i%a[j]!=0)', '   bool=false;', ' }', ' boolean bool1=true;', ' for(int j=0;j<m;j++)', ' {', '  if(b[j]%i!=0)', '   bool1=false;', ' }', ' if(bool&&bool1)', '  ans++;', '}', 'System.out.println(ans);', ' }', ' public static void DFS(int x,boolean visited[],ArrayList<Integer>[] adj)', ' {', '  visited[x]=true;', '  for(int j=0;j<adj[x].size();j++)', '  {', '   if(!visited[adj[x].get(j)])', '    DFS(adj[x].get(j),visited,adj);', '  }', ' }', ' public static long pow(long n,long p,long m)', ' {', '   long  result = 1;', '    if(p==0)', '      return 1;', '  if (p==1)', '      return n;', '  while(p!=0)', '  {', '      if(p%2==1)', '          result *= n;', '      if(result>=m)', '      result%=m;', '      p >>=1;', '      n*=n;', '      if(n>=m)', '      n%=m;', '  }', '  return result;', ' }', ' public static int BinarySearch(int val,int a[])', ' {', '  int low=0;', '  int high=a.length-1;', '  while(low<high)', '  {', '   int mid=(low+high)/2;', '   if(a[mid]>val)', '    high=mid;', '   else', '    low=mid+1;', '  }', '  return a[high];', ' }', '  ', ' ', ' static class Pair implements Comparable<Pair>{', '  int r;', '  int v;', '  Pair(int mr,int er){', '   r=mr;v=er;', '  }', '  @Override', '  public int compareTo(Pair o) {', '   if(o.r>this.r)', '    return -1;', '   else if(o.r<this.r)', '    return 1;', '   else', '   {', '    if(o.v>this.v)', '     return -1;', '    else', '     return 1;', '   }', '   }', ' }', ' static class TVF implements Comparable<TVF>{', '  int index,size;', '  TVF(int i,int c){', '   index=i;', '   size=c;', '  }', '  @Override', '  public int compareTo(TVF o) {', '   if(o.size>this.size)', '    return -1;', '   else if(o.size<this.size)', '    return 1;', '   else return 0;', '  }', ' }', ' public static long gcd(long a, long b) {', '    if (b == 0) return a;', '    return gcd(b, a%b);', '  }', ' static class InputReader {', ' ', '  private InputStream stream;', '  private byte[] buf = new byte[8192];', '  private int curChar, snumChars;', '  private SpaceCharFilter filter;', ' ', '  public InputReader(InputStream stream) {', '   this.stream = stream;', '  }', ' ', '  public int snext() {', '   if (snumChars == -1)', '    throw new InputMismatchException();', '   if (curChar >= snumChars) {', '    curChar = 0;', '    try {', '     snumChars = stream.read(buf);', '    } catch (IOException e) {', '     throw new InputMismatchException();', '    }', '    if (snumChars <= 0)', '     return -1;', '   }', '   return buf[curChar++];', '  }', ' ', '  public   int nextInt() {', '   int c = snext();', '   while (isSpaceChar(c))', '    c = snext();', '   int sgn = 1;', ""   if (c == '-') {"", '    sgn = -1;', '    c = snext();', '   }', '   int res = 0;', '   do {', ""    if (c < '0' || c > '9')"", '     throw new InputMismatchException();', '    res *= 10;', ""    res += c - '0';"", '    c = snext();', '   } while (!isSpaceChar(c));', '   return res * sgn;', '  }', ' ', '  public long nextLong() {', '   int c = snext();', '   while (isSpaceChar(c))', '    c = snext();', '   int sgn = 1;', ""   if (c == '-') {"", '    sgn = -1;', '    c = snext();', '   }', '   long res = 0;', '   do {', ""    if (c < '0' || c > '9')"", '     throw new InputMismatchException();', '    res *= 10;', ""    res += c - '0';"", '    c = snext();', '   } while (!isSpaceChar(c));', '   return res * sgn;', '  }', ' ', '  public int[] nextIntArray(int n) {', '   int a[] = new int[n];', '   for (int i = 0; i < n; i++)', '    a[i] = nextInt();', '   return a;', '  }', ' ', '  public String readString() {', '   int c = snext();', '   while (isSpaceChar(c))', '    c = snext();', '   StringBuilder res = new StringBuilder();', '   do {', '    res.appendCodePoint(c);', '    c = snext();', '   } while (!isSpaceChar(c));', '   return res.toString();', '  }', ' ', '  public boolean isSpaceChar(int c) {', '   if (filter != null)', '    return filter.isSpaceChar(c);', ""   return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;"", '  }', ' ', '  public interface SpaceCharFilter {', '   public boolean isSpaceChar(int ch);', '  }', ' }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'getTotalX' function below."", '     *', '     * The function is expected to return an INTEGER.', '     * The function accepts following parameters:', '     *  1. INTEGER_ARRAY a', '     *  2. INTEGER_ARRAY b', '     */', '', '    public static int getTotalX(List<Integer> a, List<Integer> b) {', '    // Write your code here', '      int count = 0;', ""        // Find all factors of the integers in the second array 'b'"", '        for (int factor = 1; factor <= 100; factor++) { // considering factors up to 100', '            boolean isFactor = true;', ""            // Check if the factor is divisible by all elements in the first array 'a'"", '            for (int num : a) {', '                if (factor % num != 0) {', '                    isFactor = false;', '                    break;', '                }', '            }', ""            // Check if the factor is a factor of all elements in the second array 'b'"", '            if (isFactor) {', '                for (int num : b) {', '                    if (num % factor != 0) {', '                        isFactor = false;', '                        break;', '                    }', '                }', '            }', '            // If the factor satisfies both conditions, increment the count', '            if (isFactor) {', '                count++;', '            }', '        }', '        return count;', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        int n = Integer.parseInt(firstMultipleInput[0]);', '', '        int m = Integer.parseInt(firstMultipleInput[1]);', '', '        String[] arrTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> arr = new ArrayList<>();', '', '        for (int i = 0; i < n; i++) {', '            int arrItem = Integer.parseInt(arrTemp[i]);', '            arr.add(arrItem);', '        }', '', '        String[] brrTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> brr = new ArrayList<>();', '', '        for (int i = 0; i < m; i++) {', '            int brrItem = Integer.parseInt(brrTemp[i]);', '            brr.add(brrItem);', '        }', '', '        int total = Result.getTotalX(arr, brr);', '', '        bufferedWriter.write(String.valueOf(total));', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        int[] score = new int[n];', '        for(int score_i=0; score_i < n; score_i++){', '            score[score_i] = in.nextInt();', '        }', '        int max=score[0];', '        int min=score[0];', '        int maxcount=0;', '        int mincount=0;', '        for(int i=1;i<n;i++){', '            if(score[i]>max){', '                max=score[i];', '                maxcount=maxcount+1;', '            }', '            if(score[i]<min){', '                min=score[i];', '                mincount=mincount+1;', '            }', '        }', '        System.out.println(maxcount+"" ""+mincount);', '        // your code goes here', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'breakingRecords' function below."", '     *', '     * The function is expected to return an INTEGER_ARRAY.', '     * The function accepts INTEGER_ARRAY scores as parameter.', '     */', '', '    public static List<Integer> breakingRecords(List<Integer> scores) {', '    // Write your code here', '    int min=scores.get(0);', '      int max=scores.get(0);', '      int mincount=0;', '       int maxcount=0;', '       for(int num:scores){', '           if(num>max){', '               max=num;', '               maxcount++; // we are maintaining of how many times she is breaking her max record ', '               ', '           }', '           else if(num<min){', '               min=num;', '               mincount++; // we are maintaining of how many times she is breaking her min record ', '           }', '       }', '    ', 'List<Integer> ans=Arrays.asList(maxcount,mincount);', 'return ans;', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int n = Integer.parseInt(bufferedReader.readLine().trim());', '', '        String[] scoresTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> scores = new ArrayList<>();', '', '        for (int i = 0; i < n; i++) {', '            int scoresItem = Integer.parseInt(scoresTemp[i]);', '            scores.add(scoresItem);', '        }', '', '        List<Integer> result = Result.breakingRecords(scores);', '', '        for (int i = 0; i < result.size(); i++) {', '            bufferedWriter.write(String.valueOf(result.get(i)));', '', '            if (i != result.size() - 1) {', '                bufferedWriter.write("" "");', '            }', '        }', '', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'public final class womens_a', '{', '    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));', ' static FastScanner sc=new FastScanner(br);', '    static PrintWriter out=new PrintWriter(System.out);', ' static Random rnd=new Random();', ' ', '    public static void main(String args[]) throws Exception', '    {', '  int n=sc.nextInt();int[] a=new int[n];', '  for(int i=0;i<n;i++)', '  {', '   a[i]=sc.nextInt();', '  }', '  int d=sc.nextInt(),m=sc.nextInt(),res=0;', '  for(int i=0;i+m-1<n;i++)', '  {', '   int sum=0;', '   for(int j=i;j<i+m;j++)', '   {', '    sum+=a[j];', '   }', '   if(sum==d)', '   {', '    res++;', '   }', '  }', '  out.println(res);out.close();', '    }', '}', 'class FastScanner', '{', '    BufferedReader in;', '    StringTokenizer st;', '', '    public FastScanner(BufferedReader in) {', '        this.in = in;', '    }', ' ', '    public String nextToken() throws Exception {', '        while (st == null || !st.hasMoreTokens()) {', '            st = new StringTokenizer(in.readLine());', '        }', '        return st.nextToken();', '    }', ' ', ' public String next() throws Exception {', '  return nextToken().toString();', ' }', ' ', '    public int nextInt() throws Exception {', '        return Integer.parseInt(nextToken());', '    }', '', '    public long nextLong() throws Exception {', '        return Long.parseLong(nextToken());', '    }', '', '    public double nextDouble() throws Exception {', '        return Double.parseDouble(nextToken());', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'birthday' function below."", '     *', '     * The function is expected to return an INTEGER.', '     * The function accepts following parameters:', '     *  1. INTEGER_ARRAY s', '     *  2. INTEGER d', '     *  3. INTEGER m', '     */', '', '    public static int birthday(List<Integer> s, int d, int m) {', '         int count = 0;', '        ', '         for(int i = 0; i <= s.size()-m; i++){', '              int sum = 0;', '             for(int j = i; j < i+m; j++){', '                  sum = sum + s.get(j);', '             }', '             if(sum == d){', '                 count++;', '             }', '         }', '         return count;', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int n = Integer.parseInt(bufferedReader.readLine().trim());', '', '        String[] sTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> s = new ArrayList<>();', '', '        for (int i = 0; i < n; i++) {', '            int sItem = Integer.parseInt(sTemp[i]);', '            s.add(sItem);', '        }', '', '        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        int d = Integer.parseInt(firstMultipleInput[0]);', '', '        int m = Integer.parseInt(firstMultipleInput[1]);', '', '        int result = Result.birthday(s, d, m);', '', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '         int cnt=0;', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        int k = in.nextInt();', '        int a[] = new int[n];', '        for(int a_i=0; a_i < n; a_i++){', '            a[a_i] = in.nextInt();', '        }', '        for(int a_i=0; a_i < n-1; a_i++){', '          for(int a_j=a_i+1; a_j< n; a_j++){', '           if( (a[a_i]+a[a_j])%k==0)', '               cnt++;', '               ', '        } ', '        }', '        System.out.println(cnt);', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'divisibleSumPairs' function below."", '     *', '     * The function is expected to return an INTEGER.', '     * The function accepts following parameters:', '     *  1. INTEGER n', '     *  2. INTEGER k', '     *  3. INTEGER_ARRAY ar', '     */', '', '    public static int divisibleSumPairs(int n, int k, List<Integer> ar) {', '    // Write your code here', '// 1 2 3 4 5 6', '//i=0 j=3 1 4 sum=5', 'int count=0;', 'for(int i=0;i<n-1;i++){', '    for(int j=i+1;j<n;j++){', '        if((ar.get(i)+ar.get(j))%k==0) count++;', '        ', '    }', '}', 'return count;', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        int n = Integer.parseInt(firstMultipleInput[0]);', '', '        int k = Integer.parseInt(firstMultipleInput[1]);', '', '        String[] arTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> ar = new ArrayList<>();', '', '        for (int i = 0; i < n; i++) {', '            int arItem = Integer.parseInt(arTemp[i]);', '            ar.add(arItem);', '        }', '', '        int result = Result.divisibleSumPairs(n, k, ar);', '', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        int[] types = new int[n];', '        int[] count = new int[6];', '        int max=0;', '        for(int types_i=0; types_i < n; types_i++){', '            types[types_i] = in.nextInt();', '            count[types[types_i]]++;', '            if(count[types[types_i]]>max)', '                max=count[types[types_i]];', '        }', '        for(int i=0;i<count.length;i++)', '        {', '            if(max==count[i])', '            {', '                System.out.println(i);', '                break;', '            }', '                ', '        }', '        ', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'migratoryBirds' function below."", '     *', '     * The function is expected to return an INTEGER.', '     * The function accepts INTEGER_ARRAY arr as parameter.', '     */', '', '    public static int migratoryBirds(List<Integer> arr) {', '    // Write your code here', 'Map<Integer,Integer> treemap=new TreeMap<>();', 'int type=-1;', 'for(int i=0;i<arr.size();i++){', 'if(treemap.containsKey(arr.get(i))){', '        int val=treemap.get(arr.get(i));', '        treemap.put(arr.get(i),val+1);', '        ', '    }', '    else{', '        treemap.put(arr.get(i),1);', '        ', '    }', '}', 'int maxcount=Integer.MIN_VALUE;', 'for(Integer Key:treemap.keySet()){', '    if(treemap.get(Key)>maxcount){', '        maxcount=treemap.get(Key);', '        type=Key;', '    }', '    ', '}', 'return type;', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int arrCount = Integer.parseInt(bufferedReader.readLine().trim());', '', '        String[] arrTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> arr = new ArrayList<>();', '', '        for (int i = 0; i < arrCount; i++) {', '            int arrItem = Integer.parseInt(arrTemp[i]);', '            arr.add(arrItem);', '        }', '', '        int result = Result.migratoryBirds(arr);', '', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int y = in.nextInt();', '        // your code goes here', '        ', '        if(y>=1700 && y<=1917){', '            ', '            if(y%4==0){', '                System.out.println(""12.09.""+y);', '            }', '            else{', '                System.out.println(""13.09.""+y);', '            }', '        }', '        ', '        else{', '            ', '            if(y==1918){', '                System.out.println(""26.09.""+y);', '            }', '            else{', '                if(y%400==0){', '                    System.out.println(""12.09.""+y);', '                }', '                else if(y%4==0 && y%100!=0){', '                    System.out.println(""12.09.""+y);', '                }', '                else{', '                    System.out.println(""13.09.""+y);', '                }', '            }', '        }', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'dayOfProgrammer' function below."", '     *', '     * The function is expected to return a STRING.', '     * The function accepts INTEGER year as parameter.', '     */', '', '    public static String dayOfProgrammer(int year) {', '    // Write your code here', '        if (year == 1918)', '            return ""26.09.1918""; // Special case for 1918', '', ""        // Check if it's a leap year in either Julian or Gregorian calendar"", '        boolean isLeapYear = false;', '        if (year < 1918) {', '            isLeapYear = (year % 4 == 0);', '        } else {', '            isLeapYear = (year % 400 == 0) || (year % 4 == 0 && year % 100 != 0);', '        }', '', '        // Calculate the day of the Programmer', '        int day = isLeapYear ? 256 - 244 : 256 - 243;', '', '        // Return the result in the format dd.mm.yyyy', '        return String.format(""%02d.09.%04d"", day, year);', '    }', '    }', '', '', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int year = Integer.parseInt(bufferedReader.readLine().trim());', '', '        String result = Result.dayOfProgrammer(year);', '', '        bufferedWriter.write(result);', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner sc=new Scanner(System.in);', '        int n=sc.nextInt();', '        int k=sc.nextInt();', '        int a[]=new int[n];', '        int sum=0;', '        for(int i=0;i<n;i++){', '            a[i]=sc.nextInt();', '            if(i!=k){', '                sum+=a[i];', '            }', '        }', '        int num=sc.nextInt();', '        if(num==sum/2)', '            System.out.println(""Bon Appetit"");', '        else', '            System.out.println(num-sum/2);', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'bonAppetit' function below."", '     *', '     * The function accepts following parameters:', '     *  1. INTEGER_ARRAY bill', '     *  2. INTEGER k', '     *  3. INTEGER b', '     */', '', '    public static void bonAppetit(List<Integer> bill, int k, int b) {', '    // Write your code here', '  int chargedAmount=b;', '  int actualAmount=0;', '  for(Integer billAmount:bill){', '      actualAmount=actualAmount+billAmount;', '      ', '  }', '  actualAmount=actualAmount-bill.get(k); //remove bill[k] from the bill', '  if(actualAmount/2==chargedAmount){', '      System.out.println(""Bon Appetit"");', '  }', '  else{', '      System.out.println(Math.abs(actualAmount/2-chargedAmount));', '  }', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '', '        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        int n = Integer.parseInt(firstMultipleInput[0]);', '', '        int k = Integer.parseInt(firstMultipleInput[1]);', '', '        String[] billTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> bill = new ArrayList<>();', '', '        for (int i = 0; i < n; i++) {', '            int billItem = Integer.parseInt(billTemp[i]);', '            bill.add(billItem);', '        }', '', '        int b = Integer.parseInt(bufferedReader.readLine().trim());', '', '        Result.bonAppetit(bill, k, b);', '', '        bufferedReader.close();', '    }', '}', ';']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', 'import java.lang.*;', 'public class Main{', ' static long mod=1000000007;', ' static public HashMap<String,Integer> map=new HashMap<String,Integer>(); ', ' static public HashMap<Integer, String> map1=new HashMap<Integer,String>(); ', '', '    public static void main(String[] args) throws Exception{            ', '      InputReader in = new InputReader(System.in);       ', '     PrintWriter pw=new PrintWriter(System.out);   ', 'int n=in.readInt();', 'int a[]=new int[101];', 'for(int i=0;i<n;i++)', '{', ' a[in.readInt()]++;', '}', 'int sum=0;', 'for(int i=0;i<101;i++)', '{', ' sum+=(a[i])/2;', '}', 'System.out.println(sum);', '    }', '   ', '  public  static void printAllKLengthRec(char set[], String prefix, int n, int k,int a[][]) {', '        ', '        // Base case: k is 0, print prefix', '        if (k == 0) {', '           String tar=prefix;', '           int sum=0;', '           for(int i=0;i<tar.length();i++)', '           {', '           sum+=a[i][tar.charAt(i)-97];', '           }', '         System.out.println(sum);', '         return;', '        }', ' ', '        // One by one add all characters from set and recursively ', '        // call for k equals to k-1', '        for (int i = 0; i < n; ++i) {', '             ', '            // Next character of input added', '            String newPrefix = prefix + set[i]; ', '             ', '            // k is decreased, because we have added a new character', '            printAllKLengthRec(set, newPrefix, n, k - 1,a); ', '        }', '    }', '', 'public static int BinarySearch(int x,int a[])', '{', ' int l=0;', ' int r=a.length-1;', ' int temp=-1;', ' while(l<=r)', ' {', '  int mid=l+(r-l)/2;', '  if(a[mid]<x)', '  {', '   temp=mid;', '   l=mid+1;', '  }', '  else if(a[mid]>x)', '   r=mid-1;', '  else if(a[mid]<x)', '   l=mid+1;', '   ', ' }', ' return temp;', '}', 'public static long gcd(long x,long y)', '{', ' if(x%y==0)', '  return y;', ' else', '  return gcd(y,x%y);', '}', 'public static int gcd(int x,int y)', '{', ' if(x%y==0)', '  return y;', ' else ', '  return gcd(y,x%y);', '}', 'public static int abs(int a,int b)', '{', ' return (int)Math.abs(a-b);', '}', 'public static long abs(long a,long b)', '{', ' return (long)Math.abs(a-b);', '}', 'public static int max(int a,int b)', '{', ' if(a>b)', '  return a;', ' else', '  return b;', '}', 'public static int min(int a,int b)', '{', ' if(a>b)', '  return b;', ' else ', '  return a;', '}', 'public static long max(long a,long b)', '{', ' if(a>b)', '  return a;', ' else', '  return b;', '}', 'public static long min(long a,long b)', '{', ' if(a>b)', '  return b;', ' else ', '  return a;', '}', ' ', ' ', 'public static long pow(long n,long p,long m)', '{', '  long  result = 1;', '   if(p==0)', '     return 1;', ' if (p==1)', '     return n;', ' while(p!=0)', ' {', '     if(p%2==1)', '         result *= n;', '     if(result>=m)', '     result%=m;', '     p >>=1;', '     n*=n;', '     if(n>=m)', '     n%=m;', ' }', ' return result;', '}', 'public static long pow(long n,long p)', '{', ' long  result = 1;', '   if(p==0)', '     return 1;', ' if (p==1)', '     return n;', ' while(p!=0)', ' {', '     if(p%2==1)', '         result *= n;     ', '     p >>=1;', '     n*=n;     ', ' }', ' return result;', ' ', '}', 'static class Pair implements Comparable<Pair>', '{', ' int a,b;', ' Pair (int a,int b)', ' {', '  this.a=a;', '  this.b=b;', ' }', ' ', ' public int compareTo(Pair o) {', '  // TODO Auto-generated method stub', '  if(this.a!=o.a)', '  return Integer.compare(this.a,o.a);', '  else', '   return Integer.compare(this.b, o.b);', '  //return 0;', ' }', ' public boolean equals(Object o) {', '        if (o instanceof Pair) {', '            Pair p = (Pair)o;', '            return p.a == a && p.b == b;', '        }', '        return false;', '    }', '    public int hashCode() {', '        return new Integer(a).hashCode() * 31 + new Integer(b).hashCode();', '    }', '    ', '} ', '    ', 'static long sort(int a[])', '{  int n=a.length;', ' int b[]=new int[n]; ', ' return mergeSort(a,b,0,n-1);}', 'static long mergeSort(int a[],int b[],long left,long right)', '{ long c=0;if(left<right)', ' {   long mid=left+(right-left)/2;', '  c= mergeSort(a,b,left,mid);', '  c+=mergeSort(a,b,mid+1,right);', '  c+=merge(a,b,left,mid+1,right); } ', ' return c;  }', 'static long merge(int a[],int  b[],long left,long mid,long right)', '{long c=0;int i=(int)left;int j=(int)mid; int k=(int)left;', 'while(i<=(int)mid-1&&j<=(int)right)', '{ if(a[i]<=a[j]) {b[k++]=a[i++]; }', 'else { b[k++]=a[j++];c+=mid-i;}}', 'while (i <= (int)mid - 1)   b[k++] = a[i++]; ', 'while (j <= (int)right) b[k++] = a[j++];', 'for (i=(int)left; i <= (int)right; i++) ', ' a[i] = b[i];  return c;  }', '    ', 'public static int[] radixSort(int[] f)', '{', ' int[] to = new int[f.length];', ' {', '  int[] b = new int[65537];', '  for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;', '  for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];', '  for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];', '  int[] d = f; f = to;to = d;', ' }', ' {', '  int[] b = new int[65537];', '  for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;', '  for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];', '  for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];', '  int[] d = f; f = to;to = d;', ' }', ' return f;', '}    ', '   static  class InputReader', '    {', '        private InputStream stream;', '        private byte[] buf = new byte[1024];', '        private int curChar;', '        private int numChars;', '        private SpaceCharFilter filter;', ' ', '        public InputReader(InputStream stream)', '        {', '            this.stream = stream;', '        }', ' ', '        public int read()', '        {', '            if (numChars == -1)', '                throw new InputMismatchException();', '            if (curChar >= numChars)', '            {', '                curChar = 0;', '                try', '                {', '                    numChars = stream.read(buf);', '                } catch (IOException e)', '                {', '                    throw new InputMismatchException();', '                }', '                if (numChars <= 0)', '                    return -1;', '            }', '            return buf[curChar++];', '        }', ' ', '        public int readInt()', '        {', '            int c = read();', '            while (isSpaceChar(c))', '                c = read();', '            int sgn = 1;', ""            if (c == '-')"", '            {', '                sgn = -1;', '                c = read();', '            }', '            int res = 0;', '            do', '            {', ""                if (c < '0' || c > '9')"", '                    throw new InputMismatchException();', '                res *= 10;', ""                res += c - '0';"", '                c = read();', '            } while (!isSpaceChar(c));', '            return res * sgn;', '        }', ' ', '        public String readString()', '        {', '            int c = read();', '            while (isSpaceChar(c))', '                c = read();', '            StringBuilder res = new StringBuilder();', '            do', '            {', '                res.appendCodePoint(c);', '                c = read();', '            } while (!isSpaceChar(c));', '            return res.toString();', '        }', '        public double readDouble() {', '            int c = read();', '            while (isSpaceChar(c))', '                c = read();', '            int sgn = 1;', ""            if (c == '-') {"", '                sgn = -1;', '                c = read();', '            }', '            double res = 0;', ""            while (!isSpaceChar(c) && c != '.') {"", ""                if (c == 'e' || c == 'E')"", '                    return res * Math.pow(10, readInt());', ""                if (c < '0' || c > '9')"", '                    throw new InputMismatchException();', '                res *= 10;', ""                res += c - '0';"", '                c = read();', '            }', ""            if (c == '.') {"", '                c = read();', '                double m = 1;', '                while (!isSpaceChar(c)) {', ""                    if (c == 'e' || c == 'E')"", '                        return res * Math.pow(10, readInt());', ""                    if (c < '0' || c > '9')"", '                        throw new InputMismatchException();', '                    m /= 10;', ""                    res += (c - '0') * m;"", '                    c = read();', '                }', '            }', '            return res * sgn;', '        }', '        public long readLong() {', '            int c = read();', '            while (isSpaceChar(c))', '                c = read();', '            int sgn = 1;', ""            if (c == '-') {"", '                sgn = -1;', '                c = read();', '            }', '            long res = 0;', '            do {', ""                if (c < '0' || c > '9')"", '                    throw new InputMismatchException();', '                res *= 10;', ""                res += c - '0';"", '                c = read();', '            } while (!isSpaceChar(c));', '            return res * sgn;', '        }', '        public boolean isSpaceChar(int c)', '        {', '            if (filter != null)', '                return filter.isSpaceChar(c);', ""            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;"", '        }', ' ', '        public String next()', '        {', '            return readString();', '        }', ' ', '        public interface SpaceCharFilter', '        {', '            public boolean isSpaceChar(int ch);', '        }', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'sockMerchant' function below."", '     *', '     * The function is expected to return an INTEGER.', '     * The function accepts following parameters:', '     *  1. INTEGER n', '     *  2. INTEGER_ARRAY ar', '     */', '', '    public static int sockMerchant(int n, List<Integer> ar) {', '    // Write your code here', 'Map<Integer,Integer> hmap=new HashMap<>();', 'for(int num:ar){', '    if(hmap.containsKey(num)){', '        int val=hmap.get(num);', '        hmap.put(num,val+1);', '    }', '    else{', '        hmap.put(num,1);', '    }', '}', 'int count=0;', 'for(Integer Key:hmap.keySet()){', '    count=count+hmap.get(Key)/2;', '}', '  return count;  ', '}', '    }', '', '', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int n = Integer.parseInt(bufferedReader.readLine().trim());', '', '        String[] arTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> ar = new ArrayList<>();', '', '        for (int i = 0; i < n; i++) {', '            int arItem = Integer.parseInt(arTemp[i]);', '            ar.add(arItem);', '        }', '', '        int result = Result.sockMerchant(n, ar);', '', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        int p = in.nextInt();', '        // your code goes here', '        int ans = Math.min(p/2,(n-p)/2);', '        System.out.println(ans);', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'pageCount' function below."", '     *', '     * The function is expected to return an INTEGER.', '     * The function accepts following parameters:', '     *  1. INTEGER n', '     *  2. INTEGER p', '     */', '', '    public static int pageCount(int n, int p) {', '    // Write your code here', '        int step=0;', '    Map<Integer,Integer> hmap=new HashMap<>();', 'for(int i=0; i<=n; i++){ ', '    hmap.put(i,step);', '    i++;', '    if(i<=n)hmap.put(i,step);', '    step++;', '    }', '    return Math.min(hmap.get(p),hmap.get(n)-hmap.get(p));', '', '}', '', '    }', '', '', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int n = Integer.parseInt(bufferedReader.readLine().trim());', '', '        int p = Integer.parseInt(bufferedReader.readLine().trim());', '', '        int result = Result.pageCount(n, p);', '', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['/*', ' * PDPM IIITDM Jabalpur', ' * Asutosh Rana', ' */', '', 'import java.util.*;', 'import java.io.*;', 'import java.math.*;', '', 'public class Main', '{', '    static long MOD = 1000000007;', '    public static void main (String[] args) throws java.lang.Exception', ' {', '  InputReader in=new InputReader(System.in);', '  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '        PrintWriter out=new PrintWriter(System.out);', '', '        int t = 1;', '        ', '        while(t-->0){', '         int N = in.readInt();', '         char[] A = in.readCharA();', '         int level=0,count=0;', '         ', '         for(int i=0;i<N;i++){', ""          if(A[i]=='U'){"", '           level++;', '           if(level==0)', '            count++;', '          }', '          else{', '           level--;', '          }', '          ', '         }', '         out.println(count);', '     }', '  out.flush();', '        out.close();', ' }', ' ', '      ', '}', ' ', 'class InputReader{', ' private InputStream stream;', ' private byte[] buf = new byte[1024];', ' private int curChar;', ' private int numChars;', ' private SpaceCharFilter filter;', ' ', ' public InputReader(InputStream stream){this.stream = stream;}', ' public int read(){', '  if (numChars==-1) throw new InputMismatchException();', '  if (curChar >= numChars){', '   curChar = 0;', '   try {numChars = stream.read(buf);}', '   catch (IOException e){throw new InputMismatchException();}', '   if(numChars <= 0) return -1;', '  }', '  return buf[curChar++];', ' }', ' ', ' public int readInt(){', '  int c = read();', '  while(isSpaceChar(c)) c = read();', '  int sgn = 1;', ""  if (c == '-') {sgn = -1;c = read();}"", '  int res = 0;', '  do {', ""   if(c<'0'||c>'9') throw new InputMismatchException();"", '   res *= 10;', ""   res += c - '0';"", '   c = read();', '  }', '  while (!isSpaceChar(c)); return res * sgn;', ' }', ' ', ' public void readInt(int[] A){', '  for(int i=0;i<A.length;i++)', '   A[i] = readInt();', ' }', ' ', ' public long readLong() {', '  int c = read();', '  while (isSpaceChar(c))', '   c = read();', '  int sgn = 1;', ""  if (c == '-') {"", '   sgn = -1;', '   c = read();', '        }', '  long res = 0;', '  do {', ""   if (c < '0' || c > '9')"", '    throw new InputMismatchException();', '   res *= 10;', ""   res += c - '0';"", '   c = read();', '        }', '  while (!isSpaceChar(c));', '            return res * sgn;', '    }', ' ', ' public void readLong(long[] A){', '  for(int i=0;i<A.length;i++)', '   A[i] = readLong();', ' }', ' ', ' public double readDouble() {', '        int c = read();', '        while (isSpaceChar(c))', '            c = read();', '        int sgn = 1;', ""  if (c == '-') {"", '   sgn = -1;', '   c = read();', '        }', '  double res = 0;', ""  while (!isSpaceChar(c) && c != '.') {"", ""   if (c == 'e' || c == 'E')"", '    return res * Math.pow(10, readInt());', ""   if (c < '0' || c > '9')"", '    throw new InputMismatchException();', '   res *= 10;', ""   res += c - '0';"", '   c = read();', '        }', ""  if (c == '.') {"", '   c = read();', '   double m = 1;', '   while (!isSpaceChar(c)) {', ""    if (c == 'e' || c == 'E')"", '     return res * Math.pow(10, readInt());', ""    if (c < '0' || c > '9')"", '     throw new InputMismatchException();', '    m /= 10;', ""    res += (c - '0') * m;"", '    c = read();', '            }', '        }', '  return res * sgn;', '    }', ' ', ' public char[] readCharA(){', '  return readString().toCharArray();', ' }', ' ', ' public String readString() {', '  int c = read();', '  while (isSpaceChar(c))', '   c = read();', '  StringBuilder res = new StringBuilder();', '  do {', '   res.appendCodePoint(c);', '   c = read();', '  } while (!isSpaceChar(c));', '  return res.toString();', ' }', ' ', ' public boolean isSpaceChar(int c) {', '  if (filter != null)', '   return filter.isSpaceChar(c);', ""  return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;"", '  }', ' ', ' public String next() {', '  return readString();', ' }', ' ', ' public interface SpaceCharFilter {', '  public boolean isSpaceChar(int ch);', ' }', ' ', '}']","['import java.util.Scanner;', '', 'public class Hiking {', '', '    // Function to count the number of valleys traversed', '    static int countingValleys(int steps, String path) {', '        int level = 0; // Starting at sea level', '        int valleyCount = 0;', '        ', '        // Traverse the path of steps', '        for (char step : path.toCharArray()) {', ""            if (step == 'U') {"", '                level++; // Step up', ""            } else if (step == 'D') {"", '                level--; // Step down', '            }', '            ', '            // Check if the hiker enters a valley', ""            if (level == 0 && step == 'U') {"", '                valleyCount++;', '            }', '        }', '        ', '        return valleyCount;', '    }', '', '    public static void main(String[] args) {', '        Scanner scanner = new Scanner(System.in);', '', '        // Prompt user to enter the number of steps', '        int steps = scanner.nextInt();', '        scanner.nextLine(); // Consume the newline character', '        ', '        // Prompt user to enter the path description', '        String path = scanner.nextLine();', '', '        // Calculate the number of valleys traversed using countingValleys function', '        int valleys = countingValleys(steps, path);', '', '        // Output the result', '        System.out.println( valleys);', '', '        // Close the scanner', '        scanner.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int s = in.nextInt();', '        int n = in.nextInt();', '        int m = in.nextInt();', '        int[] keyboards = new int[n];', '        for(int keyboards_i=0; keyboards_i < n; keyboards_i++){', '            keyboards[keyboards_i] = in.nextInt();', '        }', '        int[] pendrives = new int[m];', '        for(int pendrives_i=0; pendrives_i < m; pendrives_i++){', '            pendrives[pendrives_i] = in.nextInt();', '        }', '        ', '        int ans = -1;', '        for(int i=0;i<n;i++)', '            {', '            for(int j=0;j<m;j++)', '                {', '                int v = keyboards[i]+pendrives[j];', '                if(v>ans && v<= s)', '                    {', '                    ans = v;', '                }', '            }', '        }', '        ', '        System.out.println(ans);', '    }', '}']","['import java.util.Scanner;', '', 'public class Main {', '    public static void main(String[] args) {', '        Scanner scanner = new Scanner(System.in);', '        ', '        int budget = scanner.nextInt();', '        int keyboardCount = scanner.nextInt();', '        int usbCount = scanner.nextInt();', '        ', '        int[] keyboardPrices = new int[keyboardCount];', '        int[] usbPrices = new int[usbCount];', '        ', '        // Read keyboard prices', '        for (int i = 0; i < keyboardCount; i++) {', '            keyboardPrices[i] = scanner.nextInt();', '        }', '        ', '        ', '        for (int i = 0; i < usbCount; i++) {', '            usbPrices[i] = scanner.nextInt();', '        }', '        ', '        int maxAmount = -1; ', '        for (int keyboardPrice : keyboardPrices) {', '            for (int usbPrice : usbPrices) {', '                int totalPrice = keyboardPrice + usbPrice;', '                if (totalPrice <= budget && totalPrice > maxAmount) {', '                    maxAmount = totalPrice;', '                }', '            }', '        }', '        ', '        System.out.println(maxAmount);', '        ', '        scanner.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int q = in.nextInt();', '        for(int a0 = 0; a0 < q; a0++){', '            int x = in.nextInt();', '            int y = in.nextInt();', '            int z = in.nextInt();', '            int a = Math.abs(x-z);', '            int b = Math.abs(y-z);', '            if (a==b)', '                System.out.println(""Mouse C"");', '            if (a<b)', '                System.out.println(""Cat A"");', '            if (a>b)', '                System.out.println(""Cat B"");', '        }', '    }', '}']","['import java.util.Scanner;', '', 'public class Main {', '    public static void main(String[] args) {', '        Scanner scanner = new Scanner(System.in);', '        ', '        int queries = scanner.nextInt();', '        ', '        for (int q = 0; q < queries; q++) {', '            int catA = scanner.nextInt();', '            int catB = scanner.nextInt();', '            int mouseC = scanner.nextInt();', '            ', '            int distanceFromCatA = Math.abs(mouseC - catA);', '            int distanceFromCatB = Math.abs(mouseC - catB);', '            ', '            if (distanceFromCatA < distanceFromCatB) {', '                System.out.println(""Cat A"");', '            } else if (distanceFromCatB < distanceFromCatA) {', '                System.out.println(""Cat B"");', '            } else {', '                System.out.println(""Mouse C"");', '            }', '        }', '        ', '        scanner.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        int[] a = new int[100];', '        for(int a_i=0; a_i < n; a_i++){', '            a[in.nextInt()]++;', '        }', '        int max = 0;', '        for (int i = 0; i < 99; i++) {', '            max = Math.max(max, a[i]+a[i+1]);', '        }', '        System.out.println(max);', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '   public static int pickingNumbers(List<Integer> a) {', '', '    int[] freq = new int[100];', '    for (int i = 0; i < a.size(); i++) {', '        int num = a.get(i);', '        freq[num]++;', '    }', '    int maxLength = 0;', '    for (int i = 1; i < 100; i++) {', '        int currentLength = freq[i] + freq[i - 1];', '        maxLength = Math.max(maxLength, currentLength);', '    }', '', '    return maxLength;', '}', '}', '    ', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int n = Integer.parseInt(bufferedReader.readLine().trim());', '', '        String[] aTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> a = new ArrayList<>();', '', '        for (int i = 0; i < n; i++) {', '            int aItem = Integer.parseInt(aTemp[i]);', '            a.add(aItem);', '        }', '', '        int result = Result.pickingNumbers(a);', '', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt();', '        int k = in.nextInt();', '        int[] height = new int[n];', '        for(int height_i=0; height_i < n; height_i++){', '            height[height_i] = in.nextInt();', '        }', '        Arrays.sort(height);', '        System.out.println(Math.max(0, height[n-1]-k));', '    }', '}']","['import java.util.Scanner;', '', 'public class Main {', '    public static void main(String[] args) {', '        Scanner scanner = new Scanner(System.in);', '        ', '        int n = scanner.nextInt(); // Number of hurdles', '        int k = scanner.nextInt(); ', '        ', '        int[] heights = new int[n]; ', '        ', '        ', '        for (int i = 0; i < n; i++) {', '            heights[i] = scanner.nextInt();', '        }', '        ', '        ', '        int maxHurdleHeight = 0;', '        for (int height : heights) {', '            maxHurdleHeight = Math.max(maxHurdleHeight, height);', '        }', '        ', '        ', '        int dosesNeeded = Math.max(0, maxHurdleHeight - k);', '        ', '        System.out.println(dosesNeeded);', '        ', '        scanner.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int n = 26;', '        int h[] = new int[n];', '        for(int h_i=0; h_i < n; h_i++){', '            h[h_i] = in.nextInt();', '        }', '        String word = in.next();', '        int mx = 0;', '        for (int i = 0; i < word.length(); i++) {', ""            int f = h[(int) (word.charAt(i) - 'a')];"", '            if (f > mx) {', '                mx = f;', '            }', '        }', '        System.out.println((word.length() * mx));', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'designerPdfViewer' function below."", '     *', '     * The function is expected to return an INTEGER.', '     * The function accepts following parameters:', '     *  1. INTEGER_ARRAY h', '     *  2. STRING word', '     */', '', '    public static int designerPdfViewer(List<Integer> h, String word) {', '    // Write your code he', '    int max=0;', '    for(int i=0;i<word. length() ;i++){', '        int hi=h. get(word. charAt(i)-97);', '     if(max<hi)   {', '         max=hi;', '         ', '     }', '    }', '    return max*word. length() ;', '', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        String[] hTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> h = new ArrayList<>();', '', '        for (int i = 0; i < 26; i++) {', '            int hItem = Integer.parseInt(hTemp[i]);', '            h.add(hItem);', '        }', '', '        String word = bufferedReader.readLine();', '', '        int result = Result.designerPdfViewer(h, word);', '', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.BufferedReader;', 'import java.io.IOException;', 'import java.io.InputStreamReader;', 'import java.io.PrintWriter;', '', 'public class Solution', '{', ' public static void main(String[] args) throws NumberFormatException, IOException', ' {', '', '  BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '  PrintWriter printWriter = new PrintWriter(System.out);', '  ', '  int testCount = Integer.parseInt(bufferedReader.readLine());', '  ', '  while(testCount-- > 0)', '  {', '   printWriter.println(getAnswer(Integer.parseInt(bufferedReader.readLine())));', '  }', '  ', '  printWriter.flush();', ' }', '', ' private static long getAnswer(int n)', ' {', '  long h = 1;', '  ', '  for(int i = 1 ; i <= n ; i++)', '  {', '   if(i % 2 != 0)', '    h *= 2;', '   else', '    h +=1 ;', '  }', '  ', '  return h;', ' }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'utopianTree' function below."", '     *', '     * The function is expected to return an INTEGER.', '     * The function accepts INTEGER n as parameter.', '     */', '', '    public static int utopianTree(int n) {', '    // Write your code here', '    int height=1;', '    for(int i=1;i<=n;i++){', '        if(i%2==0){', '            height++;', '        }else height*=2;', '    }', 'return height;', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int t = Integer.parseInt(bufferedReader.readLine().trim());', '', '        for (int tItr = 0; tItr < t; tItr++) {', '            int n = Integer.parseInt(bufferedReader.readLine().trim());', '', '            int result = Result.utopianTree(n);', '', '            bufferedWriter.write(String.valueOf(result));', '            bufferedWriter.newLine();', '        }', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.BufferedReader;', 'import java.io.InputStreamReader;', 'import java.io.PrintWriter;', 'import java.util.StringTokenizer;', '', '', 'public class AngryProf {', '', ' public static void main(String args[] ) throws Exception {', '  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));', '     PrintWriter w = new PrintWriter(System.out);', '         ', '     int t = ip(br.readLine());', '     ', '     while(t-- > 0) {', '      StringTokenizer st1 = new StringTokenizer(br.readLine());', '      int n = ip(st1.nextToken());', '      int k = ip(st1.nextToken());', '           ', '         StringTokenizer st2 = new StringTokenizer(br.readLine());', '         int a[] = new int[n];', '         for(int i=0;i<n;i++)', '            a[i] = ip(st2.nextToken());', '            ', '         int count = 0;', '         for(int i=0;i<n;i++)', '          if(a[i]<=0) count++;', '         w.println(count < k ? ""YES"" : ""NO"");', '     }', '         ', '     w.close();', '         ', ' }', ' ', ' public static int ip(String s){', '  return Integer.parseInt(s);', ' }', ' ', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'angryProfessor' function below."", '     *', '     * The function is expected to return a STRING.', '     * The function accepts following parameters:', '     *  1. INTEGER k', '     *  2. INTEGER_ARRAY a', '     */', '', '    public static String angryProfessor(int k, List<Integer> a) {', '    // Write your code here', '    int students=0;', '    for (Integer integer : a) {', '        if(integer<=0) students++;', '    if(students==k) return ""NO"";', '    }', 'return ""YES"";', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int t = Integer.parseInt(bufferedReader.readLine().trim());', '', '        for (int tItr = 0; tItr < t; tItr++) {', '            String[] firstMultipleInput = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '            int n = Integer.parseInt(firstMultipleInput[0]);', '', '            int k = Integer.parseInt(firstMultipleInput[1]);', '', '            String[] aTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '            List<Integer> a = new ArrayList<>();', '', '            for (int i = 0; i < n; i++) {', '                int aItem = Integer.parseInt(aTemp[i]);', '                a.add(aItem);', '            }', '', '            String result = Result.angryProfessor(k, a);', '', '            bufferedWriter.write(result);', '            bufferedWriter.newLine();', '        }', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
 , 
 , 
 , 
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    public static void main(String[] args) {', '        Scanner in = new Scanner(System.in);', '        int n = in.nextInt(), k = in.nextInt(), q = in.nextInt();', '        int[] a = new int[n];', '        for(int i = 0; i < n; i++) a[i] = in.nextInt();', '        for(int i = 0; i < q; i++) System.out.println(a[(n+((in.nextInt()-k)%n)) % n]);', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'circularArrayRotation' function below."", '     *', '     * The function is expected to return an INTEGER_ARRAY.', '     * The function accepts following parameters:', '     *  1. INTEGER_ARRAY a', '     *  2. INTEGER k', '     *  3. INTEGER_ARRAY queries', '     */', '', '    public static List<Integer> circularArrayRotation(List<Integer> a, int k, List<Integer> queries) {', '    // Write your code here', '    List<Integer> li= new ArrayList<>();', '    for(int i=0;i<k;i++){', '        a.add(0, a.get(a.size()-1));', '        a.remove(a.size()-1);', '    }', '    for(int j:queries){', '        li.add(a.get(j));', '    }', '    return li;', '', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        String[] firstMultipleInput = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        int n = Integer.parseInt(firstMultipleInput[0]);', '', '        int k = Integer.parseInt(firstMultipleInput[1]);', '', '        int q = Integer.parseInt(firstMultipleInput[2]);', '', '        String[] aTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> a = new ArrayList<>();', '', '        for (int i = 0; i < n; i++) {', '            int aItem = Integer.parseInt(aTemp[i]);', '            a.add(aItem);', '        }', '', '        List<Integer> queries = new ArrayList<>();', '', '        for (int i = 0; i < q; i++) {', '            int queriesItem = Integer.parseInt(bufferedReader.readLine().trim());', '            queries.add(queriesItem);', '        }', '', '        List<Integer> result = Result.circularArrayRotation(a, k, queries);', '', '        for (int i = 0; i < result.size(); i++) {', '            bufferedWriter.write(String.valueOf(result.get(i)));', '', '            if (i != result.size() - 1) {', '                bufferedWriter.write(""\\n"");', '            }', '        }', '', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', '', 'class Main {', ' InputReader in;', ' PrintWriter out;', '', ' void main() {', '  int n = in.nextInt();', '  int nxt[] = new int[n];', '  for (int i = 0; i < n; ++i) {', '   int y = in.nextInt();', '   nxt[--y] = i;', '  }', '  for (int i = 0; i < n; ++i)', '   out.println(nxt[nxt[i]] + 1);', ' }', ' ', ' public static void main(String[] args) {', '  new Main();', ' }', '', ' public Main() {', '  in = new InputReader(System.getProperty(""ONLINE_JUDGE"") != null ? null : ""main.inp"");', '  out = new PrintWriter(System.out);', '  main();', '  out.close();', ' }', '', ' class InputReader {', '  BufferedReader bf;', '  StringTokenizer st = null;', '  ', '  InputReader(String filename) {', '   try {', '    bf = new BufferedReader(filename == null', '     ? new InputStreamReader(System.in)', '     : new FileReader(filename)', '    );', '   } catch (IOException e) {', '    e.printStackTrace();', '    System.err.println(""use stdin instead"");', '    bf = new BufferedReader(new InputStreamReader(System.in));', '   }', '  }', '  ', '  String nextString() {', '   try {', '    while (st == null || !st.hasMoreTokens())', '     st = new StringTokenizer(bf.readLine());', '   } catch (IOException e) {', '    throw new RuntimeException(e);', '   }', '   return st.nextToken();', '  }', ' ', '  long nextLong() {return Long.parseLong(nextString());}', '  int nextInt() {return Integer.parseInt(nextString());}', '  double nextDouble() {return Double.parseDouble(nextString());}', ' }', '', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'permutationEquation' function below."", '     *', '     * The function is expected to return an INTEGER_ARRAY.', '     * The function accepts INTEGER_ARRAY p as parameter.', '     */', '', '    public static List<Integer> permutationEquation(List<Integer> p) {', '    // Write your code here', '    List<Integer> li= new ArrayList<>();', '    for(int i=1;i<=p.size();i++){', '        int ind1=p.indexOf(i)+1;', '        int ind2=p.indexOf(ind1)+1;', '        li.add(ind2);', '    }', '    return li;', '', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int n = Integer.parseInt(bufferedReader.readLine().trim());', '', '        String[] pTemp = bufferedReader.readLine().replaceAll(""\\\\s+$"", """").split("" "");', '', '        List<Integer> p = new ArrayList<>();', '', '        for (int i = 0; i < n; i++) {', '            int pItem = Integer.parseInt(pTemp[i]);', '            p.add(pItem);', '        }', '', '        List<Integer> result = Result.permutationEquation(p);', '', '        for (int i = 0; i < result.size(); i++) {', '            bufferedWriter.write(String.valueOf(result.get(i)));', '', '            if (i != result.size() - 1) {', '                bufferedWriter.write(""\\n"");', '            }', '        }', '', '        bufferedWriter.newLine();', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
"['import java.awt.*;', 'import java.awt.event.*;', 'import java.awt.geom.*;', 'import java.io.*;', 'import java.math.*;', 'import java.text.*; ', 'import java.util.*;', 'import java.util.regex.*;', '/*', '      br = new BufferedReader(new FileReader(""input.txt""));', '      pw = new PrintWriter(new BufferedWriter(new FileWriter(""output.txt"")));', '      br = new BufferedReader(new InputStreamReader(System.in));', '      pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));', ' */', '', '', 'public class Solution {', ' private static BufferedReader br;', ' private static StringTokenizer st;', ' private static PrintWriter pw;', '', ' public static void main(String[] args) throws IOException {', '  br = new BufferedReader(new InputStreamReader(System.in));', '  pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));', '  int qq = 1;', '  //int qq = Integer.MAX_VALUE;', '  //int qq = readInt();', '  for(int casenum = 1; casenum <= qq; casenum++) {', '   int n = readInt();', '   int k = readInt();', '   int e = 100;', '   for(int i = 0; i < n; i++) {', '    int c = readInt();', '    if(i % k == 0) {', '     e--;', '     if(c == 1) {', '      e -= 2;', '     }', '    }', '   }', '   pw.println(e);', '  }', '  exitImmediately();', ' }', '', ' private static void exitImmediately() {', '  pw.close();', '  System.exit(0);', ' }', '', ' private static long readLong() throws IOException {', '  return Long.parseLong(nextToken());', ' }', '', ' private static double readDouble() throws IOException {', '  return Double.parseDouble(nextToken());', ' }', '', ' private static int readInt() throws IOException {', '  return Integer.parseInt(nextToken());', ' }', '', ' private static String nextLine() throws IOException  {', '  if(!br.ready()) {', '   exitImmediately();', '  }', '  st = null;', '  return br.readLine();', ' }', '', ' private static String nextToken() throws IOException  {', '  while(st == null || !st.hasMoreTokens())  {', '   if(!br.ready()) {', '    exitImmediately();', '   }', '   st = new StringTokenizer(br.readLine().trim());', '  }', '  return st.nextToken();', ' }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '    // Complete the jumpingOnClouds function below.', '    static int jumpingOnClouds(int[] c, int k) {', '       ', '    int e = 100, i = 0;', '        ', '    do {', '        e -= (c[i] == 1) ? 3 : 1;', '        i = (i + k) % c.length;', '    } while (i != 0);', '', '    return e;', '', '', '    }', '', '    private static final Scanner scanner = new Scanner(System.in);', '', '    public static void main(String[] args) throws IOException {', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        String[] nk = scanner.nextLine().split("" "");', '', '        int n = Integer.parseInt(nk[0]);', '', '        int k = Integer.parseInt(nk[1]);', '', '        int[] c = new int[n];', '', '        String[] cItems = scanner.nextLine().split("" "");', '        scanner.skip(""(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])?"");', '', '        for (int i = 0; i < n; i++) {', '            int cItem = Integer.parseInt(cItems[i]);', '            c[i] = cItem;', '        }', '', '        int result = jumpingOnClouds(c, k);', '', '        bufferedWriter.write(String.valueOf(result));', '        bufferedWriter.newLine();', '', '        bufferedWriter.close();', '', '        scanner.close();', '    }', '}']"
"['import java.io.*;', 'import java.util.*;', 'import java.text.*;', 'import java.math.*;', 'import java.util.regex.*;', '', 'public class Solution {', '', '     public static void main(String[] args){', '        int t;', '        Scanner scan = new Scanner(System.in);', '        ', '        t = scan.nextInt();', '        ', '        for(int i = 0; i < t; i++){', '            System.out.println(digits(scan.next()));', '        }', '        ', '        scan.close();', '    }', '', '    private static int digits(String number) {', '       ', '       int sum = 0;', '       char[] digits = number.toCharArray();', '      ', '       for(int i = 0; i < number.length(); i++){', '            if(Character.getNumericValue(digits[i]) != 0){ ', '                if(((Integer.parseInt(number))% (Character.getNumericValue(digits[i]))) == 0){', '                    sum++;', '                }', '            }', '            else', '                continue;', '       }', '           ', '        return sum;', '    }', '}']","['import java.io.*;', 'import java.math.*;', 'import java.security.*;', 'import java.text.*;', 'import java.util.*;', 'import java.util.concurrent.*;', 'import java.util.regex.*;', '', 'class Result {', '', '    /*', ""     * Complete the 'findDigits' function below."", '     *', '     * The function is expected to return an INTEGER.', '     * The function accepts INTEGER n as parameter.', '     */', '', '    public static int findDigits(int n) {', '    // Write your code here', '    String ns = """"+n;', '    int tot=0;', '    for (int i = 0; i<ns.length();i++)', '    {', '        if ((ns.charAt(i)-48) > 0)', '        {', '            if (n % (ns.charAt(i)-48) == 0) ', '            {', '                tot++;', '            }', '        }        ', '    }', '    ', '    return tot;', '    }', '', '}', '', 'public class Solution {', '    public static void main(String[] args) throws IOException {', '        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));', '        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(""OUTPUT_PATH"")));', '', '        int t = Integer.parseInt(bufferedReader.readLine().trim());', '', '        for (int tItr = 0; tItr < t; tItr++) {', '            int n = Integer.parseInt(bufferedReader.readLine().trim());', '', '            int result = Result.findDigits(n);', '', '            bufferedWriter.write(String.valueOf(result));', '            bufferedWriter.newLine();', '        }', '', '        bufferedReader.close();', '        bufferedWriter.close();', '    }', '}']"
